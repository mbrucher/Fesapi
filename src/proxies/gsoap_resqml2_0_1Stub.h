/* gsoap_resqml2_0_1Stub.h
   Generated by gSOAP 2.8.25 from resqml2_0_1ForGsoap.h

gSOAP XML Web services tools
Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool is licensed for commercial use, no resale/redistribution.
--------------------------------------------------------------------------------
Product and source code licensed by Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#ifndef gsoap_resqml2_0_1Stub_H
#define gsoap_resqml2_0_1Stub_H
#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_resqml2	"http://www.energistics.org/energyml/data/resqmlv2"
#define SOAP_NAMESPACE_OF_eml	"http://www.energistics.org/energyml/data/commonv2"
#define SOAP_NAMESPACE_OF_gml	"http://www.opengis.net/gml/3.2"
#define SOAP_NAMESPACE_OF_xlink	"http://www.w3.org/1999/xlink"
#define SOAP_NAMESPACE_OF_gmd	"http://www.isotc211.org/2005/gmd"
#define SOAP_NAMESPACE_OF_gts	"http://www.isotc211.org/2005/gts"
#define SOAP_NAMESPACE_OF_gco	"http://www.isotc211.org/2005/gco"
#define SOAP_NAMESPACE_OF_gsr	"http://www.isotc211.org/2005/gsr"
#define SOAP_NAMESPACE_OF_ptm	"http://www.f2i-consulting.com/PropertyTypeMapping"
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20825
# error "GSOAP VERSION 20825 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace gsoap_resqml2_0_1 {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* resqml2_0_1ForGsoap.h:1903 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSetKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSetKind (563)
/* resqml2:TimeSetKind */
enum resqml2__TimeSetKind
{
	resqml2__TimeSetKind__single_x0020time = 0,
	resqml2__TimeSetKind__equivalent_x0020times = 1,
	resqml2__TimeSetKind__not_x0020a_x0020time_x0020set = 2
};
#endif

/* resqml2_0_1ForGsoap.h:1925 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Facet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Facet (564)
/* resqml2:Facet */
enum resqml2__Facet
{
	resqml2__Facet__conditions = 0,
	resqml2__Facet__direction = 1,
	resqml2__Facet__netgross = 2,
	resqml2__Facet__qualifier = 3,
	resqml2__Facet__statistics = 4,
	resqml2__Facet__what = 5
};
#endif

/* resqml2_0_1ForGsoap.h:1956 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlUom
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlUom (565)
/* resqml2:ResqmlUom */
enum resqml2__ResqmlUom
{
	resqml2__ResqmlUom___x0025 = 0,
	resqml2__ResqmlUom___x0025_x005barea_x005d = 1,
	resqml2__ResqmlUom___x0025_x005bmass_x005d = 2,
	resqml2__ResqmlUom___x0025_x005bmolar_x005d = 3,
	resqml2__ResqmlUom___x0025_x005bvol_x005d = 4,
	resqml2__ResqmlUom___x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 5,
	resqml2__ResqmlUom___x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 6,
	resqml2__ResqmlUom___x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 7,
	resqml2__ResqmlUom__0_x002e001_x0020bbl_x002fft3 = 8,
	resqml2__ResqmlUom__0_x002e001_x0020bbl_x002fm3 = 9,
	resqml2__ResqmlUom__0_x002e001_x0020d_x002fft3 = 10,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 11,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 12,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 13,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 14,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 15,
	resqml2__ResqmlUom__0_x002e001_x0020h_x002fft = 16,
	resqml2__ResqmlUom__0_x002e001_x0020kPa2_x002fcP = 17,
	resqml2__ResqmlUom__0_x002e001_x0020lbm_x002fbbl = 18,
	resqml2__ResqmlUom__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 19,
	resqml2__ResqmlUom__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 20,
	resqml2__ResqmlUom__0_x002e001_x0020psi_x002fft = 21,
	resqml2__ResqmlUom__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 22,
	resqml2__ResqmlUom__0_x002e001_x0020seca = 23,
	resqml2__ResqmlUom__0_x002e01_x0020bbl_x002fbbl = 24,
	resqml2__ResqmlUom__0_x002e01_x0020dega_x002fft = 25,
	resqml2__ResqmlUom__0_x002e01_x0020degF_x002fft = 26,
	resqml2__ResqmlUom__0_x002e01_x0020dm3_x002fkm = 27,
	resqml2__ResqmlUom__0_x002e01_x0020ft_x002fft = 28,
	resqml2__ResqmlUom__0_x002e01_x0020grain_x002fft3 = 29,
	resqml2__ResqmlUom__0_x002e01_x0020L_x002fkg = 30,
	resqml2__ResqmlUom__0_x002e01_x0020L_x002fkm = 31,
	resqml2__ResqmlUom__0_x002e01_x0020lbf_x002fft = 32,
	resqml2__ResqmlUom__0_x002e01_x0020lbf_x002fft2 = 33,
	resqml2__ResqmlUom__0_x002e01_x0020lbm_x002fft2 = 34,
	resqml2__ResqmlUom__0_x002e01_x0020psi_x002fft = 35,
	resqml2__ResqmlUom__0_x002e1_x0020ft = 36,
	resqml2__ResqmlUom__0_x002e1_x0020ft_x005bUS_x005d = 37,
	resqml2__ResqmlUom__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 38,
	resqml2__ResqmlUom__0_x002e1_x0020in = 39,
	resqml2__ResqmlUom__0_x002e1_x0020L_x002fbbl = 40,
	resqml2__ResqmlUom__0_x002e1_x0020lbm_x002fbbl = 41,
	resqml2__ResqmlUom__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 42,
	resqml2__ResqmlUom__0_x002e1_x0020yd = 43,
	resqml2__ResqmlUom__1_x002f_x0028kg_x002es_x0029 = 44,
	resqml2__ResqmlUom__1_x002f16_x0020in = 45,
	resqml2__ResqmlUom__1_x002f2_x0020ft = 46,
	resqml2__ResqmlUom__1_x002f2_x0020ms = 47,
	resqml2__ResqmlUom__1_x002f30_x0020cm3_x002fmin = 48,
	resqml2__ResqmlUom__1_x002f30_x0020dega_x002fft = 49,
	resqml2__ResqmlUom__1_x002f30_x0020dega_x002fm = 50,
	resqml2__ResqmlUom__1_x002f30_x0020lbf_x002fm = 51,
	resqml2__ResqmlUom__1_x002f30_x0020m_x002fm = 52,
	resqml2__ResqmlUom__1_x002f30_x0020N_x002fm = 53,
	resqml2__ResqmlUom__1_x002f32_x0020in = 54,
	resqml2__ResqmlUom__1_x002f64_x0020in = 55,
	resqml2__ResqmlUom__1_x002fa = 56,
	resqml2__ResqmlUom__1_x002fangstrom = 57,
	resqml2__ResqmlUom__1_x002fbar = 58,
	resqml2__ResqmlUom__1_x002fbbl = 59,
	resqml2__ResqmlUom__1_x002fcm = 60,
	resqml2__ResqmlUom__1_x002fd = 61,
	resqml2__ResqmlUom__1_x002fdegC = 62,
	resqml2__ResqmlUom__1_x002fdegF = 63,
	resqml2__ResqmlUom__1_x002fdegR = 64,
	resqml2__ResqmlUom__1_x002fft = 65,
	resqml2__ResqmlUom__1_x002fft2 = 66,
	resqml2__ResqmlUom__1_x002fft3 = 67,
	resqml2__ResqmlUom__1_x002fg = 68,
	resqml2__ResqmlUom__1_x002fgal_x005bUK_x005d = 69,
	resqml2__ResqmlUom__1_x002fgal_x005bUS_x005d = 70,
	resqml2__ResqmlUom__1_x002fH = 71,
	resqml2__ResqmlUom__1_x002fh = 72,
	resqml2__ResqmlUom__1_x002fin = 73,
	resqml2__ResqmlUom__1_x002fK = 74,
	resqml2__ResqmlUom__1_x002fkg = 75,
	resqml2__ResqmlUom__1_x002fkm2 = 76,
	resqml2__ResqmlUom__1_x002fkPa = 77,
	resqml2__ResqmlUom__1_x002fL = 78,
	resqml2__ResqmlUom__1_x002flbf = 79,
	resqml2__ResqmlUom__1_x002flbm = 80,
	resqml2__ResqmlUom__1_x002fm = 81,
	resqml2__ResqmlUom__1_x002fm2 = 82,
	resqml2__ResqmlUom__1_x002fm3 = 83,
	resqml2__ResqmlUom__1_x002fmi = 84,
	resqml2__ResqmlUom__1_x002fmi2 = 85,
	resqml2__ResqmlUom__1_x002fmin = 86,
	resqml2__ResqmlUom__1_x002fmm = 87,
	resqml2__ResqmlUom__1_x002fms = 88,
	resqml2__ResqmlUom__1_x002fN = 89,
	resqml2__ResqmlUom__1_x002fnm = 90,
	resqml2__ResqmlUom__1_x002fPa = 91,
	resqml2__ResqmlUom__1_x002fpPa = 92,
	resqml2__ResqmlUom__1_x002fpsi = 93,
	resqml2__ResqmlUom__1_x002fs = 94,
	resqml2__ResqmlUom__1_x002fupsi = 95,
	resqml2__ResqmlUom__1_x002fus = 96,
	resqml2__ResqmlUom__1_x002fuV = 97,
	resqml2__ResqmlUom__1_x002fV = 98,
	resqml2__ResqmlUom__1_x002fwk = 99,
	resqml2__ResqmlUom__1_x002fyd = 100,
	resqml2__ResqmlUom__10_x0020ft = 101,
	resqml2__ResqmlUom__10_x0020in = 102,
	resqml2__ResqmlUom__10_x0020km = 103,
	resqml2__ResqmlUom__10_x0020kN = 104,
	resqml2__ResqmlUom__10_x0020Mg_x002fm3 = 105,
	resqml2__ResqmlUom__100_x0020ft = 106,
	resqml2__ResqmlUom__100_x0020ka_x005bt_x005d = 107,
	resqml2__ResqmlUom__100_x0020km = 108,
	resqml2__ResqmlUom__1000_x0020bbl = 109,
	resqml2__ResqmlUom__1000_x0020bbl_x002eft_x002fd = 110,
	resqml2__ResqmlUom__1000_x0020bbl_x002fd = 111,
	resqml2__ResqmlUom__1000_x0020ft = 112,
	resqml2__ResqmlUom__1000_x0020ft_x002fh = 113,
	resqml2__ResqmlUom__1000_x0020ft_x002fs = 114,
	resqml2__ResqmlUom__1000_x0020ft3 = 115,
	resqml2__ResqmlUom__1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 116,
	resqml2__ResqmlUom__1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 117,
	resqml2__ResqmlUom__1000_x0020ft3_x002fbbl = 118,
	resqml2__ResqmlUom__1000_x0020ft3_x002fd = 119,
	resqml2__ResqmlUom__1000_x0020gal_x005bUK_x005d = 120,
	resqml2__ResqmlUom__1000_x0020gal_x005bUS_x005d = 121,
	resqml2__ResqmlUom__1000_x0020lbf_x002eft = 122,
	resqml2__ResqmlUom__1000_x0020m3 = 123,
	resqml2__ResqmlUom__1000_x0020m3_x002f_x0028d_x002em_x0029 = 124,
	resqml2__ResqmlUom__1000_x0020m3_x002f_x0028h_x002em_x0029 = 125,
	resqml2__ResqmlUom__1000_x0020m3_x002fd = 126,
	resqml2__ResqmlUom__1000_x0020m3_x002fh = 127,
	resqml2__ResqmlUom__1000_x0020m3_x002fm3 = 128,
	resqml2__ResqmlUom__1000_x0020m4_x002fd = 129,
	resqml2__ResqmlUom__1E_6_x0020acre_x002eft_x002fbbl = 130,
	resqml2__ResqmlUom__1E_6_x0020bbl_x002fft3 = 131,
	resqml2__ResqmlUom__1E_6_x0020bbl_x002fm3 = 132,
	resqml2__ResqmlUom__1E_6_x0020gal_x005bUS_x005d = 133,
	resqml2__ResqmlUom__1E_6_x0020m3_x002f_x0028m3_x002edegC_x0029 = 134,
	resqml2__ResqmlUom__1E_6_x0020m3_x002f_x0028m3_x002edegF_x0029 = 135,
	resqml2__ResqmlUom__1E_9_x00201_x002fft = 136,
	resqml2__ResqmlUom__1E12_x0020ft3 = 137,
	resqml2__ResqmlUom__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 138,
	resqml2__ResqmlUom__1E6_x0020bbl = 139,
	resqml2__ResqmlUom__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 140,
	resqml2__ResqmlUom__1E6_x0020bbl_x002facre = 141,
	resqml2__ResqmlUom__1E6_x0020bbl_x002fd = 142,
	resqml2__ResqmlUom__1E6_x0020Btu_x005bIT_x005d = 143,
	resqml2__ResqmlUom__1E6_x0020Btu_x005bIT_x005d_x002fh = 144,
	resqml2__ResqmlUom__1E6_x0020ft3 = 145,
	resqml2__ResqmlUom__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 146,
	resqml2__ResqmlUom__1E6_x0020ft3_x002fbbl = 147,
	resqml2__ResqmlUom__1E6_x0020ft3_x002fd = 148,
	resqml2__ResqmlUom__1E6_x0020lbm_x002fa = 149,
	resqml2__ResqmlUom__1E6_x0020m3 = 150,
	resqml2__ResqmlUom__1E6_x0020m3_x002fd = 151,
	resqml2__ResqmlUom__1E9_x0020bbl = 152,
	resqml2__ResqmlUom__1E9_x0020ft3 = 153,
	resqml2__ResqmlUom__30_x0020ft = 154,
	resqml2__ResqmlUom__30_x0020m = 155,
	resqml2__ResqmlUom__A = 156,
	resqml2__ResqmlUom__a = 157,
	resqml2__ResqmlUom__A_x002eh = 158,
	resqml2__ResqmlUom__A_x002em2 = 159,
	resqml2__ResqmlUom__A_x002es = 160,
	resqml2__ResqmlUom__A_x002es_x002fkg = 161,
	resqml2__ResqmlUom__A_x002es_x002fm3 = 162,
	resqml2__ResqmlUom__A_x002fcm2 = 163,
	resqml2__ResqmlUom__A_x002fft2 = 164,
	resqml2__ResqmlUom__A_x002fm = 165,
	resqml2__ResqmlUom__A_x002fm2 = 166,
	resqml2__ResqmlUom__A_x002fmm = 167,
	resqml2__ResqmlUom__A_x002fmm2 = 168,
	resqml2__ResqmlUom__a_x005bt_x005d = 169,
	resqml2__ResqmlUom__acre = 170,
	resqml2__ResqmlUom__acre_x002eft = 171,
	resqml2__ResqmlUom__ag = 172,
	resqml2__ResqmlUom__aJ = 173,
	resqml2__ResqmlUom__angstrom = 174,
	resqml2__ResqmlUom__at = 175,
	resqml2__ResqmlUom__atm = 176,
	resqml2__ResqmlUom__atm_x002fft = 177,
	resqml2__ResqmlUom__atm_x002fh = 178,
	resqml2__ResqmlUom__atm_x002fhm = 179,
	resqml2__ResqmlUom__atm_x002fm = 180,
	resqml2__ResqmlUom__b = 181,
	resqml2__ResqmlUom__B = 182,
	resqml2__ResqmlUom__B_x002eW = 183,
	resqml2__ResqmlUom__b_x002fcm3 = 184,
	resqml2__ResqmlUom__B_x002fm = 185,
	resqml2__ResqmlUom__B_x002fO = 186,
	resqml2__ResqmlUom__bar = 187,
	resqml2__ResqmlUom__bar_x002fh = 188,
	resqml2__ResqmlUom__bar_x002fkm = 189,
	resqml2__ResqmlUom__bar_x002fm = 190,
	resqml2__ResqmlUom__bar2 = 191,
	resqml2__ResqmlUom__bar2_x002fcP = 192,
	resqml2__ResqmlUom__bbl = 193,
	resqml2__ResqmlUom__bbl_x002f_x0028acre_x002eft_x0029 = 194,
	resqml2__ResqmlUom__bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 195,
	resqml2__ResqmlUom__bbl_x002f_x0028d_x002eft_x0029 = 196,
	resqml2__ResqmlUom__bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 197,
	resqml2__ResqmlUom__bbl_x002f_x0028kPa_x002ed_x0029 = 198,
	resqml2__ResqmlUom__bbl_x002f_x0028psi_x002ed_x0029 = 199,
	resqml2__ResqmlUom__bbl_x002facre = 200,
	resqml2__ResqmlUom__bbl_x002fbbl = 201,
	resqml2__ResqmlUom__bbl_x002fd = 202,
	resqml2__ResqmlUom__bbl_x002fd2 = 203,
	resqml2__ResqmlUom__bbl_x002fft = 204,
	resqml2__ResqmlUom__bbl_x002fft3 = 205,
	resqml2__ResqmlUom__bbl_x002fh = 206,
	resqml2__ResqmlUom__bbl_x002fh2 = 207,
	resqml2__ResqmlUom__bbl_x002fin = 208,
	resqml2__ResqmlUom__bbl_x002fm3 = 209,
	resqml2__ResqmlUom__bbl_x002fmi = 210,
	resqml2__ResqmlUom__bbl_x002fmin = 211,
	resqml2__ResqmlUom__bbl_x002fpsi = 212,
	resqml2__ResqmlUom__bbl_x002fton_x005bUK_x005d = 213,
	resqml2__ResqmlUom__bbl_x002fton_x005bUS_x005d = 214,
	resqml2__ResqmlUom__Bd = 215,
	resqml2__ResqmlUom__bit = 216,
	resqml2__ResqmlUom__bit_x002fs = 217,
	resqml2__ResqmlUom__Bq = 218,
	resqml2__ResqmlUom__Bq_x002fkg = 219,
	resqml2__ResqmlUom__Btu_x005bIT_x005d = 220,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edegF_x0029 = 221,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edegF_x0029 = 222,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 223,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegF_x0029 = 224,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegR_x0029 = 225,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 226,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edegF_x0029 = 227,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 228,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 229,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edegF_x0029 = 230,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edegR_x0029 = 231,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028lbmol_x002edegF_x0029 = 232,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 233,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edegF_x0029 = 234,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 235,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edegF_x0029 = 236,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fbbl = 237,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fft3 = 238,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 239,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 240,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fh = 241,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002flbm = 242,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002flbmol = 243,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fmin = 244,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fs = 245,
	resqml2__ResqmlUom__Btu_x005bth_x005d = 246,
	resqml2__ResqmlUom__Btu_x005bUK_x005d = 247,
	resqml2__ResqmlUom__byte = 248,
	resqml2__ResqmlUom__byte_x002fs = 249,
	resqml2__ResqmlUom__C = 250,
	resqml2__ResqmlUom__C_x002em = 251,
	resqml2__ResqmlUom__C_x002fcm2 = 252,
	resqml2__ResqmlUom__C_x002fcm3 = 253,
	resqml2__ResqmlUom__C_x002fg = 254,
	resqml2__ResqmlUom__C_x002fkg = 255,
	resqml2__ResqmlUom__C_x002fm2 = 256,
	resqml2__ResqmlUom__C_x002fm3 = 257,
	resqml2__ResqmlUom__C_x002fmm2 = 258,
	resqml2__ResqmlUom__C_x002fmm3 = 259,
	resqml2__ResqmlUom__ca = 260,
	resqml2__ResqmlUom__cA = 261,
	resqml2__ResqmlUom__cal_x005bIT_x005d = 262,
	resqml2__ResqmlUom__cal_x005bth_x005d = 263,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028g_x002eK_x0029 = 264,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edegC_x0029 = 265,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 266,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edegC_x0029 = 267,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 268,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028mol_x002edegC_x0029 = 269,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edegC_x0029 = 270,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edegC_x0029 = 271,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 272,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fcm3 = 273,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fg = 274,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fh = 275,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fkg = 276,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002flbm = 277,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fmL = 278,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fmm3 = 279,
	resqml2__ResqmlUom__cC = 280,
	resqml2__ResqmlUom__ccal_x005bth_x005d = 281,
	resqml2__ResqmlUom__ccgr = 282,
	resqml2__ResqmlUom__cd = 283,
	resqml2__ResqmlUom__cd_x002fm2 = 284,
	resqml2__ResqmlUom__cEuc = 285,
	resqml2__ResqmlUom__ceV = 286,
	resqml2__ResqmlUom__cF = 287,
	resqml2__ResqmlUom__cg = 288,
	resqml2__ResqmlUom__cgauss = 289,
	resqml2__ResqmlUom__cgr = 290,
	resqml2__ResqmlUom__cGy = 291,
	resqml2__ResqmlUom__cH = 292,
	resqml2__ResqmlUom__chain = 293,
	resqml2__ResqmlUom__chain_x005bBnA_x005d = 294,
	resqml2__ResqmlUom__chain_x005bBnB_x005d = 295,
	resqml2__ResqmlUom__chain_x005bCla_x005d = 296,
	resqml2__ResqmlUom__chain_x005bInd37_x005d = 297,
	resqml2__ResqmlUom__chain_x005bSe_x005d = 298,
	resqml2__ResqmlUom__chain_x005bSeT_x005d = 299,
	resqml2__ResqmlUom__chain_x005bUS_x005d = 300,
	resqml2__ResqmlUom__cHz = 301,
	resqml2__ResqmlUom__Ci = 302,
	resqml2__ResqmlUom__cJ = 303,
	resqml2__ResqmlUom__cm = 304,
	resqml2__ResqmlUom__cm_x002fa = 305,
	resqml2__ResqmlUom__cm_x002fs = 306,
	resqml2__ResqmlUom__cm_x002fs2 = 307,
	resqml2__ResqmlUom__cm2 = 308,
	resqml2__ResqmlUom__cm2_x002fg = 309,
	resqml2__ResqmlUom__cm2_x002fs = 310,
	resqml2__ResqmlUom__cm3 = 311,
	resqml2__ResqmlUom__cm3_x002fcm3 = 312,
	resqml2__ResqmlUom__cm3_x002fg = 313,
	resqml2__ResqmlUom__cm3_x002fh = 314,
	resqml2__ResqmlUom__cm3_x002fL = 315,
	resqml2__ResqmlUom__cm3_x002fm3 = 316,
	resqml2__ResqmlUom__cm3_x002fmin = 317,
	resqml2__ResqmlUom__cm3_x002fs = 318,
	resqml2__ResqmlUom__cm4 = 319,
	resqml2__ResqmlUom__cmH2O_x005b4degC_x005d = 320,
	resqml2__ResqmlUom__cN = 321,
	resqml2__ResqmlUom__cohm = 322,
	resqml2__ResqmlUom__cP = 323,
	resqml2__ResqmlUom__cPa = 324,
	resqml2__ResqmlUom__crd = 325,
	resqml2__ResqmlUom__cS = 326,
	resqml2__ResqmlUom__cs = 327,
	resqml2__ResqmlUom__cSt = 328,
	resqml2__ResqmlUom__ct = 329,
	resqml2__ResqmlUom__cT = 330,
	resqml2__ResqmlUom__cu = 331,
	resqml2__ResqmlUom__cV = 332,
	resqml2__ResqmlUom__cW = 333,
	resqml2__ResqmlUom__cWb = 334,
	resqml2__ResqmlUom__cwt_x005bUK_x005d = 335,
	resqml2__ResqmlUom__cwt_x005bUS_x005d = 336,
	resqml2__ResqmlUom__d = 337,
	resqml2__ResqmlUom__D = 338,
	resqml2__ResqmlUom__D_x002eft = 339,
	resqml2__ResqmlUom__D_x002em = 340,
	resqml2__ResqmlUom__D_x002f_x0028Pa_x002es_x0029 = 341,
	resqml2__ResqmlUom__d_x002fbbl = 342,
	resqml2__ResqmlUom__D_x002fcP = 343,
	resqml2__ResqmlUom__d_x002fft3 = 344,
	resqml2__ResqmlUom__d_x002fm3 = 345,
	resqml2__ResqmlUom__D_x005bAPI_x005d = 346,
	resqml2__ResqmlUom__dA = 347,
	resqml2__ResqmlUom__dam = 348,
	resqml2__ResqmlUom__daN = 349,
	resqml2__ResqmlUom__daN_x002em = 350,
	resqml2__ResqmlUom__dAPI = 351,
	resqml2__ResqmlUom__dB = 352,
	resqml2__ResqmlUom__dB_x002eMW = 353,
	resqml2__ResqmlUom__dB_x002emW = 354,
	resqml2__ResqmlUom__dB_x002eW = 355,
	resqml2__ResqmlUom__dB_x002fft = 356,
	resqml2__ResqmlUom__dB_x002fkm = 357,
	resqml2__ResqmlUom__dB_x002fm = 358,
	resqml2__ResqmlUom__dB_x002fO = 359,
	resqml2__ResqmlUom__dC = 360,
	resqml2__ResqmlUom__dcal_x005bth_x005d = 361,
	resqml2__ResqmlUom__dega = 362,
	resqml2__ResqmlUom__dega_x002fft = 363,
	resqml2__ResqmlUom__dega_x002fh = 364,
	resqml2__ResqmlUom__dega_x002fm = 365,
	resqml2__ResqmlUom__dega_x002fmin = 366,
	resqml2__ResqmlUom__dega_x002fs = 367,
	resqml2__ResqmlUom__degC = 368,
	resqml2__ResqmlUom__degC_x002em2_x002eh_x002fkcal_x005bth_x005d = 369,
	resqml2__ResqmlUom__degC_x002fft = 370,
	resqml2__ResqmlUom__degC_x002fh = 371,
	resqml2__ResqmlUom__degC_x002fhm = 372,
	resqml2__ResqmlUom__degC_x002fkm = 373,
	resqml2__ResqmlUom__degC_x002fkPa = 374,
	resqml2__ResqmlUom__degC_x002fm = 375,
	resqml2__ResqmlUom__degC_x002fmin = 376,
	resqml2__ResqmlUom__degC_x002fs = 377,
	resqml2__ResqmlUom__degF = 378,
	resqml2__ResqmlUom__degF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 379,
	resqml2__ResqmlUom__degF_x002fft = 380,
	resqml2__ResqmlUom__degF_x002fh = 381,
	resqml2__ResqmlUom__degF_x002fm = 382,
	resqml2__ResqmlUom__degF_x002fmin = 383,
	resqml2__ResqmlUom__degF_x002fpsi = 384,
	resqml2__ResqmlUom__degF_x002fs = 385,
	resqml2__ResqmlUom__degR = 386,
	resqml2__ResqmlUom__dEuc = 387,
	resqml2__ResqmlUom__deV = 388,
	resqml2__ResqmlUom__dF = 389,
	resqml2__ResqmlUom__dgauss = 390,
	resqml2__ResqmlUom__dGy = 391,
	resqml2__ResqmlUom__dH = 392,
	resqml2__ResqmlUom__dHz = 393,
	resqml2__ResqmlUom__dJ = 394,
	resqml2__ResqmlUom__dm = 395,
	resqml2__ResqmlUom__dm_x002fs = 396,
	resqml2__ResqmlUom__dm3 = 397,
	resqml2__ResqmlUom__dm3_x002f_x0028kW_x002eh_x0029 = 398,
	resqml2__ResqmlUom__dm3_x002fkg = 399,
	resqml2__ResqmlUom__dm3_x002fkmol = 400,
	resqml2__ResqmlUom__dm3_x002fm = 401,
	resqml2__ResqmlUom__dm3_x002fm3 = 402,
	resqml2__ResqmlUom__dm3_x002fMJ = 403,
	resqml2__ResqmlUom__dm3_x002fs = 404,
	resqml2__ResqmlUom__dm3_x002fs2 = 405,
	resqml2__ResqmlUom__dm3_x002ft = 406,
	resqml2__ResqmlUom__dN = 407,
	resqml2__ResqmlUom__dN_x002em = 408,
	resqml2__ResqmlUom__dohm = 409,
	resqml2__ResqmlUom__dP = 410,
	resqml2__ResqmlUom__dPa = 411,
	resqml2__ResqmlUom__drd = 412,
	resqml2__ResqmlUom__ds = 413,
	resqml2__ResqmlUom__dS = 414,
	resqml2__ResqmlUom__dT = 415,
	resqml2__ResqmlUom__dV = 416,
	resqml2__ResqmlUom__dW = 417,
	resqml2__ResqmlUom__dWb = 418,
	resqml2__ResqmlUom__dyne = 419,
	resqml2__ResqmlUom__dyne_x002ecm2 = 420,
	resqml2__ResqmlUom__dyne_x002es_x002fcm2 = 421,
	resqml2__ResqmlUom__dyne_x002fcm = 422,
	resqml2__ResqmlUom__dyne_x002fcm2 = 423,
	resqml2__ResqmlUom__EA = 424,
	resqml2__ResqmlUom__Ea_x005bt_x005d = 425,
	resqml2__ResqmlUom__EC = 426,
	resqml2__ResqmlUom__Ecal_x005bth_x005d = 427,
	resqml2__ResqmlUom__EEuc = 428,
	resqml2__ResqmlUom__EeV = 429,
	resqml2__ResqmlUom__EF = 430,
	resqml2__ResqmlUom__Eg = 431,
	resqml2__ResqmlUom__Egauss = 432,
	resqml2__ResqmlUom__EGy = 433,
	resqml2__ResqmlUom__EH = 434,
	resqml2__ResqmlUom__EHz = 435,
	resqml2__ResqmlUom__EJ = 436,
	resqml2__ResqmlUom__EJ_x002fa = 437,
	resqml2__ResqmlUom__Em = 438,
	resqml2__ResqmlUom__EN = 439,
	resqml2__ResqmlUom__Eohm = 440,
	resqml2__ResqmlUom__EP = 441,
	resqml2__ResqmlUom__EPa = 442,
	resqml2__ResqmlUom__Erd = 443,
	resqml2__ResqmlUom__erg = 444,
	resqml2__ResqmlUom__erg_x002fa = 445,
	resqml2__ResqmlUom__erg_x002fcm2 = 446,
	resqml2__ResqmlUom__erg_x002fcm3 = 447,
	resqml2__ResqmlUom__erg_x002fg = 448,
	resqml2__ResqmlUom__erg_x002fkg = 449,
	resqml2__ResqmlUom__erg_x002fm3 = 450,
	resqml2__ResqmlUom__ES = 451,
	resqml2__ResqmlUom__ET = 452,
	resqml2__ResqmlUom__Euc = 453,
	resqml2__ResqmlUom__eV = 454,
	resqml2__ResqmlUom__EW = 455,
	resqml2__ResqmlUom__EWb = 456,
	resqml2__ResqmlUom__F = 457,
	resqml2__ResqmlUom__F_x002fm = 458,
	resqml2__ResqmlUom__fa = 459,
	resqml2__ResqmlUom__fA = 460,
	resqml2__ResqmlUom__fathom = 461,
	resqml2__ResqmlUom__fC = 462,
	resqml2__ResqmlUom__fcal_x005bth_x005d = 463,
	resqml2__ResqmlUom__fEuc = 464,
	resqml2__ResqmlUom__feV = 465,
	resqml2__ResqmlUom__fF = 466,
	resqml2__ResqmlUom__fg = 467,
	resqml2__ResqmlUom__fgauss = 468,
	resqml2__ResqmlUom__fGy = 469,
	resqml2__ResqmlUom__fH = 470,
	resqml2__ResqmlUom__fHz = 471,
	resqml2__ResqmlUom__fJ = 472,
	resqml2__ResqmlUom__floz_x005bUK_x005d = 473,
	resqml2__ResqmlUom__floz_x005bUS_x005d = 474,
	resqml2__ResqmlUom__fm = 475,
	resqml2__ResqmlUom__fN = 476,
	resqml2__ResqmlUom__fohm = 477,
	resqml2__ResqmlUom__footcandle = 478,
	resqml2__ResqmlUom__footcandle_x002es = 479,
	resqml2__ResqmlUom__fP = 480,
	resqml2__ResqmlUom__fPa = 481,
	resqml2__ResqmlUom__frd = 482,
	resqml2__ResqmlUom__fS = 483,
	resqml2__ResqmlUom__ft = 484,
	resqml2__ResqmlUom__fT = 485,
	resqml2__ResqmlUom__ft_x002fbbl = 486,
	resqml2__ResqmlUom__ft_x002fd = 487,
	resqml2__ResqmlUom__ft_x002fdegF = 488,
	resqml2__ResqmlUom__ft_x002fft = 489,
	resqml2__ResqmlUom__ft_x002fft3 = 490,
	resqml2__ResqmlUom__ft_x002fgal_x005bUS_x005d = 491,
	resqml2__ResqmlUom__ft_x002fh = 492,
	resqml2__ResqmlUom__ft_x002fin = 493,
	resqml2__ResqmlUom__ft_x002flbm = 494,
	resqml2__ResqmlUom__ft_x002fm = 495,
	resqml2__ResqmlUom__ft_x002fmi = 496,
	resqml2__ResqmlUom__ft_x002fmin = 497,
	resqml2__ResqmlUom__ft_x002fms = 498,
	resqml2__ResqmlUom__ft_x002fpsi = 499,
	resqml2__ResqmlUom__ft_x002fs = 500,
	resqml2__ResqmlUom__ft_x002fs2 = 501,
	resqml2__ResqmlUom__ft_x002fus = 502,
	resqml2__ResqmlUom__ft_x005bBnA_x005d = 503,
	resqml2__ResqmlUom__ft_x005bBnB_x005d = 504,
	resqml2__ResqmlUom__ft_x005bBr36_x005d = 505,
	resqml2__ResqmlUom__ft_x005bBr65_x005d = 506,
	resqml2__ResqmlUom__ft_x005bCla_x005d = 507,
	resqml2__ResqmlUom__ft_x005bGC_x005d = 508,
	resqml2__ResqmlUom__ft_x005bInd_x005d = 509,
	resqml2__ResqmlUom__ft_x005bInd37_x005d = 510,
	resqml2__ResqmlUom__ft_x005bInd62_x005d = 511,
	resqml2__ResqmlUom__ft_x005bInd75_x005d = 512,
	resqml2__ResqmlUom__ft_x005bSe_x005d = 513,
	resqml2__ResqmlUom__ft_x005bSeT_x005d = 514,
	resqml2__ResqmlUom__ft_x005bUS_x005d = 515,
	resqml2__ResqmlUom__ft2 = 516,
	resqml2__ResqmlUom__ft2_x002fh = 517,
	resqml2__ResqmlUom__ft2_x002fin3 = 518,
	resqml2__ResqmlUom__ft2_x002flbm = 519,
	resqml2__ResqmlUom__ft2_x002fs = 520,
	resqml2__ResqmlUom__ft3 = 521,
	resqml2__ResqmlUom__ft3_x002f_x0028d_x002eft_x0029 = 522,
	resqml2__ResqmlUom__ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 523,
	resqml2__ResqmlUom__ft3_x002f_x0028min_x002eft2_x0029 = 524,
	resqml2__ResqmlUom__ft3_x002f_x0028s_x002eft2_x0029 = 525,
	resqml2__ResqmlUom__ft3_x002fbbl = 526,
	resqml2__ResqmlUom__ft3_x002fd = 527,
	resqml2__ResqmlUom__ft3_x002fd2 = 528,
	resqml2__ResqmlUom__ft3_x002fft = 529,
	resqml2__ResqmlUom__ft3_x002fft2 = 530,
	resqml2__ResqmlUom__ft3_x002fft3 = 531,
	resqml2__ResqmlUom__ft3_x002fh = 532,
	resqml2__ResqmlUom__ft3_x002fh2 = 533,
	resqml2__ResqmlUom__ft3_x002fkg = 534,
	resqml2__ResqmlUom__ft3_x002flbm = 535,
	resqml2__ResqmlUom__ft3_x002flbmol = 536,
	resqml2__ResqmlUom__ft3_x002fmin = 537,
	resqml2__ResqmlUom__ft3_x002fmin2 = 538,
	resqml2__ResqmlUom__ft3_x002frad = 539,
	resqml2__ResqmlUom__ft3_x002fs = 540,
	resqml2__ResqmlUom__ft3_x002fs2 = 541,
	resqml2__ResqmlUom__ft3_x002fsack_x005b94lbm_x005d = 542,
	resqml2__ResqmlUom__fur_x005bUS_x005d = 543,
	resqml2__ResqmlUom__fV = 544,
	resqml2__ResqmlUom__fW = 545,
	resqml2__ResqmlUom__fWb = 546,
	resqml2__ResqmlUom__g = 547,
	resqml2__ResqmlUom__g_x002eft_x002f_x0028cm3_x002es_x0029 = 548,
	resqml2__ResqmlUom__g_x002em_x002f_x0028cm3_x002es_x0029 = 549,
	resqml2__ResqmlUom__g_x002fcm3 = 550,
	resqml2__ResqmlUom__g_x002fcm4 = 551,
	resqml2__ResqmlUom__g_x002fdm3 = 552,
	resqml2__ResqmlUom__g_x002fgal_x005bUK_x005d = 553,
	resqml2__ResqmlUom__g_x002fgal_x005bUS_x005d = 554,
	resqml2__ResqmlUom__g_x002fkg = 555,
	resqml2__ResqmlUom__g_x002fL = 556,
	resqml2__ResqmlUom__g_x002fm3 = 557,
	resqml2__ResqmlUom__g_x002fmol = 558,
	resqml2__ResqmlUom__g_x002fs = 559,
	resqml2__ResqmlUom__g_x002ft = 560,
	resqml2__ResqmlUom__GA = 561,
	resqml2__ResqmlUom__Ga_x005bt_x005d = 562,
	resqml2__ResqmlUom__Gal = 563,
	resqml2__ResqmlUom__gal_x005bUK_x005d = 564,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 565,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 566,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 567,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 568,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 569,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 570,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fd = 571,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fft3 = 572,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fh = 573,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fh2 = 574,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002flbm = 575,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fmi = 576,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fmin = 577,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fmin2 = 578,
	resqml2__ResqmlUom__gal_x005bUS_x005d = 579,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 580,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 581,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 582,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 583,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 584,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 585,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fbbl = 586,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fd = 587,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fft = 588,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fft3 = 589,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fh = 590,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fh2 = 591,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002flbm = 592,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fmi = 593,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fmin = 594,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fmin2 = 595,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 596,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fton_x005bUK_x005d = 597,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fton_x005bUS_x005d = 598,
	resqml2__ResqmlUom__gAPI = 599,
	resqml2__ResqmlUom__gauss = 600,
	resqml2__ResqmlUom__gauss_x002fcm = 601,
	resqml2__ResqmlUom__GBq = 602,
	resqml2__ResqmlUom__GC = 603,
	resqml2__ResqmlUom__Gcal_x005bth_x005d = 604,
	resqml2__ResqmlUom__GEuc = 605,
	resqml2__ResqmlUom__GeV = 606,
	resqml2__ResqmlUom__gf = 607,
	resqml2__ResqmlUom__GF = 608,
	resqml2__ResqmlUom__Gg = 609,
	resqml2__ResqmlUom__Ggauss = 610,
	resqml2__ResqmlUom__GGy = 611,
	resqml2__ResqmlUom__GH = 612,
	resqml2__ResqmlUom__GHz = 613,
	resqml2__ResqmlUom__GJ = 614,
	resqml2__ResqmlUom__Gm = 615,
	resqml2__ResqmlUom__gn = 616,
	resqml2__ResqmlUom__GN = 617,
	resqml2__ResqmlUom__Gohm = 618,
	resqml2__ResqmlUom__gon = 619,
	resqml2__ResqmlUom__GP = 620,
	resqml2__ResqmlUom__GPa = 621,
	resqml2__ResqmlUom__GPa_x002fcm = 622,
	resqml2__ResqmlUom__GPa2 = 623,
	resqml2__ResqmlUom__grain = 624,
	resqml2__ResqmlUom__grain_x002fft3 = 625,
	resqml2__ResqmlUom__grain_x002fgal_x005bUS_x005d = 626,
	resqml2__ResqmlUom__Grd = 627,
	resqml2__ResqmlUom__GS = 628,
	resqml2__ResqmlUom__GT = 629,
	resqml2__ResqmlUom__GV = 630,
	resqml2__ResqmlUom__GW = 631,
	resqml2__ResqmlUom__GW_x002eh = 632,
	resqml2__ResqmlUom__GWb = 633,
	resqml2__ResqmlUom__Gy = 634,
	resqml2__ResqmlUom__H = 635,
	resqml2__ResqmlUom__h = 636,
	resqml2__ResqmlUom__h_x002fft3 = 637,
	resqml2__ResqmlUom__h_x002fkm = 638,
	resqml2__ResqmlUom__H_x002fm = 639,
	resqml2__ResqmlUom__h_x002fm3 = 640,
	resqml2__ResqmlUom__ha = 641,
	resqml2__ResqmlUom__ha_x002em = 642,
	resqml2__ResqmlUom__hbar = 643,
	resqml2__ResqmlUom__hg = 644,
	resqml2__ResqmlUom__hL = 645,
	resqml2__ResqmlUom__hm = 646,
	resqml2__ResqmlUom__hN = 647,
	resqml2__ResqmlUom__hp = 648,
	resqml2__ResqmlUom__hp_x002eh = 649,
	resqml2__ResqmlUom__hp_x002eh_x002fbbl = 650,
	resqml2__ResqmlUom__hp_x002eh_x002flbm = 651,
	resqml2__ResqmlUom__hp_x002fft3 = 652,
	resqml2__ResqmlUom__hp_x002fin2 = 653,
	resqml2__ResqmlUom__hp_x005belec_x005d = 654,
	resqml2__ResqmlUom__hp_x005bhyd_x005d = 655,
	resqml2__ResqmlUom__hp_x005bhyd_x005d_x002fin2 = 656,
	resqml2__ResqmlUom__hp_x005bmetric_x005d = 657,
	resqml2__ResqmlUom__hp_x005bmetric_x005d_x002eh = 658,
	resqml2__ResqmlUom__hs = 659,
	resqml2__ResqmlUom__Hz = 660,
	resqml2__ResqmlUom__in = 661,
	resqml2__ResqmlUom__in_x002f_x0028in_x002edegF_x0029 = 662,
	resqml2__ResqmlUom__in_x002fa = 663,
	resqml2__ResqmlUom__in_x002fmin = 664,
	resqml2__ResqmlUom__in_x002fs = 665,
	resqml2__ResqmlUom__in_x002fs2 = 666,
	resqml2__ResqmlUom__in_x005bUS_x005d = 667,
	resqml2__ResqmlUom__in2 = 668,
	resqml2__ResqmlUom__in2_x002fft2 = 669,
	resqml2__ResqmlUom__in2_x002fin2 = 670,
	resqml2__ResqmlUom__in2_x002fs = 671,
	resqml2__ResqmlUom__in3 = 672,
	resqml2__ResqmlUom__in3_x002fft = 673,
	resqml2__ResqmlUom__in4 = 674,
	resqml2__ResqmlUom__inH2O_x005b39degF_x005d = 675,
	resqml2__ResqmlUom__inH2O_x005b60degF_x005d = 676,
	resqml2__ResqmlUom__inHg_x005b32degF_x005d = 677,
	resqml2__ResqmlUom__inHg_x005b60degF_x005d = 678,
	resqml2__ResqmlUom__J = 679,
	resqml2__ResqmlUom__J_x002em_x002f_x0028s_x002em2_x002eK_x0029 = 680,
	resqml2__ResqmlUom__J_x002em_x002fm2 = 681,
	resqml2__ResqmlUom__J_x002f_x0028g_x002eK_x0029 = 682,
	resqml2__ResqmlUom__J_x002f_x0028kg_x002eK_x0029 = 683,
	resqml2__ResqmlUom__J_x002f_x0028mol_x002eK_x0029 = 684,
	resqml2__ResqmlUom__J_x002f_x0028s_x002em2_x002edegC_x0029 = 685,
	resqml2__ResqmlUom__J_x002fcm2 = 686,
	resqml2__ResqmlUom__J_x002fdm3 = 687,
	resqml2__ResqmlUom__J_x002fg = 688,
	resqml2__ResqmlUom__J_x002fK = 689,
	resqml2__ResqmlUom__J_x002fkg = 690,
	resqml2__ResqmlUom__J_x002fm = 691,
	resqml2__ResqmlUom__J_x002fm2 = 692,
	resqml2__ResqmlUom__J_x002fm3 = 693,
	resqml2__ResqmlUom__J_x002fmol = 694,
	resqml2__ResqmlUom__J_x002fs = 695,
	resqml2__ResqmlUom__K = 696,
	resqml2__ResqmlUom__K_x002em2_x002fkW = 697,
	resqml2__ResqmlUom__K_x002em2_x002fW = 698,
	resqml2__ResqmlUom__K_x002fkm = 699,
	resqml2__ResqmlUom__K_x002fm = 700,
	resqml2__ResqmlUom__K_x002fPa = 701,
	resqml2__ResqmlUom__K_x002fs = 702,
	resqml2__ResqmlUom__K_x002fW = 703,
	resqml2__ResqmlUom__kA = 704,
	resqml2__ResqmlUom__ka_x005bt_x005d = 705,
	resqml2__ResqmlUom__kC = 706,
	resqml2__ResqmlUom__kcal_x005bth_x005d = 707,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002em_x002fcm2 = 708,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002f_x0028h_x002em_x002edegC_x0029 = 709,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 710,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002f_x0028kg_x002edegC_x0029 = 711,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fcm3 = 712,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fg = 713,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fh = 714,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fkg = 715,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fm3 = 716,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fmol = 717,
	resqml2__ResqmlUom__kcd = 718,
	resqml2__ResqmlUom__kdyne = 719,
	resqml2__ResqmlUom__kEuc = 720,
	resqml2__ResqmlUom__keV = 721,
	resqml2__ResqmlUom__kF = 722,
	resqml2__ResqmlUom__kg = 723,
	resqml2__ResqmlUom__kg_x002em = 724,
	resqml2__ResqmlUom__kg_x002em_x002fcm2 = 725,
	resqml2__ResqmlUom__kg_x002em_x002fs = 726,
	resqml2__ResqmlUom__kg_x002em2 = 727,
	resqml2__ResqmlUom__kg_x002f_x0028kW_x002eh_x0029 = 728,
	resqml2__ResqmlUom__kg_x002f_x0028m_x002es_x0029 = 729,
	resqml2__ResqmlUom__kg_x002f_x0028m2_x002es_x0029 = 730,
	resqml2__ResqmlUom__kg_x002fd = 731,
	resqml2__ResqmlUom__kg_x002fdm3 = 732,
	resqml2__ResqmlUom__kg_x002fdm4 = 733,
	resqml2__ResqmlUom__kg_x002fh = 734,
	resqml2__ResqmlUom__kg_x002fJ = 735,
	resqml2__ResqmlUom__kg_x002fkg = 736,
	resqml2__ResqmlUom__kg_x002fL = 737,
	resqml2__ResqmlUom__kg_x002fm = 738,
	resqml2__ResqmlUom__kg_x002fm2 = 739,
	resqml2__ResqmlUom__kg_x002fm3 = 740,
	resqml2__ResqmlUom__kg_x002fm4 = 741,
	resqml2__ResqmlUom__kg_x002fmin = 742,
	resqml2__ResqmlUom__kg_x002fMJ = 743,
	resqml2__ResqmlUom__kg_x002fmol = 744,
	resqml2__ResqmlUom__kg_x002fs = 745,
	resqml2__ResqmlUom__kg_x002fsack_x005b94lbm_x005d = 746,
	resqml2__ResqmlUom__kg_x002ft = 747,
	resqml2__ResqmlUom__kgauss = 748,
	resqml2__ResqmlUom__kgf = 749,
	resqml2__ResqmlUom__kgf_x002em = 750,
	resqml2__ResqmlUom__kgf_x002em_x002fcm2 = 751,
	resqml2__ResqmlUom__kgf_x002em_x002fm = 752,
	resqml2__ResqmlUom__kgf_x002em2 = 753,
	resqml2__ResqmlUom__kgf_x002es_x002fm2 = 754,
	resqml2__ResqmlUom__kgf_x002fcm = 755,
	resqml2__ResqmlUom__kgf_x002fcm2 = 756,
	resqml2__ResqmlUom__kgf_x002fkgf = 757,
	resqml2__ResqmlUom__kgf_x002fm2 = 758,
	resqml2__ResqmlUom__kgf_x002fmm2 = 759,
	resqml2__ResqmlUom__kGy = 760,
	resqml2__ResqmlUom__kH = 761,
	resqml2__ResqmlUom__kHz = 762,
	resqml2__ResqmlUom__Kibyte = 763,
	resqml2__ResqmlUom__kJ = 764,
	resqml2__ResqmlUom__kJ_x002em_x002f_x0028h_x002em2_x002eK_x0029 = 765,
	resqml2__ResqmlUom__kJ_x002f_x0028h_x002em2_x002eK_x0029 = 766,
	resqml2__ResqmlUom__kJ_x002f_x0028kg_x002eK_x0029 = 767,
	resqml2__ResqmlUom__kJ_x002f_x0028kmol_x002eK_x0029 = 768,
	resqml2__ResqmlUom__kJ_x002fdm3 = 769,
	resqml2__ResqmlUom__kJ_x002fkg = 770,
	resqml2__ResqmlUom__kJ_x002fkmol = 771,
	resqml2__ResqmlUom__kJ_x002fm3 = 772,
	resqml2__ResqmlUom__klbf = 773,
	resqml2__ResqmlUom__klbm = 774,
	resqml2__ResqmlUom__klbm_x002fin = 775,
	resqml2__ResqmlUom__klx = 776,
	resqml2__ResqmlUom__km = 777,
	resqml2__ResqmlUom__km_x002fcm = 778,
	resqml2__ResqmlUom__km_x002fdm3 = 779,
	resqml2__ResqmlUom__km_x002fh = 780,
	resqml2__ResqmlUom__km_x002fL = 781,
	resqml2__ResqmlUom__km_x002fs = 782,
	resqml2__ResqmlUom__km2 = 783,
	resqml2__ResqmlUom__km3 = 784,
	resqml2__ResqmlUom__kmol = 785,
	resqml2__ResqmlUom__kmol_x002fh = 786,
	resqml2__ResqmlUom__kmol_x002fm3 = 787,
	resqml2__ResqmlUom__kmol_x002fs = 788,
	resqml2__ResqmlUom__kN = 789,
	resqml2__ResqmlUom__kN_x002em = 790,
	resqml2__ResqmlUom__kN_x002em2 = 791,
	resqml2__ResqmlUom__kN_x002fm = 792,
	resqml2__ResqmlUom__kN_x002fm2 = 793,
	resqml2__ResqmlUom__knot = 794,
	resqml2__ResqmlUom__kohm = 795,
	resqml2__ResqmlUom__kohm_x002em = 796,
	resqml2__ResqmlUom__kP = 797,
	resqml2__ResqmlUom__kPa = 798,
	resqml2__ResqmlUom__kPa_x002es_x002fm = 799,
	resqml2__ResqmlUom__kPa_x002fh = 800,
	resqml2__ResqmlUom__kPa_x002fhm = 801,
	resqml2__ResqmlUom__kPa_x002fm = 802,
	resqml2__ResqmlUom__kPa_x002fmin = 803,
	resqml2__ResqmlUom__kPa2 = 804,
	resqml2__ResqmlUom__kPa2_x002fcP = 805,
	resqml2__ResqmlUom__kpsi = 806,
	resqml2__ResqmlUom__kpsi2 = 807,
	resqml2__ResqmlUom__krad = 808,
	resqml2__ResqmlUom__krd = 809,
	resqml2__ResqmlUom__kS = 810,
	resqml2__ResqmlUom__kS_x002fm = 811,
	resqml2__ResqmlUom__kT = 812,
	resqml2__ResqmlUom__kV = 813,
	resqml2__ResqmlUom__kW = 814,
	resqml2__ResqmlUom__kW_x002eh = 815,
	resqml2__ResqmlUom__kW_x002eh_x002f_x0028kg_x002edegC_x0029 = 816,
	resqml2__ResqmlUom__kW_x002eh_x002fdm3 = 817,
	resqml2__ResqmlUom__kW_x002eh_x002fkg = 818,
	resqml2__ResqmlUom__kW_x002eh_x002fm3 = 819,
	resqml2__ResqmlUom__kW_x002f_x0028m2_x002eK_x0029 = 820,
	resqml2__ResqmlUom__kW_x002f_x0028m3_x002eK_x0029 = 821,
	resqml2__ResqmlUom__kW_x002fcm2 = 822,
	resqml2__ResqmlUom__kW_x002fm2 = 823,
	resqml2__ResqmlUom__kW_x002fm3 = 824,
	resqml2__ResqmlUom__kWb = 825,
	resqml2__ResqmlUom__L = 826,
	resqml2__ResqmlUom__L_x002f_x0028bar_x002emin_x0029 = 827,
	resqml2__ResqmlUom__L_x002fh = 828,
	resqml2__ResqmlUom__L_x002fkg = 829,
	resqml2__ResqmlUom__L_x002fkmol = 830,
	resqml2__ResqmlUom__L_x002fm = 831,
	resqml2__ResqmlUom__L_x002fm3 = 832,
	resqml2__ResqmlUom__L_x002fmin = 833,
	resqml2__ResqmlUom__L_x002fmol = 834,
	resqml2__ResqmlUom__L_x002fs = 835,
	resqml2__ResqmlUom__L_x002fs2 = 836,
	resqml2__ResqmlUom__L_x002ft = 837,
	resqml2__ResqmlUom__L_x002fton_x005bUK_x005d = 838,
	resqml2__ResqmlUom__lbf = 839,
	resqml2__ResqmlUom__lbf_x002eft = 840,
	resqml2__ResqmlUom__lbf_x002eft_x002fbbl = 841,
	resqml2__ResqmlUom__lbf_x002eft_x002fgal_x005bUS_x005d = 842,
	resqml2__ResqmlUom__lbf_x002eft_x002fin = 843,
	resqml2__ResqmlUom__lbf_x002eft_x002fin2 = 844,
	resqml2__ResqmlUom__lbf_x002eft_x002flbm = 845,
	resqml2__ResqmlUom__lbf_x002eft_x002fmin = 846,
	resqml2__ResqmlUom__lbf_x002eft_x002fs = 847,
	resqml2__ResqmlUom__lbf_x002ein = 848,
	resqml2__ResqmlUom__lbf_x002ein_x002fin = 849,
	resqml2__ResqmlUom__lbf_x002ein2 = 850,
	resqml2__ResqmlUom__lbf_x002es_x002fft2 = 851,
	resqml2__ResqmlUom__lbf_x002es_x002fin2 = 852,
	resqml2__ResqmlUom__lbf_x002fft = 853,
	resqml2__ResqmlUom__lbf_x002fft2 = 854,
	resqml2__ResqmlUom__lbf_x002fft3 = 855,
	resqml2__ResqmlUom__lbf_x002fgal_x005bUS_x005d = 856,
	resqml2__ResqmlUom__lbf_x002fin = 857,
	resqml2__ResqmlUom__lbf_x002flbf = 858,
	resqml2__ResqmlUom__lbm = 859,
	resqml2__ResqmlUom__lbm_x002eft = 860,
	resqml2__ResqmlUom__lbm_x002eft_x002fs = 861,
	resqml2__ResqmlUom__lbm_x002eft2 = 862,
	resqml2__ResqmlUom__lbm_x002eft2_x002fs2 = 863,
	resqml2__ResqmlUom__lbm_x002f_x0028ft_x002eh_x0029 = 864,
	resqml2__ResqmlUom__lbm_x002f_x0028ft_x002es_x0029 = 865,
	resqml2__ResqmlUom__lbm_x002f_x0028ft2_x002eh_x0029 = 866,
	resqml2__ResqmlUom__lbm_x002f_x0028ft2_x002es_x0029 = 867,
	resqml2__ResqmlUom__lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 868,
	resqml2__ResqmlUom__lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 869,
	resqml2__ResqmlUom__lbm_x002f_x0028hp_x002eh_x0029 = 870,
	resqml2__ResqmlUom__lbm_x002fbbl = 871,
	resqml2__ResqmlUom__lbm_x002fd = 872,
	resqml2__ResqmlUom__lbm_x002fft = 873,
	resqml2__ResqmlUom__lbm_x002fft2 = 874,
	resqml2__ResqmlUom__lbm_x002fft3 = 875,
	resqml2__ResqmlUom__lbm_x002fft4 = 876,
	resqml2__ResqmlUom__lbm_x002fgal_x005bUK_x005d = 877,
	resqml2__ResqmlUom__lbm_x002fgal_x005bUS_x005d = 878,
	resqml2__ResqmlUom__lbm_x002fh = 879,
	resqml2__ResqmlUom__lbm_x002fin3 = 880,
	resqml2__ResqmlUom__lbm_x002flbmol = 881,
	resqml2__ResqmlUom__lbm_x002fmin = 882,
	resqml2__ResqmlUom__lbm_x002fs = 883,
	resqml2__ResqmlUom__lbmol = 884,
	resqml2__ResqmlUom__lbmol_x002f_x0028h_x002eft2_x0029 = 885,
	resqml2__ResqmlUom__lbmol_x002f_x0028s_x002eft2_x0029 = 886,
	resqml2__ResqmlUom__lbmol_x002fft3 = 887,
	resqml2__ResqmlUom__lbmol_x002fgal_x005bUK_x005d = 888,
	resqml2__ResqmlUom__lbmol_x002fgal_x005bUS_x005d = 889,
	resqml2__ResqmlUom__lbmol_x002fh = 890,
	resqml2__ResqmlUom__lbmol_x002fs = 891,
	resqml2__ResqmlUom__link = 892,
	resqml2__ResqmlUom__link_x005bBnA_x005d = 893,
	resqml2__ResqmlUom__link_x005bBnB_x005d = 894,
	resqml2__ResqmlUom__link_x005bCla_x005d = 895,
	resqml2__ResqmlUom__link_x005bSe_x005d = 896,
	resqml2__ResqmlUom__link_x005bSeT_x005d = 897,
	resqml2__ResqmlUom__link_x005bUS_x005d = 898,
	resqml2__ResqmlUom__lm = 899,
	resqml2__ResqmlUom__lm_x002es = 900,
	resqml2__ResqmlUom__lm_x002fm2 = 901,
	resqml2__ResqmlUom__lm_x002fW = 902,
	resqml2__ResqmlUom__lx = 903,
	resqml2__ResqmlUom__lx_x002es = 904,
	resqml2__ResqmlUom__m = 905,
	resqml2__ResqmlUom__m_x002f_x0028m_x002eK_x0029 = 906,
	resqml2__ResqmlUom__m_x002fcm = 907,
	resqml2__ResqmlUom__m_x002fd = 908,
	resqml2__ResqmlUom__m_x002fh = 909,
	resqml2__ResqmlUom__m_x002fK = 910,
	resqml2__ResqmlUom__m_x002fkg = 911,
	resqml2__ResqmlUom__m_x002fkm = 912,
	resqml2__ResqmlUom__m_x002fkPa = 913,
	resqml2__ResqmlUom__m_x002fm = 914,
	resqml2__ResqmlUom__m_x002fm3 = 915,
	resqml2__ResqmlUom__m_x002fmin = 916,
	resqml2__ResqmlUom__m_x002fms = 917,
	resqml2__ResqmlUom__m_x002fPa = 918,
	resqml2__ResqmlUom__m_x002fs = 919,
	resqml2__ResqmlUom__m_x002fs2 = 920,
	resqml2__ResqmlUom__m_x005bGer_x005d = 921,
	resqml2__ResqmlUom__m2 = 922,
	resqml2__ResqmlUom__m2_x002f_x0028kPa_x002ed_x0029 = 923,
	resqml2__ResqmlUom__m2_x002f_x0028Pa_x002es_x0029 = 924,
	resqml2__ResqmlUom__m2_x002fcm3 = 925,
	resqml2__ResqmlUom__m2_x002fd = 926,
	resqml2__ResqmlUom__m2_x002fg = 927,
	resqml2__ResqmlUom__m2_x002fh = 928,
	resqml2__ResqmlUom__m2_x002fkg = 929,
	resqml2__ResqmlUom__m2_x002fm2 = 930,
	resqml2__ResqmlUom__m2_x002fm3 = 931,
	resqml2__ResqmlUom__m2_x002fmol = 932,
	resqml2__ResqmlUom__m2_x002fs = 933,
	resqml2__ResqmlUom__m3 = 934,
	resqml2__ResqmlUom__m3_x002f_x0028bar_x002ed_x0029 = 935,
	resqml2__ResqmlUom__m3_x002f_x0028bar_x002eh_x0029 = 936,
	resqml2__ResqmlUom__m3_x002f_x0028bar_x002emin_x0029 = 937,
	resqml2__ResqmlUom__m3_x002f_x0028d_x002em_x0029 = 938,
	resqml2__ResqmlUom__m3_x002f_x0028h_x002em_x0029 = 939,
	resqml2__ResqmlUom__m3_x002f_x0028ha_x002em_x0029 = 940,
	resqml2__ResqmlUom__m3_x002f_x0028kPa_x002ed_x0029 = 941,
	resqml2__ResqmlUom__m3_x002f_x0028kPa_x002eh_x0029 = 942,
	resqml2__ResqmlUom__m3_x002f_x0028kW_x002eh_x0029 = 943,
	resqml2__ResqmlUom__m3_x002f_x0028m3_x002eK_x0029 = 944,
	resqml2__ResqmlUom__m3_x002f_x0028Pa_x002es_x0029 = 945,
	resqml2__ResqmlUom__m3_x002f_x0028psi_x002ed_x0029 = 946,
	resqml2__ResqmlUom__m3_x002f_x0028s_x002eft_x0029 = 947,
	resqml2__ResqmlUom__m3_x002f_x0028s_x002em_x0029 = 948,
	resqml2__ResqmlUom__m3_x002f_x0028s_x002em2_x0029 = 949,
	resqml2__ResqmlUom__m3_x002f_x0028s_x002em3_x0029 = 950,
	resqml2__ResqmlUom__m3_x002fbbl = 951,
	resqml2__ResqmlUom__m3_x002fd = 952,
	resqml2__ResqmlUom__m3_x002fd2 = 953,
	resqml2__ResqmlUom__m3_x002fg = 954,
	resqml2__ResqmlUom__m3_x002fh = 955,
	resqml2__ResqmlUom__m3_x002fJ = 956,
	resqml2__ResqmlUom__m3_x002fkg = 957,
	resqml2__ResqmlUom__m3_x002fkm = 958,
	resqml2__ResqmlUom__m3_x002fkmol = 959,
	resqml2__ResqmlUom__m3_x002fkPa = 960,
	resqml2__ResqmlUom__m3_x002fm = 961,
	resqml2__ResqmlUom__m3_x002fm2 = 962,
	resqml2__ResqmlUom__m3_x002fm3 = 963,
	resqml2__ResqmlUom__m3_x002fmin = 964,
	resqml2__ResqmlUom__m3_x002fmol = 965,
	resqml2__ResqmlUom__m3_x002fPa = 966,
	resqml2__ResqmlUom__m3_x002frad = 967,
	resqml2__ResqmlUom__m3_x002frev = 968,
	resqml2__ResqmlUom__m3_x002fs = 969,
	resqml2__ResqmlUom__m3_x002fs2 = 970,
	resqml2__ResqmlUom__m3_x002ft = 971,
	resqml2__ResqmlUom__m3_x002fton_x005bUK_x005d = 972,
	resqml2__ResqmlUom__m3_x002fton_x005bUS_x005d = 973,
	resqml2__ResqmlUom__m4 = 974,
	resqml2__ResqmlUom__m4_x002fs = 975,
	resqml2__ResqmlUom__mA = 976,
	resqml2__ResqmlUom__MA = 977,
	resqml2__ResqmlUom__mA_x002fcm2 = 978,
	resqml2__ResqmlUom__mA_x002fft2 = 979,
	resqml2__ResqmlUom__Ma_x005bt_x005d = 980,
	resqml2__ResqmlUom__mbar = 981,
	resqml2__ResqmlUom__MBq = 982,
	resqml2__ResqmlUom__mC = 983,
	resqml2__ResqmlUom__MC = 984,
	resqml2__ResqmlUom__mC_x002fm2 = 985,
	resqml2__ResqmlUom__Mcal_x005bth_x005d = 986,
	resqml2__ResqmlUom__mcal_x005bth_x005d = 987,
	resqml2__ResqmlUom__mCi = 988,
	resqml2__ResqmlUom__mD = 989,
	resqml2__ResqmlUom__mD_x002eft = 990,
	resqml2__ResqmlUom__mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 991,
	resqml2__ResqmlUom__mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 992,
	resqml2__ResqmlUom__mD_x002em = 993,
	resqml2__ResqmlUom__mD_x002f_x0028Pa_x002es_x0029 = 994,
	resqml2__ResqmlUom__mD_x002fcP = 995,
	resqml2__ResqmlUom__MEuc = 996,
	resqml2__ResqmlUom__mEuc = 997,
	resqml2__ResqmlUom__meV = 998,
	resqml2__ResqmlUom__MeV = 999,
	resqml2__ResqmlUom__mF = 1000,
	resqml2__ResqmlUom__MF = 1001,
	resqml2__ResqmlUom__Mg = 1002,
	resqml2__ResqmlUom__mg = 1003,
	resqml2__ResqmlUom__Mg_x002fa = 1004,
	resqml2__ResqmlUom__Mg_x002fd = 1005,
	resqml2__ResqmlUom__mg_x002fdm3 = 1006,
	resqml2__ResqmlUom__mg_x002fg = 1007,
	resqml2__ResqmlUom__mg_x002fgal_x005bUS_x005d = 1008,
	resqml2__ResqmlUom__Mg_x002fh = 1009,
	resqml2__ResqmlUom__Mg_x002fin = 1010,
	resqml2__ResqmlUom__mg_x002fJ = 1011,
	resqml2__ResqmlUom__mg_x002fkg = 1012,
	resqml2__ResqmlUom__mg_x002fL = 1013,
	resqml2__ResqmlUom__Mg_x002fm2 = 1014,
	resqml2__ResqmlUom__Mg_x002fm3 = 1015,
	resqml2__ResqmlUom__mg_x002fm3 = 1016,
	resqml2__ResqmlUom__Mg_x002fmin = 1017,
	resqml2__ResqmlUom__mGal = 1018,
	resqml2__ResqmlUom__Mgauss = 1019,
	resqml2__ResqmlUom__mgauss = 1020,
	resqml2__ResqmlUom__Mgf = 1021,
	resqml2__ResqmlUom__mgn = 1022,
	resqml2__ResqmlUom__MGy = 1023,
	resqml2__ResqmlUom__mGy = 1024,
	resqml2__ResqmlUom__MH = 1025,
	resqml2__ResqmlUom__mH = 1026,
	resqml2__ResqmlUom__mHz = 1027,
	resqml2__ResqmlUom__MHz = 1028,
	resqml2__ResqmlUom__mi = 1029,
	resqml2__ResqmlUom__mi_x002fgal_x005bUK_x005d = 1030,
	resqml2__ResqmlUom__mi_x002fgal_x005bUS_x005d = 1031,
	resqml2__ResqmlUom__mi_x002fh = 1032,
	resqml2__ResqmlUom__mi_x002fin = 1033,
	resqml2__ResqmlUom__mi_x005bnaut_x005d = 1034,
	resqml2__ResqmlUom__mi_x005bnautUK_x005d = 1035,
	resqml2__ResqmlUom__mi_x005bUS_x005d = 1036,
	resqml2__ResqmlUom__mi_x005bUS_x005d2 = 1037,
	resqml2__ResqmlUom__mi2 = 1038,
	resqml2__ResqmlUom__mi3 = 1039,
	resqml2__ResqmlUom__Mibyte = 1040,
	resqml2__ResqmlUom__mil = 1041,
	resqml2__ResqmlUom__mil_x002fa = 1042,
	resqml2__ResqmlUom__mila = 1043,
	resqml2__ResqmlUom__min_ = 1044,
	resqml2__ResqmlUom__min_x002fft = 1045,
	resqml2__ResqmlUom__min_x002fm = 1046,
	resqml2__ResqmlUom__mina = 1047,
	resqml2__ResqmlUom__mJ = 1048,
	resqml2__ResqmlUom__MJ = 1049,
	resqml2__ResqmlUom__MJ_x002fa = 1050,
	resqml2__ResqmlUom__mJ_x002fcm2 = 1051,
	resqml2__ResqmlUom__MJ_x002fkg = 1052,
	resqml2__ResqmlUom__MJ_x002fkmol = 1053,
	resqml2__ResqmlUom__MJ_x002fm = 1054,
	resqml2__ResqmlUom__mJ_x002fm2 = 1055,
	resqml2__ResqmlUom__MJ_x002fm3 = 1056,
	resqml2__ResqmlUom__mL = 1057,
	resqml2__ResqmlUom__mL_x002fgal_x005bUK_x005d = 1058,
	resqml2__ResqmlUom__mL_x002fgal_x005bUS_x005d = 1059,
	resqml2__ResqmlUom__mL_x002fmL = 1060,
	resqml2__ResqmlUom__Mm = 1061,
	resqml2__ResqmlUom__mm = 1062,
	resqml2__ResqmlUom__mm_x002f_x0028mm_x002eK_x0029 = 1063,
	resqml2__ResqmlUom__mm_x002fa = 1064,
	resqml2__ResqmlUom__mm_x002fs = 1065,
	resqml2__ResqmlUom__mm2 = 1066,
	resqml2__ResqmlUom__mm2_x002fmm2 = 1067,
	resqml2__ResqmlUom__mm2_x002fs = 1068,
	resqml2__ResqmlUom__mm3 = 1069,
	resqml2__ResqmlUom__mm3_x002fJ = 1070,
	resqml2__ResqmlUom__mmHg_x005b0degC_x005d = 1071,
	resqml2__ResqmlUom__mmol = 1072,
	resqml2__ResqmlUom__mN = 1073,
	resqml2__ResqmlUom__MN = 1074,
	resqml2__ResqmlUom__mN_x002em2 = 1075,
	resqml2__ResqmlUom__mN_x002fkm = 1076,
	resqml2__ResqmlUom__mN_x002fm = 1077,
	resqml2__ResqmlUom__mohm = 1078,
	resqml2__ResqmlUom__Mohm = 1079,
	resqml2__ResqmlUom__mol = 1080,
	resqml2__ResqmlUom__mol_x002em2_x002f_x0028mol_x002es_x0029 = 1081,
	resqml2__ResqmlUom__mol_x002f_x0028s_x002em2_x0029 = 1082,
	resqml2__ResqmlUom__mol_x002fm2 = 1083,
	resqml2__ResqmlUom__mol_x002fm3 = 1084,
	resqml2__ResqmlUom__mol_x002fmol = 1085,
	resqml2__ResqmlUom__mol_x002fs = 1086,
	resqml2__ResqmlUom__mP = 1087,
	resqml2__ResqmlUom__MP = 1088,
	resqml2__ResqmlUom__MPa = 1089,
	resqml2__ResqmlUom__mPa = 1090,
	resqml2__ResqmlUom__mPa_x002es = 1091,
	resqml2__ResqmlUom__MPa_x002es_x002fm = 1092,
	resqml2__ResqmlUom__MPa_x002fh = 1093,
	resqml2__ResqmlUom__MPa_x002fm = 1094,
	resqml2__ResqmlUom__Mpsi = 1095,
	resqml2__ResqmlUom__mrad = 1096,
	resqml2__ResqmlUom__Mrad = 1097,
	resqml2__ResqmlUom__Mrd = 1098,
	resqml2__ResqmlUom__mrd = 1099,
	resqml2__ResqmlUom__mrem = 1100,
	resqml2__ResqmlUom__mrem_x002fh = 1101,
	resqml2__ResqmlUom__MS = 1102,
	resqml2__ResqmlUom__mS = 1103,
	resqml2__ResqmlUom__ms = 1104,
	resqml2__ResqmlUom__ms_x002fcm = 1105,
	resqml2__ResqmlUom__mS_x002fcm = 1106,
	resqml2__ResqmlUom__ms_x002fft = 1107,
	resqml2__ResqmlUom__ms_x002fin = 1108,
	resqml2__ResqmlUom__mS_x002fm = 1109,
	resqml2__ResqmlUom__ms_x002fm = 1110,
	resqml2__ResqmlUom__ms_x002fs = 1111,
	resqml2__ResqmlUom__mSv = 1112,
	resqml2__ResqmlUom__mSv_x002fh = 1113,
	resqml2__ResqmlUom__mT = 1114,
	resqml2__ResqmlUom__mT_x002fdm = 1115,
	resqml2__ResqmlUom__MV = 1116,
	resqml2__ResqmlUom__mV = 1117,
	resqml2__ResqmlUom__mV_x002fft = 1118,
	resqml2__ResqmlUom__mV_x002fm = 1119,
	resqml2__ResqmlUom__MW = 1120,
	resqml2__ResqmlUom__mW = 1121,
	resqml2__ResqmlUom__MW_x002eh = 1122,
	resqml2__ResqmlUom__MW_x002eh_x002fkg = 1123,
	resqml2__ResqmlUom__MW_x002eh_x002fm3 = 1124,
	resqml2__ResqmlUom__mW_x002fm2 = 1125,
	resqml2__ResqmlUom__mWb = 1126,
	resqml2__ResqmlUom__MWb = 1127,
	resqml2__ResqmlUom__N = 1128,
	resqml2__ResqmlUom__N_x002em = 1129,
	resqml2__ResqmlUom__N_x002em_x002fm = 1130,
	resqml2__ResqmlUom__N_x002em2 = 1131,
	resqml2__ResqmlUom__N_x002es_x002fm2 = 1132,
	resqml2__ResqmlUom__N_x002fm = 1133,
	resqml2__ResqmlUom__N_x002fm2 = 1134,
	resqml2__ResqmlUom__N_x002fm3 = 1135,
	resqml2__ResqmlUom__N_x002fmm2 = 1136,
	resqml2__ResqmlUom__N_x002fN = 1137,
	resqml2__ResqmlUom__nA = 1138,
	resqml2__ResqmlUom__na = 1139,
	resqml2__ResqmlUom__nAPI = 1140,
	resqml2__ResqmlUom__nC = 1141,
	resqml2__ResqmlUom__ncal_x005bth_x005d = 1142,
	resqml2__ResqmlUom__nCi = 1143,
	resqml2__ResqmlUom__nEuc = 1144,
	resqml2__ResqmlUom__neV = 1145,
	resqml2__ResqmlUom__nF = 1146,
	resqml2__ResqmlUom__ng = 1147,
	resqml2__ResqmlUom__ng_x002fg = 1148,
	resqml2__ResqmlUom__ng_x002fmg = 1149,
	resqml2__ResqmlUom__ngauss = 1150,
	resqml2__ResqmlUom__nGy = 1151,
	resqml2__ResqmlUom__nH = 1152,
	resqml2__ResqmlUom__nHz = 1153,
	resqml2__ResqmlUom__nJ = 1154,
	resqml2__ResqmlUom__nm = 1155,
	resqml2__ResqmlUom__nm_x002fs = 1156,
	resqml2__ResqmlUom__nN = 1157,
	resqml2__ResqmlUom__nohm = 1158,
	resqml2__ResqmlUom__nohm_x002emil2_x002fft = 1159,
	resqml2__ResqmlUom__nohm_x002emm2_x002fm = 1160,
	resqml2__ResqmlUom__nP = 1161,
	resqml2__ResqmlUom__nPa = 1162,
	resqml2__ResqmlUom__nrd = 1163,
	resqml2__ResqmlUom__nS = 1164,
	resqml2__ResqmlUom__ns = 1165,
	resqml2__ResqmlUom__ns_x002fft = 1166,
	resqml2__ResqmlUom__ns_x002fm = 1167,
	resqml2__ResqmlUom__nT = 1168,
	resqml2__ResqmlUom__nV = 1169,
	resqml2__ResqmlUom__nW = 1170,
	resqml2__ResqmlUom__nWb = 1171,
	resqml2__ResqmlUom__O = 1172,
	resqml2__ResqmlUom__Oe = 1173,
	resqml2__ResqmlUom__ohm = 1174,
	resqml2__ResqmlUom__ohm_x002ecm = 1175,
	resqml2__ResqmlUom__ohm_x002em = 1176,
	resqml2__ResqmlUom__ohm_x002em2_x002fm = 1177,
	resqml2__ResqmlUom__ohm_x002fm = 1178,
	resqml2__ResqmlUom__ozf = 1179,
	resqml2__ResqmlUom__ozm = 1180,
	resqml2__ResqmlUom__ozm_x005btroy_x005d = 1181,
	resqml2__ResqmlUom__P = 1182,
	resqml2__ResqmlUom__pA = 1183,
	resqml2__ResqmlUom__Pa = 1184,
	resqml2__ResqmlUom__Pa_x002es = 1185,
	resqml2__ResqmlUom__Pa_x002es_x002em3_x002fkg = 1186,
	resqml2__ResqmlUom__Pa_x002es_x002fm3 = 1187,
	resqml2__ResqmlUom__Pa_x002es2_x002fm3 = 1188,
	resqml2__ResqmlUom__Pa_x002fh = 1189,
	resqml2__ResqmlUom__Pa_x002fm = 1190,
	resqml2__ResqmlUom__Pa_x002fm3 = 1191,
	resqml2__ResqmlUom__Pa_x002fs = 1192,
	resqml2__ResqmlUom__Pa2 = 1193,
	resqml2__ResqmlUom__Pa2_x002f_x0028Pa_x002es_x0029 = 1194,
	resqml2__ResqmlUom__pC = 1195,
	resqml2__ResqmlUom__pcal_x005bth_x005d = 1196,
	resqml2__ResqmlUom__pCi = 1197,
	resqml2__ResqmlUom__pCi_x002fg = 1198,
	resqml2__ResqmlUom__pdl = 1199,
	resqml2__ResqmlUom__pdl_x002ecm2 = 1200,
	resqml2__ResqmlUom__pdl_x002eft = 1201,
	resqml2__ResqmlUom__pdl_x002fcm = 1202,
	resqml2__ResqmlUom__pEuc = 1203,
	resqml2__ResqmlUom__peV = 1204,
	resqml2__ResqmlUom__pF = 1205,
	resqml2__ResqmlUom__pg = 1206,
	resqml2__ResqmlUom__pgauss = 1207,
	resqml2__ResqmlUom__pGy = 1208,
	resqml2__ResqmlUom__pHz = 1209,
	resqml2__ResqmlUom__pJ = 1210,
	resqml2__ResqmlUom__pm = 1211,
	resqml2__ResqmlUom__pN = 1212,
	resqml2__ResqmlUom__pohm = 1213,
	resqml2__ResqmlUom__pP = 1214,
	resqml2__ResqmlUom__pPa = 1215,
	resqml2__ResqmlUom__ppk = 1216,
	resqml2__ResqmlUom__ppm = 1217,
	resqml2__ResqmlUom__ppm_x005bmass_x005d = 1218,
	resqml2__ResqmlUom__ppm_x005bvol_x005d = 1219,
	resqml2__ResqmlUom__ppm_x005bvol_x005d_x002fdegC = 1220,
	resqml2__ResqmlUom__ppm_x005bvol_x005d_x002fdegF = 1221,
	resqml2__ResqmlUom__prd = 1222,
	resqml2__ResqmlUom__ps = 1223,
	resqml2__ResqmlUom__pS = 1224,
	resqml2__ResqmlUom__psi = 1225,
	resqml2__ResqmlUom__psi_x002ed_x002fbbl = 1226,
	resqml2__ResqmlUom__psi_x002es = 1227,
	resqml2__ResqmlUom__psi_x002fft = 1228,
	resqml2__ResqmlUom__psi_x002fh = 1229,
	resqml2__ResqmlUom__psi_x002fm = 1230,
	resqml2__ResqmlUom__psi_x002fmin = 1231,
	resqml2__ResqmlUom__psi2 = 1232,
	resqml2__ResqmlUom__psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1233,
	resqml2__ResqmlUom__psi2_x002fcP = 1234,
	resqml2__ResqmlUom__pT = 1235,
	resqml2__ResqmlUom__pt_x005bUK_x005d = 1236,
	resqml2__ResqmlUom__pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 1237,
	resqml2__ResqmlUom__pt_x005bUS_x005d = 1238,
	resqml2__ResqmlUom__pV = 1239,
	resqml2__ResqmlUom__pW = 1240,
	resqml2__ResqmlUom__pWb = 1241,
	resqml2__ResqmlUom__qt_x005bUK_x005d = 1242,
	resqml2__ResqmlUom__qt_x005bUS_x005d = 1243,
	resqml2__ResqmlUom__quad = 1244,
	resqml2__ResqmlUom__quad_x002fa = 1245,
	resqml2__ResqmlUom__rad = 1246,
	resqml2__ResqmlUom__rad_x002fft = 1247,
	resqml2__ResqmlUom__rad_x002fft3 = 1248,
	resqml2__ResqmlUom__rad_x002fm = 1249,
	resqml2__ResqmlUom__rad_x002fm3 = 1250,
	resqml2__ResqmlUom__rad_x002fs = 1251,
	resqml2__ResqmlUom__rad_x002fs2 = 1252,
	resqml2__ResqmlUom__rd = 1253,
	resqml2__ResqmlUom__rem = 1254,
	resqml2__ResqmlUom__rem_x002fh = 1255,
	resqml2__ResqmlUom__rev = 1256,
	resqml2__ResqmlUom__rev_x002fft = 1257,
	resqml2__ResqmlUom__rev_x002fm = 1258,
	resqml2__ResqmlUom__rev_x002fs = 1259,
	resqml2__ResqmlUom__rod_x005bUS_x005d = 1260,
	resqml2__ResqmlUom__rpm = 1261,
	resqml2__ResqmlUom__rpm_x002fs = 1262,
	resqml2__ResqmlUom__S = 1263,
	resqml2__ResqmlUom__s = 1264,
	resqml2__ResqmlUom__s_x002fcm = 1265,
	resqml2__ResqmlUom__s_x002fft = 1266,
	resqml2__ResqmlUom__s_x002fft3 = 1267,
	resqml2__ResqmlUom__s_x002fin = 1268,
	resqml2__ResqmlUom__s_x002fkg = 1269,
	resqml2__ResqmlUom__s_x002fL = 1270,
	resqml2__ResqmlUom__S_x002fm = 1271,
	resqml2__ResqmlUom__s_x002fm = 1272,
	resqml2__ResqmlUom__s_x002fm3 = 1273,
	resqml2__ResqmlUom__s_x002fqt_x005bUK_x005d = 1274,
	resqml2__ResqmlUom__s_x002fqt_x005bUS_x005d = 1275,
	resqml2__ResqmlUom__s_x002fs = 1276,
	resqml2__ResqmlUom__sack_x005b94lbm_x005d = 1277,
	resqml2__ResqmlUom__seca = 1278,
	resqml2__ResqmlUom__section = 1279,
	resqml2__ResqmlUom__sr = 1280,
	resqml2__ResqmlUom__St = 1281,
	resqml2__ResqmlUom__Sv = 1282,
	resqml2__ResqmlUom__Sv_x002fh = 1283,
	resqml2__ResqmlUom__Sv_x002fs = 1284,
	resqml2__ResqmlUom__t = 1285,
	resqml2__ResqmlUom__T = 1286,
	resqml2__ResqmlUom__t_x002fa = 1287,
	resqml2__ResqmlUom__t_x002fd = 1288,
	resqml2__ResqmlUom__t_x002fh = 1289,
	resqml2__ResqmlUom__T_x002fm = 1290,
	resqml2__ResqmlUom__t_x002fm3 = 1291,
	resqml2__ResqmlUom__t_x002fmin = 1292,
	resqml2__ResqmlUom__TA = 1293,
	resqml2__ResqmlUom__Ta_x005bt_x005d = 1294,
	resqml2__ResqmlUom__TBq = 1295,
	resqml2__ResqmlUom__TC = 1296,
	resqml2__ResqmlUom__Tcal_x005bth_x005d = 1297,
	resqml2__ResqmlUom__TD_x005bAPI_x005d = 1298,
	resqml2__ResqmlUom__TD_x005bAPI_x005d_x002em = 1299,
	resqml2__ResqmlUom__TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 1300,
	resqml2__ResqmlUom__TEuc = 1301,
	resqml2__ResqmlUom__TeV = 1302,
	resqml2__ResqmlUom__TF = 1303,
	resqml2__ResqmlUom__Tg = 1304,
	resqml2__ResqmlUom__Tgauss = 1305,
	resqml2__ResqmlUom__TGy = 1306,
	resqml2__ResqmlUom__TH = 1307,
	resqml2__ResqmlUom__therm_x005bEC_x005d = 1308,
	resqml2__ResqmlUom__therm_x005bUK_x005d = 1309,
	resqml2__ResqmlUom__therm_x005bUS_x005d = 1310,
	resqml2__ResqmlUom__THz = 1311,
	resqml2__ResqmlUom__TJ = 1312,
	resqml2__ResqmlUom__TJ_x002fa = 1313,
	resqml2__ResqmlUom__Tm = 1314,
	resqml2__ResqmlUom__TN = 1315,
	resqml2__ResqmlUom__Tohm = 1316,
	resqml2__ResqmlUom__ton_x005bUK_x005d = 1317,
	resqml2__ResqmlUom__ton_x005bUK_x005d_x002fa = 1318,
	resqml2__ResqmlUom__ton_x005bUK_x005d_x002fd = 1319,
	resqml2__ResqmlUom__ton_x005bUK_x005d_x002fh = 1320,
	resqml2__ResqmlUom__ton_x005bUK_x005d_x002fmin = 1321,
	resqml2__ResqmlUom__ton_x005bUS_x005d = 1322,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fa = 1323,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fd = 1324,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fft2 = 1325,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fh = 1326,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fmin = 1327,
	resqml2__ResqmlUom__tonf_x005bUK_x005d = 1328,
	resqml2__ResqmlUom__tonf_x005bUK_x005d_x002eft2 = 1329,
	resqml2__ResqmlUom__tonf_x005bUK_x005d_x002fft = 1330,
	resqml2__ResqmlUom__tonf_x005bUK_x005d_x002fft2 = 1331,
	resqml2__ResqmlUom__tonf_x005bUS_x005d = 1332,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002eft = 1333,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002eft2 = 1334,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002emi = 1335,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002emi_x002fbbl = 1336,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002emi_x002fft = 1337,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002fft = 1338,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002fft2 = 1339,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002fin2 = 1340,
	resqml2__ResqmlUom__tonRefrig = 1341,
	resqml2__ResqmlUom__torr = 1342,
	resqml2__ResqmlUom__TP = 1343,
	resqml2__ResqmlUom__TPa = 1344,
	resqml2__ResqmlUom__Trd = 1345,
	resqml2__ResqmlUom__TS = 1346,
	resqml2__ResqmlUom__TT = 1347,
	resqml2__ResqmlUom__TV = 1348,
	resqml2__ResqmlUom__TW = 1349,
	resqml2__ResqmlUom__TW_x002eh = 1350,
	resqml2__ResqmlUom__TWb = 1351,
	resqml2__ResqmlUom__uA = 1352,
	resqml2__ResqmlUom__uA_x002fcm2 = 1353,
	resqml2__ResqmlUom__uA_x002fin2 = 1354,
	resqml2__ResqmlUom__ubar = 1355,
	resqml2__ResqmlUom__uC = 1356,
	resqml2__ResqmlUom__ucal_x005bth_x005d = 1357,
	resqml2__ResqmlUom__ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 1358,
	resqml2__ResqmlUom__ucal_x005bth_x005d_x002fs = 1359,
	resqml2__ResqmlUom__uCi = 1360,
	resqml2__ResqmlUom__uEuc = 1361,
	resqml2__ResqmlUom__ueV = 1362,
	resqml2__ResqmlUom__uF = 1363,
	resqml2__ResqmlUom__uF_x002fm = 1364,
	resqml2__ResqmlUom__ug = 1365,
	resqml2__ResqmlUom__ug_x002fcm3 = 1366,
	resqml2__ResqmlUom__ug_x002fg = 1367,
	resqml2__ResqmlUom__ug_x002fmg = 1368,
	resqml2__ResqmlUom__ugauss = 1369,
	resqml2__ResqmlUom__uGy = 1370,
	resqml2__ResqmlUom__uH = 1371,
	resqml2__ResqmlUom__uH_x002fm = 1372,
	resqml2__ResqmlUom__uHz = 1373,
	resqml2__ResqmlUom__uJ = 1374,
	resqml2__ResqmlUom__um = 1375,
	resqml2__ResqmlUom__um_x002fs = 1376,
	resqml2__ResqmlUom__um2 = 1377,
	resqml2__ResqmlUom__um2_x002em = 1378,
	resqml2__ResqmlUom__umHg_x005b0degC_x005d = 1379,
	resqml2__ResqmlUom__umol = 1380,
	resqml2__ResqmlUom__uN = 1381,
	resqml2__ResqmlUom__uohm = 1382,
	resqml2__ResqmlUom__uohm_x002fft = 1383,
	resqml2__ResqmlUom__uohm_x002fm = 1384,
	resqml2__ResqmlUom__uP = 1385,
	resqml2__ResqmlUom__uPa = 1386,
	resqml2__ResqmlUom__upsi = 1387,
	resqml2__ResqmlUom__urad = 1388,
	resqml2__ResqmlUom__urd = 1389,
	resqml2__ResqmlUom__us = 1390,
	resqml2__ResqmlUom__uS = 1391,
	resqml2__ResqmlUom__us_x002fft = 1392,
	resqml2__ResqmlUom__us_x002fin = 1393,
	resqml2__ResqmlUom__us_x002fm = 1394,
	resqml2__ResqmlUom__uT = 1395,
	resqml2__ResqmlUom__uV = 1396,
	resqml2__ResqmlUom__uV_x002fft = 1397,
	resqml2__ResqmlUom__uV_x002fm = 1398,
	resqml2__ResqmlUom__uW = 1399,
	resqml2__ResqmlUom__uW_x002fm3 = 1400,
	resqml2__ResqmlUom__uWb = 1401,
	resqml2__ResqmlUom__V = 1402,
	resqml2__ResqmlUom__V_x002fB = 1403,
	resqml2__ResqmlUom__V_x002fdB = 1404,
	resqml2__ResqmlUom__V_x002fm = 1405,
	resqml2__ResqmlUom__W = 1406,
	resqml2__ResqmlUom__W_x002em2_x002eK_x002f_x0028J_x002eK_x0029 = 1407,
	resqml2__ResqmlUom__W_x002f_x0028m_x002eK_x0029 = 1408,
	resqml2__ResqmlUom__W_x002f_x0028m2_x002eK_x0029 = 1409,
	resqml2__ResqmlUom__W_x002f_x0028m2_x002esr_x0029 = 1410,
	resqml2__ResqmlUom__W_x002f_x0028m3_x002eK_x0029 = 1411,
	resqml2__ResqmlUom__W_x002fcm2 = 1412,
	resqml2__ResqmlUom__W_x002fK = 1413,
	resqml2__ResqmlUom__W_x002fkW = 1414,
	resqml2__ResqmlUom__W_x002fm2 = 1415,
	resqml2__ResqmlUom__W_x002fm3 = 1416,
	resqml2__ResqmlUom__W_x002fmm2 = 1417,
	resqml2__ResqmlUom__W_x002fsr = 1418,
	resqml2__ResqmlUom__W_x002fW = 1419,
	resqml2__ResqmlUom__Wb = 1420,
	resqml2__ResqmlUom__Wb_x002em = 1421,
	resqml2__ResqmlUom__Wb_x002fm = 1422,
	resqml2__ResqmlUom__Wb_x002fmm = 1423,
	resqml2__ResqmlUom__wk = 1424,
	resqml2__ResqmlUom__yd = 1425,
	resqml2__ResqmlUom__yd_x005bBnA_x005d = 1426,
	resqml2__ResqmlUom__yd_x005bBnB_x005d = 1427,
	resqml2__ResqmlUom__yd_x005bCla_x005d = 1428,
	resqml2__ResqmlUom__yd_x005bInd_x005d = 1429,
	resqml2__ResqmlUom__yd_x005bInd37_x005d = 1430,
	resqml2__ResqmlUom__yd_x005bInd62_x005d = 1431,
	resqml2__ResqmlUom__yd_x005bInd75_x005d = 1432,
	resqml2__ResqmlUom__yd_x005bSe_x005d = 1433,
	resqml2__ResqmlUom__yd_x005bSeT_x005d = 1434,
	resqml2__ResqmlUom__yd_x005bUS_x005d = 1435,
	resqml2__ResqmlUom__yd2 = 1436,
	resqml2__ResqmlUom__yd3 = 1437
};
#endif

/* resqml2_0_1ForGsoap.h:3404 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IdentityKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IdentityKind (566)
/* resqml2:IdentityKind */
enum resqml2__IdentityKind
{
	resqml2__IdentityKind__colocation = 0,
	resqml2__IdentityKind__previous_x0020colocation = 1,
	resqml2__IdentityKind__equivalence = 2,
	resqml2__IdentityKind__previous_x0020equivalence = 3
};
#endif

/* resqml2_0_1ForGsoap.h:3435 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IndexableElements (567)
/* resqml2:IndexableElements */
enum resqml2__IndexableElements
{
	resqml2__IndexableElements__cells = 0,
	resqml2__IndexableElements__column_x0020edges = 1,
	resqml2__IndexableElements__columns = 2,
	resqml2__IndexableElements__contacts = 3,
	resqml2__IndexableElements__coordinate_x0020lines = 4,
	resqml2__IndexableElements__edges = 5,
	resqml2__IndexableElements__edges_x0020per_x0020column = 6,
	resqml2__IndexableElements__enumerated_x0020elements = 7,
	resqml2__IndexableElements__faces = 8,
	resqml2__IndexableElements__faces_x0020per_x0020cell = 9,
	resqml2__IndexableElements__interval_x0020edges = 10,
	resqml2__IndexableElements__intervals = 11,
	resqml2__IndexableElements__I0 = 12,
	resqml2__IndexableElements__I0_x0020edges = 13,
	resqml2__IndexableElements__J0 = 14,
	resqml2__IndexableElements__J0_x0020edges = 15,
	resqml2__IndexableElements__layers = 16,
	resqml2__IndexableElements__nodes = 17,
	resqml2__IndexableElements__nodes_x0020per_x0020cell = 18,
	resqml2__IndexableElements__nodes_x0020per_x0020edge = 19,
	resqml2__IndexableElements__nodes_x0020per_x0020face = 20,
	resqml2__IndexableElements__patches = 21,
	resqml2__IndexableElements__pillars = 22,
	resqml2__IndexableElements__regions = 23,
	resqml2__IndexableElements__representation = 24,
	resqml2__IndexableElements__subnodes = 25,
	resqml2__IndexableElements__triangles = 26
};
#endif

/* resqml2_0_1ForGsoap.h:3490 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerIndexableElements (568)
/* resqml2:UnstructuredColumnLayerIndexableElements */
enum resqml2__UnstructuredColumnLayerIndexableElements
{
	resqml2__UnstructuredColumnLayerIndexableElements__cells = 0,
	resqml2__UnstructuredColumnLayerIndexableElements__column_x0020edges = 1,
	resqml2__UnstructuredColumnLayerIndexableElements__columns = 2,
	resqml2__UnstructuredColumnLayerIndexableElements__coordinate_x0020lines = 3,
	resqml2__UnstructuredColumnLayerIndexableElements__edges = 4,
	resqml2__UnstructuredColumnLayerIndexableElements__edges_x0020per_x0020column = 5,
	resqml2__UnstructuredColumnLayerIndexableElements__faces = 6,
	resqml2__UnstructuredColumnLayerIndexableElements__faces_x0020per_x0020cell = 7,
	resqml2__UnstructuredColumnLayerIndexableElements__hinge_x0020node_x0020faces = 8,
	resqml2__UnstructuredColumnLayerIndexableElements__interval_x0020edges = 9,
	resqml2__UnstructuredColumnLayerIndexableElements__intervals = 10,
	resqml2__UnstructuredColumnLayerIndexableElements__layers = 11,
	resqml2__UnstructuredColumnLayerIndexableElements__nodes = 12,
	resqml2__UnstructuredColumnLayerIndexableElements__nodes_x0020per_x0020cell = 13,
	resqml2__UnstructuredColumnLayerIndexableElements__nodes_x0020per_x0020edge = 14,
	resqml2__UnstructuredColumnLayerIndexableElements__nodes_x0020per_x0020face = 15,
	resqml2__UnstructuredColumnLayerIndexableElements__pillars = 16,
	resqml2__UnstructuredColumnLayerIndexableElements__subnodes = 17
};
#endif

/* resqml2_0_1ForGsoap.h:3573 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeNodeObject
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeNodeObject (569)
/* resqml2:SubnodeNodeObject */
enum resqml2__SubnodeNodeObject
{
	resqml2__SubnodeNodeObject__cell = 0,
	resqml2__SubnodeNodeObject__face = 1,
	resqml2__SubnodeNodeObject__edge = 2
};
#endif

/* resqml2_0_1ForGsoap.h:3598 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnShape (570)
/* resqml2:ColumnShape */
enum resqml2__ColumnShape
{
	resqml2__ColumnShape__triangular = 0,
	resqml2__ColumnShape__quadrilateral = 1,
	resqml2__ColumnShape__polygonal = 2
};
#endif

/* resqml2_0_1ForGsoap.h:3620 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KDirection
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KDirection (571)
/* resqml2:KDirection */
enum resqml2__KDirection
{
	resqml2__KDirection__down = 0,
	resqml2__KDirection__up = 1,
	resqml2__KDirection__not_x0020monotonic = 2
};
#endif

/* resqml2_0_1ForGsoap.h:3642 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkIndexableElements (572)
/* resqml2:IjkIndexableElements */
enum resqml2__IjkIndexableElements
{
	resqml2__IjkIndexableElements__cells = 0,
	resqml2__IjkIndexableElements__column_x0020edges = 1,
	resqml2__IjkIndexableElements__columns = 2,
	resqml2__IjkIndexableElements__coordinate_x0020lines = 3,
	resqml2__IjkIndexableElements__edges = 4,
	resqml2__IjkIndexableElements__edges_x0020per_x0020column = 5,
	resqml2__IjkIndexableElements__faces = 6,
	resqml2__IjkIndexableElements__faces_x0020per_x0020cell = 7,
	resqml2__IjkIndexableElements__hinge_x0020node_x0020faces = 8,
	resqml2__IjkIndexableElements__interval_x0020edges = 9,
	resqml2__IjkIndexableElements__intervals = 10,
	resqml2__IjkIndexableElements__I0 = 11,
	resqml2__IjkIndexableElements__I0_x0020edges = 12,
	resqml2__IjkIndexableElements__J0 = 13,
	resqml2__IjkIndexableElements__J0_x0020edges = 14,
	resqml2__IjkIndexableElements__layers = 15,
	resqml2__IjkIndexableElements__nodes = 16,
	resqml2__IjkIndexableElements__nodes_x0020per_x0020cell = 17,
	resqml2__IjkIndexableElements__nodes_x0020per_x0020edge = 18,
	resqml2__IjkIndexableElements__nodes_x0020per_x0020face = 19,
	resqml2__IjkIndexableElements__pillars = 20,
	resqml2__IjkIndexableElements__radial_x0020origin_x0020polyline = 21,
	resqml2__IjkIndexableElements__subnodes = 22
};
#endif

/* resqml2_0_1ForGsoap.h:3744 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GridGeometryAttachment
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GridGeometryAttachment (573)
/* resqml2:GridGeometryAttachment */
enum resqml2__GridGeometryAttachment
{
	resqml2__GridGeometryAttachment__cells = 0,
	resqml2__GridGeometryAttachment__edges = 1,
	resqml2__GridGeometryAttachment__faces = 2,
	resqml2__GridGeometryAttachment__hinge_x0020node_x0020faces = 3,
	resqml2__GridGeometryAttachment__nodes = 4,
	resqml2__GridGeometryAttachment__radial_x0020origin_x0020polyline = 5,
	resqml2__GridGeometryAttachment__subnodes = 6
};
#endif

/* resqml2_0_1ForGsoap.h:3788 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellShape (574)
/* resqml2:CellShape */
enum resqml2__CellShape
{
	resqml2__CellShape__tetrahedral = 0,
	resqml2__CellShape__pyramidal = 1,
	resqml2__CellShape__prism = 2,
	resqml2__CellShape__hexahedral = 3,
	resqml2__CellShape__polyhedral = 4
};
#endif

/* resqml2_0_1ForGsoap.h:3818 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredCellIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredCellIndexableElements (575)
/* resqml2:UnstructuredCellIndexableElements */
enum resqml2__UnstructuredCellIndexableElements
{
	resqml2__UnstructuredCellIndexableElements__cells = 0,
	resqml2__UnstructuredCellIndexableElements__edges = 1,
	resqml2__UnstructuredCellIndexableElements__faces = 2,
	resqml2__UnstructuredCellIndexableElements__faces_x0020per_x0020cell = 3,
	resqml2__UnstructuredCellIndexableElements__hinge_x0020node_x0020faces = 4,
	resqml2__UnstructuredCellIndexableElements__nodes = 5,
	resqml2__UnstructuredCellIndexableElements__nodes_x0020per_x0020cell = 6,
	resqml2__UnstructuredCellIndexableElements__nodes_x0020per_x0020edge = 7,
	resqml2__UnstructuredCellIndexableElements__nodes_x0020per_x0020face = 8,
	resqml2__UnstructuredCellIndexableElements__subnodes = 9
};
#endif

/* resqml2_0_1ForGsoap.h:3871 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PillarShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PillarShape (576)
/* resqml2:PillarShape */
enum resqml2__PillarShape
{
	resqml2__PillarShape__vertical = 0,
	resqml2__PillarShape__straight = 1,
	resqml2__PillarShape__curved = 2
};
#endif

/* resqml2_0_1ForGsoap.h:3893 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThrowKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThrowKind (577)
/* resqml2:ThrowKind */
enum resqml2__ThrowKind
{
	resqml2__ThrowKind__reverse = 0,
	resqml2__ThrowKind__normal = 1,
	resqml2__ThrowKind__thrust = 2,
	resqml2__ThrowKind__strike_x0020and_x0020slip = 3,
	resqml2__ThrowKind__scissor = 4,
	resqml2__ThrowKind__variable = 5
};
#endif

/* resqml2_0_1ForGsoap.h:3909 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SequenceStratigraphySurface
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SequenceStratigraphySurface (578)
/* resqml2:SequenceStratigraphySurface */
enum resqml2__SequenceStratigraphySurface
{
	resqml2__SequenceStratigraphySurface__flooding = 0,
	resqml2__SequenceStratigraphySurface__ravinement = 1,
	resqml2__SequenceStratigraphySurface__maximum_x0020flooding = 2,
	resqml2__SequenceStratigraphySurface__transgressive = 3
};
#endif

/* resqml2_0_1ForGsoap.h:3923 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRelationship
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRelationship (579)
/* resqml2:ContactRelationship */
enum resqml2__ContactRelationship
{
	resqml2__ContactRelationship__frontier_x0020feature_x0020to_x0020frontier_x0020feature = 0,
	resqml2__ContactRelationship__genetic_x0020boundary_x0020to_x0020frontier_x0020feature = 1,
	resqml2__ContactRelationship__genetic_x0020boundary_x0020to_x0020genetic_x0020boundary = 2,
	resqml2__ContactRelationship__genetic_x0020boundary_x0020to_x0020tectonic_x0020boundary = 3,
	resqml2__ContactRelationship__stratigraphic_x0020unit_x0020to_x0020frontier_x0020feature = 4,
	resqml2__ContactRelationship__stratigraphic_x0020unit_x0020to_x0020stratigraphic_x0020unit = 5,
	resqml2__ContactRelationship__tectonic_x0020boundary_x0020to_x0020frontier_x0020feature = 6,
	resqml2__ContactRelationship__tectonic_x0020boundary_x0020to_x0020genetic_x0020boundary = 7,
	resqml2__ContactRelationship__tectonic_x0020boundary_x0020to_x0020tectonic_x0020boundary = 8
};
#endif

/* resqml2_0_1ForGsoap.h:3969 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DepositionMode
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DepositionMode (580)
/* resqml2:DepositionMode */
enum resqml2__DepositionMode
{
	resqml2__DepositionMode__proportional_x0020between_x0020top_x0020and_x0020bottom = 0,
	resqml2__DepositionMode__parallel_x0020to_x0020bottom = 1,
	resqml2__DepositionMode__parallel_x0020to_x0020top = 2,
	resqml2__DepositionMode__parallel_x0020to_x0020another_x0020boundary = 3
};
#endif

/* resqml2_0_1ForGsoap.h:3980 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitComposition
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitComposition (581)
/* resqml2:GeologicUnitComposition */
enum resqml2__GeologicUnitComposition
{
	resqml2__GeologicUnitComposition__intrusive_x0020clay_x0020 = 0,
	resqml2__GeologicUnitComposition__organic = 1,
	resqml2__GeologicUnitComposition__intrusive_x0020mud_x0020 = 2,
	resqml2__GeologicUnitComposition__evaporite_x0020salt = 3,
	resqml2__GeologicUnitComposition__evaporite_x0020non_x0020salt = 4,
	resqml2__GeologicUnitComposition__sedimentary_x0020siliclastic = 5,
	resqml2__GeologicUnitComposition__carbonate = 6,
	resqml2__GeologicUnitComposition__magmatic_x0020intrusive_x0020granitoid = 7,
	resqml2__GeologicUnitComposition__magmatic_x0020intrusive_x0020pyroclastic = 8,
	resqml2__GeologicUnitComposition__magmatic_x0020extrusive_x0020lava_x0020flow = 9,
	resqml2__GeologicUnitComposition__other_x0020chemichal_x0020rock = 10,
	resqml2__GeologicUnitComposition__sedimentary_x0020turbidite = 11
};
#endif

/* resqml2_0_1ForGsoap.h:4002 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Domain
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Domain (582)
/* resqml2:Domain */
enum resqml2__Domain
{
	resqml2__Domain__depth = 0,
	resqml2__Domain__time = 1,
	resqml2__Domain__mixed = 2
};
#endif

/* resqml2_0_1ForGsoap.h:4021 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BoundaryRelation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BoundaryRelation (583)
/* resqml2:BoundaryRelation */
enum resqml2__BoundaryRelation
{
	resqml2__BoundaryRelation__conformable = 0,
	resqml2__BoundaryRelation__unconformable_x0020below_x0020and_x0020above = 1,
	resqml2__BoundaryRelation__unconformable_x0020above = 2,
	resqml2__BoundaryRelation__unconformable_x0020below = 3
};
#endif

/* resqml2_0_1ForGsoap.h:4042 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactMode
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactMode (584)
/* resqml2:ContactMode */
enum resqml2__ContactMode
{
	resqml2__ContactMode__baselap = 0,
	resqml2__ContactMode__erosion = 1,
	resqml2__ContactMode__extended = 2,
	resqml2__ContactMode__proportional = 3
};
#endif

/* resqml2_0_1ForGsoap.h:4056 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrderingCriteria
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrderingCriteria (585)
/* resqml2:OrderingCriteria */
enum resqml2__OrderingCriteria
{
	resqml2__OrderingCriteria__age = 0,
	resqml2__OrderingCriteria__apparent_x0020depth = 1,
	resqml2__OrderingCriteria__measured_x0020depth = 2
};
#endif

/* resqml2_0_1ForGsoap.h:4078 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Geobody3dShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Geobody3dShape (586)
/* resqml2:Geobody3dShape */
enum resqml2__Geobody3dShape
{
	resqml2__Geobody3dShape__dyke = 0,
	resqml2__Geobody3dShape__silt = 1,
	resqml2__Geobody3dShape__dome = 2,
	resqml2__Geobody3dShape__sheeth = 3,
	resqml2__Geobody3dShape__diapir = 4,
	resqml2__Geobody3dShape__batholith = 5,
	resqml2__Geobody3dShape__channel = 6,
	resqml2__Geobody3dShape__delta = 7,
	resqml2__Geobody3dShape__dune = 8,
	resqml2__Geobody3dShape__fan = 9,
	resqml2__Geobody3dShape__reef = 10,
	resqml2__Geobody3dShape__wedge = 11
};
#endif

/* resqml2_0_1ForGsoap.h:4100 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactVerb
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactVerb (587)
/* resqml2:ContactVerb */
enum resqml2__ContactVerb
{
	resqml2__ContactVerb__splits = 0,
	resqml2__ContactVerb__interrupts = 1,
	resqml2__ContactVerb__contains = 2,
	resqml2__ContactVerb__conforms = 3,
	resqml2__ContactVerb__erodes = 4,
	resqml2__ContactVerb__stops_x0020at = 5,
	resqml2__ContactVerb__crosses = 6,
	resqml2__ContactVerb__includes = 7
};
#endif

/* resqml2_0_1ForGsoap.h:4143 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactSide
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactSide (588)
/* resqml2:ContactSide */
enum resqml2__ContactSide
{
	resqml2__ContactSide__footwall = 0,
	resqml2__ContactSide__hanging_x0020wall = 1,
	resqml2__ContactSide__north = 2,
	resqml2__ContactSide__south = 3,
	resqml2__ContactSide__east = 4,
	resqml2__ContactSide__west = 5,
	resqml2__ContactSide__younger = 6,
	resqml2__ContactSide__older = 7,
	resqml2__ContactSide__both = 8
};
#endif

/* resqml2_0_1ForGsoap.h:4189 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitMaterialImplacement
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitMaterialImplacement (589)
/* resqml2:GeologicUnitMaterialImplacement */
enum resqml2__GeologicUnitMaterialImplacement
{
	resqml2__GeologicUnitMaterialImplacement__autochtonous = 0,
	resqml2__GeologicUnitMaterialImplacement__allochtonous = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4202 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Phase
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Phase (590)
/* resqml2:Phase */
enum resqml2__Phase
{
	resqml2__Phase__aquifer = 0,
	resqml2__Phase__gas_x0020cap = 1,
	resqml2__Phase__oil_x0020column = 2,
	resqml2__Phase__seal = 3
};
#endif

/* resqml2_0_1ForGsoap.h:4228 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeneticBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeneticBoundaryKind (591)
/* resqml2:GeneticBoundaryKind */
enum resqml2__GeneticBoundaryKind
{
	resqml2__GeneticBoundaryKind__geobody_x0020boundary = 0,
	resqml2__GeneticBoundaryKind__horizon = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4246 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidContact
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidContact (592)
/* resqml2:FluidContact */
enum resqml2__FluidContact
{
	resqml2__FluidContact__free_x0020water_x0020contact = 0,
	resqml2__FluidContact__gas_x0020oil_x0020contact = 1,
	resqml2__FluidContact__gas_x0020water_x0020contact = 2,
	resqml2__FluidContact__seal = 3,
	resqml2__FluidContact__water_x0020oil_x0020contact = 4
};
#endif

/* resqml2_0_1ForGsoap.h:4276 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TectonicBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TectonicBoundaryKind (593)
/* resqml2:TectonicBoundaryKind */
enum resqml2__TectonicBoundaryKind
{
	resqml2__TectonicBoundaryKind__fault = 0,
	resqml2__TectonicBoundaryKind__fracture = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4294 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicBoundaryKind (594)
/* resqml2:GeologicBoundaryKind */
enum resqml2__GeologicBoundaryKind
{
	resqml2__GeologicBoundaryKind__fault = 0,
	resqml2__GeologicBoundaryKind__geobody = 1,
	resqml2__GeologicBoundaryKind__horizon = 2
};
#endif

/* resqml2_0_1ForGsoap.h:4307 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreFrameIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreFrameIndexableElements (595)
/* resqml2:WellboreFrameIndexableElements */
enum resqml2__WellboreFrameIndexableElements
{
	resqml2__WellboreFrameIndexableElements__intervals = 0,
	resqml2__WellboreFrameIndexableElements__nodes = 1,
	resqml2__WellboreFrameIndexableElements__cells = 2
};
#endif

/* resqml2_0_1ForGsoap.h:4329 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdDomain
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdDomain (596)
/* resqml2:MdDomain */
enum resqml2__MdDomain
{
	resqml2__MdDomain__driller = 0,
	resqml2__MdDomain__logger = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4348 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdReference (597)
/* resqml2:MdReference */
enum resqml2__MdReference
{
	resqml2__MdReference__ground_x0020level = 0,
	resqml2__MdReference__kelly_x0020bushing = 1,
	resqml2__MdReference__mean_x0020sea_x0020level = 2,
	resqml2__MdReference__derrick_x0020floor = 3,
	resqml2__MdReference__casing_x0020flange = 4,
	resqml2__MdReference__arbitrary_x0020point = 5,
	resqml2__MdReference__crown_x0020valve = 6,
	resqml2__MdReference__rotary_x0020bushing = 7,
	resqml2__MdReference__rotary_x0020table = 8,
	resqml2__MdReference__sea_x0020floor = 9,
	resqml2__MdReference__lowest_x0020astronomical_x0020tide = 10,
	resqml2__MdReference__mean_x0020higher_x0020high_x0020water = 11,
	resqml2__MdReference__mean_x0020high_x0020water = 12,
	resqml2__MdReference__mean_x0020lower_x0020low_x0020water = 13,
	resqml2__MdReference__mean_x0020low_x0020water = 14,
	resqml2__MdReference__mean_x0020tide_x0020level = 15,
	resqml2__MdReference__kickoff_x0020point = 16
};
#endif

/* resqml2_0_1ForGsoap.h:4405 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidMarker
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidMarker (598)
/* resqml2:FluidMarker */
enum resqml2__FluidMarker
{
	resqml2__FluidMarker__gas_x0020down_x0020to = 0,
	resqml2__FluidMarker__gas_x0020up_x0020to = 1,
	resqml2__FluidMarker__oil_x0020down_x0020to = 2,
	resqml2__FluidMarker__oil_x0020up_x0020to = 3,
	resqml2__FluidMarker__water_x0020down_x0020to = 4,
	resqml2__FluidMarker__water_x0020up_x0020to = 5
};
#endif

/* resqml2_0_1ForGsoap.h:4421 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SurfaceRole
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SurfaceRole (599)
/* resqml2:SurfaceRole */
enum resqml2__SurfaceRole
{
	resqml2__SurfaceRole__map = 0,
	resqml2__SurfaceRole__pick = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4439 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LineRole
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LineRole (600)
/* resqml2:LineRole */
enum resqml2__LineRole
{
	resqml2__LineRole__fault_x0020center_x0020line = 0,
	resqml2__LineRole__pick = 1,
	resqml2__LineRole__inner_x0020ring = 2,
	resqml2__LineRole__outer_x0020ring = 3,
	resqml2__LineRole__trajectory = 4,
	resqml2__LineRole__interpretation_x0020line = 5,
	resqml2__LineRole__contact = 6,
	resqml2__LineRole__depositional_x0020line = 7,
	resqml2__LineRole__erosion_x0020line = 8,
	resqml2__LineRole__contouring = 9,
	resqml2__LineRole__pillar = 10
};
#endif

/* resqml2_0_1ForGsoap.h:4488 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterKind (601)
/* resqml2:ParameterKind */
enum resqml2__ParameterKind
{
	resqml2__ParameterKind__dataObject = 0,
	resqml2__ParameterKind__floatingPoint = 1,
	resqml2__ParameterKind__integer = 2,
	resqml2__ParameterKind__string = 3,
	resqml2__ParameterKind__timestamp = 4,
	resqml2__ParameterKind__subActivity = 5
};
#endif

/* resqml2_0_1ForGsoap.h:4504 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineFlux
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineFlux (602)
/* resqml2:StreamlineFlux */
enum resqml2__StreamlineFlux
{
	resqml2__StreamlineFlux__oil = 0,
	resqml2__StreamlineFlux__gas = 1,
	resqml2__StreamlineFlux__water = 2,
	resqml2__StreamlineFlux__total = 3,
	resqml2__StreamlineFlux__other = 4
};
#endif

/* resqml2_0_1ForGsoap.h:4586 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AggregationType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AggregationType (609)
/* gml:AggregationType */
enum gml__AggregationType
{
	gml__AggregationType__set = 0,
	gml__AggregationType__bag = 1,
	gml__AggregationType__sequence = 2,
	gml__AggregationType__array = 3,
	gml__AggregationType__record = 4,
	gml__AggregationType__table = 5
};
#endif

/* resqml2_0_1ForGsoap.h:4613 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__show
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__show (610)
/* xlink:show */
enum _xlink__show
{
	_xlink__show__new_ = 0,
	_xlink__show__replace = 1,
	_xlink__show__embed = 2,
	_xlink__show__other = 3,
	_xlink__show__none = 4
};
#endif

/* resqml2_0_1ForGsoap.h:4629 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__actuate
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__actuate (611)
/* xlink:actuate */
enum _xlink__actuate
{
	_xlink__actuate__onLoad = 0,
	_xlink__actuate__onRequest = 1,
	_xlink__actuate__other = 2,
	_xlink__actuate__none = 3
};
#endif

/* resqml2_0_1ForGsoap.h:4800 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlPropertyKind (618)
/* resqml2:ResqmlPropertyKind */
enum resqml2__ResqmlPropertyKind
{
	resqml2__ResqmlPropertyKind__absorbed_x0020dose = 0,
	resqml2__ResqmlPropertyKind__acceleration_x0020linear = 1,
	resqml2__ResqmlPropertyKind__activity_x0020_x0028of_x0020radioactivity_x0029 = 2,
	resqml2__ResqmlPropertyKind__amount_x0020of_x0020substance = 3,
	resqml2__ResqmlPropertyKind__amplitude = 4,
	resqml2__ResqmlPropertyKind__angle_x0020per_x0020length = 5,
	resqml2__ResqmlPropertyKind__angle_x0020per_x0020time = 6,
	resqml2__ResqmlPropertyKind__angle_x0020per_x0020volume = 7,
	resqml2__ResqmlPropertyKind__angular_x0020acceleration = 8,
	resqml2__ResqmlPropertyKind__area = 9,
	resqml2__ResqmlPropertyKind__area_x0020per_x0020area = 10,
	resqml2__ResqmlPropertyKind__area_x0020per_x0020volume = 11,
	resqml2__ResqmlPropertyKind__attenuation = 12,
	resqml2__ResqmlPropertyKind__attenuation_x0020per_x0020length = 13,
	resqml2__ResqmlPropertyKind__azimuth = 14,
	resqml2__ResqmlPropertyKind__bubble_x0020point_x0020pressure = 15,
	resqml2__ResqmlPropertyKind__bulk_x0020modulus = 16,
	resqml2__ResqmlPropertyKind__capacitance = 17,
	resqml2__ResqmlPropertyKind__categorical = 18,
	resqml2__ResqmlPropertyKind__cell_x0020length = 19,
	resqml2__ResqmlPropertyKind__charge_x0020density = 20,
	resqml2__ResqmlPropertyKind__chemical_x0020potential = 21,
	resqml2__ResqmlPropertyKind__code = 22,
	resqml2__ResqmlPropertyKind__compressibility = 23,
	resqml2__ResqmlPropertyKind__concentration_x0020of_x0020B = 24,
	resqml2__ResqmlPropertyKind__conductivity = 25,
	resqml2__ResqmlPropertyKind__continuous = 26,
	resqml2__ResqmlPropertyKind__cross_x0020section_x0020absorption = 27,
	resqml2__ResqmlPropertyKind__current_x0020density = 28,
	resqml2__ResqmlPropertyKind__Darcy_x0020flow_x0020coefficient = 29,
	resqml2__ResqmlPropertyKind__data_x0020transmission_x0020speed = 30,
	resqml2__ResqmlPropertyKind__delta_x0020temperature = 31,
	resqml2__ResqmlPropertyKind__density = 32,
	resqml2__ResqmlPropertyKind__depth = 33,
	resqml2__ResqmlPropertyKind__diffusion_x0020coefficient = 34,
	resqml2__ResqmlPropertyKind__digital_x0020storage = 35,
	resqml2__ResqmlPropertyKind__dimensionless = 36,
	resqml2__ResqmlPropertyKind__dip = 37,
	resqml2__ResqmlPropertyKind__discrete = 38,
	resqml2__ResqmlPropertyKind__dose_x0020equivalent = 39,
	resqml2__ResqmlPropertyKind__dose_x0020equivalent_x0020rate = 40,
	resqml2__ResqmlPropertyKind__dynamic_x0020viscosity = 41,
	resqml2__ResqmlPropertyKind__electric_x0020charge = 42,
	resqml2__ResqmlPropertyKind__electric_x0020conductance = 43,
	resqml2__ResqmlPropertyKind__electric_x0020current = 44,
	resqml2__ResqmlPropertyKind__electric_x0020dipole_x0020moment = 45,
	resqml2__ResqmlPropertyKind__electric_x0020field_x0020strength = 46,
	resqml2__ResqmlPropertyKind__electric_x0020polarization = 47,
	resqml2__ResqmlPropertyKind__electric_x0020potential = 48,
	resqml2__ResqmlPropertyKind__electrical_x0020resistivity = 49,
	resqml2__ResqmlPropertyKind__electrochemical_x0020equivalent = 50,
	resqml2__ResqmlPropertyKind__electromagnetic_x0020moment = 51,
	resqml2__ResqmlPropertyKind__energy_x0020length_x0020per_x0020area = 52,
	resqml2__ResqmlPropertyKind__energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 53,
	resqml2__ResqmlPropertyKind__energy_x0020per_x0020area = 54,
	resqml2__ResqmlPropertyKind__energy_x0020per_x0020length = 55,
	resqml2__ResqmlPropertyKind__equivalent_x0020per_x0020mass = 56,
	resqml2__ResqmlPropertyKind__equivalent_x0020per_x0020volume = 57,
	resqml2__ResqmlPropertyKind__exposure_x0020_x0028radioactivity_x0029 = 58,
	resqml2__ResqmlPropertyKind__fluid_x0020volume = 59,
	resqml2__ResqmlPropertyKind__force = 60,
	resqml2__ResqmlPropertyKind__force_x0020area = 61,
	resqml2__ResqmlPropertyKind__force_x0020length_x0020per_x0020length = 62,
	resqml2__ResqmlPropertyKind__force_x0020per_x0020force = 63,
	resqml2__ResqmlPropertyKind__force_x0020per_x0020length = 64,
	resqml2__ResqmlPropertyKind__force_x0020per_x0020volume = 65,
	resqml2__ResqmlPropertyKind__formation_x0020volume_x0020factor = 66,
	resqml2__ResqmlPropertyKind__frequency = 67,
	resqml2__ResqmlPropertyKind__frequency_x0020interval = 68,
	resqml2__ResqmlPropertyKind__gamma_x0020ray_x0020API_x0020unit = 69,
	resqml2__ResqmlPropertyKind__heat_x0020capacity = 70,
	resqml2__ResqmlPropertyKind__heat_x0020flow_x0020rate = 71,
	resqml2__ResqmlPropertyKind__heat_x0020transfer_x0020coefficient = 72,
	resqml2__ResqmlPropertyKind__illuminance = 73,
	resqml2__ResqmlPropertyKind__index = 74,
	resqml2__ResqmlPropertyKind__irradiance = 75,
	resqml2__ResqmlPropertyKind__isothermal_x0020compressibility = 76,
	resqml2__ResqmlPropertyKind__kinematic_x0020viscosity = 77,
	resqml2__ResqmlPropertyKind__Lambda_x0020Rho = 78,
	resqml2__ResqmlPropertyKind__Lame_x0020constant = 79,
	resqml2__ResqmlPropertyKind__length = 80,
	resqml2__ResqmlPropertyKind__length_x0020per_x0020length = 81,
	resqml2__ResqmlPropertyKind__length_x0020per_x0020temperature = 82,
	resqml2__ResqmlPropertyKind__length_x0020per_x0020volume = 83,
	resqml2__ResqmlPropertyKind__level_x0020of_x0020power_x0020intensity = 84,
	resqml2__ResqmlPropertyKind__light_x0020exposure = 85,
	resqml2__ResqmlPropertyKind__linear_x0020thermal_x0020expansion = 86,
	resqml2__ResqmlPropertyKind__luminance = 87,
	resqml2__ResqmlPropertyKind__luminous_x0020efficacy = 88,
	resqml2__ResqmlPropertyKind__luminous_x0020flux = 89,
	resqml2__ResqmlPropertyKind__luminous_x0020intensity = 90,
	resqml2__ResqmlPropertyKind__magnetic_x0020dipole_x0020moment = 91,
	resqml2__ResqmlPropertyKind__magnetic_x0020field_x0020strength = 92,
	resqml2__ResqmlPropertyKind__magnetic_x0020flux = 93,
	resqml2__ResqmlPropertyKind__magnetic_x0020induction = 94,
	resqml2__ResqmlPropertyKind__magnetic_x0020permeability = 95,
	resqml2__ResqmlPropertyKind__magnetic_x0020vector_x0020potential = 96,
	resqml2__ResqmlPropertyKind__mass = 97,
	resqml2__ResqmlPropertyKind__mass_x0020attenuation_x0020coefficient = 98,
	resqml2__ResqmlPropertyKind__mass_x0020concentration = 99,
	resqml2__ResqmlPropertyKind__mass_x0020flow_x0020rate = 100,
	resqml2__ResqmlPropertyKind__mass_x0020length = 101,
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020energy = 102,
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020length = 103,
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020time_x0020per_x0020area = 104,
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020time_x0020per_x0020length = 105,
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020volume_x0020per_x0020length = 106,
	resqml2__ResqmlPropertyKind__mobility = 107,
	resqml2__ResqmlPropertyKind__modulus_x0020of_x0020compression = 108,
	resqml2__ResqmlPropertyKind__molar_x0020concentration = 109,
	resqml2__ResqmlPropertyKind__molar_x0020heat_x0020capacity = 110,
	resqml2__ResqmlPropertyKind__molar_x0020volume = 111,
	resqml2__ResqmlPropertyKind__mole_x0020per_x0020area = 112,
	resqml2__ResqmlPropertyKind__mole_x0020per_x0020time = 113,
	resqml2__ResqmlPropertyKind__mole_x0020per_x0020time_x0020per_x0020area = 114,
	resqml2__ResqmlPropertyKind__moment_x0020of_x0020force = 115,
	resqml2__ResqmlPropertyKind__moment_x0020of_x0020inertia = 116,
	resqml2__ResqmlPropertyKind__moment_x0020of_x0020section = 117,
	resqml2__ResqmlPropertyKind__momentum = 118,
	resqml2__ResqmlPropertyKind__Mu_x0020Rho = 119,
	resqml2__ResqmlPropertyKind__net_x0020to_x0020gross_x0020ratio = 120,
	resqml2__ResqmlPropertyKind__neutron_x0020API_x0020unit = 121,
	resqml2__ResqmlPropertyKind__nonDarcy_x0020flow_x0020coefficient = 122,
	resqml2__ResqmlPropertyKind__operations_x0020per_x0020time = 123,
	resqml2__ResqmlPropertyKind__parachor = 124,
	resqml2__ResqmlPropertyKind__per_x0020area = 125,
	resqml2__ResqmlPropertyKind__per_x0020electric_x0020potential = 126,
	resqml2__ResqmlPropertyKind__per_x0020force = 127,
	resqml2__ResqmlPropertyKind__per_x0020length = 128,
	resqml2__ResqmlPropertyKind__per_x0020mass = 129,
	resqml2__ResqmlPropertyKind__per_x0020volume = 130,
	resqml2__ResqmlPropertyKind__permeability_x0020length = 131,
	resqml2__ResqmlPropertyKind__permeability_x0020rock = 132,
	resqml2__ResqmlPropertyKind__permeability_x0020thickness = 133,
	resqml2__ResqmlPropertyKind__permeance = 134,
	resqml2__ResqmlPropertyKind__permittivity = 135,
	resqml2__ResqmlPropertyKind__pH = 136,
	resqml2__ResqmlPropertyKind__plane_x0020angle = 137,
	resqml2__ResqmlPropertyKind__Poisson_x0020ratio = 138,
	resqml2__ResqmlPropertyKind__pore_x0020volume = 139,
	resqml2__ResqmlPropertyKind__porosity = 140,
	resqml2__ResqmlPropertyKind__potential_x0020difference_x0020per_x0020power_x0020drop = 141,
	resqml2__ResqmlPropertyKind__power = 142,
	resqml2__ResqmlPropertyKind__power_x0020per_x0020volume = 143,
	resqml2__ResqmlPropertyKind__pressure = 144,
	resqml2__ResqmlPropertyKind__pressure_x0020per_x0020time = 145,
	resqml2__ResqmlPropertyKind__pressure_x0020squared = 146,
	resqml2__ResqmlPropertyKind__pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 147,
	resqml2__ResqmlPropertyKind__pressure_x0020time_x0020per_x0020volume = 148,
	resqml2__ResqmlPropertyKind__productivity_x0020index = 149,
	resqml2__ResqmlPropertyKind__property_x0020multiplier = 150,
	resqml2__ResqmlPropertyKind__quantity = 151,
	resqml2__ResqmlPropertyKind__quantity_x0020of_x0020light = 152,
	resqml2__ResqmlPropertyKind__radiance = 153,
	resqml2__ResqmlPropertyKind__radiant_x0020intensity = 154,
	resqml2__ResqmlPropertyKind__relative_x0020permeability = 155,
	resqml2__ResqmlPropertyKind__relative_x0020power = 156,
	resqml2__ResqmlPropertyKind__relative_x0020time = 157,
	resqml2__ResqmlPropertyKind__reluctance = 158,
	resqml2__ResqmlPropertyKind__resistance = 159,
	resqml2__ResqmlPropertyKind__resistivity_x0020per_x0020length = 160,
	resqml2__ResqmlPropertyKind__RESQML_x0020root_x0020property = 161,
	resqml2__ResqmlPropertyKind__Rock_x0020Impedance = 162,
	resqml2__ResqmlPropertyKind__rock_x0020permeability = 163,
	resqml2__ResqmlPropertyKind__rock_x0020volume = 164,
	resqml2__ResqmlPropertyKind__saturation = 165,
	resqml2__ResqmlPropertyKind__second_x0020moment_x0020of_x0020area = 166,
	resqml2__ResqmlPropertyKind__shear_x0020modulus = 167,
	resqml2__ResqmlPropertyKind__solid_x0020angle = 168,
	resqml2__ResqmlPropertyKind__solution_x0020gas_oil_x0020ratio = 169,
	resqml2__ResqmlPropertyKind__specific_x0020activity_x0020_x0028of_x0020radioactivity_x0029 = 170,
	resqml2__ResqmlPropertyKind__specific_x0020energy = 171,
	resqml2__ResqmlPropertyKind__specific_x0020heat_x0020capacity = 172,
	resqml2__ResqmlPropertyKind__specific_x0020productivity_x0020index = 173,
	resqml2__ResqmlPropertyKind__specific_x0020volume = 174,
	resqml2__ResqmlPropertyKind__surface_x0020density = 175,
	resqml2__ResqmlPropertyKind__temperature_x0020per_x0020length = 176,
	resqml2__ResqmlPropertyKind__temperature_x0020per_x0020time = 177,
	resqml2__ResqmlPropertyKind__thermal_x0020conductance = 178,
	resqml2__ResqmlPropertyKind__thermal_x0020conductivity = 179,
	resqml2__ResqmlPropertyKind__thermal_x0020diffusivity = 180,
	resqml2__ResqmlPropertyKind__thermal_x0020insulance = 181,
	resqml2__ResqmlPropertyKind__thermal_x0020resistance = 182,
	resqml2__ResqmlPropertyKind__thermodynamic_x0020temperature = 183,
	resqml2__ResqmlPropertyKind__thickness = 184,
	resqml2__ResqmlPropertyKind__time = 185,
	resqml2__ResqmlPropertyKind__time_x0020per_x0020length = 186,
	resqml2__ResqmlPropertyKind__time_x0020per_x0020volume = 187,
	resqml2__ResqmlPropertyKind__transmissibility = 188,
	resqml2__ResqmlPropertyKind__unit_x0020productivity_x0020index = 189,
	resqml2__ResqmlPropertyKind__unitless = 190,
	resqml2__ResqmlPropertyKind__vapor_x0020oil_gas_x0020ratio = 191,
	resqml2__ResqmlPropertyKind__velocity = 192,
	resqml2__ResqmlPropertyKind__volume = 193,
	resqml2__ResqmlPropertyKind__volume_x0020flow_x0020rate = 194,
	resqml2__ResqmlPropertyKind__volume_x0020length_x0020per_x0020time = 195,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020area = 196,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020length = 197,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020time_x0020per_x0020area = 198,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020time_x0020per_x0020length = 199,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020time_x0020per_x0020time = 200,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020time_x0020per_x0020volume = 201,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020volume = 202,
	resqml2__ResqmlPropertyKind__volumetric_x0020heat_x0020transfer_x0020coefficient = 203,
	resqml2__ResqmlPropertyKind__volumetric_x0020thermal_x0020expansion = 204,
	resqml2__ResqmlPropertyKind__work = 205,
	resqml2__ResqmlPropertyKind__Young_x0020modulus = 206
};
#endif

/* resqml2_0_1ForGsoap.h:5200 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrganizationKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrganizationKind (619)
/* resqml2:OrganizationKind */
enum resqml2__OrganizationKind
{
	resqml2__OrganizationKind__earth_x0020model = 0,
	resqml2__OrganizationKind__fluid = 1,
	resqml2__OrganizationKind__stratigraphic = 2,
	resqml2__OrganizationKind__structural = 3
};
#endif

/* resqml2_0_1ForGsoap.h:5241 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AxisOrder2d
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AxisOrder2d (621)
/* eml:AxisOrder2d */
enum eml__AxisOrder2d
{
	eml__AxisOrder2d__easting_x0020northing = 0,
	eml__AxisOrder2d__northing_x0020easting = 1,
	eml__AxisOrder2d__westing_x0020southing = 2,
	eml__AxisOrder2d__southing_x0020westing = 3,
	eml__AxisOrder2d__northing_x0020westing = 4,
	eml__AxisOrder2d__westing_x0020northing = 5
};
#endif

/* resqml2_0_1ForGsoap.h:5272 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalDirection
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalDirection (622)
/* eml:VerticalDirection */
enum eml__VerticalDirection
{
	eml__VerticalDirection__up = 0,
	eml__VerticalDirection__down = 1
};
#endif

/* resqml2_0_1ForGsoap.h:5287 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioUom (623)
/* eml:LogarithmicPowerRatioUom */
enum eml__LogarithmicPowerRatioUom
{
	eml__LogarithmicPowerRatioUom__B = 0,
	eml__LogarithmicPowerRatioUom__dB = 1
};
#endif

/* resqml2_0_1ForGsoap.h:5302 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeUom (624)
/* eml:AmountOfSubstancePerTimeUom */
enum eml__AmountOfSubstancePerTimeUom
{
	eml__AmountOfSubstancePerTimeUom__kmol_x002fh = 0,
	eml__AmountOfSubstancePerTimeUom__kmol_x002fs = 1,
	eml__AmountOfSubstancePerTimeUom__lbmol_x002fh = 2,
	eml__AmountOfSubstancePerTimeUom__lbmol_x002fs = 3,
	eml__AmountOfSubstancePerTimeUom__mol_x002fs = 4
};
#endif

/* resqml2_0_1ForGsoap.h:5329 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityUom (625)
/* eml:ElectricConductivityUom */
enum eml__ElectricConductivityUom
{
	eml__ElectricConductivityUom__kS_x002fm = 0,
	eml__ElectricConductivityUom__mS_x002fcm = 1,
	eml__ElectricConductivityUom__mS_x002fm = 2,
	eml__ElectricConductivityUom__S_x002fm = 3
};
#endif

/* resqml2_0_1ForGsoap.h:5352 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationUom (626)
/* eml:VolumePerRotationUom */
enum eml__VolumePerRotationUom
{
	eml__VolumePerRotationUom__ft3_x002frad = 0,
	eml__VolumePerRotationUom__m3_x002frad = 1,
	eml__VolumePerRotationUom__m3_x002frev = 2
};
#endif

/* resqml2_0_1ForGsoap.h:5371 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaUom (627)
/* eml:VolumePerTimePerAreaUom */
enum eml__VolumePerTimePerAreaUom
{
	eml__VolumePerTimePerAreaUom__ft3_x002f_x0028min_x002eft2_x0029 = 0,
	eml__VolumePerTimePerAreaUom__ft3_x002f_x0028s_x002eft2_x0029 = 1,
	eml__VolumePerTimePerAreaUom__gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 2,
	eml__VolumePerTimePerAreaUom__gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 3,
	eml__VolumePerTimePerAreaUom__gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 4,
	eml__VolumePerTimePerAreaUom__gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 5,
	eml__VolumePerTimePerAreaUom__gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 6,
	eml__VolumePerTimePerAreaUom__gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 7,
	eml__VolumePerTimePerAreaUom__m3_x002f_x0028s_x002em2_x0029 = 8
};
#endif

/* resqml2_0_1ForGsoap.h:5414 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityUom (628)
/* eml:MobilityUom */
enum eml__MobilityUom
{
	eml__MobilityUom__D_x002f_x0028Pa_x002es_x0029 = 0,
	eml__MobilityUom__D_x002fcP = 1,
	eml__MobilityUom__mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 2,
	eml__MobilityUom__mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 3,
	eml__MobilityUom__mD_x002f_x0028Pa_x002es_x0029 = 4,
	eml__MobilityUom__mD_x002fcP = 5,
	eml__MobilityUom__TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 6
};
#endif

/* resqml2_0_1ForGsoap.h:5449 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientUom (629)
/* eml:HeatTransferCoefficientUom */
enum eml__HeatTransferCoefficientUom
{
	eml__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	eml__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaR_x0029 = 1,
	eml__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 2,
	eml__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edeltaF_x0029 = 3,
	eml__HeatTransferCoefficientUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edeltaC_x0029 = 4,
	eml__HeatTransferCoefficientUom__cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edeltaC_x0029 = 5,
	eml__HeatTransferCoefficientUom__J_x002f_x0028s_x002em2_x002edeltaC_x0029 = 6,
	eml__HeatTransferCoefficientUom__kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 7,
	eml__HeatTransferCoefficientUom__kJ_x002f_x0028h_x002em2_x002edeltaK_x0029 = 8,
	eml__HeatTransferCoefficientUom__kW_x002f_x0028m2_x002edeltaK_x0029 = 9,
	eml__HeatTransferCoefficientUom__W_x002f_x0028m2_x002edeltaK_x0029 = 10
};
#endif

/* resqml2_0_1ForGsoap.h:5500 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyUom (630)
/* eml:MassPerEnergyUom */
enum eml__MassPerEnergyUom
{
	eml__MassPerEnergyUom__kg_x002f_x0028kW_x002eh_x0029 = 0,
	eml__MassPerEnergyUom__kg_x002fJ = 1,
	eml__MassPerEnergyUom__kg_x002fMJ = 2,
	eml__MassPerEnergyUom__lbm_x002f_x0028hp_x002eh_x0029 = 3,
	eml__MassPerEnergyUom__mg_x002fJ = 4
};
#endif

/* resqml2_0_1ForGsoap.h:5527 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaUom (631)
/* eml:MomentOfInertiaUom */
enum eml__MomentOfInertiaUom
{
	eml__MomentOfInertiaUom__kg_x002em2 = 0,
	eml__MomentOfInertiaUom__lbm_x002eft2 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:5542 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceUom (632)
/* eml:CapacitanceUom */
enum eml__CapacitanceUom
{
	eml__CapacitanceUom__cF = 0,
	eml__CapacitanceUom__dF = 1,
	eml__CapacitanceUom__EF = 2,
	eml__CapacitanceUom__F = 3,
	eml__CapacitanceUom__fF = 4,
	eml__CapacitanceUom__GF = 5,
	eml__CapacitanceUom__kF = 6,
	eml__CapacitanceUom__mF = 7,
	eml__CapacitanceUom__MF = 8,
	eml__CapacitanceUom__nF = 9,
	eml__CapacitanceUom__pF = 10,
	eml__CapacitanceUom__TF = 11,
	eml__CapacitanceUom__uF = 12
};
#endif

/* resqml2_0_1ForGsoap.h:5601 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthUom (633)
/* eml:MagneticFluxDensityPerLengthUom */
enum eml__MagneticFluxDensityPerLengthUom
{
	eml__MagneticFluxDensityPerLengthUom__gauss_x002fcm = 0,
	eml__MagneticFluxDensityPerLengthUom__mT_x002fdm = 1,
	eml__MagneticFluxDensityPerLengthUom__T_x002fm = 2
};
#endif

/* resqml2_0_1ForGsoap.h:5620 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeUom (634)
/* eml:LengthPerVolumeUom */
enum eml__LengthPerVolumeUom
{
	eml__LengthPerVolumeUom__ft_x002fbbl = 0,
	eml__LengthPerVolumeUom__ft_x002fft3 = 1,
	eml__LengthPerVolumeUom__ft_x002fgal_x005bUS_x005d = 2,
	eml__LengthPerVolumeUom__km_x002fdm3 = 3,
	eml__LengthPerVolumeUom__km_x002fL = 4,
	eml__LengthPerVolumeUom__m_x002fm3 = 5,
	eml__LengthPerVolumeUom__mi_x002fgal_x005bUK_x005d = 6,
	eml__LengthPerVolumeUom__mi_x002fgal_x005bUS_x005d = 7
};
#endif

/* resqml2_0_1ForGsoap.h:5659 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeUom (635)
/* eml:MassPerTimeUom */
enum eml__MassPerTimeUom
{
	eml__MassPerTimeUom__1E6_x0020lbm_x002fa = 0,
	eml__MassPerTimeUom__g_x002fs = 1,
	eml__MassPerTimeUom__kg_x002fd = 2,
	eml__MassPerTimeUom__kg_x002fh = 3,
	eml__MassPerTimeUom__kg_x002fmin = 4,
	eml__MassPerTimeUom__kg_x002fs = 5,
	eml__MassPerTimeUom__lbm_x002fd = 6,
	eml__MassPerTimeUom__lbm_x002fh = 7,
	eml__MassPerTimeUom__lbm_x002fmin = 8,
	eml__MassPerTimeUom__lbm_x002fs = 9,
	eml__MassPerTimeUom__Mg_x002fa = 10,
	eml__MassPerTimeUom__Mg_x002fd = 11,
	eml__MassPerTimeUom__Mg_x002fh = 12,
	eml__MassPerTimeUom__Mg_x002fmin = 13,
	eml__MassPerTimeUom__t_x002fa = 14,
	eml__MassPerTimeUom__t_x002fd = 15,
	eml__MassPerTimeUom__t_x002fh = 16,
	eml__MassPerTimeUom__t_x002fmin = 17,
	eml__MassPerTimeUom__ton_x005bUK_x005d_x002fa = 18,
	eml__MassPerTimeUom__ton_x005bUK_x005d_x002fd = 19,
	eml__MassPerTimeUom__ton_x005bUK_x005d_x002fh = 20,
	eml__MassPerTimeUom__ton_x005bUK_x005d_x002fmin = 21,
	eml__MassPerTimeUom__ton_x005bUS_x005d_x002fa = 22,
	eml__MassPerTimeUom__ton_x005bUS_x005d_x002fd = 23,
	eml__MassPerTimeUom__ton_x005bUS_x005d_x002fh = 24,
	eml__MassPerTimeUom__ton_x005bUS_x005d_x002fmin = 25
};
#endif

/* resqml2_0_1ForGsoap.h:5770 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightUom (636)
/* eml:MolecularWeightUom */
enum eml__MolecularWeightUom
{
	eml__MolecularWeightUom__g_x002fmol = 0,
	eml__MolecularWeightUom__kg_x002fmol = 1,
	eml__MolecularWeightUom__lbm_x002flbmol = 2
};
#endif

/* resqml2_0_1ForGsoap.h:5789 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxUom (637)
/* eml:MagneticFluxUom */
enum eml__MagneticFluxUom
{
	eml__MagneticFluxUom__cWb = 0,
	eml__MagneticFluxUom__dWb = 1,
	eml__MagneticFluxUom__EWb = 2,
	eml__MagneticFluxUom__fWb = 3,
	eml__MagneticFluxUom__GWb = 4,
	eml__MagneticFluxUom__kWb = 5,
	eml__MagneticFluxUom__MWb = 6,
	eml__MagneticFluxUom__mWb = 7,
	eml__MagneticFluxUom__nWb = 8,
	eml__MagneticFluxUom__pWb = 9,
	eml__MagneticFluxUom__TWb = 10,
	eml__MagneticFluxUom__uWb = 11,
	eml__MagneticFluxUom__Wb = 12
};
#endif

/* resqml2_0_1ForGsoap.h:5848 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeUom (638)
/* eml:VolumeUom */
enum eml__VolumeUom
{
	eml__VolumeUom__1000_x0020bbl = 0,
	eml__VolumeUom__1000_x0020ft3 = 1,
	eml__VolumeUom__1000_x0020gal_x005bUK_x005d = 2,
	eml__VolumeUom__1000_x0020gal_x005bUS_x005d = 3,
	eml__VolumeUom__1000_x0020m3 = 4,
	eml__VolumeUom__1E_6_x0020gal_x005bUS_x005d = 5,
	eml__VolumeUom__1E12_x0020ft3 = 6,
	eml__VolumeUom__1E6_x0020bbl = 7,
	eml__VolumeUom__1E6_x0020ft3 = 8,
	eml__VolumeUom__1E6_x0020m3 = 9,
	eml__VolumeUom__1E9_x0020bbl = 10,
	eml__VolumeUom__1E9_x0020ft3 = 11,
	eml__VolumeUom__acre_x002eft = 12,
	eml__VolumeUom__bbl = 13,
	eml__VolumeUom__cm3 = 14,
	eml__VolumeUom__dm3 = 15,
	eml__VolumeUom__floz_x005bUK_x005d = 16,
	eml__VolumeUom__floz_x005bUS_x005d = 17,
	eml__VolumeUom__ft3 = 18,
	eml__VolumeUom__gal_x005bUK_x005d = 19,
	eml__VolumeUom__gal_x005bUS_x005d = 20,
	eml__VolumeUom__ha_x002em = 21,
	eml__VolumeUom__hL = 22,
	eml__VolumeUom__in3 = 23,
	eml__VolumeUom__km3 = 24,
	eml__VolumeUom__L = 25,
	eml__VolumeUom__m3 = 26,
	eml__VolumeUom__mi3 = 27,
	eml__VolumeUom__mL = 28,
	eml__VolumeUom__mm3 = 29,
	eml__VolumeUom__pt_x005bUK_x005d = 30,
	eml__VolumeUom__pt_x005bUS_x005d = 31,
	eml__VolumeUom__qt_x005bUK_x005d = 32,
	eml__VolumeUom__qt_x005bUS_x005d = 33,
	eml__VolumeUom__um2_x002em = 34,
	eml__VolumeUom__yd3 = 35
};
#endif

/* resqml2_0_1ForGsoap.h:5999 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceUom (639)
/* eml:ThermalConductanceUom */
enum eml__ThermalConductanceUom
{
	eml__ThermalConductanceUom__W_x002fdeltaK = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6010 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightUom (640)
/* eml:QuantityOfLightUom */
enum eml__QuantityOfLightUom
{
	eml__QuantityOfLightUom__lm_x002es = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6021 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeUom (641)
/* eml:LengthPerTimeUom */
enum eml__LengthPerTimeUom
{
	eml__LengthPerTimeUom__1000_x0020ft_x002fh = 0,
	eml__LengthPerTimeUom__1000_x0020ft_x002fs = 1,
	eml__LengthPerTimeUom__cm_x002fa = 2,
	eml__LengthPerTimeUom__cm_x002fs = 3,
	eml__LengthPerTimeUom__dm_x002fs = 4,
	eml__LengthPerTimeUom__ft_x002fd = 5,
	eml__LengthPerTimeUom__ft_x002fh = 6,
	eml__LengthPerTimeUom__ft_x002fmin = 7,
	eml__LengthPerTimeUom__ft_x002fms = 8,
	eml__LengthPerTimeUom__ft_x002fs = 9,
	eml__LengthPerTimeUom__ft_x002fus = 10,
	eml__LengthPerTimeUom__in_x002fa = 11,
	eml__LengthPerTimeUom__in_x002fmin = 12,
	eml__LengthPerTimeUom__in_x002fs = 13,
	eml__LengthPerTimeUom__km_x002fh = 14,
	eml__LengthPerTimeUom__km_x002fs = 15,
	eml__LengthPerTimeUom__knot = 16,
	eml__LengthPerTimeUom__m_x002fd = 17,
	eml__LengthPerTimeUom__m_x002fh = 18,
	eml__LengthPerTimeUom__m_x002fmin = 19,
	eml__LengthPerTimeUom__m_x002fms = 20,
	eml__LengthPerTimeUom__m_x002fs = 21,
	eml__LengthPerTimeUom__mi_x002fh = 22,
	eml__LengthPerTimeUom__mil_x002fa = 23,
	eml__LengthPerTimeUom__mm_x002fa = 24,
	eml__LengthPerTimeUom__mm_x002fs = 25,
	eml__LengthPerTimeUom__nm_x002fs = 26,
	eml__LengthPerTimeUom__um_x002fs = 27
};
#endif

/* resqml2_0_1ForGsoap.h:6140 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthUom (642)
/* eml:ForceLengthPerLengthUom */
enum eml__ForceLengthPerLengthUom
{
	eml__ForceLengthPerLengthUom__kgf_x002em_x002fm = 0,
	eml__ForceLengthPerLengthUom__lbf_x002eft_x002fin = 1,
	eml__ForceLengthPerLengthUom__lbf_x002ein_x002fin = 2,
	eml__ForceLengthPerLengthUom__N_x002em_x002fm = 3,
	eml__ForceLengthPerLengthUom__tonf_x005bUS_x005d_x002emi_x002fft = 4
};
#endif

/* resqml2_0_1ForGsoap.h:6167 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleUom (643)
/* eml:SolidAngleUom */
enum eml__SolidAngleUom
{
	eml__SolidAngleUom__sr = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6178 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeUom (644)
/* eml:VolumePerTimePerVolumeUom */
enum eml__VolumePerTimePerVolumeUom
{
	eml__VolumePerTimePerVolumeUom__bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 0,
	eml__VolumePerTimePerVolumeUom__m3_x002f_x0028s_x002em3_x0029 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:6193 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceUom (645)
/* eml:MomentOfForceUom */
enum eml__MomentOfForceUom
{
	eml__MomentOfForceUom__1000_x0020lbf_x002eft = 0,
	eml__MomentOfForceUom__daN_x002em = 1,
	eml__MomentOfForceUom__dN_x002em = 2,
	eml__MomentOfForceUom__J = 3,
	eml__MomentOfForceUom__kgf_x002em = 4,
	eml__MomentOfForceUom__kN_x002em = 5,
	eml__MomentOfForceUom__lbf_x002eft = 6,
	eml__MomentOfForceUom__lbf_x002ein = 7,
	eml__MomentOfForceUom__lbm_x002eft2_x002fs2 = 8,
	eml__MomentOfForceUom__N_x002em = 9,
	eml__MomentOfForceUom__pdl_x002eft = 10,
	eml__MomentOfForceUom__tonf_x005bUS_x005d_x002eft = 11,
	eml__MomentOfForceUom__tonf_x005bUS_x005d_x002emi = 12
};
#endif

/* resqml2_0_1ForGsoap.h:6252 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeUom (646)
/* eml:MassPerVolumeUom */
enum eml__MassPerVolumeUom
{
	eml__MassPerVolumeUom__0_x002e001_x0020lbm_x002fbbl = 0,
	eml__MassPerVolumeUom__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 1,
	eml__MassPerVolumeUom__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 2,
	eml__MassPerVolumeUom__0_x002e01_x0020grain_x002fft3 = 3,
	eml__MassPerVolumeUom__0_x002e1_x0020lbm_x002fbbl = 4,
	eml__MassPerVolumeUom__10_x0020Mg_x002fm3 = 5,
	eml__MassPerVolumeUom__g_x002fcm3 = 6,
	eml__MassPerVolumeUom__g_x002fdm3 = 7,
	eml__MassPerVolumeUom__g_x002fgal_x005bUK_x005d = 8,
	eml__MassPerVolumeUom__g_x002fgal_x005bUS_x005d = 9,
	eml__MassPerVolumeUom__g_x002fL = 10,
	eml__MassPerVolumeUom__g_x002fm3 = 11,
	eml__MassPerVolumeUom__grain_x002fft3 = 12,
	eml__MassPerVolumeUom__grain_x002fgal_x005bUS_x005d = 13,
	eml__MassPerVolumeUom__kg_x002fdm3 = 14,
	eml__MassPerVolumeUom__kg_x002fL = 15,
	eml__MassPerVolumeUom__kg_x002fm3 = 16,
	eml__MassPerVolumeUom__lbm_x002fbbl = 17,
	eml__MassPerVolumeUom__lbm_x002fft3 = 18,
	eml__MassPerVolumeUom__lbm_x002fgal_x005bUK_x005d = 19,
	eml__MassPerVolumeUom__lbm_x002fgal_x005bUS_x005d = 20,
	eml__MassPerVolumeUom__lbm_x002fin3 = 21,
	eml__MassPerVolumeUom__mg_x002fdm3 = 22,
	eml__MassPerVolumeUom__mg_x002fgal_x005bUS_x005d = 23,
	eml__MassPerVolumeUom__mg_x002fL = 24,
	eml__MassPerVolumeUom__mg_x002fm3 = 25,
	eml__MassPerVolumeUom__Mg_x002fm3 = 26,
	eml__MassPerVolumeUom__t_x002fm3 = 27,
	eml__MassPerVolumeUom__ug_x002fcm3 = 28
};
#endif

/* resqml2_0_1ForGsoap.h:6375 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeUom (647)
/* eml:MolarVolumeUom */
enum eml__MolarVolumeUom
{
	eml__MolarVolumeUom__dm3_x002fkmol = 0,
	eml__MolarVolumeUom__ft3_x002flbmol = 1,
	eml__MolarVolumeUom__L_x002fkmol = 2,
	eml__MolarVolumeUom__L_x002fmol = 3,
	eml__MolarVolumeUom__m3_x002fkmol = 4,
	eml__MolarVolumeUom__m3_x002fmol = 5
};
#endif

/* resqml2_0_1ForGsoap.h:6406 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceUom (648)
/* eml:AmountOfSubstanceUom */
enum eml__AmountOfSubstanceUom
{
	eml__AmountOfSubstanceUom__kmol = 0,
	eml__AmountOfSubstanceUom__lbmol = 1,
	eml__AmountOfSubstanceUom__mmol = 2,
	eml__AmountOfSubstanceUom__mol = 3,
	eml__AmountOfSubstanceUom__umol = 4
};
#endif

/* resqml2_0_1ForGsoap.h:6433 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentUom (649)
/* eml:DipoleMomentUom */
enum eml__DipoleMomentUom
{
	eml__DipoleMomentUom__C_x002em = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6444 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronUom (650)
/* eml:APINeutronUom */
enum eml__APINeutronUom
{
	eml__APINeutronUom__nAPI = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6455 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeUom (651)
/* eml:ReciprocalTimeUom */
enum eml__ReciprocalTimeUom
{
	eml__ReciprocalTimeUom__1_x002fa = 0,
	eml__ReciprocalTimeUom__1_x002fd = 1,
	eml__ReciprocalTimeUom__1_x002fh = 2,
	eml__ReciprocalTimeUom__1_x002fmin = 3,
	eml__ReciprocalTimeUom__1_x002fms = 4,
	eml__ReciprocalTimeUom__1_x002fs = 5,
	eml__ReciprocalTimeUom__1_x002fus = 6,
	eml__ReciprocalTimeUom__1_x002fwk = 7
};
#endif

/* resqml2_0_1ForGsoap.h:6494 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureUom (652)
/* eml:TemperatureIntervalPerPressureUom */
enum eml__TemperatureIntervalPerPressureUom
{
	eml__TemperatureIntervalPerPressureUom__deltaC_x002fkPa = 0,
	eml__TemperatureIntervalPerPressureUom__deltaF_x002fpsi = 1,
	eml__TemperatureIntervalPerPressureUom__deltaK_x002fPa = 2
};
#endif

/* resqml2_0_1ForGsoap.h:6513 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthUom (653)
/* eml:LengthPerLengthUom */
enum eml__LengthPerLengthUom
{
	eml__LengthPerLengthUom___x0025 = 0,
	eml__LengthPerLengthUom__0_x002e01_x0020ft_x002fft = 1,
	eml__LengthPerLengthUom__1_x002f30_x0020m_x002fm = 2,
	eml__LengthPerLengthUom__Euc = 3,
	eml__LengthPerLengthUom__ft_x002fft = 4,
	eml__LengthPerLengthUom__ft_x002fin = 5,
	eml__LengthPerLengthUom__ft_x002fm = 6,
	eml__LengthPerLengthUom__ft_x002fmi = 7,
	eml__LengthPerLengthUom__km_x002fcm = 8,
	eml__LengthPerLengthUom__m_x002fcm = 9,
	eml__LengthPerLengthUom__m_x002fkm = 10,
	eml__LengthPerLengthUom__m_x002fm = 11,
	eml__LengthPerLengthUom__mi_x002fin = 12
};
#endif

/* resqml2_0_1ForGsoap.h:6572 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaUom (654)
/* eml:AreaUom */
enum eml__AreaUom
{
	eml__AreaUom__acre = 0,
	eml__AreaUom__b = 1,
	eml__AreaUom__cm2 = 2,
	eml__AreaUom__ft2 = 3,
	eml__AreaUom__ha = 4,
	eml__AreaUom__in2 = 5,
	eml__AreaUom__km2 = 6,
	eml__AreaUom__m2 = 7,
	eml__AreaUom__mi_x005bUS_x005d2 = 8,
	eml__AreaUom__mi2 = 9,
	eml__AreaUom__mm2 = 10,
	eml__AreaUom__section = 11,
	eml__AreaUom__um2 = 12,
	eml__AreaUom__yd2 = 13
};
#endif

/* resqml2_0_1ForGsoap.h:6635 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayUom (655)
/* eml:APIGammaRayUom */
enum eml__APIGammaRayUom
{
	eml__APIGammaRayUom__gAPI = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6646 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionUom (656)
/* eml:VolumetricThermalExpansionUom */
enum eml__VolumetricThermalExpansionUom
{
	eml__VolumetricThermalExpansionUom__1_x002fdeltaC = 0,
	eml__VolumetricThermalExpansionUom__1_x002fdeltaF = 1,
	eml__VolumetricThermalExpansionUom__1_x002fdeltaK = 2,
	eml__VolumetricThermalExpansionUom__1_x002fdeltaR = 3,
	eml__VolumetricThermalExpansionUom__1E_6_x0020m3_x002f_x0028m3_x002edeltaC_x0029 = 4,
	eml__VolumetricThermalExpansionUom__1E_6_x0020m3_x002f_x0028m3_x002edeltaF_x0029 = 5,
	eml__VolumetricThermalExpansionUom__m3_x002f_x0028m3_x002edeltaK_x0029 = 6,
	eml__VolumetricThermalExpansionUom__ppm_x005bvol_x005d_x002fdeltaC = 7,
	eml__VolumetricThermalExpansionUom__ppm_x005bvol_x005d_x002fdeltaF = 8
};
#endif

/* resqml2_0_1ForGsoap.h:6689 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityUom (657)
/* eml:ElectricCurrentDensityUom */
enum eml__ElectricCurrentDensityUom
{
	eml__ElectricCurrentDensityUom__A_x002fcm2 = 0,
	eml__ElectricCurrentDensityUom__A_x002fft2 = 1,
	eml__ElectricCurrentDensityUom__A_x002fm2 = 2,
	eml__ElectricCurrentDensityUom__A_x002fmm2 = 3,
	eml__ElectricCurrentDensityUom__mA_x002fcm2 = 4,
	eml__ElectricCurrentDensityUom__mA_x002fft2 = 5,
	eml__ElectricCurrentDensityUom__uA_x002fcm2 = 6,
	eml__ElectricCurrentDensityUom__uA_x002fin2 = 7
};
#endif

/* resqml2_0_1ForGsoap.h:6728 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceUom (658)
/* eml:ForceUom */
enum eml__ForceUom
{
	eml__ForceUom__10_x0020kN = 0,
	eml__ForceUom__cN = 1,
	eml__ForceUom__daN = 2,
	eml__ForceUom__dN = 3,
	eml__ForceUom__dyne = 4,
	eml__ForceUom__EN = 5,
	eml__ForceUom__fN = 6,
	eml__ForceUom__gf = 7,
	eml__ForceUom__GN = 8,
	eml__ForceUom__hN = 9,
	eml__ForceUom__kdyne = 10,
	eml__ForceUom__kgf = 11,
	eml__ForceUom__klbf = 12,
	eml__ForceUom__kN = 13,
	eml__ForceUom__lbf = 14,
	eml__ForceUom__Mgf = 15,
	eml__ForceUom__mN = 16,
	eml__ForceUom__MN = 17,
	eml__ForceUom__N = 18,
	eml__ForceUom__nN = 19,
	eml__ForceUom__ozf = 20,
	eml__ForceUom__pdl = 21,
	eml__ForceUom__pN = 22,
	eml__ForceUom__TN = 23,
	eml__ForceUom__tonf_x005bUK_x005d = 24,
	eml__ForceUom__tonf_x005bUS_x005d = 25,
	eml__ForceUom__uN = 26
};
#endif

/* resqml2_0_1ForGsoap.h:6843 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaUom (659)
/* eml:VolumePerAreaUom */
enum eml__VolumePerAreaUom
{
	eml__VolumePerAreaUom__1E6_x0020bbl_x002facre = 0,
	eml__VolumePerAreaUom__bbl_x002facre = 1,
	eml__VolumePerAreaUom__ft3_x002fft2 = 2,
	eml__VolumePerAreaUom__m3_x002fm2 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:6866 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceUom (660)
/* eml:ReciprocalElectricPotentialDifferenceUom */
enum eml__ReciprocalElectricPotentialDifferenceUom
{
	eml__ReciprocalElectricPotentialDifferenceUom__1_x002fuV = 0,
	eml__ReciprocalElectricPotentialDifferenceUom__1_x002fV = 1
};
#endif

/* resqml2_0_1ForGsoap.h:6881 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthUom (661)
/* eml:TimePerLengthUom */
enum eml__TimePerLengthUom
{
	eml__TimePerLengthUom__0_x002e001_x0020h_x002fft = 0,
	eml__TimePerLengthUom__h_x002fkm = 1,
	eml__TimePerLengthUom__min_x002fft = 2,
	eml__TimePerLengthUom__min_x002fm = 3,
	eml__TimePerLengthUom__ms_x002fcm = 4,
	eml__TimePerLengthUom__ms_x002fft = 5,
	eml__TimePerLengthUom__ms_x002fin = 6,
	eml__TimePerLengthUom__ms_x002fm = 7,
	eml__TimePerLengthUom__ns_x002fft = 8,
	eml__TimePerLengthUom__ns_x002fm = 9,
	eml__TimePerLengthUom__s_x002fcm = 10,
	eml__TimePerLengthUom__s_x002fft = 11,
	eml__TimePerLengthUom__s_x002fin = 12,
	eml__TimePerLengthUom__s_x002fm = 13,
	eml__TimePerLengthUom__us_x002fft = 14,
	eml__TimePerLengthUom__us_x002fin = 15,
	eml__TimePerLengthUom__us_x002fm = 16
};
#endif

/* resqml2_0_1ForGsoap.h:6956 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureUom (662)
/* eml:VolumePerPressureUom */
enum eml__VolumePerPressureUom
{
	eml__VolumePerPressureUom__bbl_x002fpsi = 0,
	eml__VolumePerPressureUom__m3_x002fkPa = 1,
	eml__VolumePerPressureUom__m3_x002fPa = 2
};
#endif

/* resqml2_0_1ForGsoap.h:6975 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaUom (663)
/* eml:ElectricChargePerAreaUom */
enum eml__ElectricChargePerAreaUom
{
	eml__ElectricChargePerAreaUom__C_x002fcm2 = 0,
	eml__ElectricChargePerAreaUom__C_x002fm2 = 1,
	eml__ElectricChargePerAreaUom__C_x002fmm2 = 2,
	eml__ElectricChargePerAreaUom__mC_x002fm2 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:6998 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthUom (664)
/* eml:MassPerTimePerLengthUom */
enum eml__MassPerTimePerLengthUom
{
	eml__MassPerTimePerLengthUom__kg_x002f_x0028m_x002es_x0029 = 0,
	eml__MassPerTimePerLengthUom__lbm_x002f_x0028ft_x002eh_x0029 = 1,
	eml__MassPerTimePerLengthUom__lbm_x002f_x0028ft_x002es_x0029 = 2,
	eml__MassPerTimePerLengthUom__Pa_x002es = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7021 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityUom (665)
/* eml:MagneticFluxDensityUom */
enum eml__MagneticFluxDensityUom
{
	eml__MagneticFluxDensityUom__cgauss = 0,
	eml__MagneticFluxDensityUom__cT = 1,
	eml__MagneticFluxDensityUom__dgauss = 2,
	eml__MagneticFluxDensityUom__dT = 3,
	eml__MagneticFluxDensityUom__Egauss = 4,
	eml__MagneticFluxDensityUom__ET = 5,
	eml__MagneticFluxDensityUom__fgauss = 6,
	eml__MagneticFluxDensityUom__fT = 7,
	eml__MagneticFluxDensityUom__gauss = 8,
	eml__MagneticFluxDensityUom__Ggauss = 9,
	eml__MagneticFluxDensityUom__GT = 10,
	eml__MagneticFluxDensityUom__kgauss = 11,
	eml__MagneticFluxDensityUom__kT = 12,
	eml__MagneticFluxDensityUom__mgauss = 13,
	eml__MagneticFluxDensityUom__Mgauss = 14,
	eml__MagneticFluxDensityUom__mT = 15,
	eml__MagneticFluxDensityUom__ngauss = 16,
	eml__MagneticFluxDensityUom__nT = 17,
	eml__MagneticFluxDensityUom__pgauss = 18,
	eml__MagneticFluxDensityUom__pT = 19,
	eml__MagneticFluxDensityUom__T = 20,
	eml__MagneticFluxDensityUom__Tgauss = 21,
	eml__MagneticFluxDensityUom__TT = 22,
	eml__MagneticFluxDensityUom__ugauss = 23,
	eml__MagneticFluxDensityUom__uT = 24
};
#endif

/* resqml2_0_1ForGsoap.h:7128 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleUom (666)
/* eml:PlaneAngleUom */
enum eml__PlaneAngleUom
{
	eml__PlaneAngleUom__0_x002e001_x0020seca = 0,
	eml__PlaneAngleUom__ccgr = 1,
	eml__PlaneAngleUom__cgr = 2,
	eml__PlaneAngleUom__dega = 3,
	eml__PlaneAngleUom__gon = 4,
	eml__PlaneAngleUom__krad = 5,
	eml__PlaneAngleUom__mila = 6,
	eml__PlaneAngleUom__mina = 7,
	eml__PlaneAngleUom__Mrad = 8,
	eml__PlaneAngleUom__mrad = 9,
	eml__PlaneAngleUom__rad = 10,
	eml__PlaneAngleUom__rev = 11,
	eml__PlaneAngleUom__seca = 12,
	eml__PlaneAngleUom__urad = 13
};
#endif

/* resqml2_0_1ForGsoap.h:7191 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeUom (667)
/* eml:SignalingEventPerTimeUom */
enum eml__SignalingEventPerTimeUom
{
	eml__SignalingEventPerTimeUom__Bd = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7202 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthUom (668)
/* eml:EnergyPerLengthUom */
enum eml__EnergyPerLengthUom
{
	eml__EnergyPerLengthUom__J_x002fm = 0,
	eml__EnergyPerLengthUom__MJ_x002fm = 1
};
#endif

/* resqml2_0_1ForGsoap.h:7217 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentUom (669)
/* eml:ElectricCurrentUom */
enum eml__ElectricCurrentUom
{
	eml__ElectricCurrentUom__A = 0,
	eml__ElectricCurrentUom__cA = 1,
	eml__ElectricCurrentUom__dA = 2,
	eml__ElectricCurrentUom__EA = 3,
	eml__ElectricCurrentUom__fA = 4,
	eml__ElectricCurrentUom__GA = 5,
	eml__ElectricCurrentUom__kA = 6,
	eml__ElectricCurrentUom__mA = 7,
	eml__ElectricCurrentUom__MA = 8,
	eml__ElectricCurrentUom__nA = 9,
	eml__ElectricCurrentUom__pA = 10,
	eml__ElectricCurrentUom__TA = 11,
	eml__ElectricCurrentUom__uA = 12
};
#endif

/* resqml2_0_1ForGsoap.h:7276 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredUom (670)
/* eml:PressureSquaredUom */
enum eml__PressureSquaredUom
{
	eml__PressureSquaredUom__bar2 = 0,
	eml__PressureSquaredUom__GPa2 = 1,
	eml__PressureSquaredUom__kPa2 = 2,
	eml__PressureSquaredUom__kpsi2 = 3,
	eml__PressureSquaredUom__Pa2 = 4,
	eml__PressureSquaredUom__psi2 = 5
};
#endif

/* resqml2_0_1ForGsoap.h:7307 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationUom (671)
/* eml:AngularAccelerationUom */
enum eml__AngularAccelerationUom
{
	eml__AngularAccelerationUom__rad_x002fs2 = 0,
	eml__AngularAccelerationUom__rpm_x002fs = 1
};
#endif

/* resqml2_0_1ForGsoap.h:7322 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeUom (672)
/* eml:ReciprocalMassTimeUom */
enum eml__ReciprocalMassTimeUom
{
	eml__ReciprocalMassTimeUom__1_x002f_x0028kg_x002es_x0029 = 0,
	eml__ReciprocalMassTimeUom__Bq_x002fkg = 1,
	eml__ReciprocalMassTimeUom__pCi_x002fg = 2
};
#endif

/* resqml2_0_1ForGsoap.h:7341 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityUom (673)
/* eml:ThermalDiffusivityUom */
enum eml__ThermalDiffusivityUom
{
	eml__ThermalDiffusivityUom__cm2_x002fs = 0,
	eml__ThermalDiffusivityUom__ft2_x002fh = 1,
	eml__ThermalDiffusivityUom__ft2_x002fs = 2,
	eml__ThermalDiffusivityUom__in2_x002fs = 3,
	eml__ThermalDiffusivityUom__m2_x002fh = 4,
	eml__ThermalDiffusivityUom__m2_x002fs = 5,
	eml__ThermalDiffusivityUom__mm2_x002fs = 6
};
#endif

/* resqml2_0_1ForGsoap.h:7376 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthUom (674)
/* eml:VolumePerTimeLengthUom */
enum eml__VolumePerTimeLengthUom
{
	eml__VolumePerTimeLengthUom__1000_x0020bbl_x002eft_x002fd = 0,
	eml__VolumePerTimeLengthUom__1000_x0020m4_x002fd = 1,
	eml__VolumePerTimeLengthUom__m4_x002fs = 2
};
#endif

/* resqml2_0_1ForGsoap.h:7395 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockUom (675)
/* eml:PermeabilityRockUom */
enum eml__PermeabilityRockUom
{
	eml__PermeabilityRockUom__D = 0,
	eml__PermeabilityRockUom__D_x005bAPI_x005d = 1,
	eml__PermeabilityRockUom__mD = 2,
	eml__PermeabilityRockUom__TD_x005bAPI_x005d = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7418 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaUom (676)
/* eml:SecondMomentOfAreaUom */
enum eml__SecondMomentOfAreaUom
{
	eml__SecondMomentOfAreaUom__cm4 = 0,
	eml__SecondMomentOfAreaUom__in4 = 1,
	eml__SecondMomentOfAreaUom__m4 = 2
};
#endif

/* resqml2_0_1ForGsoap.h:7437 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaUom (677)
/* eml:ForceAreaUom */
enum eml__ForceAreaUom
{
	eml__ForceAreaUom__dyne_x002ecm2 = 0,
	eml__ForceAreaUom__kgf_x002em2 = 1,
	eml__ForceAreaUom__kN_x002em2 = 2,
	eml__ForceAreaUom__lbf_x002ein2 = 3,
	eml__ForceAreaUom__mN_x002em2 = 4,
	eml__ForceAreaUom__N_x002em2 = 5,
	eml__ForceAreaUom__pdl_x002ecm2 = 6,
	eml__ForceAreaUom__tonf_x005bUK_x005d_x002eft2 = 7,
	eml__ForceAreaUom__tonf_x005bUS_x005d_x002eft2 = 8
};
#endif

/* resqml2_0_1ForGsoap.h:7480 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthUom (678)
/* eml:ElectricFieldStrengthUom */
enum eml__ElectricFieldStrengthUom
{
	eml__ElectricFieldStrengthUom__mV_x002fft = 0,
	eml__ElectricFieldStrengthUom__mV_x002fm = 1,
	eml__ElectricFieldStrengthUom__uV_x002fft = 2,
	eml__ElectricFieldStrengthUom__uV_x002fm = 3,
	eml__ElectricFieldStrengthUom__V_x002fm = 4
};
#endif

/* resqml2_0_1ForGsoap.h:7507 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaUom (679)
/* eml:AmountOfSubstancePerAreaUom */
enum eml__AmountOfSubstancePerAreaUom
{
	eml__AmountOfSubstancePerAreaUom__mol_x002fm2 = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7518 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeUom (680)
/* eml:TimeUom */
enum eml__TimeUom
{
	eml__TimeUom__1_x002f2_x0020ms = 0,
	eml__TimeUom__100_x0020ka_x005bt_x005d = 1,
	eml__TimeUom__a = 2,
	eml__TimeUom__a_x005bt_x005d = 3,
	eml__TimeUom__ca = 4,
	eml__TimeUom__cs = 5,
	eml__TimeUom__d = 6,
	eml__TimeUom__ds = 7,
	eml__TimeUom__Ea_x005bt_x005d = 8,
	eml__TimeUom__fa = 9,
	eml__TimeUom__Ga_x005bt_x005d = 10,
	eml__TimeUom__h = 11,
	eml__TimeUom__hs = 12,
	eml__TimeUom__ka_x005bt_x005d = 13,
	eml__TimeUom__Ma_x005bt_x005d = 14,
	eml__TimeUom__min_ = 15,
	eml__TimeUom__ms = 16,
	eml__TimeUom__na = 17,
	eml__TimeUom__ns = 18,
	eml__TimeUom__ps = 19,
	eml__TimeUom__s = 20,
	eml__TimeUom__Ta_x005bt_x005d = 21,
	eml__TimeUom__us = 22,
	eml__TimeUom__wk = 23
};
#endif

/* resqml2_0_1ForGsoap.h:7621 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityUom (681)
/* eml:ThermalConductivityUom */
enum eml__ThermalConductivityUom
{
	eml__ThermalConductivityUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edeltaF_x0029 = 0,
	eml__ThermalConductivityUom__cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edeltaC_x0029 = 1,
	eml__ThermalConductivityUom__cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edeltaC_x0029 = 2,
	eml__ThermalConductivityUom__kcal_x005bth_x005d_x002f_x0028h_x002em_x002edeltaC_x0029 = 3,
	eml__ThermalConductivityUom__W_x002f_x0028m_x002edeltaK_x0029 = 4
};
#endif

/* resqml2_0_1ForGsoap.h:7648 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceUom (682)
/* eml:AreaPerAmountOfSubstanceUom */
enum eml__AreaPerAmountOfSubstanceUom
{
	eml__AreaPerAmountOfSubstanceUom__m2_x002fmol = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7659 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthUom (683)
/* eml:LogarithmicPowerRatioPerLengthUom */
enum eml__LogarithmicPowerRatioPerLengthUom
{
	eml__LogarithmicPowerRatioPerLengthUom__B_x002fm = 0,
	eml__LogarithmicPowerRatioPerLengthUom__dB_x002fft = 1,
	eml__LogarithmicPowerRatioPerLengthUom__dB_x002fkm = 2,
	eml__LogarithmicPowerRatioPerLengthUom__dB_x002fm = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7682 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthUom (684)
/* eml:ReciprocalLengthUom */
enum eml__ReciprocalLengthUom
{
	eml__ReciprocalLengthUom__1_x002fangstrom = 0,
	eml__ReciprocalLengthUom__1_x002fcm = 1,
	eml__ReciprocalLengthUom__1_x002fft = 2,
	eml__ReciprocalLengthUom__1_x002fin = 3,
	eml__ReciprocalLengthUom__1_x002fm = 4,
	eml__ReciprocalLengthUom__1_x002fmi = 5,
	eml__ReciprocalLengthUom__1_x002fmm = 6,
	eml__ReciprocalLengthUom__1_x002fnm = 7,
	eml__ReciprocalLengthUom__1_x002fyd = 8,
	eml__ReciprocalLengthUom__1E_9_x00201_x002fft = 9
};
#endif

/* resqml2_0_1ForGsoap.h:7729 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceUom (685)
/* eml:LuminanceUom */
enum eml__LuminanceUom
{
	eml__LuminanceUom__cd_x002fm2 = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7740 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeUom (686)
/* eml:VolumePerTimePerTimeUom */
enum eml__VolumePerTimePerTimeUom
{
	eml__VolumePerTimePerTimeUom__bbl_x002fd2 = 0,
	eml__VolumePerTimePerTimeUom__bbl_x002fh2 = 1,
	eml__VolumePerTimePerTimeUom__dm3_x002fs2 = 2,
	eml__VolumePerTimePerTimeUom__ft3_x002fd2 = 3,
	eml__VolumePerTimePerTimeUom__ft3_x002fh2 = 4,
	eml__VolumePerTimePerTimeUom__ft3_x002fmin2 = 5,
	eml__VolumePerTimePerTimeUom__ft3_x002fs2 = 6,
	eml__VolumePerTimePerTimeUom__gal_x005bUK_x005d_x002fh2 = 7,
	eml__VolumePerTimePerTimeUom__gal_x005bUK_x005d_x002fmin2 = 8,
	eml__VolumePerTimePerTimeUom__gal_x005bUS_x005d_x002fh2 = 9,
	eml__VolumePerTimePerTimeUom__gal_x005bUS_x005d_x002fmin2 = 10,
	eml__VolumePerTimePerTimeUom__L_x002fs2 = 11,
	eml__VolumePerTimePerTimeUom__m3_x002fd2 = 12,
	eml__VolumePerTimePerTimeUom__m3_x002fs2 = 13
};
#endif

/* resqml2_0_1ForGsoap.h:7803 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityUom (687)
/* eml:MolarHeatCapacityUom */
enum eml__MolarHeatCapacityUom
{
	eml__MolarHeatCapacityUom__Btu_x005bIT_x005d_x002f_x0028lbmol_x002edeltaF_x0029 = 0,
	eml__MolarHeatCapacityUom__cal_x005bth_x005d_x002f_x0028mol_x002edeltaC_x0029 = 1,
	eml__MolarHeatCapacityUom__J_x002f_x0028mol_x002edeltaK_x0029 = 2,
	eml__MolarHeatCapacityUom__kJ_x002f_x0028kmol_x002edeltaK_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7826 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateUom (688)
/* eml:VolumeFlowRatePerVolumeFlowRateUom */
enum eml__VolumeFlowRatePerVolumeFlowRateUom
{
	eml__VolumeFlowRatePerVolumeFlowRateUom___x0025 = 0,
	eml__VolumeFlowRatePerVolumeFlowRateUom___x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 1,
	eml__VolumeFlowRatePerVolumeFlowRateUom___x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 2,
	eml__VolumeFlowRatePerVolumeFlowRateUom___x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 3,
	eml__VolumeFlowRatePerVolumeFlowRateUom__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 4,
	eml__VolumeFlowRatePerVolumeFlowRateUom__Euc = 5
};
#endif

/* resqml2_0_1ForGsoap.h:7857 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalUom (689)
/* eml:FrequencyIntervalUom */
enum eml__FrequencyIntervalUom
{
	eml__FrequencyIntervalUom__O = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7868 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalUom (690)
/* eml:TemperatureIntervalUom */
enum eml__TemperatureIntervalUom
{
	eml__TemperatureIntervalUom__deltaC = 0,
	eml__TemperatureIntervalUom__deltaF = 1,
	eml__TemperatureIntervalUom__deltaK = 2,
	eml__TemperatureIntervalUom__deltaR = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7891 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityUom (691)
/* eml:RadiantIntensityUom */
enum eml__RadiantIntensityUom
{
	eml__RadiantIntensityUom__W_x002fsr = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7902 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthUom (692)
/* eml:PermeabilityLengthUom */
enum eml__PermeabilityLengthUom
{
	eml__PermeabilityLengthUom__D_x002eft = 0,
	eml__PermeabilityLengthUom__D_x002em = 1,
	eml__PermeabilityLengthUom__mD_x002eft = 2,
	eml__PermeabilityLengthUom__mD_x002em = 3,
	eml__PermeabilityLengthUom__TD_x005bAPI_x005d_x002em = 4
};
#endif

/* resqml2_0_1ForGsoap.h:7929 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedUom (693)
/* eml:DataTransferSpeedUom */
enum eml__DataTransferSpeedUom
{
	eml__DataTransferSpeedUom__bit_x002fs = 0,
	eml__DataTransferSpeedUom__byte_x002fs = 1
};
#endif

/* resqml2_0_1ForGsoap.h:7944 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceUom (694)
/* eml:InductanceUom */
enum eml__InductanceUom
{
	eml__InductanceUom__cH = 0,
	eml__InductanceUom__dH = 1,
	eml__InductanceUom__EH = 2,
	eml__InductanceUom__fH = 3,
	eml__InductanceUom__GH = 4,
	eml__InductanceUom__H = 5,
	eml__InductanceUom__kH = 6,
	eml__InductanceUom__MH = 7,
	eml__InductanceUom__mH = 8,
	eml__InductanceUom__nH = 9,
	eml__InductanceUom__TH = 10,
	eml__InductanceUom__uH = 11
};
#endif

/* resqml2_0_1ForGsoap.h:7999 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityUom (695)
/* eml:KinematicViscosityUom */
enum eml__KinematicViscosityUom
{
	eml__KinematicViscosityUom__cm2_x002fs = 0,
	eml__KinematicViscosityUom__cSt = 1,
	eml__KinematicViscosityUom__ft2_x002fh = 2,
	eml__KinematicViscosityUom__ft2_x002fs = 3,
	eml__KinematicViscosityUom__in2_x002fs = 4,
	eml__KinematicViscosityUom__m2_x002fh = 5,
	eml__KinematicViscosityUom__m2_x002fs = 6,
	eml__KinematicViscosityUom__mm2_x002fs = 7,
	eml__KinematicViscosityUom__Pa_x002es_x002em3_x002fkg = 8,
	eml__KinematicViscosityUom__St = 9
};
#endif

/* resqml2_0_1ForGsoap.h:8046 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthUom (696)
/* eml:VolumePerTimePerPressureLengthUom */
enum eml__VolumePerTimePerPressureLengthUom
{
	eml__VolumePerTimePerPressureLengthUom__bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 0,
	eml__VolumePerTimePerPressureLengthUom__ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 1,
	eml__VolumePerTimePerPressureLengthUom__m2_x002f_x0028kPa_x002ed_x0029 = 2,
	eml__VolumePerTimePerPressureLengthUom__m2_x002f_x0028Pa_x002es_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:8069 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceUom (697)
/* eml:ReciprocalForceUom */
enum eml__ReciprocalForceUom
{
	eml__ReciprocalForceUom__1_x002flbf = 0,
	eml__ReciprocalForceUom__1_x002fN = 1
};
#endif

/* resqml2_0_1ForGsoap.h:8084 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaUom (698)
/* eml:ReciprocalAreaUom */
enum eml__ReciprocalAreaUom
{
	eml__ReciprocalAreaUom__1_x002fft2 = 0,
	eml__ReciprocalAreaUom__1_x002fkm2 = 1,
	eml__ReciprocalAreaUom__1_x002fm2 = 2,
	eml__ReciprocalAreaUom__1_x002fmi2 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:8107 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeUom (699)
/* eml:PressurePerTimeUom */
enum eml__PressurePerTimeUom
{
	eml__PressurePerTimeUom__atm_x002fh = 0,
	eml__PressurePerTimeUom__bar_x002fh = 1,
	eml__PressurePerTimeUom__kPa_x002fh = 2,
	eml__PressurePerTimeUom__kPa_x002fmin = 3,
	eml__PressurePerTimeUom__MPa_x002fh = 4,
	eml__PressurePerTimeUom__Pa_x002fh = 5,
	eml__PressurePerTimeUom__Pa_x002fs = 6,
	eml__PressurePerTimeUom__psi_x002fh = 7,
	eml__PressurePerTimeUom__psi_x002fmin = 8
};
#endif

/* resqml2_0_1ForGsoap.h:8150 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeUom (700)
/* eml:ElectricChargeUom */
enum eml__ElectricChargeUom
{
	eml__ElectricChargeUom__A_x002eh = 0,
	eml__ElectricChargeUom__A_x002es = 1,
	eml__ElectricChargeUom__C = 2,
	eml__ElectricChargeUom__cC = 3,
	eml__ElectricChargeUom__dC = 4,
	eml__ElectricChargeUom__EC = 5,
	eml__ElectricChargeUom__fC = 6,
	eml__ElectricChargeUom__GC = 7,
	eml__ElectricChargeUom__kC = 8,
	eml__ElectricChargeUom__MC = 9,
	eml__ElectricChargeUom__mC = 10,
	eml__ElectricChargeUom__nC = 11,
	eml__ElectricChargeUom__pC = 12,
	eml__ElectricChargeUom__TC = 13,
	eml__ElectricChargeUom__uC = 14
};
#endif

/* resqml2_0_1ForGsoap.h:8217 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyUom (701)
/* eml:LuminousEfficacyUom */
enum eml__LuminousEfficacyUom
{
	eml__LuminousEfficacyUom__lm_x002fW = 0
};
#endif

/* resqml2_0_1ForGsoap.h:8228 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerUom (702)
/* eml:PowerUom */
enum eml__PowerUom
{
	eml__PowerUom__cW = 0,
	eml__PowerUom__dW = 1,
	eml__PowerUom__EW = 2,
	eml__PowerUom__fW = 3,
	eml__PowerUom__GW = 4,
	eml__PowerUom__hp = 5,
	eml__PowerUom__hp_x005belec_x005d = 6,
	eml__PowerUom__hp_x005bhyd_x005d = 7,
	eml__PowerUom__hp_x005bmetric_x005d = 8,
	eml__PowerUom__kW = 9,
	eml__PowerUom__MW = 10,
	eml__PowerUom__mW = 11,
	eml__PowerUom__nW = 12,
	eml__PowerUom__pW = 13,
	eml__PowerUom__tonRefrig = 14,
	eml__PowerUom__TW = 15,
	eml__PowerUom__uW = 16,
	eml__PowerUom__W = 17
};
#endif

/* resqml2_0_1ForGsoap.h:8307 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeUom (703)
/* eml:PressurePerVolumeUom */
enum eml__PressurePerVolumeUom
{
	eml__PressurePerVolumeUom__Pa_x002fm3 = 0,
	eml__PressurePerVolumeUom__psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:8322 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityUom (704)
/* eml:ActivityOfRadioactivityUom */
enum eml__ActivityOfRadioactivityUom
{
	eml__ActivityOfRadioactivityUom__Bq = 0,
	eml__ActivityOfRadioactivityUom__Ci = 1,
	eml__ActivityOfRadioactivityUom__GBq = 2,
	eml__ActivityOfRadioactivityUom__MBq = 3,
	eml__ActivityOfRadioactivityUom__mCi = 4,
	eml__ActivityOfRadioactivityUom__nCi = 5,
	eml__ActivityOfRadioactivityUom__pCi = 6,
	eml__ActivityOfRadioactivityUom__TBq = 7,
	eml__ActivityOfRadioactivityUom__uCi = 8
};
#endif

/* resqml2_0_1ForGsoap.h:8365 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceUom (705)
/* eml:ElectricPotentialDifferenceUom */
enum eml__ElectricPotentialDifferenceUom
{
	eml__ElectricPotentialDifferenceUom__cV = 0,
	eml__ElectricPotentialDifferenceUom__dV = 1,
	eml__ElectricPotentialDifferenceUom__fV = 2,
	eml__ElectricPotentialDifferenceUom__GV = 3,
	eml__ElectricPotentialDifferenceUom__kV = 4,
	eml__ElectricPotentialDifferenceUom__mV = 5,
	eml__ElectricPotentialDifferenceUom__MV = 6,
	eml__ElectricPotentialDifferenceUom__nV = 7,
	eml__ElectricPotentialDifferenceUom__pV = 8,
	eml__ElectricPotentialDifferenceUom__TV = 9,
	eml__ElectricPotentialDifferenceUom__uV = 10,
	eml__ElectricPotentialDifferenceUom__V = 11
};
#endif

/* resqml2_0_1ForGsoap.h:8420 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureUom (706)
/* eml:LengthPerPressureUom */
enum eml__LengthPerPressureUom
{
	eml__LengthPerPressureUom__ft_x002fpsi = 0,
	eml__LengthPerPressureUom__m_x002fkPa = 1,
	eml__LengthPerPressureUom__m_x002fPa = 2
};
#endif

/* resqml2_0_1ForGsoap.h:8439 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialUom (707)
/* eml:MagneticVectorPotentialUom */
enum eml__MagneticVectorPotentialUom
{
	eml__MagneticVectorPotentialUom__Wb_x002fm = 0,
	eml__MagneticVectorPotentialUom__Wb_x002fmm = 1
};
#endif

/* resqml2_0_1ForGsoap.h:8454 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthUom (708)
/* eml:MagneticFieldStrengthUom */
enum eml__MagneticFieldStrengthUom
{
	eml__MagneticFieldStrengthUom__A_x002fm = 0,
	eml__MagneticFieldStrengthUom__A_x002fmm = 1,
	eml__MagneticFieldStrengthUom__Oe = 2
};
#endif

/* resqml2_0_1ForGsoap.h:8473 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeUom (709)
/* eml:VolumePerTimeUom */
enum eml__VolumePerTimeUom
{
	eml__VolumePerTimeUom__1_x002f30_x0020cm3_x002fmin = 0,
	eml__VolumePerTimeUom__1000_x0020bbl_x002fd = 1,
	eml__VolumePerTimeUom__1000_x0020ft3_x002fd = 2,
	eml__VolumePerTimeUom__1000_x0020m3_x002fd = 3,
	eml__VolumePerTimeUom__1000_x0020m3_x002fh = 4,
	eml__VolumePerTimeUom__1E6_x0020bbl_x002fd = 5,
	eml__VolumePerTimeUom__1E6_x0020ft3_x002fd = 6,
	eml__VolumePerTimeUom__1E6_x0020m3_x002fd = 7,
	eml__VolumePerTimeUom__bbl_x002fd = 8,
	eml__VolumePerTimeUom__bbl_x002fh = 9,
	eml__VolumePerTimeUom__bbl_x002fmin = 10,
	eml__VolumePerTimeUom__cm3_x002fh = 11,
	eml__VolumePerTimeUom__cm3_x002fmin = 12,
	eml__VolumePerTimeUom__cm3_x002fs = 13,
	eml__VolumePerTimeUom__dm3_x002fs = 14,
	eml__VolumePerTimeUom__ft3_x002fd = 15,
	eml__VolumePerTimeUom__ft3_x002fh = 16,
	eml__VolumePerTimeUom__ft3_x002fmin = 17,
	eml__VolumePerTimeUom__ft3_x002fs = 18,
	eml__VolumePerTimeUom__gal_x005bUK_x005d_x002fd = 19,
	eml__VolumePerTimeUom__gal_x005bUK_x005d_x002fh = 20,
	eml__VolumePerTimeUom__gal_x005bUK_x005d_x002fmin = 21,
	eml__VolumePerTimeUom__gal_x005bUS_x005d_x002fd = 22,
	eml__VolumePerTimeUom__gal_x005bUS_x005d_x002fh = 23,
	eml__VolumePerTimeUom__gal_x005bUS_x005d_x002fmin = 24,
	eml__VolumePerTimeUom__L_x002fh = 25,
	eml__VolumePerTimeUom__L_x002fmin = 26,
	eml__VolumePerTimeUom__L_x002fs = 27,
	eml__VolumePerTimeUom__m3_x002fd = 28,
	eml__VolumePerTimeUom__m3_x002fh = 29,
	eml__VolumePerTimeUom__m3_x002fmin = 30,
	eml__VolumePerTimeUom__m3_x002fs = 31
};
#endif

/* resqml2_0_1ForGsoap.h:8608 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthUom (710)
/* eml:LengthUom */
enum eml__LengthUom
{
	eml__LengthUom__0_x002e1_x0020ft = 0,
	eml__LengthUom__0_x002e1_x0020ft_x005bUS_x005d = 1,
	eml__LengthUom__0_x002e1_x0020in = 2,
	eml__LengthUom__0_x002e1_x0020yd = 3,
	eml__LengthUom__1_x002f16_x0020in = 4,
	eml__LengthUom__1_x002f2_x0020ft = 5,
	eml__LengthUom__1_x002f32_x0020in = 6,
	eml__LengthUom__1_x002f64_x0020in = 7,
	eml__LengthUom__10_x0020ft = 8,
	eml__LengthUom__10_x0020in = 9,
	eml__LengthUom__10_x0020km = 10,
	eml__LengthUom__100_x0020ft = 11,
	eml__LengthUom__100_x0020km = 12,
	eml__LengthUom__1000_x0020ft = 13,
	eml__LengthUom__30_x0020ft = 14,
	eml__LengthUom__30_x0020m = 15,
	eml__LengthUom__angstrom = 16,
	eml__LengthUom__chain = 17,
	eml__LengthUom__chain_x005bBnA_x005d = 18,
	eml__LengthUom__chain_x005bBnB_x005d = 19,
	eml__LengthUom__chain_x005bCla_x005d = 20,
	eml__LengthUom__chain_x005bInd37_x005d = 21,
	eml__LengthUom__chain_x005bSe_x005d = 22,
	eml__LengthUom__chain_x005bSeT_x005d = 23,
	eml__LengthUom__chain_x005bUS_x005d = 24,
	eml__LengthUom__cm = 25,
	eml__LengthUom__dam = 26,
	eml__LengthUom__dm = 27,
	eml__LengthUom__Em = 28,
	eml__LengthUom__fathom = 29,
	eml__LengthUom__fm = 30,
	eml__LengthUom__ft = 31,
	eml__LengthUom__ft_x005bBnA_x005d = 32,
	eml__LengthUom__ft_x005bBnB_x005d = 33,
	eml__LengthUom__ft_x005bBr36_x005d = 34,
	eml__LengthUom__ft_x005bBr65_x005d = 35,
	eml__LengthUom__ft_x005bCla_x005d = 36,
	eml__LengthUom__ft_x005bGC_x005d = 37,
	eml__LengthUom__ft_x005bInd_x005d = 38,
	eml__LengthUom__ft_x005bInd37_x005d = 39,
	eml__LengthUom__ft_x005bInd62_x005d = 40,
	eml__LengthUom__ft_x005bInd75_x005d = 41,
	eml__LengthUom__ft_x005bSe_x005d = 42,
	eml__LengthUom__ft_x005bSeT_x005d = 43,
	eml__LengthUom__ft_x005bUS_x005d = 44,
	eml__LengthUom__fur_x005bUS_x005d = 45,
	eml__LengthUom__Gm = 46,
	eml__LengthUom__hm = 47,
	eml__LengthUom__in = 48,
	eml__LengthUom__in_x005bUS_x005d = 49,
	eml__LengthUom__km = 50,
	eml__LengthUom__link = 51,
	eml__LengthUom__link_x005bBnA_x005d = 52,
	eml__LengthUom__link_x005bBnB_x005d = 53,
	eml__LengthUom__link_x005bCla_x005d = 54,
	eml__LengthUom__link_x005bSe_x005d = 55,
	eml__LengthUom__link_x005bSeT_x005d = 56,
	eml__LengthUom__link_x005bUS_x005d = 57,
	eml__LengthUom__m = 58,
	eml__LengthUom__m_x005bGer_x005d = 59,
	eml__LengthUom__mi = 60,
	eml__LengthUom__mi_x005bnaut_x005d = 61,
	eml__LengthUom__mi_x005bnautUK_x005d = 62,
	eml__LengthUom__mi_x005bUS_x005d = 63,
	eml__LengthUom__mil = 64,
	eml__LengthUom__Mm = 65,
	eml__LengthUom__mm = 66,
	eml__LengthUom__nm = 67,
	eml__LengthUom__pm = 68,
	eml__LengthUom__rod_x005bUS_x005d = 69,
	eml__LengthUom__Tm = 70,
	eml__LengthUom__um = 71,
	eml__LengthUom__yd = 72,
	eml__LengthUom__yd_x005bBnA_x005d = 73,
	eml__LengthUom__yd_x005bBnB_x005d = 74,
	eml__LengthUom__yd_x005bCla_x005d = 75,
	eml__LengthUom__yd_x005bInd_x005d = 76,
	eml__LengthUom__yd_x005bInd37_x005d = 77,
	eml__LengthUom__yd_x005bInd62_x005d = 78,
	eml__LengthUom__yd_x005bInd75_x005d = 79,
	eml__LengthUom__yd_x005bSe_x005d = 80,
	eml__LengthUom__yd_x005bSeT_x005d = 81,
	eml__LengthUom__yd_x005bUS_x005d = 82
};
#endif

/* resqml2_0_1ForGsoap.h:8947 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassUom (711)
/* eml:AreaPerMassUom */
enum eml__AreaPerMassUom
{
	eml__AreaPerMassUom__cm2_x002fg = 0,
	eml__AreaPerMassUom__ft2_x002flbm = 1,
	eml__AreaPerMassUom__m2_x002fg = 2,
	eml__AreaPerMassUom__m2_x002fkg = 3
};
#endif

/* resqml2_0_1ForGsoap.h:8970 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceUom (712)
/* eml:ThermalResistanceUom */
enum eml__ThermalResistanceUom
{
	eml__ThermalResistanceUom__deltaK_x002fW = 0
};
#endif

/* resqml2_0_1ForGsoap.h:8981 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceUom (713)
/* eml:ForcePerForceUom */
enum eml__ForcePerForceUom
{
	eml__ForcePerForceUom___x0025 = 0,
	eml__ForcePerForceUom__Euc = 1,
	eml__ForcePerForceUom__kgf_x002fkgf = 2,
	eml__ForcePerForceUom__lbf_x002flbf = 3,
	eml__ForcePerForceUom__N_x002fN = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9008 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassUom (714)
/* eml:MassUom */
enum eml__MassUom
{
	eml__MassUom__ag = 0,
	eml__MassUom__cg = 1,
	eml__MassUom__ct = 2,
	eml__MassUom__cwt_x005bUK_x005d = 3,
	eml__MassUom__cwt_x005bUS_x005d = 4,
	eml__MassUom__Eg = 5,
	eml__MassUom__fg = 6,
	eml__MassUom__g = 7,
	eml__MassUom__Gg = 8,
	eml__MassUom__grain = 9,
	eml__MassUom__hg = 10,
	eml__MassUom__kg = 11,
	eml__MassUom__klbm = 12,
	eml__MassUom__lbm = 13,
	eml__MassUom__mg = 14,
	eml__MassUom__Mg = 15,
	eml__MassUom__ng = 16,
	eml__MassUom__ozm = 17,
	eml__MassUom__ozm_x005btroy_x005d = 18,
	eml__MassUom__pg = 19,
	eml__MassUom__sack_x005b94lbm_x005d = 20,
	eml__MassUom__t = 21,
	eml__MassUom__Tg = 22,
	eml__MassUom__ton_x005bUK_x005d = 23,
	eml__MassUom__ton_x005bUS_x005d = 24,
	eml__MassUom__ug = 25
};
#endif

/* resqml2_0_1ForGsoap.h:9119 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityUom (715)
/* eml:SpecificHeatCapacityUom */
enum eml__SpecificHeatCapacityUom
{
	eml__SpecificHeatCapacityUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaF_x0029 = 0,
	eml__SpecificHeatCapacityUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaR_x0029 = 1,
	eml__SpecificHeatCapacityUom__cal_x005bth_x005d_x002f_x0028g_x002edeltaK_x0029 = 2,
	eml__SpecificHeatCapacityUom__J_x002f_x0028g_x002edeltaK_x0029 = 3,
	eml__SpecificHeatCapacityUom__J_x002f_x0028kg_x002edeltaK_x0029 = 4,
	eml__SpecificHeatCapacityUom__kcal_x005bth_x005d_x002f_x0028kg_x002edeltaC_x0029 = 5,
	eml__SpecificHeatCapacityUom__kJ_x002f_x0028kg_x002edeltaK_x0029 = 6,
	eml__SpecificHeatCapacityUom__kW_x002eh_x002f_x0028kg_x002edeltaC_x0029 = 7
};
#endif

/* resqml2_0_1ForGsoap.h:9158 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassUom (716)
/* eml:LengthPerMassUom */
enum eml__LengthPerMassUom
{
	eml__LengthPerMassUom__ft_x002flbm = 0,
	eml__LengthPerMassUom__m_x002fkg = 1
};
#endif

/* resqml2_0_1ForGsoap.h:9173 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaUom (717)
/* eml:AmountOfSubstancePerTimePerAreaUom */
enum eml__AmountOfSubstancePerTimePerAreaUom
{
	eml__AmountOfSubstancePerTimePerAreaUom__lbmol_x002f_x0028h_x002eft2_x0029 = 0,
	eml__AmountOfSubstancePerTimePerAreaUom__lbmol_x002f_x0028s_x002eft2_x0029 = 1,
	eml__AmountOfSubstancePerTimePerAreaUom__mol_x002f_x0028s_x002em2_x0029 = 2
};
#endif

/* resqml2_0_1ForGsoap.h:9192 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureUom (718)
/* eml:ThermodynamicTemperatureUom */
enum eml__ThermodynamicTemperatureUom
{
	eml__ThermodynamicTemperatureUom__degC = 0,
	eml__ThermodynamicTemperatureUom__degF = 1,
	eml__ThermodynamicTemperatureUom__degR = 2,
	eml__ThermodynamicTemperatureUom__K = 3
};
#endif

/* resqml2_0_1ForGsoap.h:9215 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionUom (719)
/* eml:LinearThermalExpansionUom */
enum eml__LinearThermalExpansionUom
{
	eml__LinearThermalExpansionUom__1_x002fdeltaK = 0,
	eml__LinearThermalExpansionUom__in_x002f_x0028in_x002edeltaF_x0029 = 1,
	eml__LinearThermalExpansionUom__m_x002f_x0028m_x002edeltaK_x0029 = 2,
	eml__LinearThermalExpansionUom__mm_x002f_x0028mm_x002edeltaK_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:9238 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthUom (720)
/* eml:MassPerLengthUom */
enum eml__MassPerLengthUom
{
	eml__MassPerLengthUom__kg_x002em_x002fcm2 = 0,
	eml__MassPerLengthUom__kg_x002fm = 1,
	eml__MassPerLengthUom__klbm_x002fin = 2,
	eml__MassPerLengthUom__lbm_x002fft = 3,
	eml__MassPerLengthUom__Mg_x002fin = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9265 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityUom (721)
/* eml:ElectricalResistivityUom */
enum eml__ElectricalResistivityUom
{
	eml__ElectricalResistivityUom__kohm_x002em = 0,
	eml__ElectricalResistivityUom__nohm_x002emil2_x002fft = 1,
	eml__ElectricalResistivityUom__nohm_x002emm2_x002fm = 2,
	eml__ElectricalResistivityUom__ohm_x002ecm = 3,
	eml__ElectricalResistivityUom__ohm_x002em = 4,
	eml__ElectricalResistivityUom__ohm_x002em2_x002fm = 5
};
#endif

/* resqml2_0_1ForGsoap.h:9296 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassUom (722)
/* eml:MassPerMassUom */
enum eml__MassPerMassUom
{
	eml__MassPerMassUom___x0025 = 0,
	eml__MassPerMassUom___x0025_x005bmass_x005d = 1,
	eml__MassPerMassUom__Euc = 2,
	eml__MassPerMassUom__g_x002fkg = 3,
	eml__MassPerMassUom__g_x002ft = 4,
	eml__MassPerMassUom__kg_x002fkg = 5,
	eml__MassPerMassUom__kg_x002fsack_x005b94lbm_x005d = 6,
	eml__MassPerMassUom__kg_x002ft = 7,
	eml__MassPerMassUom__mg_x002fg = 8,
	eml__MassPerMassUom__mg_x002fkg = 9,
	eml__MassPerMassUom__ng_x002fg = 10,
	eml__MassPerMassUom__ng_x002fmg = 11,
	eml__MassPerMassUom__ppk = 12,
	eml__MassPerMassUom__ppm = 13,
	eml__MassPerMassUom__ppm_x005bmass_x005d = 14,
	eml__MassPerMassUom__ug_x002fg = 15,
	eml__MassPerMassUom__ug_x002fmg = 16
};
#endif

/* resqml2_0_1ForGsoap.h:9371 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaUom (723)
/* eml:PressureSquaredPerForceTimePerAreaUom */
enum eml__PressureSquaredPerForceTimePerAreaUom
{
	eml__PressureSquaredPerForceTimePerAreaUom__0_x002e001_x0020kPa2_x002fcP = 0,
	eml__PressureSquaredPerForceTimePerAreaUom__bar2_x002fcP = 1,
	eml__PressureSquaredPerForceTimePerAreaUom__kPa2_x002fcP = 2,
	eml__PressureSquaredPerForceTimePerAreaUom__Pa2_x002f_x0028Pa_x002es_x0029 = 3,
	eml__PressureSquaredPerForceTimePerAreaUom__psi2_x002fcP = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9398 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxUom (724)
/* eml:LuminousFluxUom */
enum eml__LuminousFluxUom
{
	eml__LuminousFluxUom__lm = 0
};
#endif

/* resqml2_0_1ForGsoap.h:9409 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureUom (725)
/* eml:VolumePerTimePerPressureUom */
enum eml__VolumePerTimePerPressureUom
{
	eml__VolumePerTimePerPressureUom__1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 0,
	eml__VolumePerTimePerPressureUom__bbl_x002f_x0028kPa_x002ed_x0029 = 1,
	eml__VolumePerTimePerPressureUom__bbl_x002f_x0028psi_x002ed_x0029 = 2,
	eml__VolumePerTimePerPressureUom__L_x002f_x0028bar_x002emin_x0029 = 3,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028bar_x002ed_x0029 = 4,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028bar_x002eh_x0029 = 5,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028bar_x002emin_x0029 = 6,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028kPa_x002ed_x0029 = 7,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028kPa_x002eh_x0029 = 8,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028Pa_x002es_x0029 = 9,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028psi_x002ed_x0029 = 10
};
#endif

/* resqml2_0_1ForGsoap.h:9460 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeUom (726)
/* eml:AmountOfSubstancePerVolumeUom */
enum eml__AmountOfSubstancePerVolumeUom
{
	eml__AmountOfSubstancePerVolumeUom__kmol_x002fm3 = 0,
	eml__AmountOfSubstancePerVolumeUom__lbmol_x002fft3 = 1,
	eml__AmountOfSubstancePerVolumeUom__lbmol_x002fgal_x005bUK_x005d = 2,
	eml__AmountOfSubstancePerVolumeUom__lbmol_x002fgal_x005bUS_x005d = 3,
	eml__AmountOfSubstancePerVolumeUom__mol_x002fm3 = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9487 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassUom (727)
/* eml:EnergyPerMassUom */
enum eml__EnergyPerMassUom
{
	eml__EnergyPerMassUom__Btu_x005bIT_x005d_x002flbm = 0,
	eml__EnergyPerMassUom__cal_x005bth_x005d_x002fg = 1,
	eml__EnergyPerMassUom__cal_x005bth_x005d_x002fkg = 2,
	eml__EnergyPerMassUom__cal_x005bth_x005d_x002flbm = 3,
	eml__EnergyPerMassUom__erg_x002fg = 4,
	eml__EnergyPerMassUom__erg_x002fkg = 5,
	eml__EnergyPerMassUom__hp_x002eh_x002flbm = 6,
	eml__EnergyPerMassUom__J_x002fg = 7,
	eml__EnergyPerMassUom__J_x002fkg = 8,
	eml__EnergyPerMassUom__kcal_x005bth_x005d_x002fg = 9,
	eml__EnergyPerMassUom__kcal_x005bth_x005d_x002fkg = 10,
	eml__EnergyPerMassUom__kJ_x002fkg = 11,
	eml__EnergyPerMassUom__kW_x002eh_x002fkg = 12,
	eml__EnergyPerMassUom__lbf_x002eft_x002flbm = 13,
	eml__EnergyPerMassUom__MJ_x002fkg = 14,
	eml__EnergyPerMassUom__MW_x002eh_x002fkg = 15
};
#endif

/* resqml2_0_1ForGsoap.h:9558 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityUom (728)
/* eml:PermittivityUom */
enum eml__PermittivityUom
{
	eml__PermittivityUom__F_x002fm = 0,
	eml__PermittivityUom__uF_x002fm = 1
};
#endif

/* resqml2_0_1ForGsoap.h:9573 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentUom (729)
/* eml:ElectromagneticMomentUom */
enum eml__ElectromagneticMomentUom
{
	eml__ElectromagneticMomentUom__A_x002em2 = 0
};
#endif

/* resqml2_0_1ForGsoap.h:9584 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceUom (730)
/* eml:ThermalInsulanceUom */
enum eml__ThermalInsulanceUom
{
	eml__ThermalInsulanceUom__deltaC_x002em2_x002eh_x002fkcal_x005bth_x005d = 0,
	eml__ThermalInsulanceUom__deltaF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 1,
	eml__ThermalInsulanceUom__deltaK_x002em2_x002fkW = 2,
	eml__ThermalInsulanceUom__deltaK_x002em2_x002fW = 3
};
#endif

/* resqml2_0_1ForGsoap.h:9607 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaUom (731)
/* eml:PowerPerAreaUom */
enum eml__PowerPerAreaUom
{
	eml__PowerPerAreaUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 0,
	eml__PowerPerAreaUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 1,
	eml__PowerPerAreaUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 2,
	eml__PowerPerAreaUom__hp_x002fin2 = 3,
	eml__PowerPerAreaUom__hp_x005bhyd_x005d_x002fin2 = 4,
	eml__PowerPerAreaUom__kW_x002fcm2 = 5,
	eml__PowerPerAreaUom__kW_x002fm2 = 6,
	eml__PowerPerAreaUom__mW_x002fm2 = 7,
	eml__PowerPerAreaUom__ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 8,
	eml__PowerPerAreaUom__W_x002fcm2 = 9,
	eml__PowerPerAreaUom__W_x002fm2 = 10,
	eml__PowerPerAreaUom__W_x002fmm2 = 11
};
#endif

/* resqml2_0_1ForGsoap.h:9662 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaUom (732)
/* eml:MassPerAreaUom */
enum eml__MassPerAreaUom
{
	eml__MassPerAreaUom__0_x002e01_x0020lbm_x002fft2 = 0,
	eml__MassPerAreaUom__kg_x002fm2 = 1,
	eml__MassPerAreaUom__lbm_x002fft2 = 2,
	eml__MassPerAreaUom__Mg_x002fm2 = 3,
	eml__MassPerAreaUom__ton_x005bUS_x005d_x002fft2 = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9689 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceUom (733)
/* eml:IlluminanceUom */
enum eml__IlluminanceUom
{
	eml__IlluminanceUom__footcandle = 0,
	eml__IlluminanceUom__klx = 1,
	eml__IlluminanceUom__lm_x002fm2 = 2,
	eml__IlluminanceUom__lx = 3
};
#endif

/* resqml2_0_1ForGsoap.h:9712 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeUom (734)
/* eml:AreaPerVolumeUom */
enum eml__AreaPerVolumeUom
{
	eml__AreaPerVolumeUom__1_x002fm = 0,
	eml__AreaPerVolumeUom__b_x002fcm3 = 1,
	eml__AreaPerVolumeUom__cu = 2,
	eml__AreaPerVolumeUom__ft2_x002fin3 = 3,
	eml__AreaPerVolumeUom__m2_x002fcm3 = 4,
	eml__AreaPerVolumeUom__m2_x002fm3 = 5
};
#endif

/* resqml2_0_1ForGsoap.h:9743 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeUom (735)
/* eml:TemperatureIntervalPerTimeUom */
enum eml__TemperatureIntervalPerTimeUom
{
	eml__TemperatureIntervalPerTimeUom__deltaC_x002fh = 0,
	eml__TemperatureIntervalPerTimeUom__deltaC_x002fmin = 1,
	eml__TemperatureIntervalPerTimeUom__deltaC_x002fs = 2,
	eml__TemperatureIntervalPerTimeUom__deltaF_x002fh = 3,
	eml__TemperatureIntervalPerTimeUom__deltaF_x002fmin = 4,
	eml__TemperatureIntervalPerTimeUom__deltaF_x002fs = 5,
	eml__TemperatureIntervalPerTimeUom__deltaK_x002fs = 6
};
#endif

/* resqml2_0_1ForGsoap.h:9778 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceUom (736)
/* eml:AmountOfSubstancePerAmountOfSubstanceUom */
enum eml__AmountOfSubstancePerAmountOfSubstanceUom
{
	eml__AmountOfSubstancePerAmountOfSubstanceUom___x0025 = 0,
	eml__AmountOfSubstancePerAmountOfSubstanceUom___x0025_x005bmolar_x005d = 1,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__Euc = 2,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__mol_x002fmol = 3,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__nEuc = 4,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__ppk = 5,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__ppm = 6
};
#endif

/* resqml2_0_1ForGsoap.h:9813 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceUom (737)
/* eml:RadianceUom */
enum eml__RadianceUom
{
	eml__RadianceUom__W_x002f_x0028m2_x002esr_x0029 = 0
};
#endif

/* resqml2_0_1ForGsoap.h:9824 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateUom (738)
/* eml:HeatFlowRateUom */
enum eml__HeatFlowRateUom
{
	eml__HeatFlowRateUom__1E6_x0020Btu_x005bIT_x005d_x002fh = 0,
	eml__HeatFlowRateUom__Btu_x005bIT_x005d_x002fh = 1,
	eml__HeatFlowRateUom__Btu_x005bIT_x005d_x002fmin = 2,
	eml__HeatFlowRateUom__Btu_x005bIT_x005d_x002fs = 3,
	eml__HeatFlowRateUom__cal_x005bth_x005d_x002fh = 4,
	eml__HeatFlowRateUom__EJ_x002fa = 5,
	eml__HeatFlowRateUom__erg_x002fa = 6,
	eml__HeatFlowRateUom__GW = 7,
	eml__HeatFlowRateUom__J_x002fs = 8,
	eml__HeatFlowRateUom__kcal_x005bth_x005d_x002fh = 9,
	eml__HeatFlowRateUom__kW = 10,
	eml__HeatFlowRateUom__lbf_x002eft_x002fmin = 11,
	eml__HeatFlowRateUom__lbf_x002eft_x002fs = 12,
	eml__HeatFlowRateUom__MJ_x002fa = 13,
	eml__HeatFlowRateUom__MW = 14,
	eml__HeatFlowRateUom__mW = 15,
	eml__HeatFlowRateUom__nW = 16,
	eml__HeatFlowRateUom__quad_x002fa = 17,
	eml__HeatFlowRateUom__TJ_x002fa = 18,
	eml__HeatFlowRateUom__TW = 19,
	eml__HeatFlowRateUom__ucal_x005bth_x005d_x002fs = 20,
	eml__HeatFlowRateUom__uW = 21,
	eml__HeatFlowRateUom__W = 22
};
#endif

/* resqml2_0_1ForGsoap.h:9923 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentUom (739)
/* eml:DoseEquivalentUom */
enum eml__DoseEquivalentUom
{
	eml__DoseEquivalentUom__mrem = 0,
	eml__DoseEquivalentUom__mSv = 1,
	eml__DoseEquivalentUom__rem = 2,
	eml__DoseEquivalentUom__Sv = 3
};
#endif

/* resqml2_0_1ForGsoap.h:9946 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerUom (740)
/* eml:PowerPerPowerUom */
enum eml__PowerPerPowerUom
{
	eml__PowerPerPowerUom___x0025 = 0,
	eml__PowerPerPowerUom__Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 1,
	eml__PowerPerPowerUom__Euc = 2,
	eml__PowerPerPowerUom__W_x002fkW = 3,
	eml__PowerPerPowerUom__W_x002fW = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9973 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassUom (741)
/* eml:ElectricChargePerMassUom */
enum eml__ElectricChargePerMassUom
{
	eml__ElectricChargePerMassUom__A_x002es_x002fkg = 0,
	eml__ElectricChargePerMassUom__C_x002fg = 1,
	eml__ElectricChargePerMassUom__C_x002fkg = 2
};
#endif

/* resqml2_0_1ForGsoap.h:9992 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthUom (742)
/* eml:MassPerVolumePerLengthUom */
enum eml__MassPerVolumePerLengthUom
{
	eml__MassPerVolumePerLengthUom__g_x002fcm4 = 0,
	eml__MassPerVolumePerLengthUom__kg_x002fdm4 = 1,
	eml__MassPerVolumePerLengthUom__kg_x002fm4 = 2,
	eml__MassPerVolumePerLengthUom__lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 3,
	eml__MassPerVolumePerLengthUom__lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 4,
	eml__MassPerVolumePerLengthUom__lbm_x002fft4 = 5,
	eml__MassPerVolumePerLengthUom__Pa_x002es2_x002fm3 = 6
};
#endif

/* resqml2_0_1ForGsoap.h:10027 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthUom (743)
/* eml:MassLengthUom */
enum eml__MassLengthUom
{
	eml__MassLengthUom__kg_x002em = 0,
	eml__MassLengthUom__lbm_x002eft = 1
};
#endif

/* resqml2_0_1ForGsoap.h:10042 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeUom (744)
/* eml:ForcePerVolumeUom */
enum eml__ForcePerVolumeUom
{
	eml__ForcePerVolumeUom__0_x002e001_x0020psi_x002fft = 0,
	eml__ForcePerVolumeUom__0_x002e01_x0020psi_x002fft = 1,
	eml__ForcePerVolumeUom__atm_x002fft = 2,
	eml__ForcePerVolumeUom__atm_x002fhm = 3,
	eml__ForcePerVolumeUom__atm_x002fm = 4,
	eml__ForcePerVolumeUom__bar_x002fkm = 5,
	eml__ForcePerVolumeUom__bar_x002fm = 6,
	eml__ForcePerVolumeUom__GPa_x002fcm = 7,
	eml__ForcePerVolumeUom__kPa_x002fhm = 8,
	eml__ForcePerVolumeUom__kPa_x002fm = 9,
	eml__ForcePerVolumeUom__lbf_x002fft3 = 10,
	eml__ForcePerVolumeUom__lbf_x002fgal_x005bUS_x005d = 11,
	eml__ForcePerVolumeUom__MPa_x002fm = 12,
	eml__ForcePerVolumeUom__N_x002fm3 = 13,
	eml__ForcePerVolumeUom__Pa_x002fm = 14,
	eml__ForcePerVolumeUom__psi_x002fft = 15,
	eml__ForcePerVolumeUom__psi_x002fm = 16
};
#endif

/* resqml2_0_1ForGsoap.h:10117 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeUom (745)
/* eml:ElectricChargePerVolumeUom */
enum eml__ElectricChargePerVolumeUom
{
	eml__ElectricChargePerVolumeUom__A_x002es_x002fm3 = 0,
	eml__ElectricChargePerVolumeUom__C_x002fcm3 = 1,
	eml__ElectricChargePerVolumeUom__C_x002fm3 = 2,
	eml__ElectricChargePerVolumeUom__C_x002fmm3 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:10140 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityUom (746)
/* eml:APIGravityUom */
enum eml__APIGravityUom
{
	eml__APIGravityUom__dAPI = 0
};
#endif

/* resqml2_0_1ForGsoap.h:10151 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceUom (747)
/* eml:ReluctanceUom */
enum eml__ReluctanceUom
{
	eml__ReluctanceUom__1_x002fH = 0
};
#endif

/* resqml2_0_1ForGsoap.h:10162 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureUom (748)
/* eml:LengthPerTemperatureUom */
enum eml__LengthPerTemperatureUom
{
	eml__LengthPerTemperatureUom__ft_x002fdeltaF = 0,
	eml__LengthPerTemperatureUom__m_x002fdeltaK = 1
};
#endif

/* resqml2_0_1ForGsoap.h:10177 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthUom (749)
/* eml:VolumePerTimePerLengthUom */
enum eml__VolumePerTimePerLengthUom
{
	eml__VolumePerTimePerLengthUom__1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 0,
	eml__VolumePerTimePerLengthUom__1000_x0020m3_x002f_x0028d_x002em_x0029 = 1,
	eml__VolumePerTimePerLengthUom__1000_x0020m3_x002f_x0028h_x002em_x0029 = 2,
	eml__VolumePerTimePerLengthUom__bbl_x002f_x0028d_x002eft_x0029 = 3,
	eml__VolumePerTimePerLengthUom__ft3_x002f_x0028d_x002eft_x0029 = 4,
	eml__VolumePerTimePerLengthUom__gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 5,
	eml__VolumePerTimePerLengthUom__gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 6,
	eml__VolumePerTimePerLengthUom__gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 7,
	eml__VolumePerTimePerLengthUom__gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 8,
	eml__VolumePerTimePerLengthUom__gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 9,
	eml__VolumePerTimePerLengthUom__gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 10,
	eml__VolumePerTimePerLengthUom__m3_x002f_x0028d_x002em_x0029 = 11,
	eml__VolumePerTimePerLengthUom__m3_x002f_x0028h_x002em_x0029 = 12,
	eml__VolumePerTimePerLengthUom__m3_x002f_x0028s_x002eft_x0029 = 13,
	eml__VolumePerTimePerLengthUom__m3_x002f_x0028s_x002em_x0029 = 14
};
#endif

/* resqml2_0_1ForGsoap.h:10244 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationUom (750)
/* eml:LinearAccelerationUom */
enum eml__LinearAccelerationUom
{
	eml__LinearAccelerationUom__cm_x002fs2 = 0,
	eml__LinearAccelerationUom__ft_x002fs2 = 1,
	eml__LinearAccelerationUom__Gal = 2,
	eml__LinearAccelerationUom__gn = 3,
	eml__LinearAccelerationUom__in_x002fs2 = 4,
	eml__LinearAccelerationUom__m_x002fs2 = 5,
	eml__LinearAccelerationUom__mGal = 6,
	eml__LinearAccelerationUom__mgn = 7
};
#endif

/* resqml2_0_1ForGsoap.h:10283 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessUom (751)
/* eml:DimensionlessUom */
enum eml__DimensionlessUom
{
	eml__DimensionlessUom___x0025 = 0,
	eml__DimensionlessUom__cEuc = 1,
	eml__DimensionlessUom__dEuc = 2,
	eml__DimensionlessUom__EEuc = 3,
	eml__DimensionlessUom__Euc = 4,
	eml__DimensionlessUom__fEuc = 5,
	eml__DimensionlessUom__GEuc = 6,
	eml__DimensionlessUom__kEuc = 7,
	eml__DimensionlessUom__MEuc = 8,
	eml__DimensionlessUom__mEuc = 9,
	eml__DimensionlessUom__nEuc = 10,
	eml__DimensionlessUom__pEuc = 11,
	eml__DimensionlessUom__ppk = 12,
	eml__DimensionlessUom__ppm = 13,
	eml__DimensionlessUom__TEuc = 14,
	eml__DimensionlessUom__uEuc = 15
};
#endif

/* resqml2_0_1ForGsoap.h:10354 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyUom (752)
/* eml:EnergyUom */
enum eml__EnergyUom
{
	eml__EnergyUom__1E6_x0020Btu_x005bIT_x005d = 0,
	eml__EnergyUom__aJ = 1,
	eml__EnergyUom__Btu_x005bIT_x005d = 2,
	eml__EnergyUom__Btu_x005bth_x005d = 3,
	eml__EnergyUom__Btu_x005bUK_x005d = 4,
	eml__EnergyUom__cal_x005bIT_x005d = 5,
	eml__EnergyUom__cal_x005bth_x005d = 6,
	eml__EnergyUom__ccal_x005bth_x005d = 7,
	eml__EnergyUom__ceV = 8,
	eml__EnergyUom__cJ = 9,
	eml__EnergyUom__dcal_x005bth_x005d = 10,
	eml__EnergyUom__deV = 11,
	eml__EnergyUom__dJ = 12,
	eml__EnergyUom__Ecal_x005bth_x005d = 13,
	eml__EnergyUom__EeV = 14,
	eml__EnergyUom__EJ = 15,
	eml__EnergyUom__erg = 16,
	eml__EnergyUom__eV = 17,
	eml__EnergyUom__fcal_x005bth_x005d = 18,
	eml__EnergyUom__feV = 19,
	eml__EnergyUom__fJ = 20,
	eml__EnergyUom__Gcal_x005bth_x005d = 21,
	eml__EnergyUom__GeV = 22,
	eml__EnergyUom__GJ = 23,
	eml__EnergyUom__GW_x002eh = 24,
	eml__EnergyUom__hp_x002eh = 25,
	eml__EnergyUom__hp_x005bmetric_x005d_x002eh = 26,
	eml__EnergyUom__J = 27,
	eml__EnergyUom__kcal_x005bth_x005d = 28,
	eml__EnergyUom__keV = 29,
	eml__EnergyUom__kJ = 30,
	eml__EnergyUom__kW_x002eh = 31,
	eml__EnergyUom__Mcal_x005bth_x005d = 32,
	eml__EnergyUom__mcal_x005bth_x005d = 33,
	eml__EnergyUom__meV = 34,
	eml__EnergyUom__MeV = 35,
	eml__EnergyUom__MJ = 36,
	eml__EnergyUom__mJ = 37,
	eml__EnergyUom__MW_x002eh = 38,
	eml__EnergyUom__ncal_x005bth_x005d = 39,
	eml__EnergyUom__neV = 40,
	eml__EnergyUom__nJ = 41,
	eml__EnergyUom__pcal_x005bth_x005d = 42,
	eml__EnergyUom__peV = 43,
	eml__EnergyUom__pJ = 44,
	eml__EnergyUom__quad = 45,
	eml__EnergyUom__Tcal_x005bth_x005d = 46,
	eml__EnergyUom__TeV = 47,
	eml__EnergyUom__therm_x005bEC_x005d = 48,
	eml__EnergyUom__therm_x005bUK_x005d = 49,
	eml__EnergyUom__therm_x005bUS_x005d = 50,
	eml__EnergyUom__TJ = 51,
	eml__EnergyUom__TW_x002eh = 52,
	eml__EnergyUom__ucal_x005bth_x005d = 53,
	eml__EnergyUom__ueV = 54,
	eml__EnergyUom__uJ = 55
};
#endif

/* resqml2_0_1ForGsoap.h:10585 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthUom (753)
/* eml:AnglePerLengthUom */
enum eml__AnglePerLengthUom
{
	eml__AnglePerLengthUom__0_x002e01_x0020dega_x002fft = 0,
	eml__AnglePerLengthUom__1_x002f30_x0020dega_x002fft = 1,
	eml__AnglePerLengthUom__1_x002f30_x0020dega_x002fm = 2,
	eml__AnglePerLengthUom__dega_x002fft = 3,
	eml__AnglePerLengthUom__dega_x002fm = 4,
	eml__AnglePerLengthUom__rad_x002fft = 5,
	eml__AnglePerLengthUom__rad_x002fm = 6,
	eml__AnglePerLengthUom__rev_x002fft = 7,
	eml__AnglePerLengthUom__rev_x002fm = 8
};
#endif

/* resqml2_0_1ForGsoap.h:10631 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCoordinateUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCoordinateUom (754)
/* eml:VerticalCoordinateUom */
enum eml__VerticalCoordinateUom
{
	eml__VerticalCoordinateUom__m = 0,
	eml__VerticalCoordinateUom__ft = 1,
	eml__VerticalCoordinateUom__ftUS = 2,
	eml__VerticalCoordinateUom__ftBr_x002865_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:10654 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthUom (755)
/* eml:VolumePerLengthUom */
enum eml__VolumePerLengthUom
{
	eml__VolumePerLengthUom__0_x002e01_x0020dm3_x002fkm = 0,
	eml__VolumePerLengthUom__0_x002e01_x0020L_x002fkm = 1,
	eml__VolumePerLengthUom__bbl_x002fft = 2,
	eml__VolumePerLengthUom__bbl_x002fin = 3,
	eml__VolumePerLengthUom__bbl_x002fmi = 4,
	eml__VolumePerLengthUom__dm3_x002fm = 5,
	eml__VolumePerLengthUom__ft3_x002fft = 6,
	eml__VolumePerLengthUom__gal_x005bUK_x005d_x002fmi = 7,
	eml__VolumePerLengthUom__gal_x005bUS_x005d_x002fft = 8,
	eml__VolumePerLengthUom__gal_x005bUS_x005d_x002fmi = 9,
	eml__VolumePerLengthUom__in3_x002fft = 10,
	eml__VolumePerLengthUom__L_x002fm = 11,
	eml__VolumePerLengthUom__m3_x002fkm = 12,
	eml__VolumePerLengthUom__m3_x002fm = 13
};
#endif

/* resqml2_0_1ForGsoap.h:10717 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeUom (756)
/* eml:EnergyPerVolumeUom */
enum eml__EnergyPerVolumeUom
{
	eml__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fbbl = 0,
	eml__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fft3 = 1,
	eml__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 2,
	eml__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 3,
	eml__EnergyPerVolumeUom__cal_x005bth_x005d_x002fcm3 = 4,
	eml__EnergyPerVolumeUom__cal_x005bth_x005d_x002fmL = 5,
	eml__EnergyPerVolumeUom__cal_x005bth_x005d_x002fmm3 = 6,
	eml__EnergyPerVolumeUom__erg_x002fcm3 = 7,
	eml__EnergyPerVolumeUom__erg_x002fm3 = 8,
	eml__EnergyPerVolumeUom__hp_x002eh_x002fbbl = 9,
	eml__EnergyPerVolumeUom__J_x002fdm3 = 10,
	eml__EnergyPerVolumeUom__J_x002fm3 = 11,
	eml__EnergyPerVolumeUom__kcal_x005bth_x005d_x002fcm3 = 12,
	eml__EnergyPerVolumeUom__kcal_x005bth_x005d_x002fm3 = 13,
	eml__EnergyPerVolumeUom__kJ_x002fdm3 = 14,
	eml__EnergyPerVolumeUom__kJ_x002fm3 = 15,
	eml__EnergyPerVolumeUom__kW_x002eh_x002fdm3 = 16,
	eml__EnergyPerVolumeUom__kW_x002eh_x002fm3 = 17,
	eml__EnergyPerVolumeUom__lbf_x002eft_x002fbbl = 18,
	eml__EnergyPerVolumeUom__lbf_x002eft_x002fgal_x005bUS_x005d = 19,
	eml__EnergyPerVolumeUom__MJ_x002fm3 = 20,
	eml__EnergyPerVolumeUom__MW_x002eh_x002fm3 = 21,
	eml__EnergyPerVolumeUom__tonf_x005bUS_x005d_x002emi_x002fbbl = 22
};
#endif

/* resqml2_0_1ForGsoap.h:10816 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityUom (757)
/* eml:MagneticPermeabilityUom */
enum eml__MagneticPermeabilityUom
{
	eml__MagneticPermeabilityUom__H_x002fm = 0,
	eml__MagneticPermeabilityUom__uH_x002fm = 1
};
#endif

/* resqml2_0_1ForGsoap.h:10831 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassUom (758)
/* eml:ReciprocalMassUom */
enum eml__ReciprocalMassUom
{
	eml__ReciprocalMassUom__1_x002fg = 0,
	eml__ReciprocalMassUom__1_x002fkg = 1,
	eml__ReciprocalMassUom__1_x002flbm = 2
};
#endif

/* resqml2_0_1ForGsoap.h:10850 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityUom (759)
/* eml:DynamicViscosityUom */
enum eml__DynamicViscosityUom
{
	eml__DynamicViscosityUom__cP = 0,
	eml__DynamicViscosityUom__dP = 1,
	eml__DynamicViscosityUom__dyne_x002es_x002fcm2 = 2,
	eml__DynamicViscosityUom__EP = 3,
	eml__DynamicViscosityUom__fP = 4,
	eml__DynamicViscosityUom__GP = 5,
	eml__DynamicViscosityUom__kgf_x002es_x002fm2 = 6,
	eml__DynamicViscosityUom__kP = 7,
	eml__DynamicViscosityUom__lbf_x002es_x002fft2 = 8,
	eml__DynamicViscosityUom__lbf_x002es_x002fin2 = 9,
	eml__DynamicViscosityUom__mP = 10,
	eml__DynamicViscosityUom__MP = 11,
	eml__DynamicViscosityUom__mPa_x002es = 12,
	eml__DynamicViscosityUom__N_x002es_x002fm2 = 13,
	eml__DynamicViscosityUom__nP = 14,
	eml__DynamicViscosityUom__P = 15,
	eml__DynamicViscosityUom__Pa_x002es = 16,
	eml__DynamicViscosityUom__pP = 17,
	eml__DynamicViscosityUom__psi_x002es = 18,
	eml__DynamicViscosityUom__TP = 19,
	eml__DynamicViscosityUom__uP = 20
};
#endif

/* resqml2_0_1ForGsoap.h:10941 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropUom (760)
/* eml:PotentialDifferencePerPowerDropUom */
enum eml__PotentialDifferencePerPowerDropUom
{
	eml__PotentialDifferencePerPowerDropUom__V_x002fB = 0,
	eml__PotentialDifferencePerPowerDropUom__V_x002fdB = 1
};
#endif

/* resqml2_0_1ForGsoap.h:10956 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeUom (761)
/* eml:AreaPerTimeUom */
enum eml__AreaPerTimeUom
{
	eml__AreaPerTimeUom__cm2_x002fs = 0,
	eml__AreaPerTimeUom__ft2_x002fh = 1,
	eml__AreaPerTimeUom__ft2_x002fs = 2,
	eml__AreaPerTimeUom__in2_x002fs = 3,
	eml__AreaPerTimeUom__m2_x002fd = 4,
	eml__AreaPerTimeUom__m2_x002fh = 5,
	eml__AreaPerTimeUom__m2_x002fs = 6,
	eml__AreaPerTimeUom__mm2_x002fs = 7
};
#endif

/* resqml2_0_1ForGsoap.h:10995 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityUom (762)
/* eml:HeatCapacityUom */
enum eml__HeatCapacityUom
{
	eml__HeatCapacityUom__J_x002fdeltaK = 0
};
#endif

/* resqml2_0_1ForGsoap.h:11006 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyUom (763)
/* eml:MolarEnergyUom */
enum eml__MolarEnergyUom
{
	eml__MolarEnergyUom__Btu_x005bIT_x005d_x002flbmol = 0,
	eml__MolarEnergyUom__J_x002fmol = 1,
	eml__MolarEnergyUom__kcal_x005bth_x005d_x002fmol = 2,
	eml__MolarEnergyUom__kJ_x002fkmol = 3,
	eml__MolarEnergyUom__MJ_x002fkmol = 4
};
#endif

/* resqml2_0_1ForGsoap.h:11033 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceUom (764)
/* eml:ElectricConductanceUom */
enum eml__ElectricConductanceUom
{
	eml__ElectricConductanceUom__cS = 0,
	eml__ElectricConductanceUom__dS = 1,
	eml__ElectricConductanceUom__ES = 2,
	eml__ElectricConductanceUom__fS = 3,
	eml__ElectricConductanceUom__GS = 4,
	eml__ElectricConductanceUom__kS = 5,
	eml__ElectricConductanceUom__mS = 6,
	eml__ElectricConductanceUom__MS = 7,
	eml__ElectricConductanceUom__nS = 8,
	eml__ElectricConductanceUom__pS = 9,
	eml__ElectricConductanceUom__S = 10,
	eml__ElectricConductanceUom__TS = 11,
	eml__ElectricConductanceUom__uS = 12
};
#endif

/* resqml2_0_1ForGsoap.h:11092 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumUom (765)
/* eml:MomentumUom */
enum eml__MomentumUom
{
	eml__MomentumUom__kg_x002em_x002fs = 0,
	eml__MomentumUom__lbm_x002eft_x002fs = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11107 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaUom (766)
/* eml:MassPerTimePerAreaUom */
enum eml__MassPerTimePerAreaUom
{
	eml__MassPerTimePerAreaUom__g_x002eft_x002f_x0028cm3_x002es_x0029 = 0,
	eml__MassPerTimePerAreaUom__g_x002em_x002f_x0028cm3_x002es_x0029 = 1,
	eml__MassPerTimePerAreaUom__kg_x002f_x0028m2_x002es_x0029 = 2,
	eml__MassPerTimePerAreaUom__kPa_x002es_x002fm = 3,
	eml__MassPerTimePerAreaUom__lbm_x002f_x0028ft2_x002eh_x0029 = 4,
	eml__MassPerTimePerAreaUom__lbm_x002f_x0028ft2_x002es_x0029 = 5,
	eml__MassPerTimePerAreaUom__MPa_x002es_x002fm = 6
};
#endif

/* resqml2_0_1ForGsoap.h:11142 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeUom (767)
/* eml:PowerPerVolumeUom */
enum eml__PowerPerVolumeUom
{
	eml__PowerPerVolumeUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 0,
	eml__PowerPerVolumeUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 1,
	eml__PowerPerVolumeUom__cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 2,
	eml__PowerPerVolumeUom__cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 3,
	eml__PowerPerVolumeUom__hp_x002fft3 = 4,
	eml__PowerPerVolumeUom__kW_x002fm3 = 5,
	eml__PowerPerVolumeUom__uW_x002fm3 = 6,
	eml__PowerPerVolumeUom__W_x002fm3 = 7
};
#endif

/* resqml2_0_1ForGsoap.h:11181 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyUom (768)
/* eml:FrequencyUom */
enum eml__FrequencyUom
{
	eml__FrequencyUom__cHz = 0,
	eml__FrequencyUom__dHz = 1,
	eml__FrequencyUom__EHz = 2,
	eml__FrequencyUom__fHz = 3,
	eml__FrequencyUom__GHz = 4,
	eml__FrequencyUom__Hz = 5,
	eml__FrequencyUom__kHz = 6,
	eml__FrequencyUom__mHz = 7,
	eml__FrequencyUom__MHz = 8,
	eml__FrequencyUom__nHz = 9,
	eml__FrequencyUom__pHz = 10,
	eml__FrequencyUom__THz = 11,
	eml__FrequencyUom__uHz = 12
};
#endif

/* resqml2_0_1ForGsoap.h:11240 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityUom (769)
/* eml:LuminousIntensityUom */
enum eml__LuminousIntensityUom
{
	eml__LuminousIntensityUom__cd = 0,
	eml__LuminousIntensityUom__kcd = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11255 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseUom (770)
/* eml:AbsorbedDoseUom */
enum eml__AbsorbedDoseUom
{
	eml__AbsorbedDoseUom__cGy = 0,
	eml__AbsorbedDoseUom__crd = 1,
	eml__AbsorbedDoseUom__dGy = 2,
	eml__AbsorbedDoseUom__drd = 3,
	eml__AbsorbedDoseUom__EGy = 4,
	eml__AbsorbedDoseUom__Erd = 5,
	eml__AbsorbedDoseUom__fGy = 6,
	eml__AbsorbedDoseUom__frd = 7,
	eml__AbsorbedDoseUom__GGy = 8,
	eml__AbsorbedDoseUom__Grd = 9,
	eml__AbsorbedDoseUom__Gy = 10,
	eml__AbsorbedDoseUom__kGy = 11,
	eml__AbsorbedDoseUom__krd = 12,
	eml__AbsorbedDoseUom__mGy = 13,
	eml__AbsorbedDoseUom__MGy = 14,
	eml__AbsorbedDoseUom__Mrd = 15,
	eml__AbsorbedDoseUom__mrd = 16,
	eml__AbsorbedDoseUom__nGy = 17,
	eml__AbsorbedDoseUom__nrd = 18,
	eml__AbsorbedDoseUom__pGy = 19,
	eml__AbsorbedDoseUom__prd = 20,
	eml__AbsorbedDoseUom__rd = 21,
	eml__AbsorbedDoseUom__TGy = 22,
	eml__AbsorbedDoseUom__Trd = 23,
	eml__AbsorbedDoseUom__uGy = 24,
	eml__AbsorbedDoseUom__urd = 25
};
#endif

/* resqml2_0_1ForGsoap.h:11366 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassUom (771)
/* eml:TimePerMassUom */
enum eml__TimePerMassUom
{
	eml__TimePerMassUom__s_x002fkg = 0
};
#endif

/* resqml2_0_1ForGsoap.h:11377 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientUom (772)
/* eml:VolumetricHeatTransferCoefficientUom */
enum eml__VolumetricHeatTransferCoefficientUom
{
	eml__VolumetricHeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edeltaF_x0029 = 0,
	eml__VolumetricHeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edeltaF_x0029 = 1,
	eml__VolumetricHeatTransferCoefficientUom__kW_x002f_x0028m3_x002edeltaK_x0029 = 2,
	eml__VolumetricHeatTransferCoefficientUom__W_x002f_x0028m3_x002edeltaK_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:11400 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerUom (773)
/* eml:NormalizedPowerUom */
enum eml__NormalizedPowerUom
{
	eml__NormalizedPowerUom__B_x002eW = 0,
	eml__NormalizedPowerUom__dB_x002eMW = 1,
	eml__NormalizedPowerUom__dB_x002emW = 2,
	eml__NormalizedPowerUom__dB_x002eW = 3
};
#endif

/* resqml2_0_1ForGsoap.h:11423 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureUom (774)
/* eml:EnergyLengthPerTimeAreaTemperatureUom */
enum eml__EnergyLengthPerTimeAreaTemperatureUom
{
	eml__EnergyLengthPerTimeAreaTemperatureUom__Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	eml__EnergyLengthPerTimeAreaTemperatureUom__J_x002em_x002f_x0028s_x002em2_x002edeltaK_x0029 = 1,
	eml__EnergyLengthPerTimeAreaTemperatureUom__kJ_x002em_x002f_x0028h_x002em2_x002edeltaK_x0029 = 2,
	eml__EnergyLengthPerTimeAreaTemperatureUom__W_x002f_x0028m_x002edeltaK_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:11446 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeUom (775)
/* eml:PressureTimePerVolumeUom */
enum eml__PressureTimePerVolumeUom
{
	eml__PressureTimePerVolumeUom__Pa_x002es_x002fm3 = 0,
	eml__PressureTimePerVolumeUom__psi_x002ed_x002fbbl = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11461 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeUom (776)
/* eml:VolumePerVolumeUom */
enum eml__VolumePerVolumeUom
{
	eml__VolumePerVolumeUom___x0025 = 0,
	eml__VolumePerVolumeUom___x0025_x005bvol_x005d = 1,
	eml__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fft3 = 2,
	eml__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fm3 = 3,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 4,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 5,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 6,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 7,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 8,
	eml__VolumePerVolumeUom__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 9,
	eml__VolumePerVolumeUom__0_x002e01_x0020bbl_x002fbbl = 10,
	eml__VolumePerVolumeUom__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 11,
	eml__VolumePerVolumeUom__0_x002e1_x0020L_x002fbbl = 12,
	eml__VolumePerVolumeUom__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 13,
	eml__VolumePerVolumeUom__1000_x0020ft3_x002fbbl = 14,
	eml__VolumePerVolumeUom__1000_x0020m3_x002fm3 = 15,
	eml__VolumePerVolumeUom__1E_6_x0020acre_x002eft_x002fbbl = 16,
	eml__VolumePerVolumeUom__1E_6_x0020bbl_x002fft3 = 17,
	eml__VolumePerVolumeUom__1E_6_x0020bbl_x002fm3 = 18,
	eml__VolumePerVolumeUom__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 19,
	eml__VolumePerVolumeUom__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 20,
	eml__VolumePerVolumeUom__1E6_x0020ft3_x002fbbl = 21,
	eml__VolumePerVolumeUom__bbl_x002f_x0028acre_x002eft_x0029 = 22,
	eml__VolumePerVolumeUom__bbl_x002fbbl = 23,
	eml__VolumePerVolumeUom__bbl_x002fft3 = 24,
	eml__VolumePerVolumeUom__bbl_x002fm3 = 25,
	eml__VolumePerVolumeUom__cEuc = 26,
	eml__VolumePerVolumeUom__cm3_x002fcm3 = 27,
	eml__VolumePerVolumeUom__cm3_x002fL = 28,
	eml__VolumePerVolumeUom__cm3_x002fm3 = 29,
	eml__VolumePerVolumeUom__dm3_x002fm3 = 30,
	eml__VolumePerVolumeUom__Euc = 31,
	eml__VolumePerVolumeUom__ft3_x002fbbl = 32,
	eml__VolumePerVolumeUom__ft3_x002fft3 = 33,
	eml__VolumePerVolumeUom__gal_x005bUK_x005d_x002fft3 = 34,
	eml__VolumePerVolumeUom__gal_x005bUS_x005d_x002fbbl = 35,
	eml__VolumePerVolumeUom__gal_x005bUS_x005d_x002fft3 = 36,
	eml__VolumePerVolumeUom__L_x002fm3 = 37,
	eml__VolumePerVolumeUom__m3_x002f_x0028ha_x002em_x0029 = 38,
	eml__VolumePerVolumeUom__m3_x002fbbl = 39,
	eml__VolumePerVolumeUom__m3_x002fm3 = 40,
	eml__VolumePerVolumeUom__mL_x002fgal_x005bUK_x005d = 41,
	eml__VolumePerVolumeUom__mL_x002fgal_x005bUS_x005d = 42,
	eml__VolumePerVolumeUom__mL_x002fmL = 43,
	eml__VolumePerVolumeUom__ppk = 44,
	eml__VolumePerVolumeUom__ppm = 45,
	eml__VolumePerVolumeUom__ppm_x005bvol_x005d = 46
};
#endif

/* resqml2_0_1ForGsoap.h:11656 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeUom (777)
/* eml:AnglePerVolumeUom */
enum eml__AnglePerVolumeUom
{
	eml__AnglePerVolumeUom__rad_x002fft3 = 0,
	eml__AnglePerVolumeUom__rad_x002fm3 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11671 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientUom (778)
/* eml:DiffusionCoefficientUom */
enum eml__DiffusionCoefficientUom
{
	eml__DiffusionCoefficientUom__m2_x002fs = 0
};
#endif

/* resqml2_0_1ForGsoap.h:11682 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeUom (779)
/* eml:TimePerTimeUom */
enum eml__TimePerTimeUom
{
	eml__TimePerTimeUom___x0025 = 0,
	eml__TimePerTimeUom__Euc = 1,
	eml__TimePerTimeUom__ms_x002fs = 2,
	eml__TimePerTimeUom__s_x002fs = 3
};
#endif

/* resqml2_0_1ForGsoap.h:11705 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeUom (780)
/* eml:EnergyPerMassPerTimeUom */
enum eml__EnergyPerMassPerTimeUom
{
	eml__EnergyPerMassPerTimeUom__mrem_x002fh = 0,
	eml__EnergyPerMassPerTimeUom__mSv_x002fh = 1,
	eml__EnergyPerMassPerTimeUom__rem_x002fh = 2,
	eml__EnergyPerMassPerTimeUom__Sv_x002fh = 3,
	eml__EnergyPerMassPerTimeUom__Sv_x002fs = 4
};
#endif

/* resqml2_0_1ForGsoap.h:11732 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassUom (781)
/* eml:VolumePerMassUom */
enum eml__VolumePerMassUom
{
	eml__VolumePerMassUom__0_x002e01_x0020L_x002fkg = 0,
	eml__VolumePerMassUom__bbl_x002fton_x005bUK_x005d = 1,
	eml__VolumePerMassUom__bbl_x002fton_x005bUS_x005d = 2,
	eml__VolumePerMassUom__cm3_x002fg = 3,
	eml__VolumePerMassUom__dm3_x002fkg = 4,
	eml__VolumePerMassUom__dm3_x002ft = 5,
	eml__VolumePerMassUom__ft3_x002fkg = 6,
	eml__VolumePerMassUom__ft3_x002flbm = 7,
	eml__VolumePerMassUom__ft3_x002fsack_x005b94lbm_x005d = 8,
	eml__VolumePerMassUom__gal_x005bUK_x005d_x002flbm = 9,
	eml__VolumePerMassUom__gal_x005bUS_x005d_x002flbm = 10,
	eml__VolumePerMassUom__gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 11,
	eml__VolumePerMassUom__gal_x005bUS_x005d_x002fton_x005bUK_x005d = 12,
	eml__VolumePerMassUom__gal_x005bUS_x005d_x002fton_x005bUS_x005d = 13,
	eml__VolumePerMassUom__L_x002fkg = 14,
	eml__VolumePerMassUom__L_x002ft = 15,
	eml__VolumePerMassUom__L_x002fton_x005bUK_x005d = 16,
	eml__VolumePerMassUom__m3_x002fg = 17,
	eml__VolumePerMassUom__m3_x002fkg = 18,
	eml__VolumePerMassUom__m3_x002ft = 19,
	eml__VolumePerMassUom__m3_x002fton_x005bUK_x005d = 20,
	eml__VolumePerMassUom__m3_x002fton_x005bUS_x005d = 21
};
#endif

/* resqml2_0_1ForGsoap.h:11827 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthUom (782)
/* eml:TemperatureIntervalPerLengthUom */
enum eml__TemperatureIntervalPerLengthUom
{
	eml__TemperatureIntervalPerLengthUom__0_x002e01_x0020deltaF_x002fft = 0,
	eml__TemperatureIntervalPerLengthUom__deltaC_x002fft = 1,
	eml__TemperatureIntervalPerLengthUom__deltaC_x002fhm = 2,
	eml__TemperatureIntervalPerLengthUom__deltaC_x002fkm = 3,
	eml__TemperatureIntervalPerLengthUom__deltaC_x002fm = 4,
	eml__TemperatureIntervalPerLengthUom__deltaF_x002fft = 5,
	eml__TemperatureIntervalPerLengthUom__deltaF_x002fm = 6,
	eml__TemperatureIntervalPerLengthUom__deltaK_x002fkm = 7,
	eml__TemperatureIntervalPerLengthUom__deltaK_x002fm = 8
};
#endif

/* resqml2_0_1ForGsoap.h:11870 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalUom (783)
/* eml:AttenuationPerFrequencyIntervalUom */
enum eml__AttenuationPerFrequencyIntervalUom
{
	eml__AttenuationPerFrequencyIntervalUom__B_x002fO = 0,
	eml__AttenuationPerFrequencyIntervalUom__dB_x002fO = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11885 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityUom (784)
/* eml:IsothermalCompressibilityUom */
enum eml__IsothermalCompressibilityUom
{
	eml__IsothermalCompressibilityUom__dm3_x002f_x0028kW_x002eh_x0029 = 0,
	eml__IsothermalCompressibilityUom__dm3_x002fMJ = 1,
	eml__IsothermalCompressibilityUom__m3_x002f_x0028kW_x002eh_x0029 = 2,
	eml__IsothermalCompressibilityUom__m3_x002fJ = 3,
	eml__IsothermalCompressibilityUom__mm3_x002fJ = 4,
	eml__IsothermalCompressibilityUom__pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 5
};
#endif

/* resqml2_0_1ForGsoap.h:11916 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceUom (785)
/* eml:ElectricResistanceUom */
enum eml__ElectricResistanceUom
{
	eml__ElectricResistanceUom__cohm = 0,
	eml__ElectricResistanceUom__dohm = 1,
	eml__ElectricResistanceUom__Eohm = 2,
	eml__ElectricResistanceUom__fohm = 3,
	eml__ElectricResistanceUom__Gohm = 4,
	eml__ElectricResistanceUom__kohm = 5,
	eml__ElectricResistanceUom__Mohm = 6,
	eml__ElectricResistanceUom__mohm = 7,
	eml__ElectricResistanceUom__nohm = 8,
	eml__ElectricResistanceUom__ohm = 9,
	eml__ElectricResistanceUom__pohm = 10,
	eml__ElectricResistanceUom__Tohm = 11,
	eml__ElectricResistanceUom__uohm = 12
};
#endif

/* resqml2_0_1ForGsoap.h:11975 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeUom (786)
/* eml:ReciprocalVolumeUom */
enum eml__ReciprocalVolumeUom
{
	eml__ReciprocalVolumeUom__1_x002fbbl = 0,
	eml__ReciprocalVolumeUom__1_x002fft3 = 1,
	eml__ReciprocalVolumeUom__1_x002fgal_x005bUK_x005d = 2,
	eml__ReciprocalVolumeUom__1_x002fgal_x005bUS_x005d = 3,
	eml__ReciprocalVolumeUom__1_x002fL = 4,
	eml__ReciprocalVolumeUom__1_x002fm3 = 5
};
#endif

/* resqml2_0_1ForGsoap.h:12006 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureUom (787)
/* eml:PressureUom */
enum eml__PressureUom
{
	eml__PressureUom__0_x002e01_x0020lbf_x002fft2 = 0,
	eml__PressureUom__at = 1,
	eml__PressureUom__atm = 2,
	eml__PressureUom__bar = 3,
	eml__PressureUom__cmH2O_x005b4degC_x005d = 4,
	eml__PressureUom__cPa = 5,
	eml__PressureUom__dPa = 6,
	eml__PressureUom__dyne_x002fcm2 = 7,
	eml__PressureUom__EPa = 8,
	eml__PressureUom__fPa = 9,
	eml__PressureUom__GPa = 10,
	eml__PressureUom__hbar = 11,
	eml__PressureUom__inH2O_x005b39degF_x005d = 12,
	eml__PressureUom__inH2O_x005b60degF_x005d = 13,
	eml__PressureUom__inHg_x005b32degF_x005d = 14,
	eml__PressureUom__inHg_x005b60degF_x005d = 15,
	eml__PressureUom__kgf_x002fcm2 = 16,
	eml__PressureUom__kgf_x002fm2 = 17,
	eml__PressureUom__kgf_x002fmm2 = 18,
	eml__PressureUom__kN_x002fm2 = 19,
	eml__PressureUom__kPa = 20,
	eml__PressureUom__kpsi = 21,
	eml__PressureUom__lbf_x002fft2 = 22,
	eml__PressureUom__mbar = 23,
	eml__PressureUom__mmHg_x005b0degC_x005d = 24,
	eml__PressureUom__mPa = 25,
	eml__PressureUom__MPa = 26,
	eml__PressureUom__Mpsi = 27,
	eml__PressureUom__N_x002fm2 = 28,
	eml__PressureUom__N_x002fmm2 = 29,
	eml__PressureUom__nPa = 30,
	eml__PressureUom__Pa = 31,
	eml__PressureUom__pPa = 32,
	eml__PressureUom__psi = 33,
	eml__PressureUom__tonf_x005bUK_x005d_x002fft2 = 34,
	eml__PressureUom__tonf_x005bUS_x005d_x002fft2 = 35,
	eml__PressureUom__tonf_x005bUS_x005d_x002fin2 = 36,
	eml__PressureUom__torr = 37,
	eml__PressureUom__TPa = 38,
	eml__PressureUom__ubar = 39,
	eml__PressureUom__umHg_x005b0degC_x005d = 40,
	eml__PressureUom__uPa = 41,
	eml__PressureUom__upsi = 42
};
#endif

/* resqml2_0_1ForGsoap.h:12185 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaUom (788)
/* eml:AreaPerAreaUom */
enum eml__AreaPerAreaUom
{
	eml__AreaPerAreaUom___x0025 = 0,
	eml__AreaPerAreaUom___x0025_x005barea_x005d = 1,
	eml__AreaPerAreaUom__cEuc = 2,
	eml__AreaPerAreaUom__Euc = 3,
	eml__AreaPerAreaUom__in2_x002fft2 = 4,
	eml__AreaPerAreaUom__in2_x002fin2 = 5,
	eml__AreaPerAreaUom__m2_x002fm2 = 6,
	eml__AreaPerAreaUom__mm2_x002fmm2 = 7
};
#endif

/* resqml2_0_1ForGsoap.h:12224 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityUom (789)
/* eml:AngularVelocityUom */
enum eml__AngularVelocityUom
{
	eml__AngularVelocityUom__dega_x002fh = 0,
	eml__AngularVelocityUom__dega_x002fmin = 1,
	eml__AngularVelocityUom__dega_x002fs = 2,
	eml__AngularVelocityUom__rad_x002fs = 3,
	eml__AngularVelocityUom__rev_x002fs = 4,
	eml__AngularVelocityUom__rpm = 5
};
#endif

/* resqml2_0_1ForGsoap.h:12255 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeUom (790)
/* eml:TimePerVolumeUom */
enum eml__TimePerVolumeUom
{
	eml__TimePerVolumeUom__0_x002e001_x0020d_x002fft3 = 0,
	eml__TimePerVolumeUom__d_x002fbbl = 1,
	eml__TimePerVolumeUom__d_x002fft3 = 2,
	eml__TimePerVolumeUom__d_x002fm3 = 3,
	eml__TimePerVolumeUom__h_x002fft3 = 4,
	eml__TimePerVolumeUom__h_x002fm3 = 5,
	eml__TimePerVolumeUom__s_x002fft3 = 6,
	eml__TimePerVolumeUom__s_x002fL = 7,
	eml__TimePerVolumeUom__s_x002fm3 = 8,
	eml__TimePerVolumeUom__s_x002fqt_x005bUK_x005d = 9,
	eml__TimePerVolumeUom__s_x002fqt_x005bUS_x005d = 10
};
#endif

/* resqml2_0_1ForGsoap.h:12306 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaUom (791)
/* eml:EnergyLengthPerAreaUom */
enum eml__EnergyLengthPerAreaUom
{
	eml__EnergyLengthPerAreaUom__J_x002em_x002fm2 = 0,
	eml__EnergyLengthPerAreaUom__kcal_x005bth_x005d_x002em_x002fcm2 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:12321 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthUom (792)
/* eml:ElectricResistancePerLengthUom */
enum eml__ElectricResistancePerLengthUom
{
	eml__ElectricResistancePerLengthUom__ohm_x002fm = 0,
	eml__ElectricResistancePerLengthUom__uohm_x002fft = 1,
	eml__ElectricResistancePerLengthUom__uohm_x002fm = 2
};
#endif

/* resqml2_0_1ForGsoap.h:12340 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthUom (793)
/* eml:ForcePerLengthUom */
enum eml__ForcePerLengthUom
{
	eml__ForcePerLengthUom__0_x002e01_x0020lbf_x002fft = 0,
	eml__ForcePerLengthUom__1_x002f30_x0020lbf_x002fm = 1,
	eml__ForcePerLengthUom__1_x002f30_x0020N_x002fm = 2,
	eml__ForcePerLengthUom__dyne_x002fcm = 3,
	eml__ForcePerLengthUom__kgf_x002fcm = 4,
	eml__ForcePerLengthUom__kN_x002fm = 5,
	eml__ForcePerLengthUom__lbf_x002fft = 6,
	eml__ForcePerLengthUom__lbf_x002fin = 7,
	eml__ForcePerLengthUom__mN_x002fkm = 8,
	eml__ForcePerLengthUom__mN_x002fm = 9,
	eml__ForcePerLengthUom__N_x002fm = 10,
	eml__ForcePerLengthUom__pdl_x002fcm = 11,
	eml__ForcePerLengthUom__tonf_x005bUK_x005d_x002fft = 12,
	eml__ForcePerLengthUom__tonf_x005bUS_x005d_x002fft = 13
};
#endif

/* resqml2_0_1ForGsoap.h:12403 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureUom (794)
/* eml:ReciprocalPressureUom */
enum eml__ReciprocalPressureUom
{
	eml__ReciprocalPressureUom__1_x002fbar = 0,
	eml__ReciprocalPressureUom__1_x002fkPa = 1,
	eml__ReciprocalPressureUom__1_x002fPa = 2,
	eml__ReciprocalPressureUom__1_x002fpPa = 3,
	eml__ReciprocalPressureUom__1_x002fpsi = 4,
	eml__ReciprocalPressureUom__1_x002fupsi = 5
};
#endif

/* resqml2_0_1ForGsoap.h:12434 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureUom (795)
/* eml:LightExposureUom */
enum eml__LightExposureUom
{
	eml__LightExposureUom__footcandle_x002es = 0,
	eml__LightExposureUom__lx_x002es = 1
};
#endif

/* resqml2_0_1ForGsoap.h:12449 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaUom (796)
/* eml:EnergyPerAreaUom */
enum eml__EnergyPerAreaUom
{
	eml__EnergyPerAreaUom__erg_x002fcm2 = 0,
	eml__EnergyPerAreaUom__J_x002fcm2 = 1,
	eml__EnergyPerAreaUom__J_x002fm2 = 2,
	eml__EnergyPerAreaUom__kgf_x002em_x002fcm2 = 3,
	eml__EnergyPerAreaUom__lbf_x002eft_x002fin2 = 4,
	eml__EnergyPerAreaUom__mJ_x002fcm2 = 5,
	eml__EnergyPerAreaUom__mJ_x002fm2 = 6,
	eml__EnergyPerAreaUom__N_x002fm = 7
};
#endif

/* resqml2_0_1ForGsoap.h:12488 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentUom (797)
/* eml:MagneticDipoleMomentUom */
enum eml__MagneticDipoleMomentUom
{
	eml__MagneticDipoleMomentUom__Wb_x002em = 0
};
#endif

/* resqml2_0_1ForGsoap.h:12499 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageUom (798)
/* eml:DigitalStorageUom */
enum eml__DigitalStorageUom
{
	eml__DigitalStorageUom__bit = 0,
	eml__DigitalStorageUom__byte = 1,
	eml__DigitalStorageUom__Kibyte = 2,
	eml__DigitalStorageUom__Mibyte = 3
};
#endif

/* resqml2_0_1ForGsoap.h:19995 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__RelatedTimeType_relativePosition (1028)
/* gml:RelatedTimeType-relativePosition */
enum _gml__RelatedTimeType_relativePosition
{
	_gml__RelatedTimeType_relativePosition__Before = 0,
	_gml__RelatedTimeType_relativePosition__After = 1,
	_gml__RelatedTimeType_relativePosition__Begins = 2,
	_gml__RelatedTimeType_relativePosition__Ends = 3,
	_gml__RelatedTimeType_relativePosition__During = 4,
	_gml__RelatedTimeType_relativePosition__Equals = 5,
	_gml__RelatedTimeType_relativePosition__Contains = 6,
	_gml__RelatedTimeType_relativePosition__Overlaps = 7,
	_gml__RelatedTimeType_relativePosition__Meets = 8,
	_gml__RelatedTimeType_relativePosition__OverlappedBy = 9,
	_gml__RelatedTimeType_relativePosition__MetBy = 10,
	_gml__RelatedTimeType_relativePosition__BegunBy = 11,
	_gml__RelatedTimeType_relativePosition__EndedBy = 12
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

class resqml2__PropertyKindFacet;	// resqml2_0_1ForGsoap.h:216
class resqml2__StringLookup;	// resqml2_0_1ForGsoap.h:225
class resqml2__PatchOfPoints;	// resqml2_0_1ForGsoap.h:240
class resqml2__AbstractPropertyKind;	// resqml2_0_1ForGsoap.h:270
class resqml2__PatchOfValues;	// resqml2_0_1ForGsoap.h:273
class resqml2__AbstractValueArray;	// resqml2_0_1ForGsoap.h:276
class resqml2__PropertyValuesPatch;	// resqml2_0_1ForGsoap.h:297
class resqml2__DoubleLookup;	// resqml2_0_1ForGsoap.h:309
class resqml2__Point3dOffset;	// resqml2_0_1ForGsoap.h:315
class resqml2__AbstractPoint3dArray;	// resqml2_0_1ForGsoap.h:339
class resqml2__AbstractGeometry;	// resqml2_0_1ForGsoap.h:342
class resqml2__ThreePoint3d;	// resqml2_0_1ForGsoap.h:348
class resqml2__AbstractParametricLineArray;	// resqml2_0_1ForGsoap.h:360
class resqml2__ParametricLineIntersections;	// resqml2_0_1ForGsoap.h:363
class resqml2__AbstractSeismicCoordinates;	// resqml2_0_1ForGsoap.h:381
class resqml2__Patch;	// resqml2_0_1ForGsoap.h:390
class resqml2__ElementIndices;	// resqml2_0_1ForGsoap.h:393
class resqml2__RepresentationIdentity;	// resqml2_0_1ForGsoap.h:405
class resqml2__ElementIdentity;	// resqml2_0_1ForGsoap.h:411
class resqml2__PatchOfGeometry;	// resqml2_0_1ForGsoap.h:417
class resqml2__AdditionalGridTopology;	// resqml2_0_1ForGsoap.h:426
class resqml2__CellStratigraphicUnits;	// resqml2_0_1ForGsoap.h:441
class resqml2__SubnodeTopology;	// resqml2_0_1ForGsoap.h:450
class resqml2__SplitFaces;	// resqml2_0_1ForGsoap.h:453
class __resqml2__IjGaps_sequence;	// resqml2_0_1ForGsoap.h:13474
class resqml2__IjGaps;	// resqml2_0_1ForGsoap.h:459
class resqml2__GpGridColumnLayerGrid;	// resqml2_0_1ForGsoap.h:474
class resqml2__ColumnLayerSplitCoordinateLines;	// resqml2_0_1ForGsoap.h:477
class __resqml2__KGaps_sequence;	// resqml2_0_1ForGsoap.h:13593
class resqml2__KGaps;	// resqml2_0_1ForGsoap.h:483
class resqml2__UnstructuredColumnEdges;	// resqml2_0_1ForGsoap.h:492
class resqml2__AdditionalGridPoints;	// resqml2_0_1ForGsoap.h:495
class resqml2__IjSplitColumnEdges;	// resqml2_0_1ForGsoap.h:498
class resqml2__IntervalStratigraphicUnits;	// resqml2_0_1ForGsoap.h:507
class resqml2__Regrid;	// resqml2_0_1ForGsoap.h:510
class resqml2__Activation;	// resqml2_0_1ForGsoap.h:513
class resqml2__ConnectionInterpretations;	// resqml2_0_1ForGsoap.h:522
class resqml2__SplitEdges;	// resqml2_0_1ForGsoap.h:528
class resqml2__CellFluidPhaseUnits;	// resqml2_0_1ForGsoap.h:531
class resqml2__NodesPerCell;	// resqml2_0_1ForGsoap.h:534
class resqml2__Edges;	// resqml2_0_1ForGsoap.h:540
class resqml2__UnstructuredGridHingeNodeFaces;	// resqml2_0_1ForGsoap.h:564
class __resqml2__CellOverlap_sequence;	// resqml2_0_1ForGsoap.h:14004
class resqml2__CellOverlap;	// resqml2_0_1ForGsoap.h:567
class resqml2__ColumnLayerSplitColumnEdges;	// resqml2_0_1ForGsoap.h:570
class __resqml2__OverlapVolume_sequence;	// resqml2_0_1ForGsoap.h:14079
class resqml2__OverlapVolume;	// resqml2_0_1ForGsoap.h:576
class resqml2__Intervals;	// resqml2_0_1ForGsoap.h:579
class resqml2__AbstractParentWindow;	// resqml2_0_1ForGsoap.h:585
class resqml2__TimeInterval;	// resqml2_0_1ForGsoap.h:594
class resqml2__StratigraphicUnitInterpretationIndex;	// resqml2_0_1ForGsoap.h:603
class resqml2__GeologicUnitInterpretationIndex;	// resqml2_0_1ForGsoap.h:618
class resqml2__HorizonInterpretationIndex;	// resqml2_0_1ForGsoap.h:630
class resqml2__AbstractContactInterpretationPart;	// resqml2_0_1ForGsoap.h:645
class resqml2__FaultThrow;	// resqml2_0_1ForGsoap.h:651
class resqml2__RockFluidUnitInterpretationIndex;	// resqml2_0_1ForGsoap.h:660
class resqml2__ChronostratigraphicRank;	// resqml2_0_1ForGsoap.h:687
class resqml2__Point3d;	// resqml2_0_1ForGsoap.h:714
class resqml2__TimeSeriesParentage;	// resqml2_0_1ForGsoap.h:717
class resqml2__TimeIndex;	// resqml2_0_1ForGsoap.h:723
class resqml2__Timestamp;	// resqml2_0_1ForGsoap.h:726
class resqml2__ResqmlJaggedArray;	// resqml2_0_1ForGsoap.h:732
class resqml2__NameValuePair;	// resqml2_0_1ForGsoap.h:735
class resqml2__WellboreTrajectoryParentIntersection;	// resqml2_0_1ForGsoap.h:750
class resqml2__AbstractContactRepresentationPart;	// resqml2_0_1ForGsoap.h:789
class resqml2__VolumeRegion;	// resqml2_0_1ForGsoap.h:804
class resqml2__VolumeShell;	// resqml2_0_1ForGsoap.h:807
class resqml2__PatchBoundaries;	// resqml2_0_1ForGsoap.h:828
class resqml2__OrientedMacroFace;	// resqml2_0_1ForGsoap.h:843
class resqml2__ContactIdentity;	// resqml2_0_1ForGsoap.h:846
class resqml2__WitsmlWellboreReference;	// resqml2_0_1ForGsoap.h:876
class resqml2__ParameterTemplate;	// resqml2_0_1ForGsoap.h:891
class resqml2__AbstractParameterKey;	// resqml2_0_1ForGsoap.h:903
class resqml2__AbstractActivityParameter;	// resqml2_0_1ForGsoap.h:909
class resqml2__StreamlineWellbores;	// resqml2_0_1ForGsoap.h:924
class resqml2__IntervalGridCells;	// resqml2_0_1ForGsoap.h:927
class resqml2__TimeIndices;	// resqml2_0_1ForGsoap.h:930
class eml__CustomData;	// resqml2_0_1ForGsoap.h:948
class eml__Citation;	// resqml2_0_1ForGsoap.h:951
class eml__AbstractObject;	// resqml2_0_1ForGsoap.h:954
class eml__ObjectAlias;	// resqml2_0_1ForGsoap.h:957
class eml__AbstractVerticalCrs;	// resqml2_0_1ForGsoap.h:975
class eml__AbstractProjectedCrs;	// resqml2_0_1ForGsoap.h:978
class eml__Hdf5Dataset;	// resqml2_0_1ForGsoap.h:990
class eml__DataObjectReference;	// resqml2_0_1ForGsoap.h:996
class gml__AbstractGMLType;	// resqml2_0_1ForGsoap.h:1539
class gml__ReferenceType;	// resqml2_0_1ForGsoap.h:1545
union _gml__union_TimePrimitivePropertyType;	// resqml2_0_1ForGsoap.h:15507
class __gml__TimePrimitivePropertyType_sequence;	// resqml2_0_1ForGsoap.h:15496
class gml__TimePrimitivePropertyType;	// resqml2_0_1ForGsoap.h:1563
class __gml__EllipsoidalCSPropertyType_sequence;	// resqml2_0_1ForGsoap.h:15567
class gml__EllipsoidalCSPropertyType;	// resqml2_0_1ForGsoap.h:1566
class __gml__CoordinateSystemAxisPropertyType_sequence;	// resqml2_0_1ForGsoap.h:15628
class gml__CoordinateSystemAxisPropertyType;	// resqml2_0_1ForGsoap.h:1575
class __gml__CartesianCSPropertyType_sequence;	// resqml2_0_1ForGsoap.h:15689
class gml__CartesianCSPropertyType;	// resqml2_0_1ForGsoap.h:1581
class __gml__SphericalCSPropertyType_sequence;	// resqml2_0_1ForGsoap.h:15750
class gml__SphericalCSPropertyType;	// resqml2_0_1ForGsoap.h:1587
class __gml__GeodeticDatumPropertyType_sequence;	// resqml2_0_1ForGsoap.h:15811
class gml__GeodeticDatumPropertyType;	// resqml2_0_1ForGsoap.h:1593
class __gml__PrimeMeridianPropertyType_sequence;	// resqml2_0_1ForGsoap.h:15872
class gml__PrimeMeridianPropertyType;	// resqml2_0_1ForGsoap.h:1602
class __gml__EllipsoidPropertyType_sequence;	// resqml2_0_1ForGsoap.h:15933
class gml__EllipsoidPropertyType;	// resqml2_0_1ForGsoap.h:1614
union _gml__union_GeneralConversionPropertyType;	// resqml2_0_1ForGsoap.h:16006
class __gml__GeneralConversionPropertyType_sequence;	// resqml2_0_1ForGsoap.h:15994
class gml__GeneralConversionPropertyType;	// resqml2_0_1ForGsoap.h:1629
union _gml__union_CRSPropertyType;	// resqml2_0_1ForGsoap.h:16073
class __gml__CRSPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16062
class gml__CRSPropertyType;	// resqml2_0_1ForGsoap.h:1638
class __gml__GeodeticCRSPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16129
class gml__GeodeticCRSPropertyType;	// resqml2_0_1ForGsoap.h:1641
class __gml__VerticalCSPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16187
class gml__VerticalCSPropertyType;	// resqml2_0_1ForGsoap.h:1647
class __gml__VerticalDatumPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16248
class gml__VerticalDatumPropertyType;	// resqml2_0_1ForGsoap.h:1653
class __gml__domainOfValidity_sequence;	// resqml2_0_1ForGsoap.h:16310
class _gml__domainOfValidity;	// resqml2_0_1ForGsoap.h:1659
class _gml__secondDefiningParameter;	// resqml2_0_1ForGsoap.h:1662
union _gml__union_SecondDefiningParameter;	// resqml2_0_1ForGsoap.h:16402
class _gml__SecondDefiningParameter;	// resqml2_0_1ForGsoap.h:1665
union _gml__union_coordinateOperationAccuracy;	// resqml2_0_1ForGsoap.h:16435
class __gml__coordinateOperationAccuracy_sequence;	// resqml2_0_1ForGsoap.h:16427
class _gml__coordinateOperationAccuracy;	// resqml2_0_1ForGsoap.h:1668
union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:16512
class __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16504
class gmd__EX_USCOREGeographicExtent_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1674
class __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16567
class gmd__EX_USCORETemporalExtent_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1680
class __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16624
class gmd__EX_USCOREVerticalExtent_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1686
class __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16681
class gmd__MD_USCOREIdentifier_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1698
class __gmd__CI_USCORECitation_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16738
class gmd__CI_USCORECitation_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1704
class __gmd__CI_USCOREDate_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16795
class gmd__CI_USCOREDate_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1710
class __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16852
class gmd__CI_USCOREDateTypeCode_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1716
class __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16879
class gmd__CI_USCOREResponsibleParty_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1719
class __gmd__CI_USCOREContact_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16936
class gmd__CI_USCOREContact_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1725
class __gmd__CI_USCORETelephone_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:16993
class gmd__CI_USCORETelephone_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1731
class __gmd__CI_USCOREAddress_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17050
class gmd__CI_USCOREAddress_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1737
class __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17107
class gmd__CI_USCOREOnlineResource_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1743
class __gmd__URL_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17164
class gmd__URL_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1749
class __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17191
class gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1752
class __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17218
class gmd__CI_USCORERoleCode_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1755
class __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17245
class gmd__CI_USCOREPresentationFormCode_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1758
class __gmd__CI_USCORESeries_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17272
class gmd__CI_USCORESeries_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1761
class __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17329
class gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1767
union _gmd__union_DQ_USCOREResult_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:17364
class __gmd__DQ_USCOREResult_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17356
class gmd__DQ_USCOREResult_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1770
union _gts__union_TM_USCOREPrimitive_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:17438
class __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17427
class gts__TM_USCOREPrimitive_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1776
class gco__AbstractObject_USCOREType;	// resqml2_0_1ForGsoap.h:1779
union _gco__union_CharacterString_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:17554
class __gco__CharacterString_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17525
class gco__CharacterString_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1782
class __gco__Boolean_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17579
class gco__Boolean_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1785
class __gco__Real_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17606
class gco__Real_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1788
union _gco__union_Date_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:17641
class gco__Date_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1791
class __gco__DateTime_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17664
class gco__DateTime_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1797
union _gsr__union_SC_USCORECRS_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:17710
class __gsr__SC_USCORECRS_USCOREPropertyType_sequence;	// resqml2_0_1ForGsoap.h:17699
class gsr__SC_USCORECRS_USCOREPropertyType;	// resqml2_0_1ForGsoap.h:1800
class ptm__standardEnergisticsPropertyTypeSet;	// resqml2_0_1ForGsoap.h:1803
class ptm__standardEnergisticsPropertyType;	// resqml2_0_1ForGsoap.h:1806
class ptm__equivalentPropertyType;	// resqml2_0_1ForGsoap.h:1809
class resqml2__AbstractDoubleArray;	// resqml2_0_1ForGsoap.h:252
class resqml2__StringHdf5Array;	// resqml2_0_1ForGsoap.h:264
class resqml2__AbstractIntegerArray;	// resqml2_0_1ForGsoap.h:291
class resqml2__AbstractBooleanArray;	// resqml2_0_1ForGsoap.h:294
class resqml2__StandardPropertyKind;	// resqml2_0_1ForGsoap.h:300
class resqml2__LocalPropertyKind;	// resqml2_0_1ForGsoap.h:306
class resqml2__Point2dHdf5Array;	// resqml2_0_1ForGsoap.h:318
class resqml2__ParametricLineFromRepresentationLatticeArray;	// resqml2_0_1ForGsoap.h:324
class resqml2__Point3dLatticeArray;	// resqml2_0_1ForGsoap.h:327
class resqml2__Point3dZValueArray;	// resqml2_0_1ForGsoap.h:330
class resqml2__PointGeometry;	// resqml2_0_1ForGsoap.h:336
class resqml2__Point3dHdf5Array;	// resqml2_0_1ForGsoap.h:345
class resqml2__ParametricLineArray;	// resqml2_0_1ForGsoap.h:354
class resqml2__Point3dParametricArray;	// resqml2_0_1ForGsoap.h:357
class resqml2__AbstractPlaneGeometry;	// resqml2_0_1ForGsoap.h:369
class resqml2__AbstractParametricLineGeometry;	// resqml2_0_1ForGsoap.h:372
class resqml2__Point3dFromRepresentationLatticeArray;	// resqml2_0_1ForGsoap.h:375
class resqml2__Seismic3dCoordinates;	// resqml2_0_1ForGsoap.h:378
class resqml2__Seismic2dCoordinates;	// resqml2_0_1ForGsoap.h:384
class resqml2__Patch1d;	// resqml2_0_1ForGsoap.h:387
class resqml2__SplitNodePatch;	// resqml2_0_1ForGsoap.h:432
class resqml2__IjkParentWindow;	// resqml2_0_1ForGsoap.h:435
class resqml2__ColumnLayerParentWindow;	// resqml2_0_1ForGsoap.h:465
class resqml2__UnstructuredSubnodeTopology;	// resqml2_0_1ForGsoap.h:468
class resqml2__GpGridUnstructuredColumnLayerGridPatch;	// resqml2_0_1ForGsoap.h:471
class resqml2__SubnodePatch;	// resqml2_0_1ForGsoap.h:486
class resqml2__ColumnLayerSubnodeTopology;	// resqml2_0_1ForGsoap.h:489
class resqml2__TruncationCellPatch;	// resqml2_0_1ForGsoap.h:501
class resqml2__GpGridUnstructuredGridPatch;	// resqml2_0_1ForGsoap.h:504
class resqml2__CellParentWindow;	// resqml2_0_1ForGsoap.h:546
class resqml2__GpGridIjkGridPatch;	// resqml2_0_1ForGsoap.h:552
class resqml2__BinaryContactInterpretationPart;	// resqml2_0_1ForGsoap.h:600
class resqml2__ContactElementReference;	// resqml2_0_1ForGsoap.h:606
class resqml2__MultipleContactInterpretationPart;	// resqml2_0_1ForGsoap.h:627
class resqml2__NonSealedContactRepresentationPart;	// resqml2_0_1ForGsoap.h:777
class resqml2__SealedContactRepresentationPart;	// resqml2_0_1ForGsoap.h:780
class resqml2__Grid2dPatch;	// resqml2_0_1ForGsoap.h:834
class resqml2__PolylineSetPatch;	// resqml2_0_1ForGsoap.h:840
class resqml2__ContactRepresentationReference;	// resqml2_0_1ForGsoap.h:849
class resqml2__DataObjectParameter;	// resqml2_0_1ForGsoap.h:879
class resqml2__ObjectParameterKey;	// resqml2_0_1ForGsoap.h:882
class resqml2__StringParameter;	// resqml2_0_1ForGsoap.h:888
class resqml2__IntegerQuantityParameter;	// resqml2_0_1ForGsoap.h:894
class resqml2__TimeIndexParameterKey;	// resqml2_0_1ForGsoap.h:897
class resqml2__FloatingPointQuantityParameter;	// resqml2_0_1ForGsoap.h:900
class resqml2__TimeIndexParameter;	// resqml2_0_1ForGsoap.h:906
class resqml2__StreamlinePolylineSetPatch;	// resqml2_0_1ForGsoap.h:915
class eml__AbstractCitedDataObject;	// resqml2_0_1ForGsoap.h:945
class eml__VerticalCrsEpsgCode;	// resqml2_0_1ForGsoap.h:960
class eml__GmlVerticalCrsDefinition;	// resqml2_0_1ForGsoap.h:963
class eml__VerticalUnknownCrs;	// resqml2_0_1ForGsoap.h:966
class eml__ProjectedCrsEpsgCode;	// resqml2_0_1ForGsoap.h:981
class eml__GmlProjectedCrsDefinition;	// resqml2_0_1ForGsoap.h:984
class eml__ProjectedUnknownCrs;	// resqml2_0_1ForGsoap.h:987
class gml__DefinitionBaseType;	// resqml2_0_1ForGsoap.h:1536
class gml__StringOrRefType;	// resqml2_0_1ForGsoap.h:1542
class gml__CodeType;	// resqml2_0_1ForGsoap.h:1551
class gml__AbstractTimeObjectType;	// resqml2_0_1ForGsoap.h:1557
class gml__RelatedTimeType;	// resqml2_0_1ForGsoap.h:1560
class gml__MeasureType;	// resqml2_0_1ForGsoap.h:1611
class gmd__EX_USCOREExtent_USCOREType;	// resqml2_0_1ForGsoap.h:1671
class gmd__AbstractEX_USCOREGeographicExtent_USCOREType;	// resqml2_0_1ForGsoap.h:1677
class gmd__EX_USCORETemporalExtent_USCOREType;	// resqml2_0_1ForGsoap.h:1683
class gmd__EX_USCOREVerticalExtent_USCOREType;	// resqml2_0_1ForGsoap.h:1689
class gmd__AbstractDQ_USCOREElement_USCOREType;	// resqml2_0_1ForGsoap.h:1695
class gmd__MD_USCOREIdentifier_USCOREType;	// resqml2_0_1ForGsoap.h:1701
class gmd__CI_USCORECitation_USCOREType;	// resqml2_0_1ForGsoap.h:1707
class gmd__CI_USCOREDate_USCOREType;	// resqml2_0_1ForGsoap.h:1713
class gmd__CI_USCOREResponsibleParty_USCOREType;	// resqml2_0_1ForGsoap.h:1722
class gmd__CI_USCOREContact_USCOREType;	// resqml2_0_1ForGsoap.h:1728
class gmd__CI_USCORETelephone_USCOREType;	// resqml2_0_1ForGsoap.h:1734
class gmd__CI_USCOREAddress_USCOREType;	// resqml2_0_1ForGsoap.h:1740
class gmd__CI_USCOREOnlineResource_USCOREType;	// resqml2_0_1ForGsoap.h:1746
class gmd__CI_USCORESeries_USCOREType;	// resqml2_0_1ForGsoap.h:1764
class gmd__AbstractDQ_USCOREResult_USCOREType;	// resqml2_0_1ForGsoap.h:1773
class gco__CodeListValue_USCOREType;	// resqml2_0_1ForGsoap.h:1794
class resqml2__IntegerArrayFromBooleanMaskArray;	// resqml2_0_1ForGsoap.h:201
class resqml2__BooleanArrayFromIndexArray;	// resqml2_0_1ForGsoap.h:204
class resqml2__BooleanConstantArray;	// resqml2_0_1ForGsoap.h:207
class resqml2__IntegerConstantArray;	// resqml2_0_1ForGsoap.h:210
class resqml2__IntegerHdf5Array;	// resqml2_0_1ForGsoap.h:219
class resqml2__DoubleLatticeArray;	// resqml2_0_1ForGsoap.h:231
class resqml2__DoubleConstantArray;	// resqml2_0_1ForGsoap.h:234
class resqml2__DoubleHdf5Array;	// resqml2_0_1ForGsoap.h:237
class resqml2__IntegerLatticeArray;	// resqml2_0_1ForGsoap.h:255
class resqml2__BooleanHdf5Array;	// resqml2_0_1ForGsoap.h:267
class resqml2__IntegerRangeArray;	// resqml2_0_1ForGsoap.h:282
class resqml2__BooleanArrayFromDiscretePropertyArray;	// resqml2_0_1ForGsoap.h:312
class resqml2__ParametricLineGeometry;	// resqml2_0_1ForGsoap.h:321
class resqml2__HorizontalPlaneGeometry;	// resqml2_0_1ForGsoap.h:333
class resqml2__ParametricLineFromRepresentationGeometry;	// resqml2_0_1ForGsoap.h:351
class resqml2__TiltedPlaneGeometry;	// resqml2_0_1ForGsoap.h:366
class resqml2__SubRepresentationPatch;	// resqml2_0_1ForGsoap.h:396
class resqml2__ColumnSubnodePatch;	// resqml2_0_1ForGsoap.h:438
class resqml2__UniformSubnodePatch;	// resqml2_0_1ForGsoap.h:480
class resqml2__AbstractGridGeometry;	// resqml2_0_1ForGsoap.h:561
class resqml2__VariableSubnodePatch;	// resqml2_0_1ForGsoap.h:573
class resqml2__AbstractResqmlDataObject;	// resqml2_0_1ForGsoap.h:744
class resqml2__ContactPatch;	// resqml2_0_1ForGsoap.h:783
class resqml2__EdgePatch;	// resqml2_0_1ForGsoap.h:801
class resqml2__NodePatch;	// resqml2_0_1ForGsoap.h:813
class resqml2__TrianglePatch;	// resqml2_0_1ForGsoap.h:819
class eml__ProjectedCrs;	// resqml2_0_1ForGsoap.h:969
class eml__VerticalCrs;	// resqml2_0_1ForGsoap.h:972
class eml__obj_USCOREEpcExternalPartReference;	// resqml2_0_1ForGsoap.h:993
class eml__PressureSquaredMeasure;	// resqml2_0_1ForGsoap.h:999
class eml__ForceLengthPerLengthMeasure;	// resqml2_0_1ForGsoap.h:1002
class eml__AmountOfSubstancePerTimePerAreaMeasure;	// resqml2_0_1ForGsoap.h:1005
class eml__VolumePerTimePerAreaMeasure;	// resqml2_0_1ForGsoap.h:1008
class eml__LengthPerLengthMeasure;	// resqml2_0_1ForGsoap.h:1011
class eml__TemperatureIntervalMeasure;	// resqml2_0_1ForGsoap.h:1014
class eml__VolumePerTimePerLengthMeasure;	// resqml2_0_1ForGsoap.h:1017
class eml__VolumePerTimePerTimeMeasure;	// resqml2_0_1ForGsoap.h:1020
class eml__PermeabilityLengthMeasure;	// resqml2_0_1ForGsoap.h:1023
class eml__ThermalInsulanceMeasure;	// resqml2_0_1ForGsoap.h:1026
class eml__ForceAreaMeasure;	// resqml2_0_1ForGsoap.h:1029
class eml__EnergyMeasure;	// resqml2_0_1ForGsoap.h:1032
class eml__IlluminanceMeasure;	// resqml2_0_1ForGsoap.h:1035
class eml__ForceMeasure;	// resqml2_0_1ForGsoap.h:1038
class eml__RadiantIntensityMeasure;	// resqml2_0_1ForGsoap.h:1041
class eml__PowerPerPowerMeasure;	// resqml2_0_1ForGsoap.h:1044
class eml__DimensionlessMeasure;	// resqml2_0_1ForGsoap.h:1047
class eml__HeatTransferCoefficientMeasure;	// resqml2_0_1ForGsoap.h:1050
class eml__APINeutronMeasure;	// resqml2_0_1ForGsoap.h:1053
class eml__MagneticVectorPotentialMeasure;	// resqml2_0_1ForGsoap.h:1056
class eml__LinearAccelerationMeasure;	// resqml2_0_1ForGsoap.h:1059
class eml__VolumePerTimeMeasure;	// resqml2_0_1ForGsoap.h:1062
class eml__MagneticFluxMeasure;	// resqml2_0_1ForGsoap.h:1065
class eml__VolumetricThermalExpansionMeasure;	// resqml2_0_1ForGsoap.h:1068
class eml__HeatFlowRateMeasure;	// resqml2_0_1ForGsoap.h:1071
class eml__MassPerTimeMeasure;	// resqml2_0_1ForGsoap.h:1074
class eml__VolumePerMassMeasure;	// resqml2_0_1ForGsoap.h:1077
class eml__MolarVolumeMeasure;	// resqml2_0_1ForGsoap.h:1080
class eml__ElectricConductanceMeasure;	// resqml2_0_1ForGsoap.h:1083
class eml__ReciprocalPressureMeasure;	// resqml2_0_1ForGsoap.h:1086
class eml__AreaPerAmountOfSubstanceMeasure;	// resqml2_0_1ForGsoap.h:1089
class eml__LengthMeasure;	// resqml2_0_1ForGsoap.h:1092
class eml__MassPerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1095
class eml__TemperatureIntervalPerLengthMeasure;	// resqml2_0_1ForGsoap.h:1098
class eml__AmountOfSubstancePerAreaMeasure;	// resqml2_0_1ForGsoap.h:1101
class eml__AmountOfSubstanceMeasure;	// resqml2_0_1ForGsoap.h:1104
class eml__TimePerLengthMeasure;	// resqml2_0_1ForGsoap.h:1107
class eml__ReciprocalMassTimeMeasure;	// resqml2_0_1ForGsoap.h:1110
class eml__ReciprocalVolumeMeasure;	// resqml2_0_1ForGsoap.h:1113
class eml__ForcePerForceMeasure;	// resqml2_0_1ForGsoap.h:1116
class eml__LinearThermalExpansionMeasure;	// resqml2_0_1ForGsoap.h:1119
class eml__EnergyPerLengthMeasure;	// resqml2_0_1ForGsoap.h:1122
class eml__TemperatureIntervalPerTimeMeasure;	// resqml2_0_1ForGsoap.h:1125
class eml__ThermalConductanceMeasure;	// resqml2_0_1ForGsoap.h:1128
class eml__SolidAngleMeasure;	// resqml2_0_1ForGsoap.h:1131
class eml__EnergyLengthPerTimeAreaTemperatureMeasure;	// resqml2_0_1ForGsoap.h:1134
class eml__PowerMeasure;	// resqml2_0_1ForGsoap.h:1137
class eml__VolumePerRotationMeasure;	// resqml2_0_1ForGsoap.h:1140
class eml__ElectricChargePerAreaMeasure;	// resqml2_0_1ForGsoap.h:1143
class eml__LightExposureMeasure;	// resqml2_0_1ForGsoap.h:1146
class eml__ElectricCurrentMeasure;	// resqml2_0_1ForGsoap.h:1149
class eml__LuminousFluxMeasure;	// resqml2_0_1ForGsoap.h:1152
class eml__HeatCapacityMeasure;	// resqml2_0_1ForGsoap.h:1155
class eml__ElectricResistancePerLengthMeasure;	// resqml2_0_1ForGsoap.h:1158
class eml__AbsorbedDoseMeasure;	// resqml2_0_1ForGsoap.h:1161
class eml__TemperatureIntervalPerPressureMeasure;	// resqml2_0_1ForGsoap.h:1164
class eml__AttenuationPerFrequencyIntervalMeasure;	// resqml2_0_1ForGsoap.h:1167
class eml__ThermalResistanceMeasure;	// resqml2_0_1ForGsoap.h:1170
class eml__AnglePerLengthMeasure;	// resqml2_0_1ForGsoap.h:1173
class eml__LengthPerTimeMeasure;	// resqml2_0_1ForGsoap.h:1176
class eml__MassPerLengthMeasure;	// resqml2_0_1ForGsoap.h:1179
class eml__EnergyPerAreaMeasure;	// resqml2_0_1ForGsoap.h:1182
class eml__AreaPerAreaMeasure;	// resqml2_0_1ForGsoap.h:1185
class eml__ReluctanceMeasure;	// resqml2_0_1ForGsoap.h:1188
class eml__ThermodynamicTemperatureMeasure;	// resqml2_0_1ForGsoap.h:1191
class eml__PermittivityMeasure;	// resqml2_0_1ForGsoap.h:1194
class eml__PressureTimePerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1197
class eml__DipoleMomentMeasure;	// resqml2_0_1ForGsoap.h:1200
class eml__RadianceMeasure;	// resqml2_0_1ForGsoap.h:1203
class eml__AreaPerMassMeasure;	// resqml2_0_1ForGsoap.h:1206
class eml__EnergyPerMassPerTimeMeasure;	// resqml2_0_1ForGsoap.h:1209
class eml__ElectricCurrentDensityMeasure;	// resqml2_0_1ForGsoap.h:1212
class eml__MassPerMassMeasure;	// resqml2_0_1ForGsoap.h:1215
class eml__DataTransferSpeedMeasure;	// resqml2_0_1ForGsoap.h:1218
class eml__MagneticDipoleMomentMeasure;	// resqml2_0_1ForGsoap.h:1221
class eml__MassPerEnergyMeasure;	// resqml2_0_1ForGsoap.h:1224
class eml__MagneticPermeabilityMeasure;	// resqml2_0_1ForGsoap.h:1227
class eml__APIGravityMeasure;	// resqml2_0_1ForGsoap.h:1230
class eml__VolumePerLengthMeasure;	// resqml2_0_1ForGsoap.h:1233
class eml__VolumeMeasure;	// resqml2_0_1ForGsoap.h:1236
class eml__VolumePerTimePerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1239
class eml__VolumePerTimePerPressureMeasure;	// resqml2_0_1ForGsoap.h:1242
class eml__TimeMeasure;	// resqml2_0_1ForGsoap.h:1245
class eml__MomentOfForceMeasure;	// resqml2_0_1ForGsoap.h:1248
class eml__LuminanceMeasure;	// resqml2_0_1ForGsoap.h:1251
class eml__ForcePerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1254
class eml__MolarHeatCapacityMeasure;	// resqml2_0_1ForGsoap.h:1257
class eml__DigitalStorageMeasure;	// resqml2_0_1ForGsoap.h:1260
class eml__ElectricChargeMeasure;	// resqml2_0_1ForGsoap.h:1263
class eml__LuminousIntensityMeasure;	// resqml2_0_1ForGsoap.h:1266
class eml__MolarEnergyMeasure;	// resqml2_0_1ForGsoap.h:1269
class eml__LengthPerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1272
class eml__SecondMomentOfAreaMeasure;	// resqml2_0_1ForGsoap.h:1275
class eml__MagneticFluxDensityMeasure;	// resqml2_0_1ForGsoap.h:1278
class eml__VolumePerAreaMeasure;	// resqml2_0_1ForGsoap.h:1281
class eml__QuantityOfLightMeasure;	// resqml2_0_1ForGsoap.h:1284
class eml__LuminousEfficacyMeasure;	// resqml2_0_1ForGsoap.h:1287
class eml__AreaPerTimeMeasure;	// resqml2_0_1ForGsoap.h:1290
class eml__VolumeFlowRatePerVolumeFlowRateMeasure;	// resqml2_0_1ForGsoap.h:1293
class eml__MomentumMeasure;	// resqml2_0_1ForGsoap.h:1296
class eml__PowerPerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1299
class eml__ThermalDiffusivityMeasure;	// resqml2_0_1ForGsoap.h:1302
class eml__LogarithmicPowerRatioPerLengthMeasure;	// resqml2_0_1ForGsoap.h:1305
class eml__ReciprocalTimeMeasure;	// resqml2_0_1ForGsoap.h:1308
class eml__SpecificHeatCapacityMeasure;	// resqml2_0_1ForGsoap.h:1311
class eml__PotentialDifferencePerPowerDropMeasure;	// resqml2_0_1ForGsoap.h:1314
class eml__MomentOfInertiaMeasure;	// resqml2_0_1ForGsoap.h:1317
class eml__MassPerTimePerLengthMeasure;	// resqml2_0_1ForGsoap.h:1320
class eml__MolecularWeightMeasure;	// resqml2_0_1ForGsoap.h:1323
class eml__ActivityOfRadioactivityMeasure;	// resqml2_0_1ForGsoap.h:1326
class eml__SignalingEventPerTimeMeasure;	// resqml2_0_1ForGsoap.h:1329
class eml__FrequencyMeasure;	// resqml2_0_1ForGsoap.h:1332
class eml__FrequencyIntervalMeasure;	// resqml2_0_1ForGsoap.h:1335
class eml__CapacitanceMeasure;	// resqml2_0_1ForGsoap.h:1338
class eml__ElectricalResistivityMeasure;	// resqml2_0_1ForGsoap.h:1341
class eml__MassLengthMeasure;	// resqml2_0_1ForGsoap.h:1344
class eml__ReciprocalAreaMeasure;	// resqml2_0_1ForGsoap.h:1347
class eml__KinematicViscosityMeasure;	// resqml2_0_1ForGsoap.h:1350
class eml__InductanceMeasure;	// resqml2_0_1ForGsoap.h:1353
class eml__TimePerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1356
class eml__ElectromagneticMomentMeasure;	// resqml2_0_1ForGsoap.h:1359
class eml__EnergyPerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1362
class eml__ElectricChargePerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1365
class eml__VolumetricHeatTransferCoefficientMeasure;	// resqml2_0_1ForGsoap.h:1368
class eml__PressurePerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1371
class eml__TimePerMassMeasure;	// resqml2_0_1ForGsoap.h:1374
class eml__ReciprocalLengthMeasure;	// resqml2_0_1ForGsoap.h:1377
class eml__DynamicViscosityMeasure;	// resqml2_0_1ForGsoap.h:1380
class eml__ReciprocalElectricPotentialDifferenceMeasure;	// resqml2_0_1ForGsoap.h:1383
class eml__ElectricChargePerMassMeasure;	// resqml2_0_1ForGsoap.h:1386
class eml__APIGammaRayMeasure;	// resqml2_0_1ForGsoap.h:1389
class eml__DiffusionCoefficientMeasure;	// resqml2_0_1ForGsoap.h:1392
class eml__ElectricPotentialDifferenceMeasure;	// resqml2_0_1ForGsoap.h:1395
class eml__IsothermalCompressibilityMeasure;	// resqml2_0_1ForGsoap.h:1398
class eml__MassPerVolumePerLengthMeasure;	// resqml2_0_1ForGsoap.h:1401
class eml__PressurePerTimeMeasure;	// resqml2_0_1ForGsoap.h:1404
class eml__ForcePerLengthMeasure;	// resqml2_0_1ForGsoap.h:1407
class eml__AmountOfSubstancePerTimeMeasure;	// resqml2_0_1ForGsoap.h:1410
class eml__LengthPerTemperatureMeasure;	// resqml2_0_1ForGsoap.h:1413
class eml__VolumePerTimeLengthMeasure;	// resqml2_0_1ForGsoap.h:1416
class eml__PressureSquaredPerForceTimePerAreaMeasure;	// resqml2_0_1ForGsoap.h:1419
class eml__AnglePerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1422
class eml__LengthPerPressureMeasure;	// resqml2_0_1ForGsoap.h:1425
class eml__ThermalConductivityMeasure;	// resqml2_0_1ForGsoap.h:1428
class eml__MassMeasure;	// resqml2_0_1ForGsoap.h:1431
class eml__NormalizedPowerMeasure;	// resqml2_0_1ForGsoap.h:1434
class eml__LogarithmicPowerRatioMeasure;	// resqml2_0_1ForGsoap.h:1437
class eml__AngularAccelerationMeasure;	// resqml2_0_1ForGsoap.h:1440
class eml__ReciprocalMassMeasure;	// resqml2_0_1ForGsoap.h:1443
class eml__ReciprocalForceMeasure;	// resqml2_0_1ForGsoap.h:1446
class eml__PlaneAngleMeasure;	// resqml2_0_1ForGsoap.h:1449
class eml__EnergyLengthPerAreaMeasure;	// resqml2_0_1ForGsoap.h:1452
class eml__EnergyPerMassMeasure;	// resqml2_0_1ForGsoap.h:1455
class eml__AngularVelocityMeasure;	// resqml2_0_1ForGsoap.h:1458
class eml__ElectricConductivityMeasure;	// resqml2_0_1ForGsoap.h:1461
class eml__AmountOfSubstancePerAmountOfSubstanceMeasure;	// resqml2_0_1ForGsoap.h:1464
class eml__ElectricFieldStrengthMeasure;	// resqml2_0_1ForGsoap.h:1467
class eml__PowerPerAreaMeasure;	// resqml2_0_1ForGsoap.h:1470
class eml__MagneticFluxDensityPerLengthMeasure;	// resqml2_0_1ForGsoap.h:1473
class eml__PressureMeasure;	// resqml2_0_1ForGsoap.h:1476
class eml__VolumePerTimePerPressureLengthMeasure;	// resqml2_0_1ForGsoap.h:1479
class eml__MagneticFieldStrengthMeasure;	// resqml2_0_1ForGsoap.h:1482
class eml__PermeabilityRockMeasure;	// resqml2_0_1ForGsoap.h:1485
class eml__DoseEquivalentMeasure;	// resqml2_0_1ForGsoap.h:1488
class eml__MassPerTimePerAreaMeasure;	// resqml2_0_1ForGsoap.h:1491
class eml__VolumePerPressureMeasure;	// resqml2_0_1ForGsoap.h:1494
class eml__MassPerAreaMeasure;	// resqml2_0_1ForGsoap.h:1497
class eml__AmountOfSubstancePerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1500
class eml__TimePerTimeMeasure;	// resqml2_0_1ForGsoap.h:1503
class eml__AreaPerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1506
class eml__ElectricResistanceMeasure;	// resqml2_0_1ForGsoap.h:1509
class eml__VolumePerVolumeMeasure;	// resqml2_0_1ForGsoap.h:1512
class eml__AreaMeasure;	// resqml2_0_1ForGsoap.h:1515
class eml__LengthPerMassMeasure;	// resqml2_0_1ForGsoap.h:1518
class eml__MobilityMeasure;	// resqml2_0_1ForGsoap.h:1521
class gml__DefinitionType;	// resqml2_0_1ForGsoap.h:1533
class gml__CodeWithAuthorityType;	// resqml2_0_1ForGsoap.h:1548
class gml__AbstractTimePrimitiveType;	// resqml2_0_1ForGsoap.h:1554
class gml__AngleType;	// resqml2_0_1ForGsoap.h:1608
class gml__LengthType;	// resqml2_0_1ForGsoap.h:1620
class gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType;	// resqml2_0_1ForGsoap.h:1692
class resqml2__obj_USCOREPropertyKind;	// resqml2_0_1ForGsoap.h:258
class resqml2__AbstractPropertyLookup;	// resqml2_0_1ForGsoap.h:279
class resqml2__obj_USCOREPropertySet;	// resqml2_0_1ForGsoap.h:285
class resqml2__AbstractProperty;	// resqml2_0_1ForGsoap.h:288
class resqml2__obj_USCORERepresentationIdentitySet;	// resqml2_0_1ForGsoap.h:408
class resqml2__AbstractRepresentation;	// resqml2_0_1ForGsoap.h:414
class resqml2__obj_USCORELocalGridSet;	// resqml2_0_1ForGsoap.h:444
class resqml2__UnstructuredGridGeometry;	// resqml2_0_1ForGsoap.h:537
class resqml2__AbstractColumnLayerGridGeometry;	// resqml2_0_1ForGsoap.h:582
class resqml2__AbstractFeatureInterpretation;	// resqml2_0_1ForGsoap.h:588
class resqml2__obj_USCOREStratigraphicColumn;	// resqml2_0_1ForGsoap.h:636
class resqml2__obj_USCOREGlobalChronostratigraphicColumn;	// resqml2_0_1ForGsoap.h:690
class resqml2__AbstractFeature;	// resqml2_0_1ForGsoap.h:711
class resqml2__AbstractLocal3dCrs;	// resqml2_0_1ForGsoap.h:729
class resqml2__obj_USCORETimeSeries;	// resqml2_0_1ForGsoap.h:741
class resqml2__obj_USCOREMdDatum;	// resqml2_0_1ForGsoap.h:762
class resqml2__WellboreMarker;	// resqml2_0_1ForGsoap.h:765
class resqml2__obj_USCOREActivity;	// resqml2_0_1ForGsoap.h:885
class resqml2__obj_USCOREActivityTemplate;	// resqml2_0_1ForGsoap.h:912
class gml__IdentifiedObjectType;	// resqml2_0_1ForGsoap.h:1530
class resqml2__obj_USCOREDoubleTableLookup;	// resqml2_0_1ForGsoap.h:213
class resqml2__obj_USCOREPointsProperty;	// resqml2_0_1ForGsoap.h:228
class resqml2__obj_USCOREStringTableLookup;	// resqml2_0_1ForGsoap.h:261
class resqml2__AbstractValuesProperty;	// resqml2_0_1ForGsoap.h:303
class resqml2__obj_USCORERepresentationSetRepresentation;	// resqml2_0_1ForGsoap.h:399
class resqml2__obj_USCORERedefinedGeometryRepresentation;	// resqml2_0_1ForGsoap.h:402
class resqml2__obj_USCORESubRepresentation;	// resqml2_0_1ForGsoap.h:420
class resqml2__AbstractGridRepresentation;	// resqml2_0_1ForGsoap.h:447
class resqml2__UnstructuredColumnLayerGridGeometry;	// resqml2_0_1ForGsoap.h:516
class resqml2__IjkGridGeometry;	// resqml2_0_1ForGsoap.h:519
class resqml2__obj_USCOREGridConnectionSetRepresentation;	// resqml2_0_1ForGsoap.h:558
class resqml2__AbstractOrganizationInterpretation;	// resqml2_0_1ForGsoap.h:597
class resqml2__obj_USCOREGenericFeatureInterpretation;	// resqml2_0_1ForGsoap.h:612
class resqml2__obj_USCOREWellboreInterpretation;	// resqml2_0_1ForGsoap.h:615
class resqml2__obj_USCOREBoundaryFeatureInterpretation;	// resqml2_0_1ForGsoap.h:642
class resqml2__obj_USCOREEarthModelInterpretation;	// resqml2_0_1ForGsoap.h:648
class resqml2__obj_USCOREGeologicUnitInterpretation;	// resqml2_0_1ForGsoap.h:666
class resqml2__AbstractGeologicFeature;	// resqml2_0_1ForGsoap.h:696
class resqml2__obj_USCORELocalTime3dCrs;	// resqml2_0_1ForGsoap.h:720
class resqml2__obj_USCORELocalDepth3dCrs;	// resqml2_0_1ForGsoap.h:738
class resqml2__obj_USCOREDeviationSurveyRepresentation;	// resqml2_0_1ForGsoap.h:753
class resqml2__obj_USCOREWellboreFrameRepresentation;	// resqml2_0_1ForGsoap.h:756
class resqml2__obj_USCOREWellboreTrajectoryRepresentation;	// resqml2_0_1ForGsoap.h:759
class resqml2__obj_USCOREPointSetRepresentation;	// resqml2_0_1ForGsoap.h:795
class resqml2__obj_USCOREPolylineSetRepresentation;	// resqml2_0_1ForGsoap.h:810
class resqml2__obj_USCOREPolylineRepresentation;	// resqml2_0_1ForGsoap.h:822
class resqml2__AbstractSurfaceRepresentation;	// resqml2_0_1ForGsoap.h:831
class resqml2__AbstractTechnicalFeature;	// resqml2_0_1ForGsoap.h:852
class resqml2__obj_USCOREStreamlinesRepresentation;	// resqml2_0_1ForGsoap.h:921
class gml__AbstractCRSType;	// resqml2_0_1ForGsoap.h:1527
class gml__AbstractCoordinateSystemType;	// resqml2_0_1ForGsoap.h:1572
class gml__CoordinateSystemAxisType;	// resqml2_0_1ForGsoap.h:1578
class gml__AbstractDatumType;	// resqml2_0_1ForGsoap.h:1599
class gml__PrimeMeridianType;	// resqml2_0_1ForGsoap.h:1605
class gml__EllipsoidType;	// resqml2_0_1ForGsoap.h:1617
class gml__AbstractCoordinateOperationType;	// resqml2_0_1ForGsoap.h:1635
class resqml2__obj_USCOREContinuousProperty;	// resqml2_0_1ForGsoap.h:222
class resqml2__obj_USCORECommentProperty;	// resqml2_0_1ForGsoap.h:243
class resqml2__obj_USCOREDiscreteProperty;	// resqml2_0_1ForGsoap.h:246
class resqml2__obj_USCORECategoricalProperty;	// resqml2_0_1ForGsoap.h:249
class resqml2__obj_USCOREUnstructuredGridRepresentation;	// resqml2_0_1ForGsoap.h:423
class resqml2__obj_USCOREGpGridRepresentation;	// resqml2_0_1ForGsoap.h:429
class resqml2__AbstractTruncatedColumnLayerGridRepresentation;	// resqml2_0_1ForGsoap.h:525
class resqml2__AbstractColumnLayerGridRepresentation;	// resqml2_0_1ForGsoap.h:549
class resqml2__obj_USCORERockFluidOrganizationInterpretation;	// resqml2_0_1ForGsoap.h:591
class resqml2__obj_USCORERockFluidUnitInterpretation;	// resqml2_0_1ForGsoap.h:609
class resqml2__obj_USCOREGeobodyBoundaryInterpretation;	// resqml2_0_1ForGsoap.h:621
class resqml2__obj_USCOREStructuralOrganizationInterpretation;	// resqml2_0_1ForGsoap.h:624
class resqml2__obj_USCOREFaultInterpretation;	// resqml2_0_1ForGsoap.h:633
class resqml2__obj_USCOREGeobodyInterpretation;	// resqml2_0_1ForGsoap.h:639
class resqml2__AbstractStratigraphicOrganizationInterpretation;	// resqml2_0_1ForGsoap.h:657
class resqml2__obj_USCOREHorizonInterpretation;	// resqml2_0_1ForGsoap.h:663
class resqml2__obj_USCOREStratigraphicUnitInterpretation;	// resqml2_0_1ForGsoap.h:669
class resqml2__obj_USCOREGeologicUnitFeature;	// resqml2_0_1ForGsoap.h:678
class resqml2__obj_USCOREBoundaryFeature;	// resqml2_0_1ForGsoap.h:684
class resqml2__obj_USCOREOrganizationFeature;	// resqml2_0_1ForGsoap.h:705
class resqml2__obj_USCOREBlockedWellboreRepresentation;	// resqml2_0_1ForGsoap.h:747
class resqml2__obj_USCOREWellboreMarkerFrameRepresentation;	// resqml2_0_1ForGsoap.h:768
class resqml2__obj_USCORETriangulatedSetRepresentation;	// resqml2_0_1ForGsoap.h:774
class resqml2__obj_USCOREPlaneSetRepresentation;	// resqml2_0_1ForGsoap.h:786
class resqml2__AbstractSurfaceFrameworkRepresentation;	// resqml2_0_1ForGsoap.h:792
class resqml2__obj_USCORESealedVolumeFrameworkRepresentation;	// resqml2_0_1ForGsoap.h:798
class resqml2__obj_USCOREGrid2dRepresentation;	// resqml2_0_1ForGsoap.h:825
class resqml2__obj_USCOREGrid2dSetRepresentation;	// resqml2_0_1ForGsoap.h:837
class resqml2__obj_USCOREFrontierFeature;	// resqml2_0_1ForGsoap.h:855
class resqml2__obj_USCOREWellboreFeature;	// resqml2_0_1ForGsoap.h:864
class resqml2__AbstractSeismicSurveyFeature;	// resqml2_0_1ForGsoap.h:873
class resqml2__obj_USCOREStreamlinesFeature;	// resqml2_0_1ForGsoap.h:918
union _gml__union_GeodeticCRSType;	// resqml2_0_1ForGsoap.h:29522
class gml__GeodeticCRSType;	// resqml2_0_1ForGsoap.h:1524
class gml__EllipsoidalCSType;	// resqml2_0_1ForGsoap.h:1569
class gml__CartesianCSType;	// resqml2_0_1ForGsoap.h:1584
class gml__SphericalCSType;	// resqml2_0_1ForGsoap.h:1590
class gml__GeodeticDatumType;	// resqml2_0_1ForGsoap.h:1596
class gml__AbstractGeneralDerivedCRSType;	// resqml2_0_1ForGsoap.h:1626
class gml__AbstractGeneralConversionType;	// resqml2_0_1ForGsoap.h:1632
class gml__VerticalCRSType;	// resqml2_0_1ForGsoap.h:1644
class gml__VerticalCSType;	// resqml2_0_1ForGsoap.h:1650
class gml__VerticalDatumType;	// resqml2_0_1ForGsoap.h:1656
class resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation;	// resqml2_0_1ForGsoap.h:456
class resqml2__obj_USCOREIjkGridRepresentation;	// resqml2_0_1ForGsoap.h:462
class resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation;	// resqml2_0_1ForGsoap.h:543
class resqml2__obj_USCORETruncatedIjkGridRepresentation;	// resqml2_0_1ForGsoap.h:555
class resqml2__obj_USCOREStratigraphicColumnRankInterpretation;	// resqml2_0_1ForGsoap.h:654
class resqml2__obj_USCOREStratigraphicOccurrenceInterpretation;	// resqml2_0_1ForGsoap.h:672
class resqml2__obj_USCOREFluidBoundaryFeature;	// resqml2_0_1ForGsoap.h:675
class resqml2__obj_USCORERockFluidUnitFeature;	// resqml2_0_1ForGsoap.h:681
class resqml2__obj_USCOREStratigraphicUnitFeature;	// resqml2_0_1ForGsoap.h:693
class resqml2__obj_USCOREGeneticBoundaryFeature;	// resqml2_0_1ForGsoap.h:699
class resqml2__obj_USCOREGeobodyFeature;	// resqml2_0_1ForGsoap.h:702
class resqml2__obj_USCORETectonicBoundaryFeature;	// resqml2_0_1ForGsoap.h:708
class resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation;	// resqml2_0_1ForGsoap.h:771
class resqml2__obj_USCORESealedSurfaceFrameworkRepresentation;	// resqml2_0_1ForGsoap.h:816
class resqml2__SeismicLatticeSetFeature;	// resqml2_0_1ForGsoap.h:858
class resqml2__obj_USCORESeismicLineSetFeature;	// resqml2_0_1ForGsoap.h:861
class resqml2__obj_USCORESeismicLineFeature;	// resqml2_0_1ForGsoap.h:867
class resqml2__obj_USCORESeismicLatticeFeature;	// resqml2_0_1ForGsoap.h:870
class resqml2__obj_USCOREContinuousPropertySeries;	// resqml2_0_1ForGsoap.h:933
class resqml2__obj_USCORECategoricalPropertySeries;	// resqml2_0_1ForGsoap.h:936
class resqml2__obj_USCORECommentPropertySeries;	// resqml2_0_1ForGsoap.h:939
class resqml2__obj_USCOREDiscretePropertySeries;	// resqml2_0_1ForGsoap.h:942
union _gml__union_ProjectedCRSType;	// resqml2_0_1ForGsoap.h:31102
class gml__ProjectedCRSType;	// resqml2_0_1ForGsoap.h:1623

/* resqml2_0_1ForGsoap.h:216 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyKindFacet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyKindFacet (27)
/* resqml2:PropertyKindFacet complex type: */
class SOAP_CMAC resqml2__PropertyKindFacet
{
public:
	enum resqml2__Facet Facet;	/* required element of XSD type resqml2:Facet */
	std::string Value;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyKindFacet (27)
	virtual int soap_type(void) const { return 27; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__PropertyKindFacet, default initialized and not managed by a soap context
	virtual resqml2__PropertyKindFacet *soap_alloc(void) const { return SOAP_NEW(resqml2__PropertyKindFacet); }
	         resqml2__PropertyKindFacet() { resqml2__PropertyKindFacet::soap_default(NULL); }
	virtual ~resqml2__PropertyKindFacet() { }
	friend resqml2__PropertyKindFacet *soap_instantiate_resqml2__PropertyKindFacet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:225 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringLookup (30)
/* resqml2:StringLookup complex type: */
class SOAP_CMAC resqml2__StringLookup
{
public:
	LONG64 Key;	/* required element of XSD type xsd:integer */
	std::string Value;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringLookup (30)
	virtual int soap_type(void) const { return 30; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__StringLookup, default initialized and not managed by a soap context
	virtual resqml2__StringLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__StringLookup); }
	         resqml2__StringLookup() { resqml2__StringLookup::soap_default(NULL); }
	virtual ~resqml2__StringLookup() { }
	friend resqml2__StringLookup *soap_instantiate_resqml2__StringLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:240 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfPoints (35)
/* resqml2:PatchOfPoints complex type: */
class SOAP_CMAC resqml2__PatchOfPoints
{
public:
	ULONG64 *RepresentationPatchIndex;	/* optional element of XSD type xsd:nonNegativeInteger */
	resqml2__AbstractPoint3dArray *Points;	/* required element of XSD type resqml2:AbstractPoint3dArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfPoints (35)
	virtual int soap_type(void) const { return 35; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__PatchOfPoints, default initialized and not managed by a soap context
	virtual resqml2__PatchOfPoints *soap_alloc(void) const { return SOAP_NEW(resqml2__PatchOfPoints); }
	         resqml2__PatchOfPoints() { resqml2__PatchOfPoints::soap_default(NULL); }
	virtual ~resqml2__PatchOfPoints() { }
	friend resqml2__PatchOfPoints *soap_instantiate_resqml2__PatchOfPoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:270 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyKind (45)
/* Type resqml2__AbstractPropertyKind is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractPropertyKind complex type: */
class SOAP_CMAC resqml2__AbstractPropertyKind
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyKind (45)
	virtual int soap_type(void) const { return 45; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractPropertyKind, default initialized and not managed by a soap context
	virtual resqml2__AbstractPropertyKind *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractPropertyKind); }
	         resqml2__AbstractPropertyKind() { resqml2__AbstractPropertyKind::soap_default(NULL); }
	virtual ~resqml2__AbstractPropertyKind() { }
	friend resqml2__AbstractPropertyKind *soap_instantiate_resqml2__AbstractPropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:273 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfValues
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfValues (46)
/* resqml2:PatchOfValues complex type: */
class SOAP_CMAC resqml2__PatchOfValues
{
public:
	ULONG64 *RepresentationPatchIndex;	/* optional element of XSD type xsd:nonNegativeInteger */
	resqml2__AbstractValueArray *Values;	/* required element of XSD type resqml2:AbstractValueArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfValues (46)
	virtual int soap_type(void) const { return 46; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__PatchOfValues, default initialized and not managed by a soap context
	virtual resqml2__PatchOfValues *soap_alloc(void) const { return SOAP_NEW(resqml2__PatchOfValues); }
	         resqml2__PatchOfValues() { resqml2__PatchOfValues::soap_default(NULL); }
	virtual ~resqml2__PatchOfValues() { }
	friend resqml2__PatchOfValues *soap_instantiate_resqml2__PatchOfValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:276 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValueArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValueArray (47)
/* Type resqml2__AbstractValueArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractValueArray complex type: */
class SOAP_CMAC resqml2__AbstractValueArray
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValueArray (47)
	virtual int soap_type(void) const { return 47; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractValueArray, default initialized and not managed by a soap context
	virtual resqml2__AbstractValueArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractValueArray); }
	         resqml2__AbstractValueArray() { resqml2__AbstractValueArray::soap_default(NULL); }
	virtual ~resqml2__AbstractValueArray() { }
	friend resqml2__AbstractValueArray *soap_instantiate_resqml2__AbstractValueArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:297 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyValuesPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyValuesPatch (54)
/* resqml2:PropertyValuesPatch complex type: */
class SOAP_CMAC resqml2__PropertyValuesPatch
{
public:
	ULONG64 patchUid;	/* required element of XSD type xsd:nonNegativeInteger */
	resqml2__AbstractValueArray *values;	/* required element of XSD type resqml2:AbstractValueArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyValuesPatch (54)
	virtual int soap_type(void) const { return 54; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__PropertyValuesPatch, default initialized and not managed by a soap context
	virtual resqml2__PropertyValuesPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__PropertyValuesPatch); }
	         resqml2__PropertyValuesPatch() { resqml2__PropertyValuesPatch::soap_default(NULL); }
	virtual ~resqml2__PropertyValuesPatch() { }
	friend resqml2__PropertyValuesPatch *soap_instantiate_resqml2__PropertyValuesPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:309 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLookup (58)
/* resqml2:DoubleLookup complex type: */
class SOAP_CMAC resqml2__DoubleLookup
{
public:
	double Key;	/* required element of XSD type xsd:double */
	double Value;	/* required element of XSD type xsd:double */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLookup (58)
	virtual int soap_type(void) const { return 58; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__DoubleLookup, default initialized and not managed by a soap context
	virtual resqml2__DoubleLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__DoubleLookup); }
	         resqml2__DoubleLookup() { resqml2__DoubleLookup::soap_default(NULL); }
	virtual ~resqml2__DoubleLookup() { }
	friend resqml2__DoubleLookup *soap_instantiate_resqml2__DoubleLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:315 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dOffset
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dOffset (60)
/* resqml2:Point3dOffset complex type: */
class SOAP_CMAC resqml2__Point3dOffset
{
public:
	resqml2__Point3d *Offset;	/* required element of XSD type resqml2:Point3d */
	resqml2__AbstractDoubleArray *Spacing;	/* required element of XSD type resqml2:AbstractDoubleArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dOffset (60)
	virtual int soap_type(void) const { return 60; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Point3dOffset, default initialized and not managed by a soap context
	virtual resqml2__Point3dOffset *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dOffset); }
	         resqml2__Point3dOffset() { resqml2__Point3dOffset::soap_default(NULL); }
	virtual ~resqml2__Point3dOffset() { }
	friend resqml2__Point3dOffset *soap_instantiate_resqml2__Point3dOffset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:339 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPoint3dArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPoint3dArray (68)
/* Type resqml2__AbstractPoint3dArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractPoint3dArray complex type: */
class SOAP_CMAC resqml2__AbstractPoint3dArray
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPoint3dArray (68)
	virtual int soap_type(void) const { return 68; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractPoint3dArray, default initialized and not managed by a soap context
	virtual resqml2__AbstractPoint3dArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractPoint3dArray); }
	         resqml2__AbstractPoint3dArray() { resqml2__AbstractPoint3dArray::soap_default(NULL); }
	virtual ~resqml2__AbstractPoint3dArray() { }
	friend resqml2__AbstractPoint3dArray *soap_instantiate_resqml2__AbstractPoint3dArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:342 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeometry (69)
/* Type resqml2__AbstractGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractGeometry complex type: */
class SOAP_CMAC resqml2__AbstractGeometry
{
public:
	resqml2__TimeIndex *TimeIndex;	/* optional element of XSD type resqml2:TimeIndex */
	eml__DataObjectReference *LocalCrs;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeometry (69)
	virtual int soap_type(void) const { return 69; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractGeometry, default initialized and not managed by a soap context
	virtual resqml2__AbstractGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractGeometry); }
	         resqml2__AbstractGeometry() { resqml2__AbstractGeometry::soap_default(NULL); }
	virtual ~resqml2__AbstractGeometry() { }
	friend resqml2__AbstractGeometry *soap_instantiate_resqml2__AbstractGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:348 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThreePoint3d
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThreePoint3d (71)
/* resqml2:ThreePoint3d complex type: */
class SOAP_CMAC resqml2__ThreePoint3d
{
public:
	std::vector<resqml2__Point3d *> Point3d;	/* required element of XSD type resqml2:Point3d */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThreePoint3d (71)
	virtual int soap_type(void) const { return 71; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ThreePoint3d, default initialized and not managed by a soap context
	virtual resqml2__ThreePoint3d *soap_alloc(void) const { return SOAP_NEW(resqml2__ThreePoint3d); }
	         resqml2__ThreePoint3d() { resqml2__ThreePoint3d::soap_default(NULL); }
	virtual ~resqml2__ThreePoint3d() { }
	friend resqml2__ThreePoint3d *soap_instantiate_resqml2__ThreePoint3d(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:360 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineArray (75)
/* Type resqml2__AbstractParametricLineArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractParametricLineArray complex type: */
class SOAP_CMAC resqml2__AbstractParametricLineArray
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineArray (75)
	virtual int soap_type(void) const { return 75; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractParametricLineArray, default initialized and not managed by a soap context
	virtual resqml2__AbstractParametricLineArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractParametricLineArray); }
	         resqml2__AbstractParametricLineArray() { resqml2__AbstractParametricLineArray::soap_default(NULL); }
	virtual ~resqml2__AbstractParametricLineArray() { }
	friend resqml2__AbstractParametricLineArray *soap_instantiate_resqml2__AbstractParametricLineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:363 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineIntersections
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineIntersections (76)
/* resqml2:ParametricLineIntersections complex type: */
class SOAP_CMAC resqml2__ParametricLineIntersections
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *IntersectionLinePairs;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractValueArray *ParameterValuePairs;	/* required element of XSD type resqml2:AbstractValueArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineIntersections (76)
	virtual int soap_type(void) const { return 76; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ParametricLineIntersections, default initialized and not managed by a soap context
	virtual resqml2__ParametricLineIntersections *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineIntersections); }
	         resqml2__ParametricLineIntersections() { resqml2__ParametricLineIntersections::soap_default(NULL); }
	virtual ~resqml2__ParametricLineIntersections() { }
	friend resqml2__ParametricLineIntersections *soap_instantiate_resqml2__ParametricLineIntersections(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:381 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicCoordinates (82)
/* Type resqml2__AbstractSeismicCoordinates is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractSeismicCoordinates complex type: */
class SOAP_CMAC resqml2__AbstractSeismicCoordinates
{
public:
	eml__DataObjectReference *SeismicSupport;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicCoordinates (82)
	virtual int soap_type(void) const { return 82; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractSeismicCoordinates, default initialized and not managed by a soap context
	virtual resqml2__AbstractSeismicCoordinates *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractSeismicCoordinates); }
	         resqml2__AbstractSeismicCoordinates() { resqml2__AbstractSeismicCoordinates::soap_default(NULL); }
	virtual ~resqml2__AbstractSeismicCoordinates() { }
	friend resqml2__AbstractSeismicCoordinates *soap_instantiate_resqml2__AbstractSeismicCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:390 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch (85)
/* Type resqml2__Patch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Patch complex type: */
class SOAP_CMAC resqml2__Patch
{
public:
	ULONG64 PatchIndex;	/* required element of XSD type xsd:nonNegativeInteger */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch (85)
	virtual int soap_type(void) const { return 85; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Patch, default initialized and not managed by a soap context
	virtual resqml2__Patch *soap_alloc(void) const { return SOAP_NEW(resqml2__Patch); }
	         resqml2__Patch() { resqml2__Patch::soap_default(NULL); }
	virtual ~resqml2__Patch() { }
	friend resqml2__Patch *soap_instantiate_resqml2__Patch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:393 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIndices
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIndices (86)
/* resqml2:ElementIndices complex type: */
class SOAP_CMAC resqml2__ElementIndices
{
public:
	enum resqml2__IndexableElements IndexableElement;	/* required element of XSD type resqml2:IndexableElements */
	resqml2__AbstractIntegerArray *Indices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIndices (86)
	virtual int soap_type(void) const { return 86; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ElementIndices, default initialized and not managed by a soap context
	virtual resqml2__ElementIndices *soap_alloc(void) const { return SOAP_NEW(resqml2__ElementIndices); }
	         resqml2__ElementIndices() { resqml2__ElementIndices::soap_default(NULL); }
	virtual ~resqml2__ElementIndices() { }
	friend resqml2__ElementIndices *soap_instantiate_resqml2__ElementIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:405 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RepresentationIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RepresentationIdentity (90)
/* resqml2:RepresentationIdentity complex type: */
class SOAP_CMAC resqml2__RepresentationIdentity
{
public:
	ULONG64 IdenticalElementCount;	/* required element of XSD type xsd:positiveInteger */
	std::vector<resqml2__ElementIdentity *> ElementIdentity;	/* required element of XSD type resqml2:ElementIdentity */
	resqml2__AdditionalGridTopology *AdditionalGridTopology;	/* optional element of XSD type resqml2:AdditionalGridTopology */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RepresentationIdentity (90)
	virtual int soap_type(void) const { return 90; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__RepresentationIdentity, default initialized and not managed by a soap context
	virtual resqml2__RepresentationIdentity *soap_alloc(void) const { return SOAP_NEW(resqml2__RepresentationIdentity); }
	         resqml2__RepresentationIdentity() { resqml2__RepresentationIdentity::soap_default(NULL); }
	virtual ~resqml2__RepresentationIdentity() { }
	friend resqml2__RepresentationIdentity *soap_instantiate_resqml2__RepresentationIdentity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:411 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIdentity (92)
/* resqml2:ElementIdentity complex type: */
class SOAP_CMAC resqml2__ElementIdentity
{
public:
	resqml2__AbstractIntegerArray *ElementIndices;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	enum resqml2__IdentityKind IdentityKind;	/* required element of XSD type resqml2:IdentityKind */
	enum resqml2__IndexableElements IndexableElement;	/* required element of XSD type resqml2:IndexableElements */
	eml__DataObjectReference *Representation;	/* required element of XSD type eml:DataObjectReference */
	resqml2__TimeIndex *FromTimeIndex;	/* optional element of XSD type resqml2:TimeIndex */
	resqml2__TimeIndex *ToTimeIndex;	/* optional element of XSD type resqml2:TimeIndex */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIdentity (92)
	virtual int soap_type(void) const { return 92; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ElementIdentity, default initialized and not managed by a soap context
	virtual resqml2__ElementIdentity *soap_alloc(void) const { return SOAP_NEW(resqml2__ElementIdentity); }
	         resqml2__ElementIdentity() { resqml2__ElementIdentity::soap_default(NULL); }
	virtual ~resqml2__ElementIdentity() { }
	friend resqml2__ElementIdentity *soap_instantiate_resqml2__ElementIdentity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:417 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfGeometry (94)
/* resqml2:PatchOfGeometry complex type: */
class SOAP_CMAC resqml2__PatchOfGeometry
{
public:
	ULONG64 *RepresentationPatchIndex;	/* optional element of XSD type xsd:nonNegativeInteger */
	resqml2__AbstractGeometry *Geometry;	/* required element of XSD type resqml2:AbstractGeometry */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfGeometry (94)
	virtual int soap_type(void) const { return 94; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__PatchOfGeometry, default initialized and not managed by a soap context
	virtual resqml2__PatchOfGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__PatchOfGeometry); }
	         resqml2__PatchOfGeometry() { resqml2__PatchOfGeometry::soap_default(NULL); }
	virtual ~resqml2__PatchOfGeometry() { }
	friend resqml2__PatchOfGeometry *soap_instantiate_resqml2__PatchOfGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:426 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridTopology (97)
/* resqml2:AdditionalGridTopology complex type: */
class SOAP_CMAC resqml2__AdditionalGridTopology
{
public:
	resqml2__SplitEdges *SplitEdges;	/* optional element of XSD type resqml2:SplitEdges */
	resqml2__SplitNodePatch *SplitNodes;	/* optional element of XSD type resqml2:SplitNodePatch */
	resqml2__ColumnLayerSplitColumnEdges *SplitColumnEdges;	/* optional element of XSD type resqml2:ColumnLayerSplitColumnEdges */
	resqml2__UnstructuredColumnEdges *UnstructuredColumnEdges;	/* optional element of XSD type resqml2:UnstructuredColumnEdges */
	resqml2__SplitFaces *SplitFaces;	/* optional element of XSD type resqml2:SplitFaces */
	resqml2__IjSplitColumnEdges *IjSplitColumnEdges;	/* optional element of XSD type resqml2:IjSplitColumnEdges */
	resqml2__UnstructuredSubnodeTopology *UnstructuredSubnodeTopology;	/* optional element of XSD type resqml2:UnstructuredSubnodeTopology */
	resqml2__ColumnLayerSubnodeTopology *ColumnLayerSubnodeTopology;	/* optional element of XSD type resqml2:ColumnLayerSubnodeTopology */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridTopology (97)
	virtual int soap_type(void) const { return 97; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AdditionalGridTopology, default initialized and not managed by a soap context
	virtual resqml2__AdditionalGridTopology *soap_alloc(void) const { return SOAP_NEW(resqml2__AdditionalGridTopology); }
	         resqml2__AdditionalGridTopology() { resqml2__AdditionalGridTopology::soap_default(NULL); }
	virtual ~resqml2__AdditionalGridTopology() { }
	friend resqml2__AdditionalGridTopology *soap_instantiate_resqml2__AdditionalGridTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:441 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellStratigraphicUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellStratigraphicUnits (102)
/* resqml2:CellStratigraphicUnits complex type: */
class SOAP_CMAC resqml2__CellStratigraphicUnits
{
public:
	resqml2__AbstractIntegerArray *UnitIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	eml__DataObjectReference *StratigraphicOrganization;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellStratigraphicUnits (102)
	virtual int soap_type(void) const { return 102; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__CellStratigraphicUnits, default initialized and not managed by a soap context
	virtual resqml2__CellStratigraphicUnits *soap_alloc(void) const { return SOAP_NEW(resqml2__CellStratigraphicUnits); }
	         resqml2__CellStratigraphicUnits() { resqml2__CellStratigraphicUnits::soap_default(NULL); }
	virtual ~resqml2__CellStratigraphicUnits() { }
	friend resqml2__CellStratigraphicUnits *soap_instantiate_resqml2__CellStratigraphicUnits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:450 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeTopology (105)
/* Type resqml2__SubnodeTopology is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:SubnodeTopology complex type: */
class SOAP_CMAC resqml2__SubnodeTopology
{
public:
	std::vector<resqml2__VariableSubnodePatch *> VariableSubnodes;	/* optional element of XSD type resqml2:VariableSubnodePatch */
	std::vector<resqml2__UniformSubnodePatch *> UniformSubnodes;	/* optional element of XSD type resqml2:UniformSubnodePatch */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeTopology (105)
	virtual int soap_type(void) const { return 105; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__SubnodeTopology, default initialized and not managed by a soap context
	virtual resqml2__SubnodeTopology *soap_alloc(void) const { return SOAP_NEW(resqml2__SubnodeTopology); }
	         resqml2__SubnodeTopology() { resqml2__SubnodeTopology::soap_default(NULL); }
	virtual ~resqml2__SubnodeTopology() { }
	friend resqml2__SubnodeTopology *soap_instantiate_resqml2__SubnodeTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:453 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitFaces
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitFaces (106)
/* resqml2:SplitFaces complex type: */
class SOAP_CMAC resqml2__SplitFaces
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *ParentFaceIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *CellIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__SplitEdges *SplitEdges;	/* optional element of XSD type resqml2:SplitEdges */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitFaces (106)
	virtual int soap_type(void) const { return 106; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__SplitFaces, default initialized and not managed by a soap context
	virtual resqml2__SplitFaces *soap_alloc(void) const { return SOAP_NEW(resqml2__SplitFaces); }
	         resqml2__SplitFaces() { resqml2__SplitFaces::soap_default(NULL); }
	virtual ~resqml2__SplitFaces() { }
	friend resqml2__SplitFaces *soap_instantiate_resqml2__SplitFaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:13474 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___resqml2__IjGaps_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___resqml2__IjGaps_sequence (825)
/* Operation wrapper: */
class SOAP_CMAC __resqml2__IjGaps_sequence
{
public:
	ULONG64 SplitPillarCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *ParentPillarIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__ResqmlJaggedArray *ColumnsPerSplitPillar;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	resqml2__IjSplitColumnEdges *IjSplitColumnEdges;	/* optional element of XSD type resqml2:IjSplitColumnEdges */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___resqml2__IjGaps_sequence (825)
	virtual int soap_type(void) const { return 825; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __resqml2__IjGaps_sequence, default initialized and not managed by a soap context
	virtual __resqml2__IjGaps_sequence *soap_alloc(void) const { return SOAP_NEW(__resqml2__IjGaps_sequence); }
	         __resqml2__IjGaps_sequence() { __resqml2__IjGaps_sequence::soap_default(NULL); }
	virtual ~__resqml2__IjGaps_sequence() { }
	friend __resqml2__IjGaps_sequence *soap_instantiate___resqml2__IjGaps_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:459 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjGaps
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjGaps (108)
/* resqml2:IjGaps complex type: */
class SOAP_CMAC resqml2__IjGaps
{
public:
	__resqml2__IjGaps_sequence *__IjGaps_sequence;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjGaps (108)
	virtual int soap_type(void) const { return 108; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IjGaps, default initialized and not managed by a soap context
	virtual resqml2__IjGaps *soap_alloc(void) const { return SOAP_NEW(resqml2__IjGaps); }
	         resqml2__IjGaps() { resqml2__IjGaps::soap_default(NULL); }
	virtual ~resqml2__IjGaps() { }
	friend resqml2__IjGaps *soap_instantiate_resqml2__IjGaps(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:474 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridColumnLayerGrid
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridColumnLayerGrid (113)
/* resqml2:GpGridColumnLayerGrid complex type: */
class SOAP_CMAC resqml2__GpGridColumnLayerGrid
{
public:
	ULONG64 Nk;	/* required element of XSD type xsd:nonNegativeInteger */
	resqml2__KGaps *KGaps;	/* optional element of XSD type resqml2:KGaps */
	std::vector<resqml2__GpGridIjkGridPatch *> IjkGridPatch;	/* optional element of XSD type resqml2:GpGridIjkGridPatch */
	std::vector<resqml2__GpGridUnstructuredColumnLayerGridPatch *> UnstructuredColumnLayerGridPatch;	/* optional element of XSD type resqml2:GpGridUnstructuredColumnLayerGridPatch */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridColumnLayerGrid (113)
	virtual int soap_type(void) const { return 113; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__GpGridColumnLayerGrid, default initialized and not managed by a soap context
	virtual resqml2__GpGridColumnLayerGrid *soap_alloc(void) const { return SOAP_NEW(resqml2__GpGridColumnLayerGrid); }
	         resqml2__GpGridColumnLayerGrid() { resqml2__GpGridColumnLayerGrid::soap_default(NULL); }
	virtual ~resqml2__GpGridColumnLayerGrid() { }
	friend resqml2__GpGridColumnLayerGrid *soap_instantiate_resqml2__GpGridColumnLayerGrid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:477 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitCoordinateLines
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitCoordinateLines (114)
/* resqml2:ColumnLayerSplitCoordinateLines complex type: */
class SOAP_CMAC resqml2__ColumnLayerSplitCoordinateLines
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *PillarIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__ResqmlJaggedArray *ColumnsPerSplitCoordinateLine;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	resqml2__ColumnLayerSplitColumnEdges *SplitColumnEdges;	/* optional element of XSD type resqml2:ColumnLayerSplitColumnEdges */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitCoordinateLines (114)
	virtual int soap_type(void) const { return 114; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ColumnLayerSplitCoordinateLines, default initialized and not managed by a soap context
	virtual resqml2__ColumnLayerSplitCoordinateLines *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnLayerSplitCoordinateLines); }
	         resqml2__ColumnLayerSplitCoordinateLines() { resqml2__ColumnLayerSplitCoordinateLines::soap_default(NULL); }
	virtual ~resqml2__ColumnLayerSplitCoordinateLines() { }
	friend resqml2__ColumnLayerSplitCoordinateLines *soap_instantiate_resqml2__ColumnLayerSplitCoordinateLines(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:13593 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___resqml2__KGaps_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___resqml2__KGaps_sequence (833)
/* Operation wrapper: */
class SOAP_CMAC __resqml2__KGaps_sequence
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractBooleanArray *GapAfterLayer;	/* required element of XSD type resqml2:AbstractBooleanArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___resqml2__KGaps_sequence (833)
	virtual int soap_type(void) const { return 833; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __resqml2__KGaps_sequence, default initialized and not managed by a soap context
	virtual __resqml2__KGaps_sequence *soap_alloc(void) const { return SOAP_NEW(__resqml2__KGaps_sequence); }
	         __resqml2__KGaps_sequence() { __resqml2__KGaps_sequence::soap_default(NULL); }
	virtual ~__resqml2__KGaps_sequence() { }
	friend __resqml2__KGaps_sequence *soap_instantiate___resqml2__KGaps_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:483 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KGaps
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KGaps (116)
/* resqml2:KGaps complex type: */
class SOAP_CMAC resqml2__KGaps
{
public:
	__resqml2__KGaps_sequence *__KGaps_sequence;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KGaps (116)
	virtual int soap_type(void) const { return 116; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__KGaps, default initialized and not managed by a soap context
	virtual resqml2__KGaps *soap_alloc(void) const { return SOAP_NEW(resqml2__KGaps); }
	         resqml2__KGaps() { resqml2__KGaps::soap_default(NULL); }
	virtual ~resqml2__KGaps() { }
	friend resqml2__KGaps *soap_instantiate_resqml2__KGaps(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:492 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnEdges (119)
/* resqml2:UnstructuredColumnEdges complex type: */
class SOAP_CMAC resqml2__UnstructuredColumnEdges
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__ResqmlJaggedArray *PillarsPerColumnEdge;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnEdges (119)
	virtual int soap_type(void) const { return 119; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__UnstructuredColumnEdges, default initialized and not managed by a soap context
	virtual resqml2__UnstructuredColumnEdges *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredColumnEdges); }
	         resqml2__UnstructuredColumnEdges() { resqml2__UnstructuredColumnEdges::soap_default(NULL); }
	virtual ~resqml2__UnstructuredColumnEdges() { }
	friend resqml2__UnstructuredColumnEdges *soap_instantiate_resqml2__UnstructuredColumnEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:495 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridPoints (120)
/* resqml2:AdditionalGridPoints complex type: */
class SOAP_CMAC resqml2__AdditionalGridPoints
{
public:
	ULONG64 *RepresentationPatchIndex;	/* optional element of XSD type xsd:nonNegativeInteger */
	enum resqml2__GridGeometryAttachment Attachment;	/* required element of XSD type resqml2:GridGeometryAttachment */
	resqml2__AbstractPoint3dArray *Points;	/* required element of XSD type resqml2:AbstractPoint3dArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridPoints (120)
	virtual int soap_type(void) const { return 120; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AdditionalGridPoints, default initialized and not managed by a soap context
	virtual resqml2__AdditionalGridPoints *soap_alloc(void) const { return SOAP_NEW(resqml2__AdditionalGridPoints); }
	         resqml2__AdditionalGridPoints() { resqml2__AdditionalGridPoints::soap_default(NULL); }
	virtual ~resqml2__AdditionalGridPoints() { }
	friend resqml2__AdditionalGridPoints *soap_instantiate_resqml2__AdditionalGridPoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:498 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjSplitColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjSplitColumnEdges (121)
/* resqml2:IjSplitColumnEdges complex type: */
class SOAP_CMAC resqml2__IjSplitColumnEdges
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__ResqmlJaggedArray *PillarsPerSplitColumnEdge;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjSplitColumnEdges (121)
	virtual int soap_type(void) const { return 121; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IjSplitColumnEdges, default initialized and not managed by a soap context
	virtual resqml2__IjSplitColumnEdges *soap_alloc(void) const { return SOAP_NEW(resqml2__IjSplitColumnEdges); }
	         resqml2__IjSplitColumnEdges() { resqml2__IjSplitColumnEdges::soap_default(NULL); }
	virtual ~resqml2__IjSplitColumnEdges() { }
	friend resqml2__IjSplitColumnEdges *soap_instantiate_resqml2__IjSplitColumnEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:507 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalStratigraphicUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalStratigraphicUnits (124)
/* resqml2:IntervalStratigraphicUnits complex type: */
class SOAP_CMAC resqml2__IntervalStratigraphicUnits
{
public:
	resqml2__AbstractIntegerArray *UnitIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	eml__DataObjectReference *StratigraphicOrganization;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalStratigraphicUnits (124)
	virtual int soap_type(void) const { return 124; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IntervalStratigraphicUnits, default initialized and not managed by a soap context
	virtual resqml2__IntervalStratigraphicUnits *soap_alloc(void) const { return SOAP_NEW(resqml2__IntervalStratigraphicUnits); }
	         resqml2__IntervalStratigraphicUnits() { resqml2__IntervalStratigraphicUnits::soap_default(NULL); }
	virtual ~resqml2__IntervalStratigraphicUnits() { }
	friend resqml2__IntervalStratigraphicUnits *soap_instantiate_resqml2__IntervalStratigraphicUnits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:510 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Regrid
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Regrid (125)
/* resqml2:Regrid complex type: */
class SOAP_CMAC resqml2__Regrid
{
public:
	ULONG64 InitialIndexOnParentGrid;	/* required element of XSD type xsd:nonNegativeInteger */
	resqml2__Intervals *Intervals;	/* optional element of XSD type resqml2:Intervals */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Regrid (125)
	virtual int soap_type(void) const { return 125; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Regrid, default initialized and not managed by a soap context
	virtual resqml2__Regrid *soap_alloc(void) const { return SOAP_NEW(resqml2__Regrid); }
	         resqml2__Regrid() { resqml2__Regrid::soap_default(NULL); }
	virtual ~resqml2__Regrid() { }
	friend resqml2__Regrid *soap_instantiate_resqml2__Regrid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:513 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Activation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Activation (126)
/* resqml2:Activation complex type: */
class SOAP_CMAC resqml2__Activation
{
public:
	resqml2__AbstractIntegerArray *ActivationToggleIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	eml__DataObjectReference *TimeSeries;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Activation (126)
	virtual int soap_type(void) const { return 126; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Activation, default initialized and not managed by a soap context
	virtual resqml2__Activation *soap_alloc(void) const { return SOAP_NEW(resqml2__Activation); }
	         resqml2__Activation() { resqml2__Activation::soap_default(NULL); }
	virtual ~resqml2__Activation() { }
	friend resqml2__Activation *soap_instantiate_resqml2__Activation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:522 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ConnectionInterpretations
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ConnectionInterpretations (129)
/* resqml2:ConnectionInterpretations complex type: */
class SOAP_CMAC resqml2__ConnectionInterpretations
{
public:
	resqml2__ResqmlJaggedArray *InterpretationIndices;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	std::vector<eml__DataObjectReference *> FeatureInterpretation;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ConnectionInterpretations (129)
	virtual int soap_type(void) const { return 129; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ConnectionInterpretations, default initialized and not managed by a soap context
	virtual resqml2__ConnectionInterpretations *soap_alloc(void) const { return SOAP_NEW(resqml2__ConnectionInterpretations); }
	         resqml2__ConnectionInterpretations() { resqml2__ConnectionInterpretations::soap_default(NULL); }
	virtual ~resqml2__ConnectionInterpretations() { }
	friend resqml2__ConnectionInterpretations *soap_instantiate_resqml2__ConnectionInterpretations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:528 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitEdges (131)
/* resqml2:SplitEdges complex type: */
class SOAP_CMAC resqml2__SplitEdges
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *ParentEdgeIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__ResqmlJaggedArray *FacesPerSplitEdge;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitEdges (131)
	virtual int soap_type(void) const { return 131; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__SplitEdges, default initialized and not managed by a soap context
	virtual resqml2__SplitEdges *soap_alloc(void) const { return SOAP_NEW(resqml2__SplitEdges); }
	         resqml2__SplitEdges() { resqml2__SplitEdges::soap_default(NULL); }
	virtual ~resqml2__SplitEdges() { }
	friend resqml2__SplitEdges *soap_instantiate_resqml2__SplitEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:531 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellFluidPhaseUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellFluidPhaseUnits (132)
/* resqml2:CellFluidPhaseUnits complex type: */
class SOAP_CMAC resqml2__CellFluidPhaseUnits
{
public:
	resqml2__AbstractIntegerArray *PhaseUnitIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	eml__DataObjectReference *FluidOrganization;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellFluidPhaseUnits (132)
	virtual int soap_type(void) const { return 132; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__CellFluidPhaseUnits, default initialized and not managed by a soap context
	virtual resqml2__CellFluidPhaseUnits *soap_alloc(void) const { return SOAP_NEW(resqml2__CellFluidPhaseUnits); }
	         resqml2__CellFluidPhaseUnits() { resqml2__CellFluidPhaseUnits::soap_default(NULL); }
	virtual ~resqml2__CellFluidPhaseUnits() { }
	friend resqml2__CellFluidPhaseUnits *soap_instantiate_resqml2__CellFluidPhaseUnits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:534 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodesPerCell
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodesPerCell (133)
/* resqml2:NodesPerCell complex type: */
class SOAP_CMAC resqml2__NodesPerCell
{
public:
	resqml2__ResqmlJaggedArray *NodesPerCell;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodesPerCell (133)
	virtual int soap_type(void) const { return 133; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__NodesPerCell, default initialized and not managed by a soap context
	virtual resqml2__NodesPerCell *soap_alloc(void) const { return SOAP_NEW(resqml2__NodesPerCell); }
	         resqml2__NodesPerCell() { resqml2__NodesPerCell::soap_default(NULL); }
	virtual ~resqml2__NodesPerCell() { }
	friend resqml2__NodesPerCell *soap_instantiate_resqml2__NodesPerCell(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:540 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Edges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Edges (135)
/* resqml2:Edges complex type: */
class SOAP_CMAC resqml2__Edges
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *NodesPerEdge;	/* required element of XSD type resqml2:AbstractIntegerArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Edges (135)
	virtual int soap_type(void) const { return 135; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Edges, default initialized and not managed by a soap context
	virtual resqml2__Edges *soap_alloc(void) const { return SOAP_NEW(resqml2__Edges); }
	         resqml2__Edges() { resqml2__Edges::soap_default(NULL); }
	virtual ~resqml2__Edges() { }
	friend resqml2__Edges *soap_instantiate_resqml2__Edges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:564 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridHingeNodeFaces
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridHingeNodeFaces (143)
/* resqml2:UnstructuredGridHingeNodeFaces complex type: */
class SOAP_CMAC resqml2__UnstructuredGridHingeNodeFaces
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *FaceIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridHingeNodeFaces (143)
	virtual int soap_type(void) const { return 143; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__UnstructuredGridHingeNodeFaces, default initialized and not managed by a soap context
	virtual resqml2__UnstructuredGridHingeNodeFaces *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredGridHingeNodeFaces); }
	         resqml2__UnstructuredGridHingeNodeFaces() { resqml2__UnstructuredGridHingeNodeFaces::soap_default(NULL); }
	virtual ~resqml2__UnstructuredGridHingeNodeFaces() { }
	friend resqml2__UnstructuredGridHingeNodeFaces *soap_instantiate_resqml2__UnstructuredGridHingeNodeFaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:14004 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___resqml2__CellOverlap_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___resqml2__CellOverlap_sequence (838)
/* Operation wrapper: */
class SOAP_CMAC __resqml2__CellOverlap_sequence
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *ParentChildCellPairs;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__OverlapVolume *OverlapVolume;	/* optional element of XSD type resqml2:OverlapVolume */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___resqml2__CellOverlap_sequence (838)
	virtual int soap_type(void) const { return 838; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __resqml2__CellOverlap_sequence, default initialized and not managed by a soap context
	virtual __resqml2__CellOverlap_sequence *soap_alloc(void) const { return SOAP_NEW(__resqml2__CellOverlap_sequence); }
	         __resqml2__CellOverlap_sequence() { __resqml2__CellOverlap_sequence::soap_default(NULL); }
	virtual ~__resqml2__CellOverlap_sequence() { }
	friend __resqml2__CellOverlap_sequence *soap_instantiate___resqml2__CellOverlap_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:567 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellOverlap
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellOverlap (144)
/* resqml2:CellOverlap complex type: */
class SOAP_CMAC resqml2__CellOverlap
{
public:
	__resqml2__CellOverlap_sequence *__CellOverlap_sequence;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellOverlap (144)
	virtual int soap_type(void) const { return 144; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__CellOverlap, default initialized and not managed by a soap context
	virtual resqml2__CellOverlap *soap_alloc(void) const { return SOAP_NEW(resqml2__CellOverlap); }
	         resqml2__CellOverlap() { resqml2__CellOverlap::soap_default(NULL); }
	virtual ~resqml2__CellOverlap() { }
	friend resqml2__CellOverlap *soap_instantiate_resqml2__CellOverlap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:570 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitColumnEdges (145)
/* resqml2:ColumnLayerSplitColumnEdges complex type: */
class SOAP_CMAC resqml2__ColumnLayerSplitColumnEdges
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *ParentColumnEdgeIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *ColumnPerSplitColumnEdge;	/* required element of XSD type resqml2:AbstractIntegerArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitColumnEdges (145)
	virtual int soap_type(void) const { return 145; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ColumnLayerSplitColumnEdges, default initialized and not managed by a soap context
	virtual resqml2__ColumnLayerSplitColumnEdges *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnLayerSplitColumnEdges); }
	         resqml2__ColumnLayerSplitColumnEdges() { resqml2__ColumnLayerSplitColumnEdges::soap_default(NULL); }
	virtual ~resqml2__ColumnLayerSplitColumnEdges() { }
	friend resqml2__ColumnLayerSplitColumnEdges *soap_instantiate_resqml2__ColumnLayerSplitColumnEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:14079 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___resqml2__OverlapVolume_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___resqml2__OverlapVolume_sequence (841)
/* Operation wrapper: */
class SOAP_CMAC __resqml2__OverlapVolume_sequence
{
public:
	enum eml__VolumeUom VolumeUom;	/* required element of XSD type eml:VolumeUom */
	resqml2__AbstractDoubleArray *OverlapVolumes;	/* required element of XSD type resqml2:AbstractDoubleArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___resqml2__OverlapVolume_sequence (841)
	virtual int soap_type(void) const { return 841; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __resqml2__OverlapVolume_sequence, default initialized and not managed by a soap context
	virtual __resqml2__OverlapVolume_sequence *soap_alloc(void) const { return SOAP_NEW(__resqml2__OverlapVolume_sequence); }
	         __resqml2__OverlapVolume_sequence() { __resqml2__OverlapVolume_sequence::soap_default(NULL); }
	virtual ~__resqml2__OverlapVolume_sequence() { }
	friend __resqml2__OverlapVolume_sequence *soap_instantiate___resqml2__OverlapVolume_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:576 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OverlapVolume
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OverlapVolume (147)
/* resqml2:OverlapVolume complex type: */
class SOAP_CMAC resqml2__OverlapVolume
{
public:
	__resqml2__OverlapVolume_sequence *__OverlapVolume_sequence;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OverlapVolume (147)
	virtual int soap_type(void) const { return 147; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__OverlapVolume, default initialized and not managed by a soap context
	virtual resqml2__OverlapVolume *soap_alloc(void) const { return SOAP_NEW(resqml2__OverlapVolume); }
	         resqml2__OverlapVolume() { resqml2__OverlapVolume::soap_default(NULL); }
	virtual ~resqml2__OverlapVolume() { }
	friend resqml2__OverlapVolume *soap_instantiate_resqml2__OverlapVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:579 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Intervals
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Intervals (148)
/* resqml2:Intervals complex type: */
class SOAP_CMAC resqml2__Intervals
{
public:
	ULONG64 IntervalCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *ParentCountPerInterval;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *ChildCountPerInterval;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractDoubleArray *ChildCellWeights;	/* optional element of XSD type resqml2:AbstractDoubleArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Intervals (148)
	virtual int soap_type(void) const { return 148; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Intervals, default initialized and not managed by a soap context
	virtual resqml2__Intervals *soap_alloc(void) const { return SOAP_NEW(resqml2__Intervals); }
	         resqml2__Intervals() { resqml2__Intervals::soap_default(NULL); }
	virtual ~resqml2__Intervals() { }
	friend resqml2__Intervals *soap_instantiate_resqml2__Intervals(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:585 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParentWindow (150)
/* Type resqml2__AbstractParentWindow is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractParentWindow complex type: */
class SOAP_CMAC resqml2__AbstractParentWindow
{
public:
	resqml2__CellOverlap *CellOverlap;	/* optional element of XSD type resqml2:CellOverlap */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParentWindow (150)
	virtual int soap_type(void) const { return 150; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractParentWindow, default initialized and not managed by a soap context
	virtual resqml2__AbstractParentWindow *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractParentWindow); }
	         resqml2__AbstractParentWindow() { resqml2__AbstractParentWindow::soap_default(NULL); }
	virtual ~resqml2__AbstractParentWindow() { }
	friend resqml2__AbstractParentWindow *soap_instantiate_resqml2__AbstractParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:594 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeInterval
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeInterval (153)
/* resqml2:TimeInterval complex type: */
class SOAP_CMAC resqml2__TimeInterval
{
public:
	eml__DataObjectReference *ChronoBottom;	/* required element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *ChronoTop;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeInterval (153)
	virtual int soap_type(void) const { return 153; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__TimeInterval, default initialized and not managed by a soap context
	virtual resqml2__TimeInterval *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeInterval); }
	         resqml2__TimeInterval() { resqml2__TimeInterval::soap_default(NULL); }
	virtual ~resqml2__TimeInterval() { }
	friend resqml2__TimeInterval *soap_instantiate_resqml2__TimeInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:603 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StratigraphicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StratigraphicUnitInterpretationIndex (156)
/* resqml2:StratigraphicUnitInterpretationIndex complex type: */
class SOAP_CMAC resqml2__StratigraphicUnitInterpretationIndex
{
public:
	ULONG64 Index;	/* required element of XSD type xsd:nonNegativeInteger */
	eml__DataObjectReference *Unit;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StratigraphicUnitInterpretationIndex (156)
	virtual int soap_type(void) const { return 156; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__StratigraphicUnitInterpretationIndex, default initialized and not managed by a soap context
	virtual resqml2__StratigraphicUnitInterpretationIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__StratigraphicUnitInterpretationIndex); }
	         resqml2__StratigraphicUnitInterpretationIndex() { resqml2__StratigraphicUnitInterpretationIndex::soap_default(NULL); }
	virtual ~resqml2__StratigraphicUnitInterpretationIndex() { }
	friend resqml2__StratigraphicUnitInterpretationIndex *soap_instantiate_resqml2__StratigraphicUnitInterpretationIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:618 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitInterpretationIndex (161)
/* resqml2:GeologicUnitInterpretationIndex complex type: */
class SOAP_CMAC resqml2__GeologicUnitInterpretationIndex
{
public:
	ULONG64 Index;	/* required element of XSD type xsd:nonNegativeInteger */
	eml__DataObjectReference *Unit;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitInterpretationIndex (161)
	virtual int soap_type(void) const { return 161; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__GeologicUnitInterpretationIndex, default initialized and not managed by a soap context
	virtual resqml2__GeologicUnitInterpretationIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__GeologicUnitInterpretationIndex); }
	         resqml2__GeologicUnitInterpretationIndex() { resqml2__GeologicUnitInterpretationIndex::soap_default(NULL); }
	virtual ~resqml2__GeologicUnitInterpretationIndex() { }
	friend resqml2__GeologicUnitInterpretationIndex *soap_instantiate_resqml2__GeologicUnitInterpretationIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:630 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizonInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizonInterpretationIndex (165)
/* resqml2:HorizonInterpretationIndex complex type: */
class SOAP_CMAC resqml2__HorizonInterpretationIndex
{
public:
	ULONG64 Index;	/* required element of XSD type xsd:nonNegativeInteger */
	ULONG64 *StratigraphicRank;	/* optional element of XSD type xsd:nonNegativeInteger */
	eml__DataObjectReference *Horizon;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizonInterpretationIndex (165)
	virtual int soap_type(void) const { return 165; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__HorizonInterpretationIndex, default initialized and not managed by a soap context
	virtual resqml2__HorizonInterpretationIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__HorizonInterpretationIndex); }
	         resqml2__HorizonInterpretationIndex() { resqml2__HorizonInterpretationIndex::soap_default(NULL); }
	virtual ~resqml2__HorizonInterpretationIndex() { }
	friend resqml2__HorizonInterpretationIndex *soap_instantiate_resqml2__HorizonInterpretationIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:645 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactInterpretationPart (170)
/* Type resqml2__AbstractContactInterpretationPart is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractContactInterpretationPart complex type: */
class SOAP_CMAC resqml2__AbstractContactInterpretationPart
{
public:
	enum resqml2__ContactRelationship ContactRelationship;	/* required element of XSD type resqml2:ContactRelationship */
	ULONG64 Index;	/* required element of XSD type xsd:nonNegativeInteger */
	eml__DataObjectReference *PartOf;	/* optional element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactInterpretationPart (170)
	virtual int soap_type(void) const { return 170; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractContactInterpretationPart, default initialized and not managed by a soap context
	virtual resqml2__AbstractContactInterpretationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractContactInterpretationPart); }
	         resqml2__AbstractContactInterpretationPart() { resqml2__AbstractContactInterpretationPart::soap_default(NULL); }
	virtual ~resqml2__AbstractContactInterpretationPart() { }
	friend resqml2__AbstractContactInterpretationPart *soap_instantiate_resqml2__AbstractContactInterpretationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:651 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FaultThrow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FaultThrow (172)
/* resqml2:FaultThrow complex type: */
class SOAP_CMAC resqml2__FaultThrow
{
public:
	std::vector<enum resqml2__ThrowKind> Throw;	/* required element of XSD type resqml2:ThrowKind */
	resqml2__TimeInterval *HasOccuredDuring;	/* optional element of XSD type resqml2:TimeInterval */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FaultThrow (172)
	virtual int soap_type(void) const { return 172; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__FaultThrow, default initialized and not managed by a soap context
	virtual resqml2__FaultThrow *soap_alloc(void) const { return SOAP_NEW(resqml2__FaultThrow); }
	         resqml2__FaultThrow() { resqml2__FaultThrow::soap_default(NULL); }
	virtual ~resqml2__FaultThrow() { }
	friend resqml2__FaultThrow *soap_instantiate_resqml2__FaultThrow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:660 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RockFluidUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RockFluidUnitInterpretationIndex (175)
/* resqml2:RockFluidUnitInterpretationIndex complex type: */
class SOAP_CMAC resqml2__RockFluidUnitInterpretationIndex
{
public:
	ULONG64 Index;	/* required element of XSD type xsd:nonNegativeInteger */
	eml__DataObjectReference *RockFluidUnit;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RockFluidUnitInterpretationIndex (175)
	virtual int soap_type(void) const { return 175; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__RockFluidUnitInterpretationIndex, default initialized and not managed by a soap context
	virtual resqml2__RockFluidUnitInterpretationIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__RockFluidUnitInterpretationIndex); }
	         resqml2__RockFluidUnitInterpretationIndex() { resqml2__RockFluidUnitInterpretationIndex::soap_default(NULL); }
	virtual ~resqml2__RockFluidUnitInterpretationIndex() { }
	friend resqml2__RockFluidUnitInterpretationIndex *soap_instantiate_resqml2__RockFluidUnitInterpretationIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:687 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ChronostratigraphicRank
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ChronostratigraphicRank (184)
/* resqml2:ChronostratigraphicRank complex type: */
class SOAP_CMAC resqml2__ChronostratigraphicRank
{
public:
	std::string Name;	/* required element of XSD type eml:NameString */
	std::vector<eml__DataObjectReference *> Contains;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ChronostratigraphicRank (184)
	virtual int soap_type(void) const { return 184; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ChronostratigraphicRank, default initialized and not managed by a soap context
	virtual resqml2__ChronostratigraphicRank *soap_alloc(void) const { return SOAP_NEW(resqml2__ChronostratigraphicRank); }
	         resqml2__ChronostratigraphicRank() { resqml2__ChronostratigraphicRank::soap_default(NULL); }
	virtual ~resqml2__ChronostratigraphicRank() { }
	friend resqml2__ChronostratigraphicRank *soap_instantiate_resqml2__ChronostratigraphicRank(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:714 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3d
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3d (193)
/* resqml2:Point3d complex type: */
class SOAP_CMAC resqml2__Point3d
{
public:
	double Coordinate1;	/* required element of XSD type xsd:double */
	double Coordinate2;	/* required element of XSD type xsd:double */
	double Coordinate3;	/* required element of XSD type xsd:double */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3d (193)
	virtual int soap_type(void) const { return 193; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Point3d, default initialized and not managed by a soap context
	virtual resqml2__Point3d *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3d); }
	         resqml2__Point3d() { resqml2__Point3d::soap_default(NULL); }
	virtual ~resqml2__Point3d() { }
	friend resqml2__Point3d *soap_instantiate_resqml2__Point3d(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:717 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSeriesParentage
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSeriesParentage (194)
/* resqml2:TimeSeriesParentage complex type: */
class SOAP_CMAC resqml2__TimeSeriesParentage
{
public:
	bool HasOverlap;	/* required element of XSD type xsd:boolean */
	resqml2__TimeIndex *ParentTimeIndex;	/* required element of XSD type resqml2:TimeIndex */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSeriesParentage (194)
	virtual int soap_type(void) const { return 194; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__TimeSeriesParentage, default initialized and not managed by a soap context
	virtual resqml2__TimeSeriesParentage *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeSeriesParentage); }
	         resqml2__TimeSeriesParentage() { resqml2__TimeSeriesParentage::soap_default(NULL); }
	virtual ~resqml2__TimeSeriesParentage() { }
	friend resqml2__TimeSeriesParentage *soap_instantiate_resqml2__TimeSeriesParentage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:723 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndex (196)
/* resqml2:TimeIndex complex type: */
class SOAP_CMAC resqml2__TimeIndex
{
public:
	ULONG64 Index;	/* required element of XSD type xsd:nonNegativeInteger */
	eml__DataObjectReference *TimeSeries;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndex (196)
	virtual int soap_type(void) const { return 196; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__TimeIndex, default initialized and not managed by a soap context
	virtual resqml2__TimeIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeIndex); }
	         resqml2__TimeIndex() { resqml2__TimeIndex::soap_default(NULL); }
	virtual ~resqml2__TimeIndex() { }
	friend resqml2__TimeIndex *soap_instantiate_resqml2__TimeIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:726 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Timestamp
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Timestamp (197)
/* resqml2:Timestamp complex type: */
class SOAP_CMAC resqml2__Timestamp
{
public:
	time_t DateTime;	/* required element of XSD type xsd:dateTime */
	LONG64 *YearOffset;	/* optional element of XSD type xsd:long */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Timestamp (197)
	virtual int soap_type(void) const { return 197; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Timestamp, default initialized and not managed by a soap context
	virtual resqml2__Timestamp *soap_alloc(void) const { return SOAP_NEW(resqml2__Timestamp); }
	         resqml2__Timestamp() { resqml2__Timestamp::soap_default(NULL); }
	virtual ~resqml2__Timestamp() { }
	friend resqml2__Timestamp *soap_instantiate_resqml2__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:732 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlJaggedArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlJaggedArray (199)
/* resqml2:ResqmlJaggedArray complex type: */
class SOAP_CMAC resqml2__ResqmlJaggedArray
{
public:
	resqml2__AbstractValueArray *Elements;	/* required element of XSD type resqml2:AbstractValueArray */
	resqml2__AbstractIntegerArray *CumulativeLength;	/* required element of XSD type resqml2:AbstractIntegerArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlJaggedArray (199)
	virtual int soap_type(void) const { return 199; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ResqmlJaggedArray, default initialized and not managed by a soap context
	virtual resqml2__ResqmlJaggedArray *soap_alloc(void) const { return SOAP_NEW(resqml2__ResqmlJaggedArray); }
	         resqml2__ResqmlJaggedArray() { resqml2__ResqmlJaggedArray::soap_default(NULL); }
	virtual ~resqml2__ResqmlJaggedArray() { }
	friend resqml2__ResqmlJaggedArray *soap_instantiate_resqml2__ResqmlJaggedArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:735 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NameValuePair
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NameValuePair (200)
/* resqml2:NameValuePair complex type: */
class SOAP_CMAC resqml2__NameValuePair
{
public:
	std::string Name;	/* required element of XSD type xsd:string */
	std::string Value;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NameValuePair (200)
	virtual int soap_type(void) const { return 200; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__NameValuePair, default initialized and not managed by a soap context
	virtual resqml2__NameValuePair *soap_alloc(void) const { return SOAP_NEW(resqml2__NameValuePair); }
	         resqml2__NameValuePair() { resqml2__NameValuePair::soap_default(NULL); }
	virtual ~resqml2__NameValuePair() { }
	friend resqml2__NameValuePair *soap_instantiate_resqml2__NameValuePair(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:750 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreTrajectoryParentIntersection
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreTrajectoryParentIntersection (205)
/* resqml2:WellboreTrajectoryParentIntersection complex type: */
class SOAP_CMAC resqml2__WellboreTrajectoryParentIntersection
{
public:
	double KickoffMd;	/* required element of XSD type xsd:double */
	double ParentMd;	/* required element of XSD type xsd:double */
	eml__DataObjectReference *ParentTrajectory;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreTrajectoryParentIntersection (205)
	virtual int soap_type(void) const { return 205; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__WellboreTrajectoryParentIntersection, default initialized and not managed by a soap context
	virtual resqml2__WellboreTrajectoryParentIntersection *soap_alloc(void) const { return SOAP_NEW(resqml2__WellboreTrajectoryParentIntersection); }
	         resqml2__WellboreTrajectoryParentIntersection() { resqml2__WellboreTrajectoryParentIntersection::soap_default(NULL); }
	virtual ~resqml2__WellboreTrajectoryParentIntersection() { }
	friend resqml2__WellboreTrajectoryParentIntersection *soap_instantiate_resqml2__WellboreTrajectoryParentIntersection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:789 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactRepresentationPart (218)
/* Type resqml2__AbstractContactRepresentationPart is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractContactRepresentationPart complex type: */
class SOAP_CMAC resqml2__AbstractContactRepresentationPart
{
public:
	ULONG64 Index;	/* required element of XSD type xsd:nonNegativeInteger */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactRepresentationPart (218)
	virtual int soap_type(void) const { return 218; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractContactRepresentationPart, default initialized and not managed by a soap context
	virtual resqml2__AbstractContactRepresentationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractContactRepresentationPart); }
	         resqml2__AbstractContactRepresentationPart() { resqml2__AbstractContactRepresentationPart::soap_default(NULL); }
	virtual ~resqml2__AbstractContactRepresentationPart() { }
	friend resqml2__AbstractContactRepresentationPart *soap_instantiate_resqml2__AbstractContactRepresentationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:804 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeRegion
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeRegion (223)
/* resqml2:VolumeRegion complex type: */
class SOAP_CMAC resqml2__VolumeRegion
{
public:
	ULONG64 PatchIndex;	/* required element of XSD type xsd:nonNegativeInteger */
	std::vector<resqml2__VolumeShell *> InternalShells;	/* optional element of XSD type resqml2:VolumeShell */
	eml__DataObjectReference *Represents;	/* required element of XSD type eml:DataObjectReference */
	resqml2__VolumeShell *ExternalShell;	/* required element of XSD type resqml2:VolumeShell */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeRegion (223)
	virtual int soap_type(void) const { return 223; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__VolumeRegion, default initialized and not managed by a soap context
	virtual resqml2__VolumeRegion *soap_alloc(void) const { return SOAP_NEW(resqml2__VolumeRegion); }
	         resqml2__VolumeRegion() { resqml2__VolumeRegion::soap_default(NULL); }
	virtual ~resqml2__VolumeRegion() { }
	friend resqml2__VolumeRegion *soap_instantiate_resqml2__VolumeRegion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:807 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeShell
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeShell (224)
/* resqml2:VolumeShell complex type: */
class SOAP_CMAC resqml2__VolumeShell
{
public:
	std::string ShellUid;	/* required element of XSD type xsd:string */
	std::vector<resqml2__OrientedMacroFace *> MacroFaces;	/* required element of XSD type resqml2:OrientedMacroFace */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeShell (224)
	virtual int soap_type(void) const { return 224; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__VolumeShell, default initialized and not managed by a soap context
	virtual resqml2__VolumeShell *soap_alloc(void) const { return SOAP_NEW(resqml2__VolumeShell); }
	         resqml2__VolumeShell() { resqml2__VolumeShell::soap_default(NULL); }
	virtual ~resqml2__VolumeShell() { }
	friend resqml2__VolumeShell *soap_instantiate_resqml2__VolumeShell(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:828 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchBoundaries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchBoundaries (231)
/* resqml2:PatchBoundaries complex type: */
class SOAP_CMAC resqml2__PatchBoundaries
{
public:
	std::vector<eml__DataObjectReference *> InnerRing;	/* optional element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *OuterRing;	/* optional element of XSD type eml:DataObjectReference */
	ULONG64 ReferencedPatch;	/* required element of XSD type xsd:nonNegativeInteger */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchBoundaries (231)
	virtual int soap_type(void) const { return 231; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__PatchBoundaries, default initialized and not managed by a soap context
	virtual resqml2__PatchBoundaries *soap_alloc(void) const { return SOAP_NEW(resqml2__PatchBoundaries); }
	         resqml2__PatchBoundaries() { resqml2__PatchBoundaries::soap_default(NULL); }
	virtual ~resqml2__PatchBoundaries() { }
	friend resqml2__PatchBoundaries *soap_instantiate_resqml2__PatchBoundaries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:843 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrientedMacroFace
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrientedMacroFace (236)
/* resqml2:OrientedMacroFace complex type: */
class SOAP_CMAC resqml2__OrientedMacroFace
{
public:
	ULONG64 PatchIndexOfRepresentation;	/* required element of XSD type xsd:nonNegativeInteger */
	ULONG64 RepresentationIndex;	/* required element of XSD type xsd:nonNegativeInteger */
	bool SideIsPlus;	/* required element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrientedMacroFace (236)
	virtual int soap_type(void) const { return 236; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__OrientedMacroFace, default initialized and not managed by a soap context
	virtual resqml2__OrientedMacroFace *soap_alloc(void) const { return SOAP_NEW(resqml2__OrientedMacroFace); }
	         resqml2__OrientedMacroFace() { resqml2__OrientedMacroFace::soap_default(NULL); }
	virtual ~resqml2__OrientedMacroFace() { }
	friend resqml2__OrientedMacroFace *soap_instantiate_resqml2__OrientedMacroFace(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:846 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactIdentity (237)
/* resqml2:ContactIdentity complex type: */
class SOAP_CMAC resqml2__ContactIdentity
{
public:
	enum resqml2__IdentityKind IdentityKind;	/* required element of XSD type resqml2:IdentityKind */
	resqml2__AbstractIntegerArray *ListOfContactRepresentations;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *ListOfIdenticalNodes;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactIdentity (237)
	virtual int soap_type(void) const { return 237; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ContactIdentity, default initialized and not managed by a soap context
	virtual resqml2__ContactIdentity *soap_alloc(void) const { return SOAP_NEW(resqml2__ContactIdentity); }
	         resqml2__ContactIdentity() { resqml2__ContactIdentity::soap_default(NULL); }
	virtual ~resqml2__ContactIdentity() { }
	friend resqml2__ContactIdentity *soap_instantiate_resqml2__ContactIdentity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:876 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WitsmlWellboreReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WitsmlWellboreReference (247)
/* resqml2:WitsmlWellboreReference complex type: */
class SOAP_CMAC resqml2__WitsmlWellboreReference
{
public:
	eml__DataObjectReference *WitsmlWell;	/* required element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *WitsmlWellbore;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WitsmlWellboreReference (247)
	virtual int soap_type(void) const { return 247; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__WitsmlWellboreReference, default initialized and not managed by a soap context
	virtual resqml2__WitsmlWellboreReference *soap_alloc(void) const { return SOAP_NEW(resqml2__WitsmlWellboreReference); }
	         resqml2__WitsmlWellboreReference() { resqml2__WitsmlWellboreReference::soap_default(NULL); }
	virtual ~resqml2__WitsmlWellboreReference() { }
	friend resqml2__WitsmlWellboreReference *soap_instantiate_resqml2__WitsmlWellboreReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:891 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterTemplate (252)
/* resqml2:ParameterTemplate complex type: */
class SOAP_CMAC resqml2__ParameterTemplate
{
public:
	std::vector<std::string> KeyConstraint;	/* optional element of XSD type xsd:string */
	bool IsInput;	/* required element of XSD type xsd:boolean */
	std::vector<enum resqml2__ParameterKind> AllowedKind;	/* optional element of XSD type resqml2:ParameterKind */
	bool IsOutput;	/* required element of XSD type xsd:boolean */
	std::string Title;	/* required element of XSD type xsd:string */
	std::string *DataObjectContentType;	/* optional element of XSD type xsd:string */
	LONG64 MaxOccurs;	/* required element of XSD type xsd:long */
	LONG64 MinOccurs;	/* required element of XSD type xsd:long */
	std::string *Constraint;	/* optional element of XSD type xsd:string */
	std::vector<resqml2__AbstractActivityParameter *> DefaultValue;	/* optional element of XSD type resqml2:AbstractActivityParameter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterTemplate (252)
	virtual int soap_type(void) const { return 252; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ParameterTemplate, default initialized and not managed by a soap context
	virtual resqml2__ParameterTemplate *soap_alloc(void) const { return SOAP_NEW(resqml2__ParameterTemplate); }
	         resqml2__ParameterTemplate() { resqml2__ParameterTemplate::soap_default(NULL); }
	virtual ~resqml2__ParameterTemplate() { }
	friend resqml2__ParameterTemplate *soap_instantiate_resqml2__ParameterTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:903 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParameterKey (256)
/* Type resqml2__AbstractParameterKey is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractParameterKey complex type: */
class SOAP_CMAC resqml2__AbstractParameterKey
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParameterKey (256)
	virtual int soap_type(void) const { return 256; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractParameterKey, default initialized and not managed by a soap context
	virtual resqml2__AbstractParameterKey *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractParameterKey); }
	         resqml2__AbstractParameterKey() { resqml2__AbstractParameterKey::soap_default(NULL); }
	virtual ~resqml2__AbstractParameterKey() { }
	friend resqml2__AbstractParameterKey *soap_instantiate_resqml2__AbstractParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:909 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractActivityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractActivityParameter (258)
/* Type resqml2__AbstractActivityParameter is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractActivityParameter complex type: */
class SOAP_CMAC resqml2__AbstractActivityParameter
{
public:
	std::string Title;	/* required element of XSD type xsd:string */
	LONG64 *Index;	/* optional element of XSD type xsd:long */
	std::string *Selection;	/* optional element of XSD type xsd:string */
	std::vector<resqml2__AbstractParameterKey *> Key;	/* optional element of XSD type resqml2:AbstractParameterKey */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractActivityParameter (258)
	virtual int soap_type(void) const { return 258; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractActivityParameter, default initialized and not managed by a soap context
	virtual resqml2__AbstractActivityParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractActivityParameter); }
	         resqml2__AbstractActivityParameter() { resqml2__AbstractActivityParameter::soap_default(NULL); }
	virtual ~resqml2__AbstractActivityParameter() { }
	friend resqml2__AbstractActivityParameter *soap_instantiate_resqml2__AbstractActivityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:924 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineWellbores
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineWellbores (263)
/* resqml2:StreamlineWellbores complex type: */
class SOAP_CMAC resqml2__StreamlineWellbores
{
public:
	resqml2__AbstractIntegerArray *InjectorPerLine;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *ProducerPerLine;	/* required element of XSD type resqml2:AbstractIntegerArray */
	std::vector<eml__DataObjectReference *> WellboreTrajectoryRepresentation;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineWellbores (263)
	virtual int soap_type(void) const { return 263; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__StreamlineWellbores, default initialized and not managed by a soap context
	virtual resqml2__StreamlineWellbores *soap_alloc(void) const { return SOAP_NEW(resqml2__StreamlineWellbores); }
	         resqml2__StreamlineWellbores() { resqml2__StreamlineWellbores::soap_default(NULL); }
	virtual ~resqml2__StreamlineWellbores() { }
	friend resqml2__StreamlineWellbores *soap_instantiate_resqml2__StreamlineWellbores(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:927 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalGridCells
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalGridCells (264)
/* resqml2:IntervalGridCells complex type: */
class SOAP_CMAC resqml2__IntervalGridCells
{
public:
	ULONG64 CellCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *GridIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *CellIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *LocalFacePairPerCellIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	std::vector<eml__DataObjectReference *> Grids;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalGridCells (264)
	virtual int soap_type(void) const { return 264; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IntervalGridCells, default initialized and not managed by a soap context
	virtual resqml2__IntervalGridCells *soap_alloc(void) const { return SOAP_NEW(resqml2__IntervalGridCells); }
	         resqml2__IntervalGridCells() { resqml2__IntervalGridCells::soap_default(NULL); }
	virtual ~resqml2__IntervalGridCells() { }
	friend resqml2__IntervalGridCells *soap_instantiate_resqml2__IntervalGridCells(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:930 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndices
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndices (265)
/* resqml2:TimeIndices complex type: */
class SOAP_CMAC resqml2__TimeIndices
{
public:
	ULONG64 TimeIndexCount;	/* required element of XSD type xsd:positiveInteger */
	ULONG64 *TimeIndexStart;	/* optional element of XSD type xsd:nonNegativeInteger */
	resqml2__AbstractIntegerArray *SimulatorTimeStep;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	bool UseInterval;	/* required element of XSD type xsd:boolean */
	eml__DataObjectReference *TimeSeries;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndices (265)
	virtual int soap_type(void) const { return 265; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__TimeIndices, default initialized and not managed by a soap context
	virtual resqml2__TimeIndices *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeIndices); }
	         resqml2__TimeIndices() { resqml2__TimeIndices::soap_default(NULL); }
	virtual ~resqml2__TimeIndices() { }
	friend resqml2__TimeIndices *soap_instantiate_resqml2__TimeIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:948 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CustomData
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CustomData (271)
/* eml:CustomData complex type: */
class SOAP_CMAC eml__CustomData
{
public:
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__CustomData (271)
	virtual int soap_type(void) const { return 271; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__CustomData, default initialized and not managed by a soap context
	virtual eml__CustomData *soap_alloc(void) const { return SOAP_NEW(eml__CustomData); }
	         eml__CustomData() { eml__CustomData::soap_default(NULL); }
	virtual ~eml__CustomData() { }
	friend eml__CustomData *soap_instantiate_eml__CustomData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:951 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__Citation
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__Citation (272)
/* eml:Citation complex type: */
class SOAP_CMAC eml__Citation
{
public:
	std::string Title;	/* required element of XSD type eml:DescriptionString */
	std::string Originator;	/* required element of XSD type eml:NameString */
	time_t Creation;	/* required element of XSD type xsd:dateTime */
	std::string Format;	/* required element of XSD type eml:DescriptionString */
	std::string *Editor;	/* optional element of XSD type eml:NameString */
	time_t *LastUpdate;	/* optional element of XSD type xsd:dateTime */
	std::string *VersionString;	/* optional element of XSD type xsd:string */
	std::string *Description;	/* optional element of XSD type eml:CommentString */
	std::string *DescriptiveKeywords;	/* optional element of XSD type eml:CommentString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__Citation (272)
	virtual int soap_type(void) const { return 272; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__Citation, default initialized and not managed by a soap context
	virtual eml__Citation *soap_alloc(void) const { return SOAP_NEW(eml__Citation); }
	         eml__Citation() { eml__Citation::soap_default(NULL); }
	virtual ~eml__Citation() { }
	friend eml__Citation *soap_instantiate_eml__Citation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:954 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractObject
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractObject (273)
/* eml:AbstractObject complex type: */
class SOAP_CMAC eml__AbstractObject
{
public:
	eml__Citation *Citation;	/* optional element of XSD type eml:Citation */
	std::vector<eml__ObjectAlias *> Aliases;	/* optional element of XSD type eml:ObjectAlias */
	eml__CustomData *CustomData;	/* optional element of XSD type eml:CustomData */
	std::string schemaVersion;	/* required attribute of XSD type xsd:string */
	std::string uuid;	/* required attribute of XSD type eml:UuidString */
	std::string *objectVersion;	/* optional attribute of XSD type eml:NameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractObject (273)
	virtual int soap_type(void) const { return 273; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AbstractObject, default initialized and not managed by a soap context
	virtual eml__AbstractObject *soap_alloc(void) const { return SOAP_NEW(eml__AbstractObject); }
	         eml__AbstractObject() { eml__AbstractObject::soap_default(NULL); }
	virtual ~eml__AbstractObject() { }
	friend eml__AbstractObject *soap_instantiate_eml__AbstractObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:957 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ObjectAlias
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ObjectAlias (274)
/* eml:ObjectAlias complex type: */
class SOAP_CMAC eml__ObjectAlias
{
public:
	std::string Identifier;	/* required element of XSD type xsd:string */
	std::string *Description;	/* optional element of XSD type eml:DescriptionString */
	std::string *authority;	/* optional attribute of XSD type eml:NameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ObjectAlias (274)
	virtual int soap_type(void) const { return 274; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ObjectAlias, default initialized and not managed by a soap context
	virtual eml__ObjectAlias *soap_alloc(void) const { return SOAP_NEW(eml__ObjectAlias); }
	         eml__ObjectAlias() { eml__ObjectAlias::soap_default(NULL); }
	virtual ~eml__ObjectAlias() { }
	friend eml__ObjectAlias *soap_instantiate_eml__ObjectAlias(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:975 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractVerticalCrs (280)
/* Type eml__AbstractVerticalCrs is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:AbstractVerticalCrs complex type: */
class SOAP_CMAC eml__AbstractVerticalCrs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractVerticalCrs (280)
	virtual int soap_type(void) const { return 280; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AbstractVerticalCrs, default initialized and not managed by a soap context
	virtual eml__AbstractVerticalCrs *soap_alloc(void) const { return SOAP_NEW(eml__AbstractVerticalCrs); }
	         eml__AbstractVerticalCrs() { eml__AbstractVerticalCrs::soap_default(NULL); }
	virtual ~eml__AbstractVerticalCrs() { }
	friend eml__AbstractVerticalCrs *soap_instantiate_eml__AbstractVerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:978 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractProjectedCrs (281)
/* Type eml__AbstractProjectedCrs is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:AbstractProjectedCrs complex type: */
class SOAP_CMAC eml__AbstractProjectedCrs
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractProjectedCrs (281)
	virtual int soap_type(void) const { return 281; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AbstractProjectedCrs, default initialized and not managed by a soap context
	virtual eml__AbstractProjectedCrs *soap_alloc(void) const { return SOAP_NEW(eml__AbstractProjectedCrs); }
	         eml__AbstractProjectedCrs() { eml__AbstractProjectedCrs::soap_default(NULL); }
	virtual ~eml__AbstractProjectedCrs() { }
	friend eml__AbstractProjectedCrs *soap_instantiate_eml__AbstractProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:990 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__Hdf5Dataset
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__Hdf5Dataset (285)
/* eml:Hdf5Dataset complex type: */
class SOAP_CMAC eml__Hdf5Dataset
{
public:
	std::string PathInHdfFile;	/* required element of XSD type xsd:string */
	eml__DataObjectReference *HdfProxy;	/* required element of XSD type eml:DataObjectReference */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__Hdf5Dataset (285)
	virtual int soap_type(void) const { return 285; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__Hdf5Dataset, default initialized and not managed by a soap context
	virtual eml__Hdf5Dataset *soap_alloc(void) const { return SOAP_NEW(eml__Hdf5Dataset); }
	         eml__Hdf5Dataset() { eml__Hdf5Dataset::soap_default(NULL); }
	virtual ~eml__Hdf5Dataset() { }
	friend eml__Hdf5Dataset *soap_instantiate_eml__Hdf5Dataset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:996 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DataObjectReference
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DataObjectReference (287)
/* Type eml__DataObjectReference is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:DataObjectReference complex type: */
class SOAP_CMAC eml__DataObjectReference
{
public:
	std::string ContentType;	/* required element of XSD type xsd:string */
	std::string Title;	/* required element of XSD type eml:DescriptionString */
	std::string UUID;	/* required element of XSD type eml:UuidString */
	std::string *UuidAuthority;	/* optional element of XSD type xsd:string */
	std::string *VersionString;	/* optional element of XSD type eml:NameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__DataObjectReference (287)
	virtual int soap_type(void) const { return 287; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__DataObjectReference, default initialized and not managed by a soap context
	virtual eml__DataObjectReference *soap_alloc(void) const { return SOAP_NEW(eml__DataObjectReference); }
	         eml__DataObjectReference() { eml__DataObjectReference::soap_default(NULL); }
	virtual ~eml__DataObjectReference() { }
	friend eml__DataObjectReference *soap_instantiate_eml__DataObjectReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1539 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGMLType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGMLType (468)
/* Type gml__AbstractGMLType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractGMLType complex type: */
class SOAP_CMAC gml__AbstractGMLType
{
public:
	gml__StringOrRefType *description;	/* optional element of XSD type gml:StringOrRefType */
	gml__ReferenceType *descriptionReference;	/* optional element of XSD type gml:ReferenceType */
	gml__CodeWithAuthorityType *identifier;	/* optional element of XSD type gml:CodeWithAuthorityType */
	std::vector<gml__CodeType *> name;	/* optional element of XSD type gml:CodeType */
	std::string gml__id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGMLType (468)
	virtual int soap_type(void) const { return 468; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractGMLType, default initialized and not managed by a soap context
	virtual gml__AbstractGMLType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGMLType); }
	         gml__AbstractGMLType() { gml__AbstractGMLType::soap_default(NULL); }
	virtual ~gml__AbstractGMLType() { }
	friend gml__AbstractGMLType *soap_instantiate_gml__AbstractGMLType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1545 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__ReferenceType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__ReferenceType (470)
/* gml:ReferenceType complex type: */
class SOAP_CMAC gml__ReferenceType
{
public:
	bool owns;	/* optional attribute of XSD type xsd:boolean */
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__ReferenceType (470)
	virtual int soap_type(void) const { return 470; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__ReferenceType, default initialized and not managed by a soap context
	virtual gml__ReferenceType *soap_alloc(void) const { return SOAP_NEW(gml__ReferenceType); }
	         gml__ReferenceType() { gml__ReferenceType::soap_default(NULL); }
	virtual ~gml__ReferenceType() { }
	friend gml__ReferenceType *soap_instantiate_gml__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15507 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_TimePrimitivePropertyType (879)
/* xsd:choice complex type: */
union _gml__union_TimePrimitivePropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:15496 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__TimePrimitivePropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__TimePrimitivePropertyType_sequence (878)
/* Operation wrapper: */
class SOAP_CMAC __gml__TimePrimitivePropertyType_sequence
{
public:
	int __unionAbstractTimePrimitive;	/* union discriminant (of union defined below) */
	union _gml__union_TimePrimitivePropertyType __union_TimePrimitivePropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__TimePrimitivePropertyType_sequence (878)
	virtual int soap_type(void) const { return 878; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__TimePrimitivePropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__TimePrimitivePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__TimePrimitivePropertyType_sequence); }
	         __gml__TimePrimitivePropertyType_sequence() { __gml__TimePrimitivePropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__TimePrimitivePropertyType_sequence() { }
	friend __gml__TimePrimitivePropertyType_sequence *soap_instantiate___gml__TimePrimitivePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1563 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__TimePrimitivePropertyType (476)
/* Type gml__TimePrimitivePropertyType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:TimePrimitivePropertyType complex type: */
class SOAP_CMAC gml__TimePrimitivePropertyType
{
public:
	__gml__TimePrimitivePropertyType_sequence *__TimePrimitivePropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	bool owns;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__TimePrimitivePropertyType (476)
	virtual int soap_type(void) const { return 476; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__TimePrimitivePropertyType, default initialized and not managed by a soap context
	virtual gml__TimePrimitivePropertyType *soap_alloc(void) const { return SOAP_NEW(gml__TimePrimitivePropertyType); }
	         gml__TimePrimitivePropertyType() { gml__TimePrimitivePropertyType::soap_default(NULL); }
	virtual ~gml__TimePrimitivePropertyType() { }
	friend gml__TimePrimitivePropertyType *soap_instantiate_gml__TimePrimitivePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15567 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidalCSPropertyType_sequence (881)
/* Operation wrapper: */
class SOAP_CMAC __gml__EllipsoidalCSPropertyType_sequence
{
public:
	gml__EllipsoidalCSType *EllipsoidalCS;	/* required element of XSD type gml:EllipsoidalCSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidalCSPropertyType_sequence (881)
	virtual int soap_type(void) const { return 881; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__EllipsoidalCSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__EllipsoidalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__EllipsoidalCSPropertyType_sequence); }
	         __gml__EllipsoidalCSPropertyType_sequence() { __gml__EllipsoidalCSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__EllipsoidalCSPropertyType_sequence() { }
	friend __gml__EllipsoidalCSPropertyType_sequence *soap_instantiate___gml__EllipsoidalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1566 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSPropertyType (477)
/* gml:EllipsoidalCSPropertyType complex type: */
class SOAP_CMAC gml__EllipsoidalCSPropertyType
{
public:
	__gml__EllipsoidalCSPropertyType_sequence *__EllipsoidalCSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSPropertyType (477)
	virtual int soap_type(void) const { return 477; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__EllipsoidalCSPropertyType, default initialized and not managed by a soap context
	virtual gml__EllipsoidalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidalCSPropertyType); }
	         gml__EllipsoidalCSPropertyType() { gml__EllipsoidalCSPropertyType::soap_default(NULL); }
	virtual ~gml__EllipsoidalCSPropertyType() { }
	friend gml__EllipsoidalCSPropertyType *soap_instantiate_gml__EllipsoidalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15628 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__CoordinateSystemAxisPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__CoordinateSystemAxisPropertyType_sequence (884)
/* Operation wrapper: */
class SOAP_CMAC __gml__CoordinateSystemAxisPropertyType_sequence
{
public:
	gml__CoordinateSystemAxisType *CoordinateSystemAxis;	/* required element of XSD type gml:CoordinateSystemAxisType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__CoordinateSystemAxisPropertyType_sequence (884)
	virtual int soap_type(void) const { return 884; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__CoordinateSystemAxisPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__CoordinateSystemAxisPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CoordinateSystemAxisPropertyType_sequence); }
	         __gml__CoordinateSystemAxisPropertyType_sequence() { __gml__CoordinateSystemAxisPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__CoordinateSystemAxisPropertyType_sequence() { }
	friend __gml__CoordinateSystemAxisPropertyType_sequence *soap_instantiate___gml__CoordinateSystemAxisPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1575 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisPropertyType (480)
/* gml:CoordinateSystemAxisPropertyType complex type: */
class SOAP_CMAC gml__CoordinateSystemAxisPropertyType
{
public:
	__gml__CoordinateSystemAxisPropertyType_sequence *__CoordinateSystemAxisPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisPropertyType (480)
	virtual int soap_type(void) const { return 480; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CoordinateSystemAxisPropertyType, default initialized and not managed by a soap context
	virtual gml__CoordinateSystemAxisPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CoordinateSystemAxisPropertyType); }
	         gml__CoordinateSystemAxisPropertyType() { gml__CoordinateSystemAxisPropertyType::soap_default(NULL); }
	virtual ~gml__CoordinateSystemAxisPropertyType() { }
	friend gml__CoordinateSystemAxisPropertyType *soap_instantiate_gml__CoordinateSystemAxisPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15689 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__CartesianCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__CartesianCSPropertyType_sequence (887)
/* Operation wrapper: */
class SOAP_CMAC __gml__CartesianCSPropertyType_sequence
{
public:
	gml__CartesianCSType *CartesianCS;	/* required element of XSD type gml:CartesianCSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__CartesianCSPropertyType_sequence (887)
	virtual int soap_type(void) const { return 887; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__CartesianCSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__CartesianCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CartesianCSPropertyType_sequence); }
	         __gml__CartesianCSPropertyType_sequence() { __gml__CartesianCSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__CartesianCSPropertyType_sequence() { }
	friend __gml__CartesianCSPropertyType_sequence *soap_instantiate___gml__CartesianCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1581 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSPropertyType (482)
/* gml:CartesianCSPropertyType complex type: */
class SOAP_CMAC gml__CartesianCSPropertyType
{
public:
	__gml__CartesianCSPropertyType_sequence *__CartesianCSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSPropertyType (482)
	virtual int soap_type(void) const { return 482; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CartesianCSPropertyType, default initialized and not managed by a soap context
	virtual gml__CartesianCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CartesianCSPropertyType); }
	         gml__CartesianCSPropertyType() { gml__CartesianCSPropertyType::soap_default(NULL); }
	virtual ~gml__CartesianCSPropertyType() { }
	friend gml__CartesianCSPropertyType *soap_instantiate_gml__CartesianCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15750 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__SphericalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__SphericalCSPropertyType_sequence (890)
/* Operation wrapper: */
class SOAP_CMAC __gml__SphericalCSPropertyType_sequence
{
public:
	gml__SphericalCSType *SphericalCS;	/* required element of XSD type gml:SphericalCSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__SphericalCSPropertyType_sequence (890)
	virtual int soap_type(void) const { return 890; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__SphericalCSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__SphericalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__SphericalCSPropertyType_sequence); }
	         __gml__SphericalCSPropertyType_sequence() { __gml__SphericalCSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__SphericalCSPropertyType_sequence() { }
	friend __gml__SphericalCSPropertyType_sequence *soap_instantiate___gml__SphericalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1587 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSPropertyType (484)
/* gml:SphericalCSPropertyType complex type: */
class SOAP_CMAC gml__SphericalCSPropertyType
{
public:
	__gml__SphericalCSPropertyType_sequence *__SphericalCSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSPropertyType (484)
	virtual int soap_type(void) const { return 484; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__SphericalCSPropertyType, default initialized and not managed by a soap context
	virtual gml__SphericalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__SphericalCSPropertyType); }
	         gml__SphericalCSPropertyType() { gml__SphericalCSPropertyType::soap_default(NULL); }
	virtual ~gml__SphericalCSPropertyType() { }
	friend gml__SphericalCSPropertyType *soap_instantiate_gml__SphericalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15811 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticDatumPropertyType_sequence (893)
/* Operation wrapper: */
class SOAP_CMAC __gml__GeodeticDatumPropertyType_sequence
{
public:
	gml__GeodeticDatumType *GeodeticDatum;	/* required element of XSD type gml:GeodeticDatumType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticDatumPropertyType_sequence (893)
	virtual int soap_type(void) const { return 893; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__GeodeticDatumPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__GeodeticDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeodeticDatumPropertyType_sequence); }
	         __gml__GeodeticDatumPropertyType_sequence() { __gml__GeodeticDatumPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__GeodeticDatumPropertyType_sequence() { }
	friend __gml__GeodeticDatumPropertyType_sequence *soap_instantiate___gml__GeodeticDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1593 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumPropertyType (486)
/* gml:GeodeticDatumPropertyType complex type: */
class SOAP_CMAC gml__GeodeticDatumPropertyType
{
public:
	__gml__GeodeticDatumPropertyType_sequence *__GeodeticDatumPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumPropertyType (486)
	virtual int soap_type(void) const { return 486; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeodeticDatumPropertyType, default initialized and not managed by a soap context
	virtual gml__GeodeticDatumPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticDatumPropertyType); }
	         gml__GeodeticDatumPropertyType() { gml__GeodeticDatumPropertyType::soap_default(NULL); }
	virtual ~gml__GeodeticDatumPropertyType() { }
	friend gml__GeodeticDatumPropertyType *soap_instantiate_gml__GeodeticDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15872 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__PrimeMeridianPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__PrimeMeridianPropertyType_sequence (896)
/* Operation wrapper: */
class SOAP_CMAC __gml__PrimeMeridianPropertyType_sequence
{
public:
	gml__PrimeMeridianType *PrimeMeridian;	/* required element of XSD type gml:PrimeMeridianType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__PrimeMeridianPropertyType_sequence (896)
	virtual int soap_type(void) const { return 896; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__PrimeMeridianPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__PrimeMeridianPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__PrimeMeridianPropertyType_sequence); }
	         __gml__PrimeMeridianPropertyType_sequence() { __gml__PrimeMeridianPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__PrimeMeridianPropertyType_sequence() { }
	friend __gml__PrimeMeridianPropertyType_sequence *soap_instantiate___gml__PrimeMeridianPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1602 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianPropertyType (489)
/* gml:PrimeMeridianPropertyType complex type: */
class SOAP_CMAC gml__PrimeMeridianPropertyType
{
public:
	__gml__PrimeMeridianPropertyType_sequence *__PrimeMeridianPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianPropertyType (489)
	virtual int soap_type(void) const { return 489; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__PrimeMeridianPropertyType, default initialized and not managed by a soap context
	virtual gml__PrimeMeridianPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__PrimeMeridianPropertyType); }
	         gml__PrimeMeridianPropertyType() { gml__PrimeMeridianPropertyType::soap_default(NULL); }
	virtual ~gml__PrimeMeridianPropertyType() { }
	friend gml__PrimeMeridianPropertyType *soap_instantiate_gml__PrimeMeridianPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15933 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidPropertyType_sequence (899)
/* Operation wrapper: */
class SOAP_CMAC __gml__EllipsoidPropertyType_sequence
{
public:
	gml__EllipsoidType *Ellipsoid;	/* required element of XSD type gml:EllipsoidType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidPropertyType_sequence (899)
	virtual int soap_type(void) const { return 899; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__EllipsoidPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__EllipsoidPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__EllipsoidPropertyType_sequence); }
	         __gml__EllipsoidPropertyType_sequence() { __gml__EllipsoidPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__EllipsoidPropertyType_sequence() { }
	friend __gml__EllipsoidPropertyType_sequence *soap_instantiate___gml__EllipsoidPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1614 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidPropertyType (493)
/* gml:EllipsoidPropertyType complex type: */
class SOAP_CMAC gml__EllipsoidPropertyType
{
public:
	__gml__EllipsoidPropertyType_sequence *__EllipsoidPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidPropertyType (493)
	virtual int soap_type(void) const { return 493; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__EllipsoidPropertyType, default initialized and not managed by a soap context
	virtual gml__EllipsoidPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidPropertyType); }
	         gml__EllipsoidPropertyType() { gml__EllipsoidPropertyType::soap_default(NULL); }
	virtual ~gml__EllipsoidPropertyType() { }
	friend gml__EllipsoidPropertyType *soap_instantiate_gml__EllipsoidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16006 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_GeneralConversionPropertyType (903)
/* xsd:choice complex type: */
union _gml__union_GeneralConversionPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:15994 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__GeneralConversionPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__GeneralConversionPropertyType_sequence (902)
/* Operation wrapper: */
class SOAP_CMAC __gml__GeneralConversionPropertyType_sequence
{
public:
	int __unionAbstractGeneralConversion;	/* union discriminant (of union defined below) */
	union _gml__union_GeneralConversionPropertyType __union_GeneralConversionPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__GeneralConversionPropertyType_sequence (902)
	virtual int soap_type(void) const { return 902; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__GeneralConversionPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__GeneralConversionPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeneralConversionPropertyType_sequence); }
	         __gml__GeneralConversionPropertyType_sequence() { __gml__GeneralConversionPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__GeneralConversionPropertyType_sequence() { }
	friend __gml__GeneralConversionPropertyType_sequence *soap_instantiate___gml__GeneralConversionPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1629 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeneralConversionPropertyType (498)
/* gml:GeneralConversionPropertyType complex type: */
class SOAP_CMAC gml__GeneralConversionPropertyType
{
public:
	__gml__GeneralConversionPropertyType_sequence *__GeneralConversionPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__GeneralConversionPropertyType (498)
	virtual int soap_type(void) const { return 498; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeneralConversionPropertyType, default initialized and not managed by a soap context
	virtual gml__GeneralConversionPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeneralConversionPropertyType); }
	         gml__GeneralConversionPropertyType() { gml__GeneralConversionPropertyType::soap_default(NULL); }
	virtual ~gml__GeneralConversionPropertyType() { }
	friend gml__GeneralConversionPropertyType *soap_instantiate_gml__GeneralConversionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16073 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_CRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_CRSPropertyType (906)
/* xsd:choice complex type: */
union _gml__union_CRSPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:16062 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__CRSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__CRSPropertyType_sequence (905)
/* Operation wrapper: */
class SOAP_CMAC __gml__CRSPropertyType_sequence
{
public:
	int __unionAbstractCRS;	/* union discriminant (of union defined below) */
	union _gml__union_CRSPropertyType __union_CRSPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__CRSPropertyType_sequence (905)
	virtual int soap_type(void) const { return 905; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__CRSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__CRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CRSPropertyType_sequence); }
	         __gml__CRSPropertyType_sequence() { __gml__CRSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__CRSPropertyType_sequence() { }
	friend __gml__CRSPropertyType_sequence *soap_instantiate___gml__CRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1638 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CRSPropertyType (501)
/* gml:CRSPropertyType complex type: */
class SOAP_CMAC gml__CRSPropertyType
{
public:
	__gml__CRSPropertyType_sequence *__CRSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__CRSPropertyType (501)
	virtual int soap_type(void) const { return 501; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CRSPropertyType, default initialized and not managed by a soap context
	virtual gml__CRSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CRSPropertyType); }
	         gml__CRSPropertyType() { gml__CRSPropertyType::soap_default(NULL); }
	virtual ~gml__CRSPropertyType() { }
	friend gml__CRSPropertyType *soap_instantiate_gml__CRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16129 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticCRSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticCRSPropertyType_sequence (908)
/* Operation wrapper: */
class SOAP_CMAC __gml__GeodeticCRSPropertyType_sequence
{
public:
	gml__GeodeticCRSType *GeodeticCRS;	/* required element of XSD type gml:GeodeticCRSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticCRSPropertyType_sequence (908)
	virtual int soap_type(void) const { return 908; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__GeodeticCRSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__GeodeticCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeodeticCRSPropertyType_sequence); }
	         __gml__GeodeticCRSPropertyType_sequence() { __gml__GeodeticCRSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__GeodeticCRSPropertyType_sequence() { }
	friend __gml__GeodeticCRSPropertyType_sequence *soap_instantiate___gml__GeodeticCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1641 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSPropertyType (502)
/* gml:GeodeticCRSPropertyType complex type: */
class SOAP_CMAC gml__GeodeticCRSPropertyType
{
public:
	__gml__GeodeticCRSPropertyType_sequence *__GeodeticCRSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSPropertyType (502)
	virtual int soap_type(void) const { return 502; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeodeticCRSPropertyType, default initialized and not managed by a soap context
	virtual gml__GeodeticCRSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticCRSPropertyType); }
	         gml__GeodeticCRSPropertyType() { gml__GeodeticCRSPropertyType::soap_default(NULL); }
	virtual ~gml__GeodeticCRSPropertyType() { }
	friend gml__GeodeticCRSPropertyType *soap_instantiate_gml__GeodeticCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16187 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalCSPropertyType_sequence (911)
/* Operation wrapper: */
class SOAP_CMAC __gml__VerticalCSPropertyType_sequence
{
public:
	gml__VerticalCSType *VerticalCS;	/* required element of XSD type gml:VerticalCSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalCSPropertyType_sequence (911)
	virtual int soap_type(void) const { return 911; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__VerticalCSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__VerticalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__VerticalCSPropertyType_sequence); }
	         __gml__VerticalCSPropertyType_sequence() { __gml__VerticalCSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__VerticalCSPropertyType_sequence() { }
	friend __gml__VerticalCSPropertyType_sequence *soap_instantiate___gml__VerticalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1647 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSPropertyType (504)
/* gml:VerticalCSPropertyType complex type: */
class SOAP_CMAC gml__VerticalCSPropertyType
{
public:
	__gml__VerticalCSPropertyType_sequence *__VerticalCSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSPropertyType (504)
	virtual int soap_type(void) const { return 504; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalCSPropertyType, default initialized and not managed by a soap context
	virtual gml__VerticalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCSPropertyType); }
	         gml__VerticalCSPropertyType() { gml__VerticalCSPropertyType::soap_default(NULL); }
	virtual ~gml__VerticalCSPropertyType() { }
	friend gml__VerticalCSPropertyType *soap_instantiate_gml__VerticalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16248 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalDatumPropertyType_sequence (914)
/* Operation wrapper: */
class SOAP_CMAC __gml__VerticalDatumPropertyType_sequence
{
public:
	gml__VerticalDatumType *VerticalDatum;	/* required element of XSD type gml:VerticalDatumType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalDatumPropertyType_sequence (914)
	virtual int soap_type(void) const { return 914; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__VerticalDatumPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__VerticalDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__VerticalDatumPropertyType_sequence); }
	         __gml__VerticalDatumPropertyType_sequence() { __gml__VerticalDatumPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__VerticalDatumPropertyType_sequence() { }
	friend __gml__VerticalDatumPropertyType_sequence *soap_instantiate___gml__VerticalDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1653 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumPropertyType (506)
/* gml:VerticalDatumPropertyType complex type: */
class SOAP_CMAC gml__VerticalDatumPropertyType
{
public:
	__gml__VerticalDatumPropertyType_sequence *__VerticalDatumPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumPropertyType (506)
	virtual int soap_type(void) const { return 506; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalDatumPropertyType, default initialized and not managed by a soap context
	virtual gml__VerticalDatumPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalDatumPropertyType); }
	         gml__VerticalDatumPropertyType() { gml__VerticalDatumPropertyType::soap_default(NULL); }
	virtual ~gml__VerticalDatumPropertyType() { }
	friend gml__VerticalDatumPropertyType *soap_instantiate_gml__VerticalDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16310 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__domainOfValidity_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__domainOfValidity_sequence (917)
/* Operation wrapper: */
class SOAP_CMAC __gml__domainOfValidity_sequence
{
public:
	gmd__EX_USCOREExtent_USCOREType *gmd__EX_USCOREExtent;	/* required element of XSD type gmd:EX_Extent_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__domainOfValidity_sequence (917)
	virtual int soap_type(void) const { return 917; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__domainOfValidity_sequence, default initialized and not managed by a soap context
	virtual __gml__domainOfValidity_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__domainOfValidity_sequence); }
	         __gml__domainOfValidity_sequence() { __gml__domainOfValidity_sequence::soap_default(NULL); }
	virtual ~__gml__domainOfValidity_sequence() { }
	friend __gml__domainOfValidity_sequence *soap_instantiate___gml__domainOfValidity_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1659 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__domainOfValidity
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__domainOfValidity (508)
/* gml:domainOfValidity complex type: */
class SOAP_CMAC _gml__domainOfValidity
{
public:
	__gml__domainOfValidity_sequence *__domainOfValidity_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1__gml__domainOfValidity (508)
	virtual int soap_type(void) const { return 508; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _gml__domainOfValidity, default initialized and not managed by a soap context
	virtual _gml__domainOfValidity *soap_alloc(void) const { return SOAP_NEW(_gml__domainOfValidity); }
	         _gml__domainOfValidity() { _gml__domainOfValidity::soap_default(NULL); }
	virtual ~_gml__domainOfValidity() { }
	friend _gml__domainOfValidity *soap_instantiate__gml__domainOfValidity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1662 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__secondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__secondDefiningParameter (509)
/* gml:secondDefiningParameter complex type: */
class SOAP_CMAC _gml__secondDefiningParameter
{
public:
	_gml__SecondDefiningParameter *SecondDefiningParameter;	/* required element of XSD type gml:SecondDefiningParameter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1__gml__secondDefiningParameter (509)
	virtual int soap_type(void) const { return 509; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _gml__secondDefiningParameter, default initialized and not managed by a soap context
	virtual _gml__secondDefiningParameter *soap_alloc(void) const { return SOAP_NEW(_gml__secondDefiningParameter); }
	         _gml__secondDefiningParameter() { _gml__secondDefiningParameter::soap_default(NULL); }
	virtual ~_gml__secondDefiningParameter() { }
	friend _gml__secondDefiningParameter *soap_instantiate__gml__secondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16402 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter (923)
/* xsd:choice complex type: */
union _gml__union_SecondDefiningParameter
{
#define SOAP_UNION_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter_inverseFlattening	(1)
	gml__MeasureType *inverseFlattening;
#define SOAP_UNION_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter_semiMinorAxis	(2)
	gml__LengthType *semiMinorAxis;
#define SOAP_UNION_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter_isSphere	(3)
	bool isSphere;
};
#endif

/* resqml2_0_1ForGsoap.h:1665 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__SecondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__SecondDefiningParameter (510)
/* Choice: */
class SOAP_CMAC _gml__SecondDefiningParameter
{
public:
	int __union_SecondDefiningParameter;	/* union discriminant (of union defined below) */
	union _gml__union_SecondDefiningParameter union_SecondDefiningParameter;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1__gml__SecondDefiningParameter (510)
	virtual int soap_type(void) const { return 510; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _gml__SecondDefiningParameter, default initialized and not managed by a soap context
	virtual _gml__SecondDefiningParameter *soap_alloc(void) const { return SOAP_NEW(_gml__SecondDefiningParameter); }
	         _gml__SecondDefiningParameter() { _gml__SecondDefiningParameter::soap_default(NULL); }
	virtual ~_gml__SecondDefiningParameter() { }
	friend _gml__SecondDefiningParameter *soap_instantiate__gml__SecondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16435 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_coordinateOperationAccuracy (925)
/* xsd:choice complex type: */
union _gml__union_coordinateOperationAccuracy
{
};
#endif

/* resqml2_0_1ForGsoap.h:16427 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__coordinateOperationAccuracy_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__coordinateOperationAccuracy_sequence (924)
/* Operation wrapper: */
class SOAP_CMAC __gml__coordinateOperationAccuracy_sequence
{
public:
	int __unionAbstractDQ_USCOREPositionalAccuracy;	/* union discriminant (of union defined below) */
	union _gml__union_coordinateOperationAccuracy __union_coordinateOperationAccuracy;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gml__coordinateOperationAccuracy_sequence (924)
	virtual int soap_type(void) const { return 924; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__coordinateOperationAccuracy_sequence, default initialized and not managed by a soap context
	virtual __gml__coordinateOperationAccuracy_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__coordinateOperationAccuracy_sequence); }
	         __gml__coordinateOperationAccuracy_sequence() { __gml__coordinateOperationAccuracy_sequence::soap_default(NULL); }
	virtual ~__gml__coordinateOperationAccuracy_sequence() { }
	friend __gml__coordinateOperationAccuracy_sequence *soap_instantiate___gml__coordinateOperationAccuracy_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1668 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__coordinateOperationAccuracy (511)
/* gml:coordinateOperationAccuracy complex type: */
class SOAP_CMAC _gml__coordinateOperationAccuracy
{
public:
	__gml__coordinateOperationAccuracy_sequence *__coordinateOperationAccuracy_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1__gml__coordinateOperationAccuracy (511)
	virtual int soap_type(void) const { return 511; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _gml__coordinateOperationAccuracy, default initialized and not managed by a soap context
	virtual _gml__coordinateOperationAccuracy *soap_alloc(void) const { return SOAP_NEW(_gml__coordinateOperationAccuracy); }
	         _gml__coordinateOperationAccuracy() { _gml__coordinateOperationAccuracy::soap_default(NULL); }
	virtual ~_gml__coordinateOperationAccuracy() { }
	friend _gml__coordinateOperationAccuracy *soap_instantiate__gml__coordinateOperationAccuracy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16512 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType (928)
/* xsd:choice complex type: */
union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:16504 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence (927)
/* Operation wrapper: */
class SOAP_CMAC __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
{
public:
	int __unionAbstractEX_USCOREGeographicExtent;	/* union discriminant (of union defined below) */
	union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType __union_EX_USCOREGeographicExtent_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence (927)
	virtual int soap_type(void) const { return 927; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence); }
	         __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence() { __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence() { }
	friend __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *soap_instantiate___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1674 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType (513)
/* gmd:EX_GeographicExtent_PropertyType complex type: */
class SOAP_CMAC gmd__EX_USCOREGeographicExtent_USCOREPropertyType
{
public:
	__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *__EX_USCOREGeographicExtent_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType (513)
	virtual int soap_type(void) const { return 513; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCOREGeographicExtent_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__EX_USCOREGeographicExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREGeographicExtent_USCOREPropertyType); }
	         gmd__EX_USCOREGeographicExtent_USCOREPropertyType() { gmd__EX_USCOREGeographicExtent_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__EX_USCOREGeographicExtent_USCOREPropertyType() { }
	friend gmd__EX_USCOREGeographicExtent_USCOREPropertyType *soap_instantiate_gmd__EX_USCOREGeographicExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16567 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence (930)
/* Operation wrapper: */
class SOAP_CMAC __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
{
public:
	gmd__EX_USCORETemporalExtent_USCOREType *EX_USCORETemporalExtent;	/* required element of XSD type gmd:EX_TemporalExtent_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence (930)
	virtual int soap_type(void) const { return 930; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence); }
	         __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence() { __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence() { }
	friend __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *soap_instantiate___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1680 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType (515)
/* gmd:EX_TemporalExtent_PropertyType complex type: */
class SOAP_CMAC gmd__EX_USCORETemporalExtent_USCOREPropertyType
{
public:
	__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *__EX_USCORETemporalExtent_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType (515)
	virtual int soap_type(void) const { return 515; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCORETemporalExtent_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__EX_USCORETemporalExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCORETemporalExtent_USCOREPropertyType); }
	         gmd__EX_USCORETemporalExtent_USCOREPropertyType() { gmd__EX_USCORETemporalExtent_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__EX_USCORETemporalExtent_USCOREPropertyType() { }
	friend gmd__EX_USCORETemporalExtent_USCOREPropertyType *soap_instantiate_gmd__EX_USCORETemporalExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16624 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence (933)
/* Operation wrapper: */
class SOAP_CMAC __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
{
public:
	gmd__EX_USCOREVerticalExtent_USCOREType *EX_USCOREVerticalExtent;	/* required element of XSD type gmd:EX_VerticalExtent_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence (933)
	virtual int soap_type(void) const { return 933; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence); }
	         __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence() { __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence() { }
	friend __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *soap_instantiate___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1686 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType (517)
/* gmd:EX_VerticalExtent_PropertyType complex type: */
class SOAP_CMAC gmd__EX_USCOREVerticalExtent_USCOREPropertyType
{
public:
	__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *__EX_USCOREVerticalExtent_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType (517)
	virtual int soap_type(void) const { return 517; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCOREVerticalExtent_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__EX_USCOREVerticalExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREVerticalExtent_USCOREPropertyType); }
	         gmd__EX_USCOREVerticalExtent_USCOREPropertyType() { gmd__EX_USCOREVerticalExtent_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__EX_USCOREVerticalExtent_USCOREPropertyType() { }
	friend gmd__EX_USCOREVerticalExtent_USCOREPropertyType *soap_instantiate_gmd__EX_USCOREVerticalExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16681 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence (936)
/* Operation wrapper: */
class SOAP_CMAC __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
{
public:
	gmd__MD_USCOREIdentifier_USCOREType *MD_USCOREIdentifier;	/* required element of XSD type gmd:MD_Identifier_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence (936)
	virtual int soap_type(void) const { return 936; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence); }
	         __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence() { __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence() { }
	friend __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *soap_instantiate___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1698 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREPropertyType (521)
/* Type gmd__MD_USCOREIdentifier_USCOREPropertyType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:MD_Identifier_PropertyType complex type: */
class SOAP_CMAC gmd__MD_USCOREIdentifier_USCOREPropertyType
{
public:
	__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *__MD_USCOREIdentifier_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREPropertyType (521)
	virtual int soap_type(void) const { return 521; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__MD_USCOREIdentifier_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__MD_USCOREIdentifier_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__MD_USCOREIdentifier_USCOREPropertyType); }
	         gmd__MD_USCOREIdentifier_USCOREPropertyType() { gmd__MD_USCOREIdentifier_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__MD_USCOREIdentifier_USCOREPropertyType() { }
	friend gmd__MD_USCOREIdentifier_USCOREPropertyType *soap_instantiate_gmd__MD_USCOREIdentifier_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16738 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence (939)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCORECitation_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCORECitation_USCOREType *CI_USCORECitation;	/* required element of XSD type gmd:CI_Citation_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence (939)
	virtual int soap_type(void) const { return 939; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCORECitation_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCORECitation_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORECitation_USCOREPropertyType_sequence); }
	         __gmd__CI_USCORECitation_USCOREPropertyType_sequence() { __gmd__CI_USCORECitation_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCORECitation_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCORECitation_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCORECitation_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1704 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREPropertyType (523)
/* gmd:CI_Citation_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCORECitation_USCOREPropertyType
{
public:
	__gmd__CI_USCORECitation_USCOREPropertyType_sequence *__CI_USCORECitation_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREPropertyType (523)
	virtual int soap_type(void) const { return 523; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORECitation_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORECitation_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORECitation_USCOREPropertyType); }
	         gmd__CI_USCORECitation_USCOREPropertyType() { gmd__CI_USCORECitation_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCORECitation_USCOREPropertyType() { }
	friend gmd__CI_USCORECitation_USCOREPropertyType *soap_instantiate_gmd__CI_USCORECitation_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16795 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence (942)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREDate_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREDate_USCOREType *CI_USCOREDate;	/* required element of XSD type gmd:CI_Date_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence (942)
	virtual int soap_type(void) const { return 942; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREDate_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREDate_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREDate_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREDate_USCOREPropertyType_sequence() { __gmd__CI_USCOREDate_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREDate_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREDate_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREDate_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1710 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREPropertyType (525)
/* gmd:CI_Date_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREDate_USCOREPropertyType
{
public:
	__gmd__CI_USCOREDate_USCOREPropertyType_sequence *__CI_USCOREDate_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREPropertyType (525)
	virtual int soap_type(void) const { return 525; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREDate_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREDate_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDate_USCOREPropertyType); }
	         gmd__CI_USCOREDate_USCOREPropertyType() { gmd__CI_USCOREDate_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREDate_USCOREPropertyType() { }
	friend gmd__CI_USCOREDate_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREDate_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16852 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence (945)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *CI_USCOREDateTypeCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence (945)
	virtual int soap_type(void) const { return 945; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence() { __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1716 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType (527)
/* gmd:CI_DateTypeCode_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREDateTypeCode_USCOREPropertyType
{
public:
	__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *__CI_USCOREDateTypeCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType (527)
	virtual int soap_type(void) const { return 527; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREDateTypeCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREDateTypeCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDateTypeCode_USCOREPropertyType); }
	         gmd__CI_USCOREDateTypeCode_USCOREPropertyType() { gmd__CI_USCOREDateTypeCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREDateTypeCode_USCOREPropertyType() { }
	friend gmd__CI_USCOREDateTypeCode_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREDateTypeCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16879 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence (948)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREResponsibleParty_USCOREType *CI_USCOREResponsibleParty;	/* required element of XSD type gmd:CI_ResponsibleParty_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence (948)
	virtual int soap_type(void) const { return 948; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence() { __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1719 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType (528)
/* gmd:CI_ResponsibleParty_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREResponsibleParty_USCOREPropertyType
{
public:
	__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *__CI_USCOREResponsibleParty_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType (528)
	virtual int soap_type(void) const { return 528; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREResponsibleParty_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREResponsibleParty_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREResponsibleParty_USCOREPropertyType); }
	         gmd__CI_USCOREResponsibleParty_USCOREPropertyType() { gmd__CI_USCOREResponsibleParty_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREResponsibleParty_USCOREPropertyType() { }
	friend gmd__CI_USCOREResponsibleParty_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREResponsibleParty_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16936 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence (951)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREContact_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREContact_USCOREType *CI_USCOREContact;	/* required element of XSD type gmd:CI_Contact_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence (951)
	virtual int soap_type(void) const { return 951; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREContact_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREContact_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREContact_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREContact_USCOREPropertyType_sequence() { __gmd__CI_USCOREContact_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREContact_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREContact_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREContact_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1725 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREPropertyType (530)
/* gmd:CI_Contact_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREContact_USCOREPropertyType
{
public:
	__gmd__CI_USCOREContact_USCOREPropertyType_sequence *__CI_USCOREContact_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREPropertyType (530)
	virtual int soap_type(void) const { return 530; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREContact_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREContact_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREContact_USCOREPropertyType); }
	         gmd__CI_USCOREContact_USCOREPropertyType() { gmd__CI_USCOREContact_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREContact_USCOREPropertyType() { }
	friend gmd__CI_USCOREContact_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREContact_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16993 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence (954)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCORETelephone_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCORETelephone_USCOREType *CI_USCORETelephone;	/* required element of XSD type gmd:CI_Telephone_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence (954)
	virtual int soap_type(void) const { return 954; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCORETelephone_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCORETelephone_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORETelephone_USCOREPropertyType_sequence); }
	         __gmd__CI_USCORETelephone_USCOREPropertyType_sequence() { __gmd__CI_USCORETelephone_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCORETelephone_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCORETelephone_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCORETelephone_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1731 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREPropertyType (532)
/* gmd:CI_Telephone_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCORETelephone_USCOREPropertyType
{
public:
	__gmd__CI_USCORETelephone_USCOREPropertyType_sequence *__CI_USCORETelephone_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREPropertyType (532)
	virtual int soap_type(void) const { return 532; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORETelephone_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORETelephone_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORETelephone_USCOREPropertyType); }
	         gmd__CI_USCORETelephone_USCOREPropertyType() { gmd__CI_USCORETelephone_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCORETelephone_USCOREPropertyType() { }
	friend gmd__CI_USCORETelephone_USCOREPropertyType *soap_instantiate_gmd__CI_USCORETelephone_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17050 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence (957)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREAddress_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREAddress_USCOREType *CI_USCOREAddress;	/* required element of XSD type gmd:CI_Address_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence (957)
	virtual int soap_type(void) const { return 957; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREAddress_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREAddress_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREAddress_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREAddress_USCOREPropertyType_sequence() { __gmd__CI_USCOREAddress_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREAddress_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREAddress_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREAddress_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1737 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREPropertyType (534)
/* gmd:CI_Address_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREAddress_USCOREPropertyType
{
public:
	__gmd__CI_USCOREAddress_USCOREPropertyType_sequence *__CI_USCOREAddress_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREPropertyType (534)
	virtual int soap_type(void) const { return 534; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREAddress_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREAddress_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREAddress_USCOREPropertyType); }
	         gmd__CI_USCOREAddress_USCOREPropertyType() { gmd__CI_USCOREAddress_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREAddress_USCOREPropertyType() { }
	friend gmd__CI_USCOREAddress_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREAddress_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17107 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence (960)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREOnlineResource_USCOREType *CI_USCOREOnlineResource;	/* required element of XSD type gmd:CI_OnlineResource_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence (960)
	virtual int soap_type(void) const { return 960; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence() { __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1743 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType (536)
/* gmd:CI_OnlineResource_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREOnlineResource_USCOREPropertyType
{
public:
	__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *__CI_USCOREOnlineResource_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType (536)
	virtual int soap_type(void) const { return 536; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREOnlineResource_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREOnlineResource_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnlineResource_USCOREPropertyType); }
	         gmd__CI_USCOREOnlineResource_USCOREPropertyType() { gmd__CI_USCOREOnlineResource_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREOnlineResource_USCOREPropertyType() { }
	friend gmd__CI_USCOREOnlineResource_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREOnlineResource_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17164 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__URL_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__URL_USCOREPropertyType_sequence (963)
/* Operation wrapper: */
class SOAP_CMAC __gmd__URL_USCOREPropertyType_sequence
{
public:
	std::string URL;	/* required element of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__URL_USCOREPropertyType_sequence (963)
	virtual int soap_type(void) const { return 963; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__URL_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__URL_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__URL_USCOREPropertyType_sequence); }
	         __gmd__URL_USCOREPropertyType_sequence() { __gmd__URL_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__URL_USCOREPropertyType_sequence() { }
	friend __gmd__URL_USCOREPropertyType_sequence *soap_instantiate___gmd__URL_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1749 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__URL_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__URL_USCOREPropertyType (538)
/* gmd:URL_PropertyType complex type: */
class SOAP_CMAC gmd__URL_USCOREPropertyType
{
public:
	__gmd__URL_USCOREPropertyType_sequence *__URL_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__URL_USCOREPropertyType (538)
	virtual int soap_type(void) const { return 538; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__URL_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__URL_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__URL_USCOREPropertyType); }
	         gmd__URL_USCOREPropertyType() { gmd__URL_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__URL_USCOREPropertyType() { }
	friend gmd__URL_USCOREPropertyType *soap_instantiate_gmd__URL_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17191 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence (965)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *CI_USCOREOnLineFunctionCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence (965)
	virtual int soap_type(void) const { return 965; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence() { __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1752 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (539)
/* gmd:CI_OnLineFunctionCode_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
{
public:
	__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (539)
	virtual int soap_type(void) const { return 539; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType); }
	         gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType() { gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType() { }
	friend gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17218 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence (967)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *CI_USCORERoleCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence (967)
	virtual int soap_type(void) const { return 967; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence); }
	         __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence() { __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1755 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORERoleCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORERoleCode_USCOREPropertyType (540)
/* gmd:CI_RoleCode_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCORERoleCode_USCOREPropertyType
{
public:
	__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *__CI_USCORERoleCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORERoleCode_USCOREPropertyType (540)
	virtual int soap_type(void) const { return 540; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORERoleCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORERoleCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORERoleCode_USCOREPropertyType); }
	         gmd__CI_USCORERoleCode_USCOREPropertyType() { gmd__CI_USCORERoleCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCORERoleCode_USCOREPropertyType() { }
	friend gmd__CI_USCORERoleCode_USCOREPropertyType *soap_instantiate_gmd__CI_USCORERoleCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17245 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence (969)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *CI_USCOREPresentationFormCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence (969)
	virtual int soap_type(void) const { return 969; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence() { __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1758 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType (541)
/* gmd:CI_PresentationFormCode_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
{
public:
	__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType (541)
	virtual int soap_type(void) const { return 541; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREPresentationFormCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREPresentationFormCode_USCOREPropertyType); }
	         gmd__CI_USCOREPresentationFormCode_USCOREPropertyType() { gmd__CI_USCOREPresentationFormCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREPresentationFormCode_USCOREPropertyType() { }
	friend gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17272 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence (971)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCORESeries_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCORESeries_USCOREType *CI_USCORESeries;	/* required element of XSD type gmd:CI_Series_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence (971)
	virtual int soap_type(void) const { return 971; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCORESeries_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCORESeries_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORESeries_USCOREPropertyType_sequence); }
	         __gmd__CI_USCORESeries_USCOREPropertyType_sequence() { __gmd__CI_USCORESeries_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCORESeries_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCORESeries_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCORESeries_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1761 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREPropertyType (542)
/* gmd:CI_Series_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCORESeries_USCOREPropertyType
{
public:
	__gmd__CI_USCORESeries_USCOREPropertyType_sequence *__CI_USCORESeries_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREPropertyType (542)
	virtual int soap_type(void) const { return 542; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORESeries_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORESeries_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORESeries_USCOREPropertyType); }
	         gmd__CI_USCORESeries_USCOREPropertyType() { gmd__CI_USCORESeries_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCORESeries_USCOREPropertyType() { }
	friend gmd__CI_USCORESeries_USCOREPropertyType *soap_instantiate_gmd__CI_USCORESeries_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17329 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence (974)
/* Operation wrapper: */
class SOAP_CMAC __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *DQ_USCOREEvaluationMethodTypeCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence (974)
	virtual int soap_type(void) const { return 974; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence); }
	         __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence() { __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence() { }
	friend __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *soap_instantiate___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1767 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (544)
/* gmd:DQ_EvaluationMethodTypeCode_PropertyType complex type: */
class SOAP_CMAC gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
{
public:
	__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (544)
	virtual int soap_type(void) const { return 544; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType); }
	         gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType() { gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType() { }
	friend gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *soap_instantiate_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17364 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__union_DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__union_DQ_USCOREResult_USCOREPropertyType (977)
/* xsd:choice complex type: */
union _gmd__union_DQ_USCOREResult_USCOREPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:17356 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence (976)
/* Operation wrapper: */
class SOAP_CMAC __gmd__DQ_USCOREResult_USCOREPropertyType_sequence
{
public:
	int __unionAbstractDQ_USCOREResult;	/* union discriminant (of union defined below) */
	union _gmd__union_DQ_USCOREResult_USCOREPropertyType __union_DQ_USCOREResult_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence (976)
	virtual int soap_type(void) const { return 976; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__DQ_USCOREResult_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__DQ_USCOREResult_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__DQ_USCOREResult_USCOREPropertyType_sequence); }
	         __gmd__DQ_USCOREResult_USCOREPropertyType_sequence() { __gmd__DQ_USCOREResult_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__DQ_USCOREResult_USCOREPropertyType_sequence() { }
	friend __gmd__DQ_USCOREResult_USCOREPropertyType_sequence *soap_instantiate___gmd__DQ_USCOREResult_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1770 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREResult_USCOREPropertyType (545)
/* gmd:DQ_Result_PropertyType complex type: */
class SOAP_CMAC gmd__DQ_USCOREResult_USCOREPropertyType
{
public:
	__gmd__DQ_USCOREResult_USCOREPropertyType_sequence *__DQ_USCOREResult_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREResult_USCOREPropertyType (545)
	virtual int soap_type(void) const { return 545; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__DQ_USCOREResult_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__DQ_USCOREResult_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__DQ_USCOREResult_USCOREPropertyType); }
	         gmd__DQ_USCOREResult_USCOREPropertyType() { gmd__DQ_USCOREResult_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__DQ_USCOREResult_USCOREPropertyType() { }
	friend gmd__DQ_USCOREResult_USCOREPropertyType *soap_instantiate_gmd__DQ_USCOREResult_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17438 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gts__union_TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gts__union_TM_USCOREPrimitive_USCOREPropertyType (980)
/* xsd:choice complex type: */
union _gts__union_TM_USCOREPrimitive_USCOREPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:17427 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence (979)
/* Operation wrapper: */
class SOAP_CMAC __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
{
public:
	int __unionAbstractTimePrimitive;	/* union discriminant (of union defined below) */
	union _gts__union_TM_USCOREPrimitive_USCOREPropertyType __union_TM_USCOREPrimitive_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence (979)
	virtual int soap_type(void) const { return 979; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence); }
	         __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence() { __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence() { }
	friend __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *soap_instantiate___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1776 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gts__TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gts__TM_USCOREPrimitive_USCOREPropertyType (547)
/* gts:TM_Primitive_PropertyType complex type: */
class SOAP_CMAC gts__TM_USCOREPrimitive_USCOREPropertyType
{
public:
	__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *__TM_USCOREPrimitive_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gts__TM_USCOREPrimitive_USCOREPropertyType (547)
	virtual int soap_type(void) const { return 547; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gts__TM_USCOREPrimitive_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gts__TM_USCOREPrimitive_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gts__TM_USCOREPrimitive_USCOREPropertyType); }
	         gts__TM_USCOREPrimitive_USCOREPropertyType() { gts__TM_USCOREPrimitive_USCOREPropertyType::soap_default(NULL); }
	virtual ~gts__TM_USCOREPrimitive_USCOREPropertyType() { }
	friend gts__TM_USCOREPrimitive_USCOREPropertyType *soap_instantiate_gts__TM_USCOREPrimitive_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1779 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__AbstractObject_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__AbstractObject_USCOREType (548)
/* Type gco__AbstractObject_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gco:AbstractObject_Type complex type: */
class SOAP_CMAC gco__AbstractObject_USCOREType
{
public:
	std::string *id;	/* optional attribute of XSD type xsd:ID */
	std::string *uuid;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gco__AbstractObject_USCOREType (548)
	virtual int soap_type(void) const { return 548; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__AbstractObject_USCOREType, default initialized and not managed by a soap context
	virtual gco__AbstractObject_USCOREType *soap_alloc(void) const { return SOAP_NEW(gco__AbstractObject_USCOREType); }
	         gco__AbstractObject_USCOREType() { gco__AbstractObject_USCOREType::soap_default(NULL); }
	virtual ~gco__AbstractObject_USCOREType() { }
	friend gco__AbstractObject_USCOREType *soap_instantiate_gco__AbstractObject_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17554 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType (984)
/* xsd:choice complex type: */
union _gco__union_CharacterString_USCOREPropertyType
{
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_CharacterString	(1)
	std::string *CharacterString;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode	(2)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREDateTypeCode;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode_	(3)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREDateTypeCode_;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode	(4)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREOnLineFunctionCode;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode_	(5)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREOnLineFunctionCode_;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode	(6)
	gco__CodeListValue_USCOREType *gmd__CI_USCORERoleCode;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode_	(7)
	gco__CodeListValue_USCOREType *gmd__CI_USCORERoleCode_;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode	(8)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREPresentationFormCode;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode_	(9)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREPresentationFormCode_;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode	(10)
	gco__CodeListValue_USCOREType *gmd__DQ_USCOREEvaluationMethodTypeCode;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode_	(11)
	gco__CodeListValue_USCOREType *gmd__DQ_USCOREEvaluationMethodTypeCode_;
};
#endif

/* resqml2_0_1ForGsoap.h:17525 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gco__CharacterString_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gco__CharacterString_USCOREPropertyType_sequence (983)
/* Operation wrapper: */
class SOAP_CMAC __gco__CharacterString_USCOREPropertyType_sequence
{
public:
	int __unionCharacterString;	/* union discriminant (of union defined below) */
	union _gco__union_CharacterString_USCOREPropertyType __union_CharacterString_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gco__CharacterString_USCOREPropertyType_sequence (983)
	virtual int soap_type(void) const { return 983; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gco__CharacterString_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gco__CharacterString_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__CharacterString_USCOREPropertyType_sequence); }
	         __gco__CharacterString_USCOREPropertyType_sequence() { __gco__CharacterString_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gco__CharacterString_USCOREPropertyType_sequence() { }
	friend __gco__CharacterString_USCOREPropertyType_sequence *soap_instantiate___gco__CharacterString_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1782 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__CharacterString_USCOREPropertyType (549)
/* gco:CharacterString_PropertyType complex type: */
class SOAP_CMAC gco__CharacterString_USCOREPropertyType
{
public:
	__gco__CharacterString_USCOREPropertyType_sequence *__CharacterString_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gco__CharacterString_USCOREPropertyType (549)
	virtual int soap_type(void) const { return 549; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__CharacterString_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__CharacterString_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__CharacterString_USCOREPropertyType); }
	         gco__CharacterString_USCOREPropertyType() { gco__CharacterString_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__CharacterString_USCOREPropertyType() { }
	friend gco__CharacterString_USCOREPropertyType *soap_instantiate_gco__CharacterString_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17579 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gco__Boolean_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gco__Boolean_USCOREPropertyType_sequence (986)
/* Operation wrapper: */
class SOAP_CMAC __gco__Boolean_USCOREPropertyType_sequence
{
public:
	bool Boolean;	/* required element of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gco__Boolean_USCOREPropertyType_sequence (986)
	virtual int soap_type(void) const { return 986; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gco__Boolean_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gco__Boolean_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__Boolean_USCOREPropertyType_sequence); }
	         __gco__Boolean_USCOREPropertyType_sequence() { __gco__Boolean_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gco__Boolean_USCOREPropertyType_sequence() { }
	friend __gco__Boolean_USCOREPropertyType_sequence *soap_instantiate___gco__Boolean_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1785 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Boolean_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Boolean_USCOREPropertyType (550)
/* gco:Boolean_PropertyType complex type: */
class SOAP_CMAC gco__Boolean_USCOREPropertyType
{
public:
	__gco__Boolean_USCOREPropertyType_sequence *__Boolean_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gco__Boolean_USCOREPropertyType (550)
	virtual int soap_type(void) const { return 550; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__Boolean_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__Boolean_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Boolean_USCOREPropertyType); }
	         gco__Boolean_USCOREPropertyType() { gco__Boolean_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__Boolean_USCOREPropertyType() { }
	friend gco__Boolean_USCOREPropertyType *soap_instantiate_gco__Boolean_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17606 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gco__Real_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gco__Real_USCOREPropertyType_sequence (988)
/* Operation wrapper: */
class SOAP_CMAC __gco__Real_USCOREPropertyType_sequence
{
public:
	double Real;	/* required element of XSD type xsd:double */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gco__Real_USCOREPropertyType_sequence (988)
	virtual int soap_type(void) const { return 988; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gco__Real_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gco__Real_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__Real_USCOREPropertyType_sequence); }
	         __gco__Real_USCOREPropertyType_sequence() { __gco__Real_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gco__Real_USCOREPropertyType_sequence() { }
	friend __gco__Real_USCOREPropertyType_sequence *soap_instantiate___gco__Real_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1788 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Real_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Real_USCOREPropertyType (551)
/* gco:Real_PropertyType complex type: */
class SOAP_CMAC gco__Real_USCOREPropertyType
{
public:
	__gco__Real_USCOREPropertyType_sequence *__Real_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gco__Real_USCOREPropertyType (551)
	virtual int soap_type(void) const { return 551; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__Real_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__Real_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Real_USCOREPropertyType); }
	         gco__Real_USCOREPropertyType() { gco__Real_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__Real_USCOREPropertyType() { }
	friend gco__Real_USCOREPropertyType *soap_instantiate_gco__Real_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17641 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType (991)
/* xsd:choice complex type: */
union _gco__union_Date_USCOREPropertyType
{
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType_Date	(1)
	std::string *Date;
#define SOAP_UNION_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType_DateTime	(2)
	time_t DateTime;
};
#endif

/* resqml2_0_1ForGsoap.h:1791 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREPropertyType (552)
/* gco:Date_PropertyType complex type: */
class SOAP_CMAC gco__Date_USCOREPropertyType
{
public:
	int __union_Date_USCOREPropertyType;	/* union discriminant (of union defined below) */
	union _gco__union_Date_USCOREPropertyType union_Date_USCOREPropertyType;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREPropertyType (552)
	virtual int soap_type(void) const { return 552; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__Date_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__Date_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Date_USCOREPropertyType); }
	         gco__Date_USCOREPropertyType() { gco__Date_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__Date_USCOREPropertyType() { }
	friend gco__Date_USCOREPropertyType *soap_instantiate_gco__Date_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17664 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gco__DateTime_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gco__DateTime_USCOREPropertyType_sequence (992)
/* Operation wrapper: */
class SOAP_CMAC __gco__DateTime_USCOREPropertyType_sequence
{
public:
	time_t DateTime;	/* required element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gco__DateTime_USCOREPropertyType_sequence (992)
	virtual int soap_type(void) const { return 992; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gco__DateTime_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gco__DateTime_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__DateTime_USCOREPropertyType_sequence); }
	         __gco__DateTime_USCOREPropertyType_sequence() { __gco__DateTime_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gco__DateTime_USCOREPropertyType_sequence() { }
	friend __gco__DateTime_USCOREPropertyType_sequence *soap_instantiate___gco__DateTime_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1797 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__DateTime_USCOREPropertyType (554)
/* gco:DateTime_PropertyType complex type: */
class SOAP_CMAC gco__DateTime_USCOREPropertyType
{
public:
	__gco__DateTime_USCOREPropertyType_sequence *__DateTime_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gco__DateTime_USCOREPropertyType (554)
	virtual int soap_type(void) const { return 554; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__DateTime_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__DateTime_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__DateTime_USCOREPropertyType); }
	         gco__DateTime_USCOREPropertyType() { gco__DateTime_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__DateTime_USCOREPropertyType() { }
	friend gco__DateTime_USCOREPropertyType *soap_instantiate_gco__DateTime_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17710 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gsr__union_SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gsr__union_SC_USCORECRS_USCOREPropertyType (995)
/* xsd:choice complex type: */
union _gsr__union_SC_USCORECRS_USCOREPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:17699 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence (994)
/* Operation wrapper: */
class SOAP_CMAC __gsr__SC_USCORECRS_USCOREPropertyType_sequence
{
public:
	int __unionAbstractCRS;	/* union discriminant (of union defined below) */
	union _gsr__union_SC_USCORECRS_USCOREPropertyType __union_SC_USCORECRS_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence (994)
	virtual int soap_type(void) const { return 994; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gsr__SC_USCORECRS_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gsr__SC_USCORECRS_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gsr__SC_USCORECRS_USCOREPropertyType_sequence); }
	         __gsr__SC_USCORECRS_USCOREPropertyType_sequence() { __gsr__SC_USCORECRS_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gsr__SC_USCORECRS_USCOREPropertyType_sequence() { }
	friend __gsr__SC_USCORECRS_USCOREPropertyType_sequence *soap_instantiate___gsr__SC_USCORECRS_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1800 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gsr__SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gsr__SC_USCORECRS_USCOREPropertyType (555)
/* gsr:SC_CRS_PropertyType complex type: */
class SOAP_CMAC gsr__SC_USCORECRS_USCOREPropertyType
{
public:
	__gsr__SC_USCORECRS_USCOREPropertyType_sequence *__SC_USCORECRS_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gsr__SC_USCORECRS_USCOREPropertyType (555)
	virtual int soap_type(void) const { return 555; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gsr__SC_USCORECRS_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gsr__SC_USCORECRS_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gsr__SC_USCORECRS_USCOREPropertyType); }
	         gsr__SC_USCORECRS_USCOREPropertyType() { gsr__SC_USCORECRS_USCOREPropertyType::soap_default(NULL); }
	virtual ~gsr__SC_USCORECRS_USCOREPropertyType() { }
	friend gsr__SC_USCORECRS_USCOREPropertyType *soap_instantiate_gsr__SC_USCORECRS_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1803 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyTypeSet
#define SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyTypeSet (556)
/* ptm:standardEnergisticsPropertyTypeSet complex type: */
class SOAP_CMAC ptm__standardEnergisticsPropertyTypeSet
{
public:
	std::vector<ptm__standardEnergisticsPropertyType *> standardEnergisticsPropertyType;	/* required element of XSD type ptm:standardEnergisticsPropertyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyTypeSet (556)
	virtual int soap_type(void) const { return 556; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ptm__standardEnergisticsPropertyTypeSet, default initialized and not managed by a soap context
	virtual ptm__standardEnergisticsPropertyTypeSet *soap_alloc(void) const { return SOAP_NEW(ptm__standardEnergisticsPropertyTypeSet); }
	         ptm__standardEnergisticsPropertyTypeSet() { ptm__standardEnergisticsPropertyTypeSet::soap_default(NULL); }
	virtual ~ptm__standardEnergisticsPropertyTypeSet() { }
	friend ptm__standardEnergisticsPropertyTypeSet *soap_instantiate_ptm__standardEnergisticsPropertyTypeSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1806 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyType (557)
/* ptm:standardEnergisticsPropertyType complex type: */
class SOAP_CMAC ptm__standardEnergisticsPropertyType
{
public:
	enum resqml2__ResqmlPropertyKind name;	/* required element of XSD type resqml2:ResqmlPropertyKind */
	std::string *description;	/* optional element of XSD type xsd:string */
	std::string *version;	/* optional element of XSD type xsd:string */
	std::string *deprecated;	/* optional element of XSD type xsd:string */
	std::string *replacedBy;	/* optional element of XSD type xsd:string */
	bool *isAbstract;	/* optional element of XSD type xsd:boolean */
	std::string *parentKind;	/* optional element of XSD type xsd:string */
	std::vector<ptm__equivalentPropertyType *> equivalentPropertyType;	/* optional element of XSD type ptm:equivalentPropertyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyType (557)
	virtual int soap_type(void) const { return 557; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ptm__standardEnergisticsPropertyType, default initialized and not managed by a soap context
	virtual ptm__standardEnergisticsPropertyType *soap_alloc(void) const { return SOAP_NEW(ptm__standardEnergisticsPropertyType); }
	         ptm__standardEnergisticsPropertyType() { ptm__standardEnergisticsPropertyType::soap_default(NULL); }
	virtual ~ptm__standardEnergisticsPropertyType() { }
	friend ptm__standardEnergisticsPropertyType *soap_instantiate_ptm__standardEnergisticsPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1809 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ptm__equivalentPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_ptm__equivalentPropertyType (558)
/* ptm:equivalentPropertyType complex type: */
class SOAP_CMAC ptm__equivalentPropertyType
{
public:
	std::string name;	/* required element of XSD type xsd:string */
	std::string namingSystem;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_ptm__equivalentPropertyType (558)
	virtual int soap_type(void) const { return 558; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ptm__equivalentPropertyType, default initialized and not managed by a soap context
	virtual ptm__equivalentPropertyType *soap_alloc(void) const { return SOAP_NEW(ptm__equivalentPropertyType); }
	         ptm__equivalentPropertyType() { ptm__equivalentPropertyType::soap_default(NULL); }
	virtual ~ptm__equivalentPropertyType() { }
	friend ptm__equivalentPropertyType *soap_instantiate_ptm__equivalentPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:252 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractDoubleArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractDoubleArray (39)
/* Type resqml2__AbstractDoubleArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractDoubleArray complex type: */
class SOAP_CMAC resqml2__AbstractDoubleArray : public resqml2__AbstractValueArray
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractDoubleArray (39)
	virtual int soap_type(void) const { return 39; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractDoubleArray, default initialized and not managed by a soap context
	virtual resqml2__AbstractDoubleArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractDoubleArray); }
	         resqml2__AbstractDoubleArray() { resqml2__AbstractDoubleArray::soap_default(NULL); }
	virtual ~resqml2__AbstractDoubleArray() { }
	friend resqml2__AbstractDoubleArray *soap_instantiate_resqml2__AbstractDoubleArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:264 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringHdf5Array (43)
/* Type resqml2__StringHdf5Array is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:StringHdf5Array complex type: */
class SOAP_CMAC resqml2__StringHdf5Array : public resqml2__AbstractValueArray
{
public:
	eml__Hdf5Dataset *Values;	/* required element of XSD type eml:Hdf5Dataset */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringHdf5Array (43)
	virtual int soap_type(void) const { return 43; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__StringHdf5Array, default initialized and not managed by a soap context
	virtual resqml2__StringHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__StringHdf5Array); }
	         resqml2__StringHdf5Array() { resqml2__StringHdf5Array::soap_default(NULL); }
	virtual ~resqml2__StringHdf5Array() { }
	friend resqml2__StringHdf5Array *soap_instantiate_resqml2__StringHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:291 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractIntegerArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractIntegerArray (52)
/* Type resqml2__AbstractIntegerArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractIntegerArray complex type: */
class SOAP_CMAC resqml2__AbstractIntegerArray : public resqml2__AbstractValueArray
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractIntegerArray (52)
	virtual int soap_type(void) const { return 52; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractIntegerArray, default initialized and not managed by a soap context
	virtual resqml2__AbstractIntegerArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractIntegerArray); }
	         resqml2__AbstractIntegerArray() { resqml2__AbstractIntegerArray::soap_default(NULL); }
	virtual ~resqml2__AbstractIntegerArray() { }
	friend resqml2__AbstractIntegerArray *soap_instantiate_resqml2__AbstractIntegerArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:294 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractBooleanArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractBooleanArray (53)
/* Type resqml2__AbstractBooleanArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractBooleanArray complex type: */
class SOAP_CMAC resqml2__AbstractBooleanArray : public resqml2__AbstractValueArray
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractBooleanArray (53)
	virtual int soap_type(void) const { return 53; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractBooleanArray, default initialized and not managed by a soap context
	virtual resqml2__AbstractBooleanArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractBooleanArray); }
	         resqml2__AbstractBooleanArray() { resqml2__AbstractBooleanArray::soap_default(NULL); }
	virtual ~resqml2__AbstractBooleanArray() { }
	friend resqml2__AbstractBooleanArray *soap_instantiate_resqml2__AbstractBooleanArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:300 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StandardPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StandardPropertyKind (55)
/* Type resqml2__StandardPropertyKind is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:StandardPropertyKind complex type: */
class SOAP_CMAC resqml2__StandardPropertyKind : public resqml2__AbstractPropertyKind
{
public:
	enum resqml2__ResqmlPropertyKind Kind;	/* required element of XSD type resqml2:ResqmlPropertyKind */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StandardPropertyKind (55)
	virtual int soap_type(void) const { return 55; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__StandardPropertyKind, default initialized and not managed by a soap context
	virtual resqml2__StandardPropertyKind *soap_alloc(void) const { return SOAP_NEW(resqml2__StandardPropertyKind); }
	         resqml2__StandardPropertyKind() { resqml2__StandardPropertyKind::soap_default(NULL); }
	virtual ~resqml2__StandardPropertyKind() { }
	friend resqml2__StandardPropertyKind *soap_instantiate_resqml2__StandardPropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:306 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LocalPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LocalPropertyKind (57)
/* Type resqml2__LocalPropertyKind is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:LocalPropertyKind complex type: */
class SOAP_CMAC resqml2__LocalPropertyKind : public resqml2__AbstractPropertyKind
{
public:
	eml__DataObjectReference *LocalPropertyKind;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LocalPropertyKind (57)
	virtual int soap_type(void) const { return 57; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__LocalPropertyKind, default initialized and not managed by a soap context
	virtual resqml2__LocalPropertyKind *soap_alloc(void) const { return SOAP_NEW(resqml2__LocalPropertyKind); }
	         resqml2__LocalPropertyKind() { resqml2__LocalPropertyKind::soap_default(NULL); }
	virtual ~resqml2__LocalPropertyKind() { }
	friend resqml2__LocalPropertyKind *soap_instantiate_resqml2__LocalPropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:318 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point2dHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point2dHdf5Array (61)
/* Type resqml2__Point2dHdf5Array is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Point2dHdf5Array complex type: */
class SOAP_CMAC resqml2__Point2dHdf5Array : public resqml2__AbstractPoint3dArray
{
public:
	eml__Hdf5Dataset *Coordinates;	/* required element of XSD type eml:Hdf5Dataset */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point2dHdf5Array (61)
	virtual int soap_type(void) const { return 61; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Point2dHdf5Array, default initialized and not managed by a soap context
	virtual resqml2__Point2dHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__Point2dHdf5Array); }
	         resqml2__Point2dHdf5Array() { resqml2__Point2dHdf5Array::soap_default(NULL); }
	virtual ~resqml2__Point2dHdf5Array() { }
	friend resqml2__Point2dHdf5Array *soap_instantiate_resqml2__Point2dHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:324 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationLatticeArray (63)
/* Type resqml2__ParametricLineFromRepresentationLatticeArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ParametricLineFromRepresentationLatticeArray complex type: */
class SOAP_CMAC resqml2__ParametricLineFromRepresentationLatticeArray : public resqml2__AbstractParametricLineArray
{
public:
	resqml2__IntegerLatticeArray *LineIndicesOnSupportingRepresentation;	/* required element of XSD type resqml2:IntegerLatticeArray */
	eml__DataObjectReference *SupportingRepresentation;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationLatticeArray (63)
	virtual int soap_type(void) const { return 63; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ParametricLineFromRepresentationLatticeArray, default initialized and not managed by a soap context
	virtual resqml2__ParametricLineFromRepresentationLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineFromRepresentationLatticeArray); }
	         resqml2__ParametricLineFromRepresentationLatticeArray() { resqml2__ParametricLineFromRepresentationLatticeArray::soap_default(NULL); }
	virtual ~resqml2__ParametricLineFromRepresentationLatticeArray() { }
	friend resqml2__ParametricLineFromRepresentationLatticeArray *soap_instantiate_resqml2__ParametricLineFromRepresentationLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:327 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dLatticeArray (64)
/* Type resqml2__Point3dLatticeArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Point3dLatticeArray complex type: */
class SOAP_CMAC resqml2__Point3dLatticeArray : public resqml2__AbstractPoint3dArray
{
public:
	bool *AllDimensionsAreOrthogonal;	/* optional element of XSD type xsd:boolean */
	resqml2__Point3d *Origin;	/* required element of XSD type resqml2:Point3d */
	std::vector<resqml2__Point3dOffset *> Offset;	/* required element of XSD type resqml2:Point3dOffset */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dLatticeArray (64)
	virtual int soap_type(void) const { return 64; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Point3dLatticeArray, default initialized and not managed by a soap context
	virtual resqml2__Point3dLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dLatticeArray); }
	         resqml2__Point3dLatticeArray() { resqml2__Point3dLatticeArray::soap_default(NULL); }
	virtual ~resqml2__Point3dLatticeArray() { }
	friend resqml2__Point3dLatticeArray *soap_instantiate_resqml2__Point3dLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:330 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dZValueArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dZValueArray (65)
/* Type resqml2__Point3dZValueArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Point3dZValueArray complex type: */
class SOAP_CMAC resqml2__Point3dZValueArray : public resqml2__AbstractPoint3dArray
{
public:
	resqml2__AbstractPoint3dArray *SupportingGeometry;	/* required element of XSD type resqml2:AbstractPoint3dArray */
	resqml2__AbstractDoubleArray *ZValues;	/* required element of XSD type resqml2:AbstractDoubleArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dZValueArray (65)
	virtual int soap_type(void) const { return 65; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Point3dZValueArray, default initialized and not managed by a soap context
	virtual resqml2__Point3dZValueArray *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dZValueArray); }
	         resqml2__Point3dZValueArray() { resqml2__Point3dZValueArray::soap_default(NULL); }
	virtual ~resqml2__Point3dZValueArray() { }
	friend resqml2__Point3dZValueArray *soap_instantiate_resqml2__Point3dZValueArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:336 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PointGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PointGeometry (67)
/* Type resqml2__PointGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:PointGeometry complex type: */
class SOAP_CMAC resqml2__PointGeometry : public resqml2__AbstractGeometry
{
public:
	resqml2__AbstractPoint3dArray *Points;	/* required element of XSD type resqml2:AbstractPoint3dArray */
	resqml2__AbstractSeismicCoordinates *SeismicCoordinates;	/* optional element of XSD type resqml2:AbstractSeismicCoordinates */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PointGeometry (67)
	virtual int soap_type(void) const { return 67; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__PointGeometry, default initialized and not managed by a soap context
	virtual resqml2__PointGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__PointGeometry); }
	         resqml2__PointGeometry() { resqml2__PointGeometry::soap_default(NULL); }
	virtual ~resqml2__PointGeometry() { }
	friend resqml2__PointGeometry *soap_instantiate_resqml2__PointGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:345 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dHdf5Array (70)
/* Type resqml2__Point3dHdf5Array is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Point3dHdf5Array complex type: */
class SOAP_CMAC resqml2__Point3dHdf5Array : public resqml2__AbstractPoint3dArray
{
public:
	eml__Hdf5Dataset *Coordinates;	/* required element of XSD type eml:Hdf5Dataset */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dHdf5Array (70)
	virtual int soap_type(void) const { return 70; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Point3dHdf5Array, default initialized and not managed by a soap context
	virtual resqml2__Point3dHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dHdf5Array); }
	         resqml2__Point3dHdf5Array() { resqml2__Point3dHdf5Array::soap_default(NULL); }
	virtual ~resqml2__Point3dHdf5Array() { }
	friend resqml2__Point3dHdf5Array *soap_instantiate_resqml2__Point3dHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:354 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineArray (73)
/* Type resqml2__ParametricLineArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ParametricLineArray complex type: */
class SOAP_CMAC resqml2__ParametricLineArray : public resqml2__AbstractParametricLineArray
{
public:
	resqml2__AbstractDoubleArray *ControlPointParameters;	/* optional element of XSD type resqml2:AbstractDoubleArray */
	resqml2__AbstractPoint3dArray *ControlPoints;	/* required element of XSD type resqml2:AbstractPoint3dArray */
	ULONG64 KnotCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *LineKindIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractPoint3dArray *TangentVectors;	/* optional element of XSD type resqml2:AbstractPoint3dArray */
	resqml2__ParametricLineIntersections *ParametricLineIntersections;	/* optional element of XSD type resqml2:ParametricLineIntersections */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineArray (73)
	virtual int soap_type(void) const { return 73; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ParametricLineArray, default initialized and not managed by a soap context
	virtual resqml2__ParametricLineArray *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineArray); }
	         resqml2__ParametricLineArray() { resqml2__ParametricLineArray::soap_default(NULL); }
	virtual ~resqml2__ParametricLineArray() { }
	friend resqml2__ParametricLineArray *soap_instantiate_resqml2__ParametricLineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:357 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dParametricArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dParametricArray (74)
/* Type resqml2__Point3dParametricArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Point3dParametricArray complex type: */
class SOAP_CMAC resqml2__Point3dParametricArray : public resqml2__AbstractPoint3dArray
{
public:
	resqml2__AbstractValueArray *Parameters;	/* required element of XSD type resqml2:AbstractValueArray */
	resqml2__AbstractIntegerArray *ParametricLineIndices;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *TruncatedLineIndices;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractParametricLineArray *ParametricLines;	/* required element of XSD type resqml2:AbstractParametricLineArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dParametricArray (74)
	virtual int soap_type(void) const { return 74; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Point3dParametricArray, default initialized and not managed by a soap context
	virtual resqml2__Point3dParametricArray *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dParametricArray); }
	         resqml2__Point3dParametricArray() { resqml2__Point3dParametricArray::soap_default(NULL); }
	virtual ~resqml2__Point3dParametricArray() { }
	friend resqml2__Point3dParametricArray *soap_instantiate_resqml2__Point3dParametricArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:369 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPlaneGeometry (78)
/* Type resqml2__AbstractPlaneGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractPlaneGeometry complex type: */
class SOAP_CMAC resqml2__AbstractPlaneGeometry : public resqml2__AbstractGeometry
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPlaneGeometry (78)
	virtual int soap_type(void) const { return 78; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractPlaneGeometry, default initialized and not managed by a soap context
	virtual resqml2__AbstractPlaneGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractPlaneGeometry); }
	         resqml2__AbstractPlaneGeometry() { resqml2__AbstractPlaneGeometry::soap_default(NULL); }
	virtual ~resqml2__AbstractPlaneGeometry() { }
	friend resqml2__AbstractPlaneGeometry *soap_instantiate_resqml2__AbstractPlaneGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:372 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineGeometry (79)
/* Type resqml2__AbstractParametricLineGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractParametricLineGeometry complex type: */
class SOAP_CMAC resqml2__AbstractParametricLineGeometry : public resqml2__AbstractGeometry
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineGeometry (79)
	virtual int soap_type(void) const { return 79; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractParametricLineGeometry, default initialized and not managed by a soap context
	virtual resqml2__AbstractParametricLineGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractParametricLineGeometry); }
	         resqml2__AbstractParametricLineGeometry() { resqml2__AbstractParametricLineGeometry::soap_default(NULL); }
	virtual ~resqml2__AbstractParametricLineGeometry() { }
	friend resqml2__AbstractParametricLineGeometry *soap_instantiate_resqml2__AbstractParametricLineGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:375 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dFromRepresentationLatticeArray (80)
/* Type resqml2__Point3dFromRepresentationLatticeArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Point3dFromRepresentationLatticeArray complex type: */
class SOAP_CMAC resqml2__Point3dFromRepresentationLatticeArray : public resqml2__AbstractPoint3dArray
{
public:
	resqml2__IntegerLatticeArray *NodeIndicesOnSupportingRepresentation;	/* required element of XSD type resqml2:IntegerLatticeArray */
	eml__DataObjectReference *SupportingRepresentation;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dFromRepresentationLatticeArray (80)
	virtual int soap_type(void) const { return 80; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Point3dFromRepresentationLatticeArray, default initialized and not managed by a soap context
	virtual resqml2__Point3dFromRepresentationLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dFromRepresentationLatticeArray); }
	         resqml2__Point3dFromRepresentationLatticeArray() { resqml2__Point3dFromRepresentationLatticeArray::soap_default(NULL); }
	virtual ~resqml2__Point3dFromRepresentationLatticeArray() { }
	friend resqml2__Point3dFromRepresentationLatticeArray *soap_instantiate_resqml2__Point3dFromRepresentationLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:378 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic3dCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic3dCoordinates (81)
/* Type resqml2__Seismic3dCoordinates is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Seismic3dCoordinates complex type: */
class SOAP_CMAC resqml2__Seismic3dCoordinates : public resqml2__AbstractSeismicCoordinates
{
public:
	resqml2__AbstractDoubleArray *CrosslineCoordinates;	/* required element of XSD type resqml2:AbstractDoubleArray */
	resqml2__AbstractDoubleArray *InlineCoordinates;	/* required element of XSD type resqml2:AbstractDoubleArray */
	resqml2__AbstractDoubleArray *VerticalCoordinates;	/* optional element of XSD type resqml2:AbstractDoubleArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic3dCoordinates (81)
	virtual int soap_type(void) const { return 81; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Seismic3dCoordinates, default initialized and not managed by a soap context
	virtual resqml2__Seismic3dCoordinates *soap_alloc(void) const { return SOAP_NEW(resqml2__Seismic3dCoordinates); }
	         resqml2__Seismic3dCoordinates() { resqml2__Seismic3dCoordinates::soap_default(NULL); }
	virtual ~resqml2__Seismic3dCoordinates() { }
	friend resqml2__Seismic3dCoordinates *soap_instantiate_resqml2__Seismic3dCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:384 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic2dCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic2dCoordinates (83)
/* Type resqml2__Seismic2dCoordinates is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Seismic2dCoordinates complex type: */
class SOAP_CMAC resqml2__Seismic2dCoordinates : public resqml2__AbstractSeismicCoordinates
{
public:
	resqml2__AbstractDoubleArray *LineAbscissa;	/* required element of XSD type resqml2:AbstractDoubleArray */
	resqml2__AbstractDoubleArray *VerticalCoordinates;	/* optional element of XSD type resqml2:AbstractDoubleArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic2dCoordinates (83)
	virtual int soap_type(void) const { return 83; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Seismic2dCoordinates, default initialized and not managed by a soap context
	virtual resqml2__Seismic2dCoordinates *soap_alloc(void) const { return SOAP_NEW(resqml2__Seismic2dCoordinates); }
	         resqml2__Seismic2dCoordinates() { resqml2__Seismic2dCoordinates::soap_default(NULL); }
	virtual ~resqml2__Seismic2dCoordinates() { }
	friend resqml2__Seismic2dCoordinates *soap_instantiate_resqml2__Seismic2dCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:387 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch1d
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch1d (84)
/* Type resqml2__Patch1d is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Patch1d complex type: */
class SOAP_CMAC resqml2__Patch1d : public resqml2__Patch
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch1d (84)
	virtual int soap_type(void) const { return 84; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Patch1d, default initialized and not managed by a soap context
	virtual resqml2__Patch1d *soap_alloc(void) const { return SOAP_NEW(resqml2__Patch1d); }
	         resqml2__Patch1d() { resqml2__Patch1d::soap_default(NULL); }
	virtual ~resqml2__Patch1d() { }
	friend resqml2__Patch1d *soap_instantiate_resqml2__Patch1d(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:432 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitNodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitNodePatch (99)
/* Type resqml2__SplitNodePatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:SplitNodePatch complex type: */
class SOAP_CMAC resqml2__SplitNodePatch : public resqml2__Patch
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *ParentNodeIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__ResqmlJaggedArray *CellsPerSplitNode;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	resqml2__SplitFaces *SplitFaces;	/* optional element of XSD type resqml2:SplitFaces */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitNodePatch (99)
	virtual int soap_type(void) const { return 99; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__SplitNodePatch, default initialized and not managed by a soap context
	virtual resqml2__SplitNodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__SplitNodePatch); }
	         resqml2__SplitNodePatch() { resqml2__SplitNodePatch::soap_default(NULL); }
	virtual ~resqml2__SplitNodePatch() { }
	friend resqml2__SplitNodePatch *soap_instantiate_resqml2__SplitNodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:435 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkParentWindow (100)
/* Type resqml2__IjkParentWindow is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:IjkParentWindow complex type: */
class SOAP_CMAC resqml2__IjkParentWindow : public resqml2__AbstractParentWindow
{
public:
	resqml2__AbstractIntegerArray *OmitParentCells;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__Regrid *JRegrid;	/* required element of XSD type resqml2:Regrid */
	eml__DataObjectReference *ParentGrid;	/* required element of XSD type eml:DataObjectReference */
	resqml2__Regrid *KRegrid;	/* required element of XSD type resqml2:Regrid */
	resqml2__Regrid *IRegrid;	/* required element of XSD type resqml2:Regrid */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkParentWindow (100)
	virtual int soap_type(void) const { return 100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IjkParentWindow, default initialized and not managed by a soap context
	virtual resqml2__IjkParentWindow *soap_alloc(void) const { return SOAP_NEW(resqml2__IjkParentWindow); }
	         resqml2__IjkParentWindow() { resqml2__IjkParentWindow::soap_default(NULL); }
	virtual ~resqml2__IjkParentWindow() { }
	friend resqml2__IjkParentWindow *soap_instantiate_resqml2__IjkParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:465 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerParentWindow (110)
/* Type resqml2__ColumnLayerParentWindow is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ColumnLayerParentWindow complex type: */
class SOAP_CMAC resqml2__ColumnLayerParentWindow : public resqml2__AbstractParentWindow
{
public:
	resqml2__AbstractIntegerArray *ColumnIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *OmitParentCells;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__Regrid *KRegrid;	/* required element of XSD type resqml2:Regrid */
	eml__DataObjectReference *ParentGrid;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerParentWindow (110)
	virtual int soap_type(void) const { return 110; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ColumnLayerParentWindow, default initialized and not managed by a soap context
	virtual resqml2__ColumnLayerParentWindow *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnLayerParentWindow); }
	         resqml2__ColumnLayerParentWindow() { resqml2__ColumnLayerParentWindow::soap_default(NULL); }
	virtual ~resqml2__ColumnLayerParentWindow() { }
	friend resqml2__ColumnLayerParentWindow *soap_instantiate_resqml2__ColumnLayerParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:468 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredSubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredSubnodeTopology (111)
/* Type resqml2__UnstructuredSubnodeTopology is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:UnstructuredSubnodeTopology complex type: */
class SOAP_CMAC resqml2__UnstructuredSubnodeTopology : public resqml2__SubnodeTopology
{
public:
	resqml2__Edges *Edges;	/* optional element of XSD type resqml2:Edges */
	resqml2__NodesPerCell *NodesPerCell;	/* optional element of XSD type resqml2:NodesPerCell */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredSubnodeTopology (111)
	virtual int soap_type(void) const { return 111; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__UnstructuredSubnodeTopology, default initialized and not managed by a soap context
	virtual resqml2__UnstructuredSubnodeTopology *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredSubnodeTopology); }
	         resqml2__UnstructuredSubnodeTopology() { resqml2__UnstructuredSubnodeTopology::soap_default(NULL); }
	virtual ~resqml2__UnstructuredSubnodeTopology() { }
	friend resqml2__UnstructuredSubnodeTopology *soap_instantiate_resqml2__UnstructuredSubnodeTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:471 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredColumnLayerGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredColumnLayerGridPatch (112)
/* Type resqml2__GpGridUnstructuredColumnLayerGridPatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:GpGridUnstructuredColumnLayerGridPatch complex type: */
class SOAP_CMAC resqml2__GpGridUnstructuredColumnLayerGridPatch : public resqml2__Patch
{
public:
	ULONG64 UnstructuredColumnCount;	/* required element of XSD type xsd:nonNegativeInteger */
	resqml2__UnstructuredColumnLayerGridGeometry *Geometry;	/* optional element of XSD type resqml2:UnstructuredColumnLayerGridGeometry */
	resqml2__TruncationCellPatch *TruncationCells;	/* optional element of XSD type resqml2:TruncationCellPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredColumnLayerGridPatch (112)
	virtual int soap_type(void) const { return 112; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__GpGridUnstructuredColumnLayerGridPatch, default initialized and not managed by a soap context
	virtual resqml2__GpGridUnstructuredColumnLayerGridPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__GpGridUnstructuredColumnLayerGridPatch); }
	         resqml2__GpGridUnstructuredColumnLayerGridPatch() { resqml2__GpGridUnstructuredColumnLayerGridPatch::soap_default(NULL); }
	virtual ~resqml2__GpGridUnstructuredColumnLayerGridPatch() { }
	friend resqml2__GpGridUnstructuredColumnLayerGridPatch *soap_instantiate_resqml2__GpGridUnstructuredColumnLayerGridPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:486 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodePatch (117)
/* Type resqml2__SubnodePatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:SubnodePatch complex type: */
class SOAP_CMAC resqml2__SubnodePatch : public resqml2__Patch
{
public:
	enum resqml2__SubnodeNodeObject SubnodeNodeObject;	/* required element of XSD type resqml2:SubnodeNodeObject */
	resqml2__AbstractValueArray *NodeWeightsPerSubnode;	/* required element of XSD type resqml2:AbstractValueArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodePatch (117)
	virtual int soap_type(void) const { return 117; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__SubnodePatch, default initialized and not managed by a soap context
	virtual resqml2__SubnodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__SubnodePatch); }
	         resqml2__SubnodePatch() { resqml2__SubnodePatch::soap_default(NULL); }
	virtual ~resqml2__SubnodePatch() { }
	friend resqml2__SubnodePatch *soap_instantiate_resqml2__SubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:489 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSubnodeTopology (118)
/* Type resqml2__ColumnLayerSubnodeTopology is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ColumnLayerSubnodeTopology complex type: */
class SOAP_CMAC resqml2__ColumnLayerSubnodeTopology : public resqml2__SubnodeTopology
{
public:
	std::vector<resqml2__ColumnSubnodePatch *> ColumnSubnodes;	/* optional element of XSD type resqml2:ColumnSubnodePatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSubnodeTopology (118)
	virtual int soap_type(void) const { return 118; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ColumnLayerSubnodeTopology, default initialized and not managed by a soap context
	virtual resqml2__ColumnLayerSubnodeTopology *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnLayerSubnodeTopology); }
	         resqml2__ColumnLayerSubnodeTopology() { resqml2__ColumnLayerSubnodeTopology::soap_default(NULL); }
	virtual ~resqml2__ColumnLayerSubnodeTopology() { }
	friend resqml2__ColumnLayerSubnodeTopology *soap_instantiate_resqml2__ColumnLayerSubnodeTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:501 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TruncationCellPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TruncationCellPatch (122)
/* Type resqml2__TruncationCellPatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:TruncationCellPatch complex type: */
class SOAP_CMAC resqml2__TruncationCellPatch : public resqml2__Patch
{
public:
	ULONG64 TruncationNodeCount;	/* required element of XSD type xsd:positiveInteger */
	ULONG64 TruncationFaceCount;	/* required element of XSD type xsd:positiveInteger */
	ULONG64 TruncationCellCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__ResqmlJaggedArray *NodesPerTruncationFace;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	resqml2__AbstractIntegerArray *ParentCellIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__ResqmlJaggedArray *LocalFacesPerCell;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	resqml2__ResqmlJaggedArray *TruncationFacesPerCell;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	resqml2__AbstractBooleanArray *TruncationCellFaceIsRightHanded;	/* required element of XSD type resqml2:AbstractBooleanArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TruncationCellPatch (122)
	virtual int soap_type(void) const { return 122; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__TruncationCellPatch, default initialized and not managed by a soap context
	virtual resqml2__TruncationCellPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__TruncationCellPatch); }
	         resqml2__TruncationCellPatch() { resqml2__TruncationCellPatch::soap_default(NULL); }
	virtual ~resqml2__TruncationCellPatch() { }
	friend resqml2__TruncationCellPatch *soap_instantiate_resqml2__TruncationCellPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:504 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredGridPatch (123)
/* Type resqml2__GpGridUnstructuredGridPatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:GpGridUnstructuredGridPatch complex type: */
class SOAP_CMAC resqml2__GpGridUnstructuredGridPatch : public resqml2__Patch
{
public:
	ULONG64 UnstructuredCellCount;	/* required element of XSD type xsd:nonNegativeInteger */
	resqml2__UnstructuredGridGeometry *Geometry;	/* optional element of XSD type resqml2:UnstructuredGridGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredGridPatch (123)
	virtual int soap_type(void) const { return 123; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__GpGridUnstructuredGridPatch, default initialized and not managed by a soap context
	virtual resqml2__GpGridUnstructuredGridPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__GpGridUnstructuredGridPatch); }
	         resqml2__GpGridUnstructuredGridPatch() { resqml2__GpGridUnstructuredGridPatch::soap_default(NULL); }
	virtual ~resqml2__GpGridUnstructuredGridPatch() { }
	friend resqml2__GpGridUnstructuredGridPatch *soap_instantiate_resqml2__GpGridUnstructuredGridPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:546 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellParentWindow (137)
/* Type resqml2__CellParentWindow is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:CellParentWindow complex type: */
class SOAP_CMAC resqml2__CellParentWindow : public resqml2__AbstractParentWindow
{
public:
	resqml2__AbstractIntegerArray *CellIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	eml__DataObjectReference *ParentGrid;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellParentWindow (137)
	virtual int soap_type(void) const { return 137; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__CellParentWindow, default initialized and not managed by a soap context
	virtual resqml2__CellParentWindow *soap_alloc(void) const { return SOAP_NEW(resqml2__CellParentWindow); }
	         resqml2__CellParentWindow() { resqml2__CellParentWindow::soap_default(NULL); }
	virtual ~resqml2__CellParentWindow() { }
	friend resqml2__CellParentWindow *soap_instantiate_resqml2__CellParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:552 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridIjkGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridIjkGridPatch (139)
/* Type resqml2__GpGridIjkGridPatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:GpGridIjkGridPatch complex type: */
class SOAP_CMAC resqml2__GpGridIjkGridPatch : public resqml2__Patch
{
public:
	ULONG64 Ni;	/* required element of XSD type xsd:nonNegativeInteger */
	ULONG64 Nj;	/* required element of XSD type xsd:nonNegativeInteger */
	bool *RadialGridIsComplete;	/* optional element of XSD type xsd:boolean */
	resqml2__IjkGridGeometry *Geometry;	/* optional element of XSD type resqml2:IjkGridGeometry */
	resqml2__TruncationCellPatch *TruncationCells;	/* optional element of XSD type resqml2:TruncationCellPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridIjkGridPatch (139)
	virtual int soap_type(void) const { return 139; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__GpGridIjkGridPatch, default initialized and not managed by a soap context
	virtual resqml2__GpGridIjkGridPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__GpGridIjkGridPatch); }
	         resqml2__GpGridIjkGridPatch() { resqml2__GpGridIjkGridPatch::soap_default(NULL); }
	virtual ~resqml2__GpGridIjkGridPatch() { }
	friend resqml2__GpGridIjkGridPatch *soap_instantiate_resqml2__GpGridIjkGridPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:600 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BinaryContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BinaryContactInterpretationPart (155)
/* Type resqml2__BinaryContactInterpretationPart is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:BinaryContactInterpretationPart complex type: */
class SOAP_CMAC resqml2__BinaryContactInterpretationPart : public resqml2__AbstractContactInterpretationPart
{
public:
	resqml2__ContactElementReference *DirectObject;	/* required element of XSD type resqml2:ContactElementReference */
	enum resqml2__ContactVerb Verb;	/* required element of XSD type resqml2:ContactVerb */
	resqml2__ContactElementReference *Subject;	/* required element of XSD type resqml2:ContactElementReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BinaryContactInterpretationPart (155)
	virtual int soap_type(void) const { return 155; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__BinaryContactInterpretationPart, default initialized and not managed by a soap context
	virtual resqml2__BinaryContactInterpretationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__BinaryContactInterpretationPart); }
	         resqml2__BinaryContactInterpretationPart() { resqml2__BinaryContactInterpretationPart::soap_default(NULL); }
	virtual ~resqml2__BinaryContactInterpretationPart() { }
	friend resqml2__BinaryContactInterpretationPart *soap_instantiate_resqml2__BinaryContactInterpretationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:606 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactElementReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactElementReference (157)
/* Type resqml2__ContactElementReference is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ContactElementReference complex type: */
class SOAP_CMAC resqml2__ContactElementReference : public eml__DataObjectReference
{
public:
	enum resqml2__ContactSide *Qualifier;	/* optional element of XSD type resqml2:ContactSide */
	enum resqml2__ContactMode *SecondaryQualifier;	/* optional element of XSD type resqml2:ContactMode */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactElementReference (157)
	virtual int soap_type(void) const { return 157; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ContactElementReference, default initialized and not managed by a soap context
	virtual resqml2__ContactElementReference *soap_alloc(void) const { return SOAP_NEW(resqml2__ContactElementReference); }
	         resqml2__ContactElementReference() { resqml2__ContactElementReference::soap_default(NULL); }
	virtual ~resqml2__ContactElementReference() { }
	friend resqml2__ContactElementReference *soap_instantiate_resqml2__ContactElementReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:627 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MultipleContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MultipleContactInterpretationPart (164)
/* Type resqml2__MultipleContactInterpretationPart is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:MultipleContactInterpretationPart complex type: */
class SOAP_CMAC resqml2__MultipleContactInterpretationPart : public resqml2__AbstractContactInterpretationPart
{
public:
	std::vector<ULONG64> With;	/* required element of XSD type xsd:nonNegativeInteger */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MultipleContactInterpretationPart (164)
	virtual int soap_type(void) const { return 164; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__MultipleContactInterpretationPart, default initialized and not managed by a soap context
	virtual resqml2__MultipleContactInterpretationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__MultipleContactInterpretationPart); }
	         resqml2__MultipleContactInterpretationPart() { resqml2__MultipleContactInterpretationPart::soap_default(NULL); }
	virtual ~resqml2__MultipleContactInterpretationPart() { }
	friend resqml2__MultipleContactInterpretationPart *soap_instantiate_resqml2__MultipleContactInterpretationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:777 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NonSealedContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NonSealedContactRepresentationPart (214)
/* Type resqml2__NonSealedContactRepresentationPart is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:NonSealedContactRepresentationPart complex type: */
class SOAP_CMAC resqml2__NonSealedContactRepresentationPart : public resqml2__AbstractContactRepresentationPart
{
public:
	std::vector<resqml2__ContactPatch *> Contact;	/* optional element of XSD type resqml2:ContactPatch */
	resqml2__AbstractGeometry *Geometry;	/* required element of XSD type resqml2:AbstractGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NonSealedContactRepresentationPart (214)
	virtual int soap_type(void) const { return 214; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__NonSealedContactRepresentationPart, default initialized and not managed by a soap context
	virtual resqml2__NonSealedContactRepresentationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__NonSealedContactRepresentationPart); }
	         resqml2__NonSealedContactRepresentationPart() { resqml2__NonSealedContactRepresentationPart::soap_default(NULL); }
	virtual ~resqml2__NonSealedContactRepresentationPart() { }
	friend resqml2__NonSealedContactRepresentationPart *soap_instantiate_resqml2__NonSealedContactRepresentationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:780 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SealedContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SealedContactRepresentationPart (215)
/* Type resqml2__SealedContactRepresentationPart is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:SealedContactRepresentationPart complex type: */
class SOAP_CMAC resqml2__SealedContactRepresentationPart : public resqml2__AbstractContactRepresentationPart
{
public:
	resqml2__AbstractIntegerArray *IdenticalNodeIndices;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	enum resqml2__IdentityKind IdentityKind;	/* required element of XSD type resqml2:IdentityKind */
	std::vector<resqml2__ContactPatch *> Contact;	/* required element of XSD type resqml2:ContactPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SealedContactRepresentationPart (215)
	virtual int soap_type(void) const { return 215; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__SealedContactRepresentationPart, default initialized and not managed by a soap context
	virtual resqml2__SealedContactRepresentationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__SealedContactRepresentationPart); }
	         resqml2__SealedContactRepresentationPart() { resqml2__SealedContactRepresentationPart::soap_default(NULL); }
	virtual ~resqml2__SealedContactRepresentationPart() { }
	friend resqml2__SealedContactRepresentationPart *soap_instantiate_resqml2__SealedContactRepresentationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:834 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Grid2dPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Grid2dPatch (233)
/* Type resqml2__Grid2dPatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:Grid2dPatch complex type: */
class SOAP_CMAC resqml2__Grid2dPatch : public resqml2__Patch
{
public:
	ULONG64 FastestAxisCount;	/* required element of XSD type xsd:positiveInteger */
	ULONG64 SlowestAxisCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__PointGeometry *Geometry;	/* required element of XSD type resqml2:PointGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Grid2dPatch (233)
	virtual int soap_type(void) const { return 233; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__Grid2dPatch, default initialized and not managed by a soap context
	virtual resqml2__Grid2dPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__Grid2dPatch); }
	         resqml2__Grid2dPatch() { resqml2__Grid2dPatch::soap_default(NULL); }
	virtual ~resqml2__Grid2dPatch() { }
	friend resqml2__Grid2dPatch *soap_instantiate_resqml2__Grid2dPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:840 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PolylineSetPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PolylineSetPatch (235)
/* Type resqml2__PolylineSetPatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:PolylineSetPatch complex type: */
class SOAP_CMAC resqml2__PolylineSetPatch : public resqml2__Patch
{
public:
	resqml2__AbstractBooleanArray *ClosedPolylines;	/* required element of XSD type resqml2:AbstractBooleanArray */
	resqml2__AbstractIntegerArray *NodeCountPerPolyline;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__PointGeometry *Geometry;	/* required element of XSD type resqml2:PointGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PolylineSetPatch (235)
	virtual int soap_type(void) const { return 235; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__PolylineSetPatch, default initialized and not managed by a soap context
	virtual resqml2__PolylineSetPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__PolylineSetPatch); }
	         resqml2__PolylineSetPatch() { resqml2__PolylineSetPatch::soap_default(NULL); }
	virtual ~resqml2__PolylineSetPatch() { }
	friend resqml2__PolylineSetPatch *soap_instantiate_resqml2__PolylineSetPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:849 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRepresentationReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRepresentationReference (238)
/* Type resqml2__ContactRepresentationReference is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ContactRepresentationReference complex type: */
class SOAP_CMAC resqml2__ContactRepresentationReference : public resqml2__AbstractContactRepresentationPart
{
public:
	eml__DataObjectReference *Representation;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRepresentationReference (238)
	virtual int soap_type(void) const { return 238; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ContactRepresentationReference, default initialized and not managed by a soap context
	virtual resqml2__ContactRepresentationReference *soap_alloc(void) const { return SOAP_NEW(resqml2__ContactRepresentationReference); }
	         resqml2__ContactRepresentationReference() { resqml2__ContactRepresentationReference::soap_default(NULL); }
	virtual ~resqml2__ContactRepresentationReference() { }
	friend resqml2__ContactRepresentationReference *soap_instantiate_resqml2__ContactRepresentationReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:879 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DataObjectParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DataObjectParameter (248)
/* Type resqml2__DataObjectParameter is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:DataObjectParameter complex type: */
class SOAP_CMAC resqml2__DataObjectParameter : public resqml2__AbstractActivityParameter
{
public:
	eml__DataObjectReference *DataObject;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DataObjectParameter (248)
	virtual int soap_type(void) const { return 248; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__DataObjectParameter, default initialized and not managed by a soap context
	virtual resqml2__DataObjectParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__DataObjectParameter); }
	         resqml2__DataObjectParameter() { resqml2__DataObjectParameter::soap_default(NULL); }
	virtual ~resqml2__DataObjectParameter() { }
	friend resqml2__DataObjectParameter *soap_instantiate_resqml2__DataObjectParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:882 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ObjectParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ObjectParameterKey (249)
/* Type resqml2__ObjectParameterKey is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ObjectParameterKey complex type: */
class SOAP_CMAC resqml2__ObjectParameterKey : public resqml2__AbstractParameterKey
{
public:
	eml__DataObjectReference *DataObject;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ObjectParameterKey (249)
	virtual int soap_type(void) const { return 249; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ObjectParameterKey, default initialized and not managed by a soap context
	virtual resqml2__ObjectParameterKey *soap_alloc(void) const { return SOAP_NEW(resqml2__ObjectParameterKey); }
	         resqml2__ObjectParameterKey() { resqml2__ObjectParameterKey::soap_default(NULL); }
	virtual ~resqml2__ObjectParameterKey() { }
	friend resqml2__ObjectParameterKey *soap_instantiate_resqml2__ObjectParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:888 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringParameter (251)
/* Type resqml2__StringParameter is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:StringParameter complex type: */
class SOAP_CMAC resqml2__StringParameter : public resqml2__AbstractActivityParameter
{
public:
	std::string Value;	/* required element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringParameter (251)
	virtual int soap_type(void) const { return 251; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__StringParameter, default initialized and not managed by a soap context
	virtual resqml2__StringParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__StringParameter); }
	         resqml2__StringParameter() { resqml2__StringParameter::soap_default(NULL); }
	virtual ~resqml2__StringParameter() { }
	friend resqml2__StringParameter *soap_instantiate_resqml2__StringParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:894 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerQuantityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerQuantityParameter (253)
/* Type resqml2__IntegerQuantityParameter is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:IntegerQuantityParameter complex type: */
class SOAP_CMAC resqml2__IntegerQuantityParameter : public resqml2__AbstractActivityParameter
{
public:
	LONG64 Value;	/* required element of XSD type xsd:long */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerQuantityParameter (253)
	virtual int soap_type(void) const { return 253; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IntegerQuantityParameter, default initialized and not managed by a soap context
	virtual resqml2__IntegerQuantityParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerQuantityParameter); }
	         resqml2__IntegerQuantityParameter() { resqml2__IntegerQuantityParameter::soap_default(NULL); }
	virtual ~resqml2__IntegerQuantityParameter() { }
	friend resqml2__IntegerQuantityParameter *soap_instantiate_resqml2__IntegerQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:897 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameterKey (254)
/* Type resqml2__TimeIndexParameterKey is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:TimeIndexParameterKey complex type: */
class SOAP_CMAC resqml2__TimeIndexParameterKey : public resqml2__AbstractParameterKey
{
public:
	resqml2__TimeIndex *TimeIndex;	/* required element of XSD type resqml2:TimeIndex */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameterKey (254)
	virtual int soap_type(void) const { return 254; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__TimeIndexParameterKey, default initialized and not managed by a soap context
	virtual resqml2__TimeIndexParameterKey *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeIndexParameterKey); }
	         resqml2__TimeIndexParameterKey() { resqml2__TimeIndexParameterKey::soap_default(NULL); }
	virtual ~resqml2__TimeIndexParameterKey() { }
	friend resqml2__TimeIndexParameterKey *soap_instantiate_resqml2__TimeIndexParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:900 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FloatingPointQuantityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FloatingPointQuantityParameter (255)
/* Type resqml2__FloatingPointQuantityParameter is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:FloatingPointQuantityParameter complex type: */
class SOAP_CMAC resqml2__FloatingPointQuantityParameter : public resqml2__AbstractActivityParameter
{
public:
	double Value;	/* required element of XSD type xsd:double */
	enum resqml2__ResqmlUom Uom;	/* required element of XSD type resqml2:ResqmlUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FloatingPointQuantityParameter (255)
	virtual int soap_type(void) const { return 255; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__FloatingPointQuantityParameter, default initialized and not managed by a soap context
	virtual resqml2__FloatingPointQuantityParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__FloatingPointQuantityParameter); }
	         resqml2__FloatingPointQuantityParameter() { resqml2__FloatingPointQuantityParameter::soap_default(NULL); }
	virtual ~resqml2__FloatingPointQuantityParameter() { }
	friend resqml2__FloatingPointQuantityParameter *soap_instantiate_resqml2__FloatingPointQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:906 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameter (257)
/* Type resqml2__TimeIndexParameter is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:TimeIndexParameter complex type: */
class SOAP_CMAC resqml2__TimeIndexParameter : public resqml2__AbstractActivityParameter
{
public:
	resqml2__TimeIndex *TimeIndex;	/* required element of XSD type resqml2:TimeIndex */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameter (257)
	virtual int soap_type(void) const { return 257; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__TimeIndexParameter, default initialized and not managed by a soap context
	virtual resqml2__TimeIndexParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeIndexParameter); }
	         resqml2__TimeIndexParameter() { resqml2__TimeIndexParameter::soap_default(NULL); }
	virtual ~resqml2__TimeIndexParameter() { }
	friend resqml2__TimeIndexParameter *soap_instantiate_resqml2__TimeIndexParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:915 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlinePolylineSetPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlinePolylineSetPatch (260)
/* Type resqml2__StreamlinePolylineSetPatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:StreamlinePolylineSetPatch complex type: */
class SOAP_CMAC resqml2__StreamlinePolylineSetPatch : public resqml2__Patch
{
public:
	ULONG64 NodeCount;	/* required element of XSD type xsd:positiveInteger */
	ULONG64 IntervalCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractBooleanArray *ClosedPolylines;	/* required element of XSD type resqml2:AbstractBooleanArray */
	resqml2__AbstractIntegerArray *NodeCountPerPolyline;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__IntervalGridCells *IntervalGridCells;	/* optional element of XSD type resqml2:IntervalGridCells */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlinePolylineSetPatch (260)
	virtual int soap_type(void) const { return 260; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__StreamlinePolylineSetPatch, default initialized and not managed by a soap context
	virtual resqml2__StreamlinePolylineSetPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__StreamlinePolylineSetPatch); }
	         resqml2__StreamlinePolylineSetPatch() { resqml2__StreamlinePolylineSetPatch::soap_default(NULL); }
	virtual ~resqml2__StreamlinePolylineSetPatch() { }
	friend resqml2__StreamlinePolylineSetPatch *soap_instantiate_resqml2__StreamlinePolylineSetPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:945 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractCitedDataObject
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractCitedDataObject (270)
/* Type eml__AbstractCitedDataObject is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:AbstractCitedDataObject complex type: */
class SOAP_CMAC eml__AbstractCitedDataObject
{
public:
	eml__Citation *Citation;	/* required element of XSD type eml:Citation */
	std::vector<eml__ObjectAlias *> Aliases;	/* optional element of XSD type eml:ObjectAlias */
	eml__CustomData *CustomData;	/* optional element of XSD type eml:CustomData */
	std::string schemaVersion;	/* required attribute of XSD type xsd:string */
	std::string uuid;	/* required attribute of XSD type eml:UuidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractCitedDataObject (270)
	virtual int soap_type(void) const { return 270; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AbstractCitedDataObject, default initialized and not managed by a soap context
	virtual eml__AbstractCitedDataObject *soap_alloc(void) const { return SOAP_NEW(eml__AbstractCitedDataObject); }
	         eml__AbstractCitedDataObject() { eml__AbstractCitedDataObject::soap_default(NULL); }
	virtual ~eml__AbstractCitedDataObject() { }
	friend eml__AbstractCitedDataObject *soap_instantiate_eml__AbstractCitedDataObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:960 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrsEpsgCode
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrsEpsgCode (275)
/* Type eml__VerticalCrsEpsgCode is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:VerticalCrsEpsgCode complex type: */
class SOAP_CMAC eml__VerticalCrsEpsgCode : public eml__AbstractVerticalCrs
{
public:
	ULONG64 EpsgCode;	/* required element of XSD type xsd:positiveInteger */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrsEpsgCode (275)
	virtual int soap_type(void) const { return 275; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VerticalCrsEpsgCode, default initialized and not managed by a soap context
	virtual eml__VerticalCrsEpsgCode *soap_alloc(void) const { return SOAP_NEW(eml__VerticalCrsEpsgCode); }
	         eml__VerticalCrsEpsgCode() { eml__VerticalCrsEpsgCode::soap_default(NULL); }
	virtual ~eml__VerticalCrsEpsgCode() { }
	friend eml__VerticalCrsEpsgCode *soap_instantiate_eml__VerticalCrsEpsgCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:963 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlVerticalCrsDefinition
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlVerticalCrsDefinition (276)
/* Type eml__GmlVerticalCrsDefinition is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:GmlVerticalCrsDefinition complex type: */
class SOAP_CMAC eml__GmlVerticalCrsDefinition : public eml__AbstractVerticalCrs
{
public:
	gml__VerticalCRSType *GmlVerticalCrsDefinition;	/* required element of XSD type gml:VerticalCRSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlVerticalCrsDefinition (276)
	virtual int soap_type(void) const { return 276; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__GmlVerticalCrsDefinition, default initialized and not managed by a soap context
	virtual eml__GmlVerticalCrsDefinition *soap_alloc(void) const { return SOAP_NEW(eml__GmlVerticalCrsDefinition); }
	         eml__GmlVerticalCrsDefinition() { eml__GmlVerticalCrsDefinition::soap_default(NULL); }
	virtual ~eml__GmlVerticalCrsDefinition() { }
	friend eml__GmlVerticalCrsDefinition *soap_instantiate_eml__GmlVerticalCrsDefinition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:966 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalUnknownCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalUnknownCrs (277)
/* Type eml__VerticalUnknownCrs is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:VerticalUnknownCrs complex type: */
class SOAP_CMAC eml__VerticalUnknownCrs : public eml__AbstractVerticalCrs
{
public:
	std::string Unknown;	/* required element of XSD type eml:DescriptionString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalUnknownCrs (277)
	virtual int soap_type(void) const { return 277; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VerticalUnknownCrs, default initialized and not managed by a soap context
	virtual eml__VerticalUnknownCrs *soap_alloc(void) const { return SOAP_NEW(eml__VerticalUnknownCrs); }
	         eml__VerticalUnknownCrs() { eml__VerticalUnknownCrs::soap_default(NULL); }
	virtual ~eml__VerticalUnknownCrs() { }
	friend eml__VerticalUnknownCrs *soap_instantiate_eml__VerticalUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:981 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrsEpsgCode
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrsEpsgCode (282)
/* Type eml__ProjectedCrsEpsgCode is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:ProjectedCrsEpsgCode complex type: */
class SOAP_CMAC eml__ProjectedCrsEpsgCode : public eml__AbstractProjectedCrs
{
public:
	ULONG64 EpsgCode;	/* required element of XSD type xsd:positiveInteger */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrsEpsgCode (282)
	virtual int soap_type(void) const { return 282; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ProjectedCrsEpsgCode, default initialized and not managed by a soap context
	virtual eml__ProjectedCrsEpsgCode *soap_alloc(void) const { return SOAP_NEW(eml__ProjectedCrsEpsgCode); }
	         eml__ProjectedCrsEpsgCode() { eml__ProjectedCrsEpsgCode::soap_default(NULL); }
	virtual ~eml__ProjectedCrsEpsgCode() { }
	friend eml__ProjectedCrsEpsgCode *soap_instantiate_eml__ProjectedCrsEpsgCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:984 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlProjectedCrsDefinition
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlProjectedCrsDefinition (283)
/* Type eml__GmlProjectedCrsDefinition is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:GmlProjectedCrsDefinition complex type: */
class SOAP_CMAC eml__GmlProjectedCrsDefinition : public eml__AbstractProjectedCrs
{
public:
	gml__ProjectedCRSType *GmlProjectedCrsDefinition;	/* required element of XSD type gml:ProjectedCRSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlProjectedCrsDefinition (283)
	virtual int soap_type(void) const { return 283; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__GmlProjectedCrsDefinition, default initialized and not managed by a soap context
	virtual eml__GmlProjectedCrsDefinition *soap_alloc(void) const { return SOAP_NEW(eml__GmlProjectedCrsDefinition); }
	         eml__GmlProjectedCrsDefinition() { eml__GmlProjectedCrsDefinition::soap_default(NULL); }
	virtual ~eml__GmlProjectedCrsDefinition() { }
	friend eml__GmlProjectedCrsDefinition *soap_instantiate_eml__GmlProjectedCrsDefinition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:987 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedUnknownCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedUnknownCrs (284)
/* Type eml__ProjectedUnknownCrs is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:ProjectedUnknownCrs complex type: */
class SOAP_CMAC eml__ProjectedUnknownCrs : public eml__AbstractProjectedCrs
{
public:
	std::string Unknown;	/* required element of XSD type eml:DescriptionString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedUnknownCrs (284)
	virtual int soap_type(void) const { return 284; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ProjectedUnknownCrs, default initialized and not managed by a soap context
	virtual eml__ProjectedUnknownCrs *soap_alloc(void) const { return SOAP_NEW(eml__ProjectedUnknownCrs); }
	         eml__ProjectedUnknownCrs() { eml__ProjectedUnknownCrs::soap_default(NULL); }
	virtual ~eml__ProjectedUnknownCrs() { }
	friend eml__ProjectedUnknownCrs *soap_instantiate_eml__ProjectedUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1536 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionBaseType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionBaseType (467)
/* Type gml__DefinitionBaseType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:DefinitionBaseType complex type: */
class SOAP_CMAC gml__DefinitionBaseType
{
public:
	gml__StringOrRefType *description;	/* optional element of XSD type gml:StringOrRefType */
	gml__ReferenceType *descriptionReference;	/* optional element of XSD type gml:ReferenceType */
	gml__CodeWithAuthorityType *identifier;	/* required element of XSD type gml:CodeWithAuthorityType */
	std::vector<gml__CodeType *> name;	/* optional element of XSD type gml:CodeType */
	std::string gml__id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionBaseType (467)
	virtual int soap_type(void) const { return 467; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__DefinitionBaseType, default initialized and not managed by a soap context
	virtual gml__DefinitionBaseType *soap_alloc(void) const { return SOAP_NEW(gml__DefinitionBaseType); }
	         gml__DefinitionBaseType() { gml__DefinitionBaseType::soap_default(NULL); }
	virtual ~gml__DefinitionBaseType() { }
	friend gml__DefinitionBaseType *soap_instantiate_gml__DefinitionBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1542 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__StringOrRefType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__StringOrRefType (469)
/* gml:StringOrRefType simple type: */
class SOAP_CMAC gml__StringOrRefType
{
public:
	std::string __item;	/* mixed XML content */
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__StringOrRefType (469)
	virtual int soap_type(void) const { return 469; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__StringOrRefType, default initialized and not managed by a soap context
	virtual gml__StringOrRefType *soap_alloc(void) const { return SOAP_NEW(gml__StringOrRefType); }
	         gml__StringOrRefType() { gml__StringOrRefType::soap_default(NULL); }
	virtual ~gml__StringOrRefType() { }
	friend gml__StringOrRefType *soap_instantiate_gml__StringOrRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1551 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeType (472)
/* gml:CodeType simple type: */
class SOAP_CMAC gml__CodeType
{
public:
	std::string __item;	/* mixed XML content */
	std::string *codeSpace;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeType (472)
	virtual int soap_type(void) const { return 472; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CodeType, default initialized and not managed by a soap context
	virtual gml__CodeType *soap_alloc(void) const { return SOAP_NEW(gml__CodeType); }
	         gml__CodeType() { gml__CodeType::soap_default(NULL); }
	virtual ~gml__CodeType() { }
	friend gml__CodeType *soap_instantiate_gml__CodeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1557 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimeObjectType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimeObjectType (474)
/* Type gml__AbstractTimeObjectType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractTimeObjectType complex type: */
class SOAP_CMAC gml__AbstractTimeObjectType : public gml__AbstractGMLType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimeObjectType (474)
	virtual int soap_type(void) const { return 474; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractTimeObjectType, default initialized and not managed by a soap context
	virtual gml__AbstractTimeObjectType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractTimeObjectType); }
	         gml__AbstractTimeObjectType() { gml__AbstractTimeObjectType::soap_default(NULL); }
	virtual ~gml__AbstractTimeObjectType() { }
	friend gml__AbstractTimeObjectType *soap_instantiate_gml__AbstractTimeObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1560 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__RelatedTimeType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__RelatedTimeType (475)
/* Type gml__RelatedTimeType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:RelatedTimeType complex type: */
class SOAP_CMAC gml__RelatedTimeType : public gml__TimePrimitivePropertyType
{
public:
	enum _gml__RelatedTimeType_relativePosition *relativePosition;	/* optional attribute of XSD type gml:RelatedTimeType-relativePosition */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__RelatedTimeType (475)
	virtual int soap_type(void) const { return 475; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__RelatedTimeType, default initialized and not managed by a soap context
	virtual gml__RelatedTimeType *soap_alloc(void) const { return SOAP_NEW(gml__RelatedTimeType); }
	         gml__RelatedTimeType() { gml__RelatedTimeType::soap_default(NULL); }
	virtual ~gml__RelatedTimeType() { }
	friend gml__RelatedTimeType *soap_instantiate_gml__RelatedTimeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1611 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__MeasureType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__MeasureType (492)
/* Type gml__MeasureType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:MeasureType simple type: */
class SOAP_CMAC gml__MeasureType
{
public:
	double __item;	/* mixed XML content */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__MeasureType (492)
	virtual int soap_type(void) const { return 492; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__MeasureType, default initialized and not managed by a soap context
	virtual gml__MeasureType *soap_alloc(void) const { return SOAP_NEW(gml__MeasureType); }
	         gml__MeasureType() { gml__MeasureType::soap_default(NULL); }
	virtual ~gml__MeasureType() { }
	friend gml__MeasureType *soap_instantiate_gml__MeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1671 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREExtent_USCOREType (512)
/* Type gmd__EX_USCOREExtent_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:EX_Extent_Type complex type: */
class SOAP_CMAC gmd__EX_USCOREExtent_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__CharacterString_USCOREPropertyType *description;	/* optional element of XSD type gco:CharacterString_PropertyType */
	std::vector<gmd__EX_USCOREGeographicExtent_USCOREPropertyType *> geographicElement;	/* optional element of XSD type gmd:EX_GeographicExtent_PropertyType */
	std::vector<gmd__EX_USCORETemporalExtent_USCOREPropertyType *> temporalElement;	/* optional element of XSD type gmd:EX_TemporalExtent_PropertyType */
	std::vector<gmd__EX_USCOREVerticalExtent_USCOREPropertyType *> verticalElement;	/* optional element of XSD type gmd:EX_VerticalExtent_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREExtent_USCOREType (512)
	virtual int soap_type(void) const { return 512; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCOREExtent_USCOREType, default initialized and not managed by a soap context
	virtual gmd__EX_USCOREExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREExtent_USCOREType); }
	         gmd__EX_USCOREExtent_USCOREType() { gmd__EX_USCOREExtent_USCOREType::soap_default(NULL); }
	virtual ~gmd__EX_USCOREExtent_USCOREType() { }
	friend gmd__EX_USCOREExtent_USCOREType *soap_instantiate_gmd__EX_USCOREExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1677 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType (514)
/* Type gmd__AbstractEX_USCOREGeographicExtent_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:AbstractEX_GeographicExtent_Type complex type: */
class SOAP_CMAC gmd__AbstractEX_USCOREGeographicExtent_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__Boolean_USCOREPropertyType *extentTypeCode;	/* optional element of XSD type gco:Boolean_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType (514)
	virtual int soap_type(void) const { return 514; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__AbstractEX_USCOREGeographicExtent_USCOREType, default initialized and not managed by a soap context
	virtual gmd__AbstractEX_USCOREGeographicExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractEX_USCOREGeographicExtent_USCOREType); }
	         gmd__AbstractEX_USCOREGeographicExtent_USCOREType() { gmd__AbstractEX_USCOREGeographicExtent_USCOREType::soap_default(NULL); }
	virtual ~gmd__AbstractEX_USCOREGeographicExtent_USCOREType() { }
	friend gmd__AbstractEX_USCOREGeographicExtent_USCOREType *soap_instantiate_gmd__AbstractEX_USCOREGeographicExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1683 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREType (516)
/* Type gmd__EX_USCORETemporalExtent_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:EX_TemporalExtent_Type complex type: */
class SOAP_CMAC gmd__EX_USCORETemporalExtent_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gts__TM_USCOREPrimitive_USCOREPropertyType *extent;	/* required element of XSD type gts:TM_Primitive_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREType (516)
	virtual int soap_type(void) const { return 516; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCORETemporalExtent_USCOREType, default initialized and not managed by a soap context
	virtual gmd__EX_USCORETemporalExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCORETemporalExtent_USCOREType); }
	         gmd__EX_USCORETemporalExtent_USCOREType() { gmd__EX_USCORETemporalExtent_USCOREType::soap_default(NULL); }
	virtual ~gmd__EX_USCORETemporalExtent_USCOREType() { }
	friend gmd__EX_USCORETemporalExtent_USCOREType *soap_instantiate_gmd__EX_USCORETemporalExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1689 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREType (518)
/* Type gmd__EX_USCOREVerticalExtent_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:EX_VerticalExtent_Type complex type: */
class SOAP_CMAC gmd__EX_USCOREVerticalExtent_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__Real_USCOREPropertyType *minimumValue;	/* required element of XSD type gco:Real_PropertyType */
	gco__Real_USCOREPropertyType *maximumValue;	/* required element of XSD type gco:Real_PropertyType */
	gsr__SC_USCORECRS_USCOREPropertyType *verticalCRS;	/* required element of XSD type gsr:SC_CRS_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREType (518)
	virtual int soap_type(void) const { return 518; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCOREVerticalExtent_USCOREType, default initialized and not managed by a soap context
	virtual gmd__EX_USCOREVerticalExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREVerticalExtent_USCOREType); }
	         gmd__EX_USCOREVerticalExtent_USCOREType() { gmd__EX_USCOREVerticalExtent_USCOREType::soap_default(NULL); }
	virtual ~gmd__EX_USCOREVerticalExtent_USCOREType() { }
	friend gmd__EX_USCOREVerticalExtent_USCOREType *soap_instantiate_gmd__EX_USCOREVerticalExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1695 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREElement_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREElement_USCOREType (520)
/* Type gmd__AbstractDQ_USCOREElement_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:AbstractDQ_Element_Type complex type: */
class SOAP_CMAC gmd__AbstractDQ_USCOREElement_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	std::vector<gco__CharacterString_USCOREPropertyType *> nameOfMeasure;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__MD_USCOREIdentifier_USCOREPropertyType *measureIdentification;	/* optional element of XSD type gmd:MD_Identifier_PropertyType */
	gco__CharacterString_USCOREPropertyType *measureDescription;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *evaluationMethodType;	/* optional element of XSD type gmd:DQ_EvaluationMethodTypeCode_PropertyType */
	gco__CharacterString_USCOREPropertyType *evaluationMethodDescription;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__CI_USCORECitation_USCOREPropertyType *evaluationProcedure;	/* optional element of XSD type gmd:CI_Citation_PropertyType */
	std::vector<gco__DateTime_USCOREPropertyType *> dateTime;	/* optional element of XSD type gco:DateTime_PropertyType */
	std::vector<gmd__DQ_USCOREResult_USCOREPropertyType *> result;	/* required element of XSD type gmd:DQ_Result_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREElement_USCOREType (520)
	virtual int soap_type(void) const { return 520; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__AbstractDQ_USCOREElement_USCOREType, default initialized and not managed by a soap context
	virtual gmd__AbstractDQ_USCOREElement_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREElement_USCOREType); }
	         gmd__AbstractDQ_USCOREElement_USCOREType() { gmd__AbstractDQ_USCOREElement_USCOREType::soap_default(NULL); }
	virtual ~gmd__AbstractDQ_USCOREElement_USCOREType() { }
	friend gmd__AbstractDQ_USCOREElement_USCOREType *soap_instantiate_gmd__AbstractDQ_USCOREElement_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1701 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREType (522)
/* Type gmd__MD_USCOREIdentifier_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:MD_Identifier_Type complex type: */
class SOAP_CMAC gmd__MD_USCOREIdentifier_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gmd__CI_USCORECitation_USCOREPropertyType *authority;	/* optional element of XSD type gmd:CI_Citation_PropertyType */
	gco__CharacterString_USCOREPropertyType *code;	/* required element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREType (522)
	virtual int soap_type(void) const { return 522; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__MD_USCOREIdentifier_USCOREType, default initialized and not managed by a soap context
	virtual gmd__MD_USCOREIdentifier_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__MD_USCOREIdentifier_USCOREType); }
	         gmd__MD_USCOREIdentifier_USCOREType() { gmd__MD_USCOREIdentifier_USCOREType::soap_default(NULL); }
	virtual ~gmd__MD_USCOREIdentifier_USCOREType() { }
	friend gmd__MD_USCOREIdentifier_USCOREType *soap_instantiate_gmd__MD_USCOREIdentifier_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1707 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREType (524)
/* Type gmd__CI_USCORECitation_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Citation_Type complex type: */
class SOAP_CMAC gmd__CI_USCORECitation_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__CharacterString_USCOREPropertyType *title;	/* required element of XSD type gco:CharacterString_PropertyType */
	std::vector<gco__CharacterString_USCOREPropertyType *> alternateTitle;	/* optional element of XSD type gco:CharacterString_PropertyType */
	std::vector<gmd__CI_USCOREDate_USCOREPropertyType *> date;	/* required element of XSD type gmd:CI_Date_PropertyType */
	gco__CharacterString_USCOREPropertyType *edition;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__Date_USCOREPropertyType *editionDate;	/* optional element of XSD type gco:Date_PropertyType */
	std::vector<gmd__MD_USCOREIdentifier_USCOREPropertyType *> identifier;	/* optional element of XSD type gmd:MD_Identifier_PropertyType */
	std::vector<gmd__CI_USCOREResponsibleParty_USCOREPropertyType *> citedResponsibleParty;	/* optional element of XSD type gmd:CI_ResponsibleParty_PropertyType */
	std::vector<gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *> presentationForm;	/* optional element of XSD type gmd:CI_PresentationFormCode_PropertyType */
	gmd__CI_USCORESeries_USCOREPropertyType *series;	/* optional element of XSD type gmd:CI_Series_PropertyType */
	gco__CharacterString_USCOREPropertyType *otherCitationDetails;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *collectiveTitle;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *ISBN;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *ISSN;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREType (524)
	virtual int soap_type(void) const { return 524; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORECitation_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORECitation_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORECitation_USCOREType); }
	         gmd__CI_USCORECitation_USCOREType() { gmd__CI_USCORECitation_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCORECitation_USCOREType() { }
	friend gmd__CI_USCORECitation_USCOREType *soap_instantiate_gmd__CI_USCORECitation_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1713 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREType (526)
/* Type gmd__CI_USCOREDate_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Date_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREDate_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__Date_USCOREPropertyType *date;	/* required element of XSD type gco:Date_PropertyType */
	gmd__CI_USCOREDateTypeCode_USCOREPropertyType *dateType;	/* required element of XSD type gmd:CI_DateTypeCode_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREType (526)
	virtual int soap_type(void) const { return 526; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREDate_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREDate_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDate_USCOREType); }
	         gmd__CI_USCOREDate_USCOREType() { gmd__CI_USCOREDate_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREDate_USCOREType() { }
	friend gmd__CI_USCOREDate_USCOREType *soap_instantiate_gmd__CI_USCOREDate_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1722 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREType (529)
/* Type gmd__CI_USCOREResponsibleParty_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_ResponsibleParty_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREResponsibleParty_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__CharacterString_USCOREPropertyType *individualName;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *organisationName;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *positionName;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__CI_USCOREContact_USCOREPropertyType *contactInfo;	/* optional element of XSD type gmd:CI_Contact_PropertyType */
	gmd__CI_USCORERoleCode_USCOREPropertyType *role;	/* required element of XSD type gmd:CI_RoleCode_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREType (529)
	virtual int soap_type(void) const { return 529; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREResponsibleParty_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREResponsibleParty_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREResponsibleParty_USCOREType); }
	         gmd__CI_USCOREResponsibleParty_USCOREType() { gmd__CI_USCOREResponsibleParty_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREResponsibleParty_USCOREType() { }
	friend gmd__CI_USCOREResponsibleParty_USCOREType *soap_instantiate_gmd__CI_USCOREResponsibleParty_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1728 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREType (531)
/* Type gmd__CI_USCOREContact_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Contact_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREContact_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gmd__CI_USCORETelephone_USCOREPropertyType *phone;	/* optional element of XSD type gmd:CI_Telephone_PropertyType */
	gmd__CI_USCOREAddress_USCOREPropertyType *address;	/* optional element of XSD type gmd:CI_Address_PropertyType */
	gmd__CI_USCOREOnlineResource_USCOREPropertyType *onlineResource;	/* optional element of XSD type gmd:CI_OnlineResource_PropertyType */
	gco__CharacterString_USCOREPropertyType *hoursOfService;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *contactInstructions;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREType (531)
	virtual int soap_type(void) const { return 531; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREContact_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREContact_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREContact_USCOREType); }
	         gmd__CI_USCOREContact_USCOREType() { gmd__CI_USCOREContact_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREContact_USCOREType() { }
	friend gmd__CI_USCOREContact_USCOREType *soap_instantiate_gmd__CI_USCOREContact_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1734 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREType (533)
/* Type gmd__CI_USCORETelephone_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Telephone_Type complex type: */
class SOAP_CMAC gmd__CI_USCORETelephone_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	std::vector<gco__CharacterString_USCOREPropertyType *> voice;	/* optional element of XSD type gco:CharacterString_PropertyType */
	std::vector<gco__CharacterString_USCOREPropertyType *> facsimile;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREType (533)
	virtual int soap_type(void) const { return 533; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORETelephone_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORETelephone_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORETelephone_USCOREType); }
	         gmd__CI_USCORETelephone_USCOREType() { gmd__CI_USCORETelephone_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCORETelephone_USCOREType() { }
	friend gmd__CI_USCORETelephone_USCOREType *soap_instantiate_gmd__CI_USCORETelephone_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1740 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREType (535)
/* Type gmd__CI_USCOREAddress_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Address_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREAddress_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	std::vector<gco__CharacterString_USCOREPropertyType *> deliveryPoint;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *city;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *administrativeArea;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *postalCode;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *country;	/* optional element of XSD type gco:CharacterString_PropertyType */
	std::vector<gco__CharacterString_USCOREPropertyType *> electronicMailAddress;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREType (535)
	virtual int soap_type(void) const { return 535; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREAddress_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREAddress_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREAddress_USCOREType); }
	         gmd__CI_USCOREAddress_USCOREType() { gmd__CI_USCOREAddress_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREAddress_USCOREType() { }
	friend gmd__CI_USCOREAddress_USCOREType *soap_instantiate_gmd__CI_USCOREAddress_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1746 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREType (537)
/* Type gmd__CI_USCOREOnlineResource_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_OnlineResource_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREOnlineResource_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gmd__URL_USCOREPropertyType *linkage;	/* required element of XSD type gmd:URL_PropertyType */
	gco__CharacterString_USCOREPropertyType *protocol;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *applicationProfile;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *name;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *description;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *function;	/* optional element of XSD type gmd:CI_OnLineFunctionCode_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREType (537)
	virtual int soap_type(void) const { return 537; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREOnlineResource_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREOnlineResource_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnlineResource_USCOREType); }
	         gmd__CI_USCOREOnlineResource_USCOREType() { gmd__CI_USCOREOnlineResource_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREOnlineResource_USCOREType() { }
	friend gmd__CI_USCOREOnlineResource_USCOREType *soap_instantiate_gmd__CI_USCOREOnlineResource_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1764 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREType (543)
/* Type gmd__CI_USCORESeries_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Series_Type complex type: */
class SOAP_CMAC gmd__CI_USCORESeries_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__CharacterString_USCOREPropertyType *name;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *issueIdentification;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *page;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREType (543)
	virtual int soap_type(void) const { return 543; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORESeries_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORESeries_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORESeries_USCOREType); }
	         gmd__CI_USCORESeries_USCOREType() { gmd__CI_USCORESeries_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCORESeries_USCOREType() { }
	friend gmd__CI_USCORESeries_USCOREType *soap_instantiate_gmd__CI_USCORESeries_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1773 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREResult_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREResult_USCOREType (546)
/* Type gmd__AbstractDQ_USCOREResult_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:AbstractDQ_Result_Type complex type: */
class SOAP_CMAC gmd__AbstractDQ_USCOREResult_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREResult_USCOREType (546)
	virtual int soap_type(void) const { return 546; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__AbstractDQ_USCOREResult_USCOREType, default initialized and not managed by a soap context
	virtual gmd__AbstractDQ_USCOREResult_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREResult_USCOREType); }
	         gmd__AbstractDQ_USCOREResult_USCOREType() { gmd__AbstractDQ_USCOREResult_USCOREType::soap_default(NULL); }
	virtual ~gmd__AbstractDQ_USCOREResult_USCOREType() { }
	friend gmd__AbstractDQ_USCOREResult_USCOREType *soap_instantiate_gmd__AbstractDQ_USCOREResult_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1794 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__CodeListValue_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__CodeListValue_USCOREType (553)
/* gco:CodeListValue_Type simple type: */
class SOAP_CMAC gco__CodeListValue_USCOREType
{
public:
	std::string __item;	/* mixed XML content */
	std::string codeList;	/* required attribute of XSD type xsd:anyURI */
	std::string codeListValue;	/* required attribute of XSD type xsd:anyURI */
	std::string *codeSpace;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gco__CodeListValue_USCOREType (553)
	virtual int soap_type(void) const { return 553; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__CodeListValue_USCOREType, default initialized and not managed by a soap context
	virtual gco__CodeListValue_USCOREType *soap_alloc(void) const { return SOAP_NEW(gco__CodeListValue_USCOREType); }
	         gco__CodeListValue_USCOREType() { gco__CodeListValue_USCOREType::soap_default(NULL); }
	virtual ~gco__CodeListValue_USCOREType() { }
	friend gco__CodeListValue_USCOREType *soap_instantiate_gco__CodeListValue_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:201 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerArrayFromBooleanMaskArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerArrayFromBooleanMaskArray (22)
/* Type resqml2__IntegerArrayFromBooleanMaskArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:IntegerArrayFromBooleanMaskArray complex type: */
class SOAP_CMAC resqml2__IntegerArrayFromBooleanMaskArray : public resqml2__AbstractIntegerArray
{
public:
	ULONG64 TotalIndexCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractBooleanArray *Mask;	/* required element of XSD type resqml2:AbstractBooleanArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerArrayFromBooleanMaskArray (22)
	virtual int soap_type(void) const { return 22; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IntegerArrayFromBooleanMaskArray, default initialized and not managed by a soap context
	virtual resqml2__IntegerArrayFromBooleanMaskArray *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerArrayFromBooleanMaskArray); }
	         resqml2__IntegerArrayFromBooleanMaskArray() { resqml2__IntegerArrayFromBooleanMaskArray::soap_default(NULL); }
	virtual ~resqml2__IntegerArrayFromBooleanMaskArray() { }
	friend resqml2__IntegerArrayFromBooleanMaskArray *soap_instantiate_resqml2__IntegerArrayFromBooleanMaskArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:204 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromIndexArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromIndexArray (23)
/* Type resqml2__BooleanArrayFromIndexArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:BooleanArrayFromIndexArray complex type: */
class SOAP_CMAC resqml2__BooleanArrayFromIndexArray : public resqml2__AbstractBooleanArray
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *Indices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	bool IndexIsTrue;	/* required element of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromIndexArray (23)
	virtual int soap_type(void) const { return 23; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__BooleanArrayFromIndexArray, default initialized and not managed by a soap context
	virtual resqml2__BooleanArrayFromIndexArray *soap_alloc(void) const { return SOAP_NEW(resqml2__BooleanArrayFromIndexArray); }
	         resqml2__BooleanArrayFromIndexArray() { resqml2__BooleanArrayFromIndexArray::soap_default(NULL); }
	virtual ~resqml2__BooleanArrayFromIndexArray() { }
	friend resqml2__BooleanArrayFromIndexArray *soap_instantiate_resqml2__BooleanArrayFromIndexArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:207 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanConstantArray (24)
/* Type resqml2__BooleanConstantArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:BooleanConstantArray complex type: */
class SOAP_CMAC resqml2__BooleanConstantArray : public resqml2__AbstractBooleanArray
{
public:
	bool Value;	/* required element of XSD type xsd:boolean */
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanConstantArray (24)
	virtual int soap_type(void) const { return 24; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__BooleanConstantArray, default initialized and not managed by a soap context
	virtual resqml2__BooleanConstantArray *soap_alloc(void) const { return SOAP_NEW(resqml2__BooleanConstantArray); }
	         resqml2__BooleanConstantArray() { resqml2__BooleanConstantArray::soap_default(NULL); }
	virtual ~resqml2__BooleanConstantArray() { }
	friend resqml2__BooleanConstantArray *soap_instantiate_resqml2__BooleanConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:210 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerConstantArray (25)
/* Type resqml2__IntegerConstantArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:IntegerConstantArray complex type: */
class SOAP_CMAC resqml2__IntegerConstantArray : public resqml2__AbstractIntegerArray
{
public:
	LONG64 Value;	/* required element of XSD type xsd:integer */
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerConstantArray (25)
	virtual int soap_type(void) const { return 25; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IntegerConstantArray, default initialized and not managed by a soap context
	virtual resqml2__IntegerConstantArray *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerConstantArray); }
	         resqml2__IntegerConstantArray() { resqml2__IntegerConstantArray::soap_default(NULL); }
	virtual ~resqml2__IntegerConstantArray() { }
	friend resqml2__IntegerConstantArray *soap_instantiate_resqml2__IntegerConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:219 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerHdf5Array (28)
/* Type resqml2__IntegerHdf5Array is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:IntegerHdf5Array complex type: */
class SOAP_CMAC resqml2__IntegerHdf5Array : public resqml2__AbstractIntegerArray
{
public:
	LONG64 NullValue;	/* required element of XSD type xsd:integer */
	eml__Hdf5Dataset *Values;	/* required element of XSD type eml:Hdf5Dataset */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerHdf5Array (28)
	virtual int soap_type(void) const { return 28; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IntegerHdf5Array, default initialized and not managed by a soap context
	virtual resqml2__IntegerHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerHdf5Array); }
	         resqml2__IntegerHdf5Array() { resqml2__IntegerHdf5Array::soap_default(NULL); }
	virtual ~resqml2__IntegerHdf5Array() { }
	friend resqml2__IntegerHdf5Array *soap_instantiate_resqml2__IntegerHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:231 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLatticeArray (32)
/* Type resqml2__DoubleLatticeArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:DoubleLatticeArray complex type: */
class SOAP_CMAC resqml2__DoubleLatticeArray : public resqml2__AbstractDoubleArray
{
public:
	double StartValue;	/* required element of XSD type xsd:double */
	std::vector<resqml2__DoubleConstantArray *> Offset;	/* required element of XSD type resqml2:DoubleConstantArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLatticeArray (32)
	virtual int soap_type(void) const { return 32; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__DoubleLatticeArray, default initialized and not managed by a soap context
	virtual resqml2__DoubleLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__DoubleLatticeArray); }
	         resqml2__DoubleLatticeArray() { resqml2__DoubleLatticeArray::soap_default(NULL); }
	virtual ~resqml2__DoubleLatticeArray() { }
	friend resqml2__DoubleLatticeArray *soap_instantiate_resqml2__DoubleLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:234 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleConstantArray (33)
/* Type resqml2__DoubleConstantArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:DoubleConstantArray complex type: */
class SOAP_CMAC resqml2__DoubleConstantArray : public resqml2__AbstractDoubleArray
{
public:
	double Value;	/* required element of XSD type xsd:double */
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleConstantArray (33)
	virtual int soap_type(void) const { return 33; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__DoubleConstantArray, default initialized and not managed by a soap context
	virtual resqml2__DoubleConstantArray *soap_alloc(void) const { return SOAP_NEW(resqml2__DoubleConstantArray); }
	         resqml2__DoubleConstantArray() { resqml2__DoubleConstantArray::soap_default(NULL); }
	virtual ~resqml2__DoubleConstantArray() { }
	friend resqml2__DoubleConstantArray *soap_instantiate_resqml2__DoubleConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:237 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleHdf5Array (34)
/* Type resqml2__DoubleHdf5Array is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:DoubleHdf5Array complex type: */
class SOAP_CMAC resqml2__DoubleHdf5Array : public resqml2__AbstractDoubleArray
{
public:
	eml__Hdf5Dataset *Values;	/* required element of XSD type eml:Hdf5Dataset */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleHdf5Array (34)
	virtual int soap_type(void) const { return 34; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__DoubleHdf5Array, default initialized and not managed by a soap context
	virtual resqml2__DoubleHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__DoubleHdf5Array); }
	         resqml2__DoubleHdf5Array() { resqml2__DoubleHdf5Array::soap_default(NULL); }
	virtual ~resqml2__DoubleHdf5Array() { }
	friend resqml2__DoubleHdf5Array *soap_instantiate_resqml2__DoubleHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:255 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerLatticeArray (40)
/* Type resqml2__IntegerLatticeArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:IntegerLatticeArray complex type: */
class SOAP_CMAC resqml2__IntegerLatticeArray : public resqml2__AbstractIntegerArray
{
public:
	LONG64 StartValue;	/* required element of XSD type xsd:integer */
	std::vector<resqml2__IntegerConstantArray *> Offset;	/* required element of XSD type resqml2:IntegerConstantArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerLatticeArray (40)
	virtual int soap_type(void) const { return 40; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IntegerLatticeArray, default initialized and not managed by a soap context
	virtual resqml2__IntegerLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerLatticeArray); }
	         resqml2__IntegerLatticeArray() { resqml2__IntegerLatticeArray::soap_default(NULL); }
	virtual ~resqml2__IntegerLatticeArray() { }
	friend resqml2__IntegerLatticeArray *soap_instantiate_resqml2__IntegerLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:267 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanHdf5Array (44)
/* Type resqml2__BooleanHdf5Array is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:BooleanHdf5Array complex type: */
class SOAP_CMAC resqml2__BooleanHdf5Array : public resqml2__AbstractBooleanArray
{
public:
	eml__Hdf5Dataset *Values;	/* required element of XSD type eml:Hdf5Dataset */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanHdf5Array (44)
	virtual int soap_type(void) const { return 44; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__BooleanHdf5Array, default initialized and not managed by a soap context
	virtual resqml2__BooleanHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__BooleanHdf5Array); }
	         resqml2__BooleanHdf5Array() { resqml2__BooleanHdf5Array::soap_default(NULL); }
	virtual ~resqml2__BooleanHdf5Array() { }
	friend resqml2__BooleanHdf5Array *soap_instantiate_resqml2__BooleanHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:282 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerRangeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerRangeArray (49)
/* Type resqml2__IntegerRangeArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:IntegerRangeArray complex type: */
class SOAP_CMAC resqml2__IntegerRangeArray : public resqml2__AbstractIntegerArray
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	LONG64 Value;	/* required element of XSD type xsd:integer */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerRangeArray (49)
	virtual int soap_type(void) const { return 49; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IntegerRangeArray, default initialized and not managed by a soap context
	virtual resqml2__IntegerRangeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerRangeArray); }
	         resqml2__IntegerRangeArray() { resqml2__IntegerRangeArray::soap_default(NULL); }
	virtual ~resqml2__IntegerRangeArray() { }
	friend resqml2__IntegerRangeArray *soap_instantiate_resqml2__IntegerRangeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:312 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromDiscretePropertyArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromDiscretePropertyArray (59)
/* Type resqml2__BooleanArrayFromDiscretePropertyArray is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:BooleanArrayFromDiscretePropertyArray complex type: */
class SOAP_CMAC resqml2__BooleanArrayFromDiscretePropertyArray : public resqml2__AbstractBooleanArray
{
public:
	LONG64 Value;	/* required element of XSD type xsd:integer */
	eml__DataObjectReference *Property;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromDiscretePropertyArray (59)
	virtual int soap_type(void) const { return 59; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__BooleanArrayFromDiscretePropertyArray, default initialized and not managed by a soap context
	virtual resqml2__BooleanArrayFromDiscretePropertyArray *soap_alloc(void) const { return SOAP_NEW(resqml2__BooleanArrayFromDiscretePropertyArray); }
	         resqml2__BooleanArrayFromDiscretePropertyArray() { resqml2__BooleanArrayFromDiscretePropertyArray::soap_default(NULL); }
	virtual ~resqml2__BooleanArrayFromDiscretePropertyArray() { }
	friend resqml2__BooleanArrayFromDiscretePropertyArray *soap_instantiate_resqml2__BooleanArrayFromDiscretePropertyArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:321 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineGeometry (62)
/* Type resqml2__ParametricLineGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ParametricLineGeometry complex type: */
class SOAP_CMAC resqml2__ParametricLineGeometry : public resqml2__AbstractParametricLineGeometry
{
public:
	resqml2__AbstractDoubleArray *ControlPointParameters;	/* optional element of XSD type resqml2:AbstractDoubleArray */
	resqml2__AbstractPoint3dArray *ControlPoints;	/* required element of XSD type resqml2:AbstractPoint3dArray */
	ULONG64 KnotCount;	/* required element of XSD type xsd:positiveInteger */
	LONG64 LineKindIndex;	/* required element of XSD type xsd:integer */
	resqml2__AbstractPoint3dArray *TangentVectors;	/* optional element of XSD type resqml2:AbstractPoint3dArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineGeometry (62)
	virtual int soap_type(void) const { return 62; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ParametricLineGeometry, default initialized and not managed by a soap context
	virtual resqml2__ParametricLineGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineGeometry); }
	         resqml2__ParametricLineGeometry() { resqml2__ParametricLineGeometry::soap_default(NULL); }
	virtual ~resqml2__ParametricLineGeometry() { }
	friend resqml2__ParametricLineGeometry *soap_instantiate_resqml2__ParametricLineGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:333 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizontalPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizontalPlaneGeometry (66)
/* Type resqml2__HorizontalPlaneGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:HorizontalPlaneGeometry complex type: */
class SOAP_CMAC resqml2__HorizontalPlaneGeometry : public resqml2__AbstractPlaneGeometry
{
public:
	double Coordinate;	/* required element of XSD type xsd:double */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizontalPlaneGeometry (66)
	virtual int soap_type(void) const { return 66; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__HorizontalPlaneGeometry, default initialized and not managed by a soap context
	virtual resqml2__HorizontalPlaneGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__HorizontalPlaneGeometry); }
	         resqml2__HorizontalPlaneGeometry() { resqml2__HorizontalPlaneGeometry::soap_default(NULL); }
	virtual ~resqml2__HorizontalPlaneGeometry() { }
	friend resqml2__HorizontalPlaneGeometry *soap_instantiate_resqml2__HorizontalPlaneGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:351 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationGeometry (72)
/* Type resqml2__ParametricLineFromRepresentationGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ParametricLineFromRepresentationGeometry complex type: */
class SOAP_CMAC resqml2__ParametricLineFromRepresentationGeometry : public resqml2__AbstractParametricLineGeometry
{
public:
	ULONG64 LineIndiexOnSupportingRepresentation;	/* required element of XSD type xsd:nonNegativeInteger */
	eml__DataObjectReference *SupportingRepresentation;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationGeometry (72)
	virtual int soap_type(void) const { return 72; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ParametricLineFromRepresentationGeometry, default initialized and not managed by a soap context
	virtual resqml2__ParametricLineFromRepresentationGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineFromRepresentationGeometry); }
	         resqml2__ParametricLineFromRepresentationGeometry() { resqml2__ParametricLineFromRepresentationGeometry::soap_default(NULL); }
	virtual ~resqml2__ParametricLineFromRepresentationGeometry() { }
	friend resqml2__ParametricLineFromRepresentationGeometry *soap_instantiate_resqml2__ParametricLineFromRepresentationGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:366 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TiltedPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TiltedPlaneGeometry (77)
/* Type resqml2__TiltedPlaneGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:TiltedPlaneGeometry complex type: */
class SOAP_CMAC resqml2__TiltedPlaneGeometry : public resqml2__AbstractPlaneGeometry
{
public:
	std::vector<resqml2__ThreePoint3d *> Plane;	/* required element of XSD type resqml2:ThreePoint3d */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TiltedPlaneGeometry (77)
	virtual int soap_type(void) const { return 77; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__TiltedPlaneGeometry, default initialized and not managed by a soap context
	virtual resqml2__TiltedPlaneGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__TiltedPlaneGeometry); }
	         resqml2__TiltedPlaneGeometry() { resqml2__TiltedPlaneGeometry::soap_default(NULL); }
	virtual ~resqml2__TiltedPlaneGeometry() { }
	friend resqml2__TiltedPlaneGeometry *soap_instantiate_resqml2__TiltedPlaneGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:396 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubRepresentationPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubRepresentationPatch (87)
/* Type resqml2__SubRepresentationPatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:SubRepresentationPatch complex type: */
class SOAP_CMAC resqml2__SubRepresentationPatch : public resqml2__Patch1d
{
public:
	std::vector<resqml2__ElementIndices *> ElementIndices;	/* required element of XSD type resqml2:ElementIndices */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubRepresentationPatch (87)
	virtual int soap_type(void) const { return 87; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__SubRepresentationPatch, default initialized and not managed by a soap context
	virtual resqml2__SubRepresentationPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__SubRepresentationPatch); }
	         resqml2__SubRepresentationPatch() { resqml2__SubRepresentationPatch::soap_default(NULL); }
	virtual ~resqml2__SubRepresentationPatch() { }
	friend resqml2__SubRepresentationPatch *soap_instantiate_resqml2__SubRepresentationPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:438 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnSubnodePatch (101)
/* Type resqml2__ColumnSubnodePatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ColumnSubnodePatch complex type: */
class SOAP_CMAC resqml2__ColumnSubnodePatch : public resqml2__SubnodePatch
{
public:
	resqml2__AbstractIntegerArray *SubnodeCountPerObject;	/* required element of XSD type resqml2:AbstractIntegerArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnSubnodePatch (101)
	virtual int soap_type(void) const { return 101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ColumnSubnodePatch, default initialized and not managed by a soap context
	virtual resqml2__ColumnSubnodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnSubnodePatch); }
	         resqml2__ColumnSubnodePatch() { resqml2__ColumnSubnodePatch::soap_default(NULL); }
	virtual ~resqml2__ColumnSubnodePatch() { }
	friend resqml2__ColumnSubnodePatch *soap_instantiate_resqml2__ColumnSubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:480 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UniformSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UniformSubnodePatch (115)
/* Type resqml2__UniformSubnodePatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:UniformSubnodePatch complex type: */
class SOAP_CMAC resqml2__UniformSubnodePatch : public resqml2__SubnodePatch
{
public:
	ULONG64 SubnodeCountPerObject;	/* required element of XSD type xsd:positiveInteger */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UniformSubnodePatch (115)
	virtual int soap_type(void) const { return 115; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__UniformSubnodePatch, default initialized and not managed by a soap context
	virtual resqml2__UniformSubnodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__UniformSubnodePatch); }
	         resqml2__UniformSubnodePatch() { resqml2__UniformSubnodePatch::soap_default(NULL); }
	virtual ~resqml2__UniformSubnodePatch() { }
	friend resqml2__UniformSubnodePatch *soap_instantiate_resqml2__UniformSubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:561 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridGeometry (142)
/* Type resqml2__AbstractGridGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractGridGeometry complex type: */
class SOAP_CMAC resqml2__AbstractGridGeometry : public resqml2__PointGeometry
{
public:
	std::vector<resqml2__AdditionalGridPoints *> AdditionalGridPoints;	/* optional element of XSD type resqml2:AdditionalGridPoints */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridGeometry (142)
	virtual int soap_type(void) const { return 142; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractGridGeometry, default initialized and not managed by a soap context
	virtual resqml2__AbstractGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractGridGeometry); }
	         resqml2__AbstractGridGeometry() { resqml2__AbstractGridGeometry::soap_default(NULL); }
	virtual ~resqml2__AbstractGridGeometry() { }
	friend resqml2__AbstractGridGeometry *soap_instantiate_resqml2__AbstractGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:573 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VariableSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VariableSubnodePatch (146)
/* Type resqml2__VariableSubnodePatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:VariableSubnodePatch complex type: */
class SOAP_CMAC resqml2__VariableSubnodePatch : public resqml2__SubnodePatch
{
public:
	resqml2__AbstractIntegerArray *ObjectIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *SubnodeCountPerSelectedObject;	/* required element of XSD type resqml2:AbstractIntegerArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VariableSubnodePatch (146)
	virtual int soap_type(void) const { return 146; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__VariableSubnodePatch, default initialized and not managed by a soap context
	virtual resqml2__VariableSubnodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__VariableSubnodePatch); }
	         resqml2__VariableSubnodePatch() { resqml2__VariableSubnodePatch::soap_default(NULL); }
	virtual ~resqml2__VariableSubnodePatch() { }
	friend resqml2__VariableSubnodePatch *soap_instantiate_resqml2__VariableSubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:744 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractResqmlDataObject
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractResqmlDataObject (203)
/* Type resqml2__AbstractResqmlDataObject is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractResqmlDataObject complex type: */
class SOAP_CMAC resqml2__AbstractResqmlDataObject : public eml__AbstractCitedDataObject
{
public:
	std::vector<resqml2__NameValuePair *> ExtraMetadata;	/* optional element of XSD type resqml2:NameValuePair */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractResqmlDataObject (203)
	virtual int soap_type(void) const { return 203; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractResqmlDataObject, default initialized and not managed by a soap context
	virtual resqml2__AbstractResqmlDataObject *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractResqmlDataObject); }
	         resqml2__AbstractResqmlDataObject() { resqml2__AbstractResqmlDataObject::soap_default(NULL); }
	virtual ~resqml2__AbstractResqmlDataObject() { }
	friend resqml2__AbstractResqmlDataObject *soap_instantiate_resqml2__AbstractResqmlDataObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:783 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactPatch (216)
/* Type resqml2__ContactPatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:ContactPatch complex type: */
class SOAP_CMAC resqml2__ContactPatch : public resqml2__Patch1d
{
public:
	ULONG64 RepresentationIndex;	/* required element of XSD type xsd:nonNegativeInteger */
	resqml2__AbstractIntegerArray *SupportingRepresentationNodes;	/* required element of XSD type resqml2:AbstractIntegerArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactPatch (216)
	virtual int soap_type(void) const { return 216; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__ContactPatch, default initialized and not managed by a soap context
	virtual resqml2__ContactPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__ContactPatch); }
	         resqml2__ContactPatch() { resqml2__ContactPatch::soap_default(NULL); }
	virtual ~resqml2__ContactPatch() { }
	friend resqml2__ContactPatch *soap_instantiate_resqml2__ContactPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:801 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__EdgePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__EdgePatch (222)
/* Type resqml2__EdgePatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:EdgePatch complex type: */
class SOAP_CMAC resqml2__EdgePatch : public resqml2__Patch1d
{
public:
	resqml2__AbstractIntegerArray *SplitEdges;	/* optional element of XSD type resqml2:AbstractIntegerArray */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__EdgePatch (222)
	virtual int soap_type(void) const { return 222; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__EdgePatch, default initialized and not managed by a soap context
	virtual resqml2__EdgePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__EdgePatch); }
	         resqml2__EdgePatch() { resqml2__EdgePatch::soap_default(NULL); }
	virtual ~resqml2__EdgePatch() { }
	friend resqml2__EdgePatch *soap_instantiate_resqml2__EdgePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:813 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodePatch (226)
/* Type resqml2__NodePatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:NodePatch complex type: */
class SOAP_CMAC resqml2__NodePatch : public resqml2__Patch1d
{
public:
	resqml2__PointGeometry *Geometry;	/* required element of XSD type resqml2:PointGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodePatch (226)
	virtual int soap_type(void) const { return 226; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__NodePatch, default initialized and not managed by a soap context
	virtual resqml2__NodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__NodePatch); }
	         resqml2__NodePatch() { resqml2__NodePatch::soap_default(NULL); }
	virtual ~resqml2__NodePatch() { }
	friend resqml2__NodePatch *soap_instantiate_resqml2__NodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:819 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TrianglePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TrianglePatch (228)
/* Type resqml2__TrianglePatch is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:TrianglePatch complex type: */
class SOAP_CMAC resqml2__TrianglePatch : public resqml2__Patch1d
{
public:
	ULONG64 NodeCount;	/* required element of XSD type xsd:nonNegativeInteger */
	resqml2__AbstractIntegerArray *Triangles;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__PointGeometry *Geometry;	/* required element of XSD type resqml2:PointGeometry */
	std::vector<resqml2__EdgePatch *> SplitEdgePatch;	/* optional element of XSD type resqml2:EdgePatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TrianglePatch (228)
	virtual int soap_type(void) const { return 228; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__TrianglePatch, default initialized and not managed by a soap context
	virtual resqml2__TrianglePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__TrianglePatch); }
	         resqml2__TrianglePatch() { resqml2__TrianglePatch::soap_default(NULL); }
	virtual ~resqml2__TrianglePatch() { }
	friend resqml2__TrianglePatch *soap_instantiate_resqml2__TrianglePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:969 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrs (278)
/* Type eml__ProjectedCrs is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:ProjectedCrs complex type: */
class SOAP_CMAC eml__ProjectedCrs : public eml__AbstractCitedDataObject
{
public:
	enum eml__AxisOrder2d AxisOrder;	/* required element of XSD type eml:AxisOrder2d */
	eml__AbstractProjectedCrs *AbstractProjectedCrs;	/* required element of XSD type eml:AbstractProjectedCrs */
	enum eml__LengthUom *uom;	/* optional attribute of XSD type eml:LengthUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrs (278)
	virtual int soap_type(void) const { return 278; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ProjectedCrs, default initialized and not managed by a soap context
	virtual eml__ProjectedCrs *soap_alloc(void) const { return SOAP_NEW(eml__ProjectedCrs); }
	         eml__ProjectedCrs() { eml__ProjectedCrs::soap_default(NULL); }
	virtual ~eml__ProjectedCrs() { }
	friend eml__ProjectedCrs *soap_instantiate_eml__ProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:972 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrs (279)
/* Type eml__VerticalCrs is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:VerticalCrs complex type: */
class SOAP_CMAC eml__VerticalCrs : public eml__AbstractCitedDataObject
{
public:
	enum eml__VerticalDirection Direction;	/* required element of XSD type eml:VerticalDirection */
	eml__AbstractVerticalCrs *AbstractVerticalCrs;	/* required element of XSD type eml:AbstractVerticalCrs */
	enum eml__LengthUom uom;	/* required attribute of XSD type eml:LengthUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrs (279)
	virtual int soap_type(void) const { return 279; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VerticalCrs, default initialized and not managed by a soap context
	virtual eml__VerticalCrs *soap_alloc(void) const { return SOAP_NEW(eml__VerticalCrs); }
	         eml__VerticalCrs() { eml__VerticalCrs::soap_default(NULL); }
	virtual ~eml__VerticalCrs() { }
	friend eml__VerticalCrs *soap_instantiate_eml__VerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:993 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__obj_USCOREEpcExternalPartReference
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__obj_USCOREEpcExternalPartReference (286)
/* Type eml__obj_USCOREEpcExternalPartReference is a recursive data type (in)directly referencing itself through its (base) class members */
/* eml:obj_EpcExternalPartReference complex type: */
class SOAP_CMAC eml__obj_USCOREEpcExternalPartReference : public eml__AbstractCitedDataObject
{
public:
	std::string MimeType;	/* required element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__obj_USCOREEpcExternalPartReference (286)
	virtual int soap_type(void) const { return 286; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__obj_USCOREEpcExternalPartReference, default initialized and not managed by a soap context
	virtual eml__obj_USCOREEpcExternalPartReference *soap_alloc(void) const { return SOAP_NEW(eml__obj_USCOREEpcExternalPartReference); }
	         eml__obj_USCOREEpcExternalPartReference() { eml__obj_USCOREEpcExternalPartReference::soap_default(NULL); }
	virtual ~eml__obj_USCOREEpcExternalPartReference() { }
	friend eml__obj_USCOREEpcExternalPartReference *soap_instantiate_eml__obj_USCOREEpcExternalPartReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:999 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredMeasure (288)
/* eml:PressureSquaredMeasure simple type: */
class SOAP_CMAC eml__PressureSquaredMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PressureSquaredUom uom;	/* required attribute of XSD type eml:PressureSquaredUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredMeasure (288)
	virtual int soap_type(void) const { return 288; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PressureSquaredMeasure, default initialized and not managed by a soap context
	virtual eml__PressureSquaredMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressureSquaredMeasure); }
	         eml__PressureSquaredMeasure() { eml__PressureSquaredMeasure::soap_default(NULL); }
	virtual ~eml__PressureSquaredMeasure() { }
	friend eml__PressureSquaredMeasure *soap_instantiate_eml__PressureSquaredMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1002 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthMeasure (289)
/* eml:ForceLengthPerLengthMeasure simple type: */
class SOAP_CMAC eml__ForceLengthPerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ForceLengthPerLengthUom uom;	/* required attribute of XSD type eml:ForceLengthPerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthMeasure (289)
	virtual int soap_type(void) const { return 289; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ForceLengthPerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__ForceLengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForceLengthPerLengthMeasure); }
	         eml__ForceLengthPerLengthMeasure() { eml__ForceLengthPerLengthMeasure::soap_default(NULL); }
	virtual ~eml__ForceLengthPerLengthMeasure() { }
	friend eml__ForceLengthPerLengthMeasure *soap_instantiate_eml__ForceLengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1005 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaMeasure (290)
/* eml:AmountOfSubstancePerTimePerAreaMeasure simple type: */
class SOAP_CMAC eml__AmountOfSubstancePerTimePerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AmountOfSubstancePerTimePerAreaUom uom;	/* required attribute of XSD type eml:AmountOfSubstancePerTimePerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaMeasure (290)
	virtual int soap_type(void) const { return 290; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AmountOfSubstancePerTimePerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__AmountOfSubstancePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerTimePerAreaMeasure); }
	         eml__AmountOfSubstancePerTimePerAreaMeasure() { eml__AmountOfSubstancePerTimePerAreaMeasure::soap_default(NULL); }
	virtual ~eml__AmountOfSubstancePerTimePerAreaMeasure() { }
	friend eml__AmountOfSubstancePerTimePerAreaMeasure *soap_instantiate_eml__AmountOfSubstancePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1008 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaMeasure (291)
/* eml:VolumePerTimePerAreaMeasure simple type: */
class SOAP_CMAC eml__VolumePerTimePerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerTimePerAreaUom uom;	/* required attribute of XSD type eml:VolumePerTimePerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaMeasure (291)
	virtual int soap_type(void) const { return 291; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerTimePerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerAreaMeasure); }
	         eml__VolumePerTimePerAreaMeasure() { eml__VolumePerTimePerAreaMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerTimePerAreaMeasure() { }
	friend eml__VolumePerTimePerAreaMeasure *soap_instantiate_eml__VolumePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1011 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthMeasure (292)
/* eml:LengthPerLengthMeasure simple type: */
class SOAP_CMAC eml__LengthPerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LengthPerLengthUom uom;	/* required attribute of XSD type eml:LengthPerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthMeasure (292)
	virtual int soap_type(void) const { return 292; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LengthPerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__LengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerLengthMeasure); }
	         eml__LengthPerLengthMeasure() { eml__LengthPerLengthMeasure::soap_default(NULL); }
	virtual ~eml__LengthPerLengthMeasure() { }
	friend eml__LengthPerLengthMeasure *soap_instantiate_eml__LengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1014 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalMeasure (293)
/* eml:TemperatureIntervalMeasure simple type: */
class SOAP_CMAC eml__TemperatureIntervalMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__TemperatureIntervalUom uom;	/* required attribute of XSD type eml:TemperatureIntervalUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalMeasure (293)
	virtual int soap_type(void) const { return 293; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__TemperatureIntervalMeasure, default initialized and not managed by a soap context
	virtual eml__TemperatureIntervalMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TemperatureIntervalMeasure); }
	         eml__TemperatureIntervalMeasure() { eml__TemperatureIntervalMeasure::soap_default(NULL); }
	virtual ~eml__TemperatureIntervalMeasure() { }
	friend eml__TemperatureIntervalMeasure *soap_instantiate_eml__TemperatureIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1017 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthMeasure (294)
/* eml:VolumePerTimePerLengthMeasure simple type: */
class SOAP_CMAC eml__VolumePerTimePerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerTimePerLengthUom uom;	/* required attribute of XSD type eml:VolumePerTimePerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthMeasure (294)
	virtual int soap_type(void) const { return 294; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerTimePerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerLengthMeasure); }
	         eml__VolumePerTimePerLengthMeasure() { eml__VolumePerTimePerLengthMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerTimePerLengthMeasure() { }
	friend eml__VolumePerTimePerLengthMeasure *soap_instantiate_eml__VolumePerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1020 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeMeasure (295)
/* eml:VolumePerTimePerTimeMeasure simple type: */
class SOAP_CMAC eml__VolumePerTimePerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerTimePerTimeUom uom;	/* required attribute of XSD type eml:VolumePerTimePerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeMeasure (295)
	virtual int soap_type(void) const { return 295; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerTimePerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerTimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerTimeMeasure); }
	         eml__VolumePerTimePerTimeMeasure() { eml__VolumePerTimePerTimeMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerTimePerTimeMeasure() { }
	friend eml__VolumePerTimePerTimeMeasure *soap_instantiate_eml__VolumePerTimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1023 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthMeasure (296)
/* eml:PermeabilityLengthMeasure simple type: */
class SOAP_CMAC eml__PermeabilityLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PermeabilityLengthUom uom;	/* required attribute of XSD type eml:PermeabilityLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthMeasure (296)
	virtual int soap_type(void) const { return 296; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PermeabilityLengthMeasure, default initialized and not managed by a soap context
	virtual eml__PermeabilityLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PermeabilityLengthMeasure); }
	         eml__PermeabilityLengthMeasure() { eml__PermeabilityLengthMeasure::soap_default(NULL); }
	virtual ~eml__PermeabilityLengthMeasure() { }
	friend eml__PermeabilityLengthMeasure *soap_instantiate_eml__PermeabilityLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1026 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceMeasure (297)
/* eml:ThermalInsulanceMeasure simple type: */
class SOAP_CMAC eml__ThermalInsulanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ThermalInsulanceUom uom;	/* required attribute of XSD type eml:ThermalInsulanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceMeasure (297)
	virtual int soap_type(void) const { return 297; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ThermalInsulanceMeasure, default initialized and not managed by a soap context
	virtual eml__ThermalInsulanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalInsulanceMeasure); }
	         eml__ThermalInsulanceMeasure() { eml__ThermalInsulanceMeasure::soap_default(NULL); }
	virtual ~eml__ThermalInsulanceMeasure() { }
	friend eml__ThermalInsulanceMeasure *soap_instantiate_eml__ThermalInsulanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1029 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaMeasure (298)
/* eml:ForceAreaMeasure simple type: */
class SOAP_CMAC eml__ForceAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ForceAreaUom uom;	/* required attribute of XSD type eml:ForceAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaMeasure (298)
	virtual int soap_type(void) const { return 298; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ForceAreaMeasure, default initialized and not managed by a soap context
	virtual eml__ForceAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForceAreaMeasure); }
	         eml__ForceAreaMeasure() { eml__ForceAreaMeasure::soap_default(NULL); }
	virtual ~eml__ForceAreaMeasure() { }
	friend eml__ForceAreaMeasure *soap_instantiate_eml__ForceAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1032 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyMeasure (299)
/* eml:EnergyMeasure simple type: */
class SOAP_CMAC eml__EnergyMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__EnergyUom uom;	/* required attribute of XSD type eml:EnergyUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyMeasure (299)
	virtual int soap_type(void) const { return 299; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__EnergyMeasure, default initialized and not managed by a soap context
	virtual eml__EnergyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyMeasure); }
	         eml__EnergyMeasure() { eml__EnergyMeasure::soap_default(NULL); }
	virtual ~eml__EnergyMeasure() { }
	friend eml__EnergyMeasure *soap_instantiate_eml__EnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1035 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceMeasure (300)
/* eml:IlluminanceMeasure simple type: */
class SOAP_CMAC eml__IlluminanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__IlluminanceUom uom;	/* required attribute of XSD type eml:IlluminanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceMeasure (300)
	virtual int soap_type(void) const { return 300; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__IlluminanceMeasure, default initialized and not managed by a soap context
	virtual eml__IlluminanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__IlluminanceMeasure); }
	         eml__IlluminanceMeasure() { eml__IlluminanceMeasure::soap_default(NULL); }
	virtual ~eml__IlluminanceMeasure() { }
	friend eml__IlluminanceMeasure *soap_instantiate_eml__IlluminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1038 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceMeasure (301)
/* eml:ForceMeasure simple type: */
class SOAP_CMAC eml__ForceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ForceUom uom;	/* required attribute of XSD type eml:ForceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceMeasure (301)
	virtual int soap_type(void) const { return 301; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ForceMeasure, default initialized and not managed by a soap context
	virtual eml__ForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForceMeasure); }
	         eml__ForceMeasure() { eml__ForceMeasure::soap_default(NULL); }
	virtual ~eml__ForceMeasure() { }
	friend eml__ForceMeasure *soap_instantiate_eml__ForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1041 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityMeasure (302)
/* eml:RadiantIntensityMeasure simple type: */
class SOAP_CMAC eml__RadiantIntensityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__RadiantIntensityUom uom;	/* required attribute of XSD type eml:RadiantIntensityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityMeasure (302)
	virtual int soap_type(void) const { return 302; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__RadiantIntensityMeasure, default initialized and not managed by a soap context
	virtual eml__RadiantIntensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__RadiantIntensityMeasure); }
	         eml__RadiantIntensityMeasure() { eml__RadiantIntensityMeasure::soap_default(NULL); }
	virtual ~eml__RadiantIntensityMeasure() { }
	friend eml__RadiantIntensityMeasure *soap_instantiate_eml__RadiantIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1044 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerMeasure (303)
/* eml:PowerPerPowerMeasure simple type: */
class SOAP_CMAC eml__PowerPerPowerMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PowerPerPowerUom uom;	/* required attribute of XSD type eml:PowerPerPowerUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerMeasure (303)
	virtual int soap_type(void) const { return 303; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PowerPerPowerMeasure, default initialized and not managed by a soap context
	virtual eml__PowerPerPowerMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PowerPerPowerMeasure); }
	         eml__PowerPerPowerMeasure() { eml__PowerPerPowerMeasure::soap_default(NULL); }
	virtual ~eml__PowerPerPowerMeasure() { }
	friend eml__PowerPerPowerMeasure *soap_instantiate_eml__PowerPerPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1047 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessMeasure (304)
/* eml:DimensionlessMeasure simple type: */
class SOAP_CMAC eml__DimensionlessMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__DimensionlessUom uom;	/* required attribute of XSD type eml:DimensionlessUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessMeasure (304)
	virtual int soap_type(void) const { return 304; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__DimensionlessMeasure, default initialized and not managed by a soap context
	virtual eml__DimensionlessMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DimensionlessMeasure); }
	         eml__DimensionlessMeasure() { eml__DimensionlessMeasure::soap_default(NULL); }
	virtual ~eml__DimensionlessMeasure() { }
	friend eml__DimensionlessMeasure *soap_instantiate_eml__DimensionlessMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1050 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientMeasure (305)
/* eml:HeatTransferCoefficientMeasure simple type: */
class SOAP_CMAC eml__HeatTransferCoefficientMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__HeatTransferCoefficientUom uom;	/* required attribute of XSD type eml:HeatTransferCoefficientUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientMeasure (305)
	virtual int soap_type(void) const { return 305; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__HeatTransferCoefficientMeasure, default initialized and not managed by a soap context
	virtual eml__HeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW(eml__HeatTransferCoefficientMeasure); }
	         eml__HeatTransferCoefficientMeasure() { eml__HeatTransferCoefficientMeasure::soap_default(NULL); }
	virtual ~eml__HeatTransferCoefficientMeasure() { }
	friend eml__HeatTransferCoefficientMeasure *soap_instantiate_eml__HeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1053 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronMeasure (306)
/* eml:APINeutronMeasure simple type: */
class SOAP_CMAC eml__APINeutronMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__APINeutronUom uom;	/* required attribute of XSD type eml:APINeutronUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronMeasure (306)
	virtual int soap_type(void) const { return 306; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__APINeutronMeasure, default initialized and not managed by a soap context
	virtual eml__APINeutronMeasure *soap_alloc(void) const { return SOAP_NEW(eml__APINeutronMeasure); }
	         eml__APINeutronMeasure() { eml__APINeutronMeasure::soap_default(NULL); }
	virtual ~eml__APINeutronMeasure() { }
	friend eml__APINeutronMeasure *soap_instantiate_eml__APINeutronMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1056 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialMeasure (307)
/* eml:MagneticVectorPotentialMeasure simple type: */
class SOAP_CMAC eml__MagneticVectorPotentialMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MagneticVectorPotentialUom uom;	/* required attribute of XSD type eml:MagneticVectorPotentialUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialMeasure (307)
	virtual int soap_type(void) const { return 307; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MagneticVectorPotentialMeasure, default initialized and not managed by a soap context
	virtual eml__MagneticVectorPotentialMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticVectorPotentialMeasure); }
	         eml__MagneticVectorPotentialMeasure() { eml__MagneticVectorPotentialMeasure::soap_default(NULL); }
	virtual ~eml__MagneticVectorPotentialMeasure() { }
	friend eml__MagneticVectorPotentialMeasure *soap_instantiate_eml__MagneticVectorPotentialMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1059 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationMeasure (308)
/* eml:LinearAccelerationMeasure simple type: */
class SOAP_CMAC eml__LinearAccelerationMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LinearAccelerationUom uom;	/* required attribute of XSD type eml:LinearAccelerationUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationMeasure (308)
	virtual int soap_type(void) const { return 308; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LinearAccelerationMeasure, default initialized and not managed by a soap context
	virtual eml__LinearAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LinearAccelerationMeasure); }
	         eml__LinearAccelerationMeasure() { eml__LinearAccelerationMeasure::soap_default(NULL); }
	virtual ~eml__LinearAccelerationMeasure() { }
	friend eml__LinearAccelerationMeasure *soap_instantiate_eml__LinearAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1062 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeMeasure (309)
/* eml:VolumePerTimeMeasure simple type: */
class SOAP_CMAC eml__VolumePerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerTimeUom uom;	/* required attribute of XSD type eml:VolumePerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeMeasure (309)
	virtual int soap_type(void) const { return 309; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimeMeasure); }
	         eml__VolumePerTimeMeasure() { eml__VolumePerTimeMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerTimeMeasure() { }
	friend eml__VolumePerTimeMeasure *soap_instantiate_eml__VolumePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1065 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxMeasure (310)
/* eml:MagneticFluxMeasure simple type: */
class SOAP_CMAC eml__MagneticFluxMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MagneticFluxUom uom;	/* required attribute of XSD type eml:MagneticFluxUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxMeasure (310)
	virtual int soap_type(void) const { return 310; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MagneticFluxMeasure, default initialized and not managed by a soap context
	virtual eml__MagneticFluxMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticFluxMeasure); }
	         eml__MagneticFluxMeasure() { eml__MagneticFluxMeasure::soap_default(NULL); }
	virtual ~eml__MagneticFluxMeasure() { }
	friend eml__MagneticFluxMeasure *soap_instantiate_eml__MagneticFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1068 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionMeasure (311)
/* eml:VolumetricThermalExpansionMeasure simple type: */
class SOAP_CMAC eml__VolumetricThermalExpansionMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumetricThermalExpansionUom uom;	/* required attribute of XSD type eml:VolumetricThermalExpansionUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionMeasure (311)
	virtual int soap_type(void) const { return 311; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumetricThermalExpansionMeasure, default initialized and not managed by a soap context
	virtual eml__VolumetricThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumetricThermalExpansionMeasure); }
	         eml__VolumetricThermalExpansionMeasure() { eml__VolumetricThermalExpansionMeasure::soap_default(NULL); }
	virtual ~eml__VolumetricThermalExpansionMeasure() { }
	friend eml__VolumetricThermalExpansionMeasure *soap_instantiate_eml__VolumetricThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1071 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateMeasure (312)
/* eml:HeatFlowRateMeasure simple type: */
class SOAP_CMAC eml__HeatFlowRateMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__HeatFlowRateUom uom;	/* required attribute of XSD type eml:HeatFlowRateUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateMeasure (312)
	virtual int soap_type(void) const { return 312; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__HeatFlowRateMeasure, default initialized and not managed by a soap context
	virtual eml__HeatFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW(eml__HeatFlowRateMeasure); }
	         eml__HeatFlowRateMeasure() { eml__HeatFlowRateMeasure::soap_default(NULL); }
	virtual ~eml__HeatFlowRateMeasure() { }
	friend eml__HeatFlowRateMeasure *soap_instantiate_eml__HeatFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1074 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeMeasure (313)
/* eml:MassPerTimeMeasure simple type: */
class SOAP_CMAC eml__MassPerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassPerTimeUom uom;	/* required attribute of XSD type eml:MassPerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeMeasure (313)
	virtual int soap_type(void) const { return 313; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassPerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__MassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerTimeMeasure); }
	         eml__MassPerTimeMeasure() { eml__MassPerTimeMeasure::soap_default(NULL); }
	virtual ~eml__MassPerTimeMeasure() { }
	friend eml__MassPerTimeMeasure *soap_instantiate_eml__MassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1077 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassMeasure (314)
/* eml:VolumePerMassMeasure simple type: */
class SOAP_CMAC eml__VolumePerMassMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerMassUom uom;	/* required attribute of XSD type eml:VolumePerMassUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassMeasure (314)
	virtual int soap_type(void) const { return 314; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerMassMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerMassMeasure); }
	         eml__VolumePerMassMeasure() { eml__VolumePerMassMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerMassMeasure() { }
	friend eml__VolumePerMassMeasure *soap_instantiate_eml__VolumePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1080 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeMeasure (315)
/* eml:MolarVolumeMeasure simple type: */
class SOAP_CMAC eml__MolarVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MolarVolumeUom uom;	/* required attribute of XSD type eml:MolarVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeMeasure (315)
	virtual int soap_type(void) const { return 315; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MolarVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__MolarVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MolarVolumeMeasure); }
	         eml__MolarVolumeMeasure() { eml__MolarVolumeMeasure::soap_default(NULL); }
	virtual ~eml__MolarVolumeMeasure() { }
	friend eml__MolarVolumeMeasure *soap_instantiate_eml__MolarVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1083 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceMeasure (316)
/* eml:ElectricConductanceMeasure simple type: */
class SOAP_CMAC eml__ElectricConductanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricConductanceUom uom;	/* required attribute of XSD type eml:ElectricConductanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceMeasure (316)
	virtual int soap_type(void) const { return 316; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricConductanceMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricConductanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricConductanceMeasure); }
	         eml__ElectricConductanceMeasure() { eml__ElectricConductanceMeasure::soap_default(NULL); }
	virtual ~eml__ElectricConductanceMeasure() { }
	friend eml__ElectricConductanceMeasure *soap_instantiate_eml__ElectricConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1086 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureMeasure (317)
/* eml:ReciprocalPressureMeasure simple type: */
class SOAP_CMAC eml__ReciprocalPressureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReciprocalPressureUom uom;	/* required attribute of XSD type eml:ReciprocalPressureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureMeasure (317)
	virtual int soap_type(void) const { return 317; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReciprocalPressureMeasure, default initialized and not managed by a soap context
	virtual eml__ReciprocalPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalPressureMeasure); }
	         eml__ReciprocalPressureMeasure() { eml__ReciprocalPressureMeasure::soap_default(NULL); }
	virtual ~eml__ReciprocalPressureMeasure() { }
	friend eml__ReciprocalPressureMeasure *soap_instantiate_eml__ReciprocalPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1089 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceMeasure (318)
/* eml:AreaPerAmountOfSubstanceMeasure simple type: */
class SOAP_CMAC eml__AreaPerAmountOfSubstanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AreaPerAmountOfSubstanceUom uom;	/* required attribute of XSD type eml:AreaPerAmountOfSubstanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceMeasure (318)
	virtual int soap_type(void) const { return 318; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AreaPerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
	virtual eml__AreaPerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerAmountOfSubstanceMeasure); }
	         eml__AreaPerAmountOfSubstanceMeasure() { eml__AreaPerAmountOfSubstanceMeasure::soap_default(NULL); }
	virtual ~eml__AreaPerAmountOfSubstanceMeasure() { }
	friend eml__AreaPerAmountOfSubstanceMeasure *soap_instantiate_eml__AreaPerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1092 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthMeasure (319)
/* eml:LengthMeasure simple type: */
class SOAP_CMAC eml__LengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LengthUom uom;	/* required attribute of XSD type eml:LengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthMeasure (319)
	virtual int soap_type(void) const { return 319; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LengthMeasure, default initialized and not managed by a soap context
	virtual eml__LengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthMeasure); }
	         eml__LengthMeasure() { eml__LengthMeasure::soap_default(NULL); }
	virtual ~eml__LengthMeasure() { }
	friend eml__LengthMeasure *soap_instantiate_eml__LengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1095 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeMeasure (320)
/* eml:MassPerVolumeMeasure simple type: */
class SOAP_CMAC eml__MassPerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassPerVolumeUom uom;	/* required attribute of XSD type eml:MassPerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeMeasure (320)
	virtual int soap_type(void) const { return 320; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassPerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__MassPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerVolumeMeasure); }
	         eml__MassPerVolumeMeasure() { eml__MassPerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__MassPerVolumeMeasure() { }
	friend eml__MassPerVolumeMeasure *soap_instantiate_eml__MassPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1098 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthMeasure (321)
/* eml:TemperatureIntervalPerLengthMeasure simple type: */
class SOAP_CMAC eml__TemperatureIntervalPerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__TemperatureIntervalPerLengthUom uom;	/* required attribute of XSD type eml:TemperatureIntervalPerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthMeasure (321)
	virtual int soap_type(void) const { return 321; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__TemperatureIntervalPerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__TemperatureIntervalPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TemperatureIntervalPerLengthMeasure); }
	         eml__TemperatureIntervalPerLengthMeasure() { eml__TemperatureIntervalPerLengthMeasure::soap_default(NULL); }
	virtual ~eml__TemperatureIntervalPerLengthMeasure() { }
	friend eml__TemperatureIntervalPerLengthMeasure *soap_instantiate_eml__TemperatureIntervalPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1101 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaMeasure (322)
/* eml:AmountOfSubstancePerAreaMeasure simple type: */
class SOAP_CMAC eml__AmountOfSubstancePerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AmountOfSubstancePerAreaUom uom;	/* required attribute of XSD type eml:AmountOfSubstancePerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaMeasure (322)
	virtual int soap_type(void) const { return 322; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AmountOfSubstancePerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__AmountOfSubstancePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerAreaMeasure); }
	         eml__AmountOfSubstancePerAreaMeasure() { eml__AmountOfSubstancePerAreaMeasure::soap_default(NULL); }
	virtual ~eml__AmountOfSubstancePerAreaMeasure() { }
	friend eml__AmountOfSubstancePerAreaMeasure *soap_instantiate_eml__AmountOfSubstancePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1104 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceMeasure (323)
/* eml:AmountOfSubstanceMeasure simple type: */
class SOAP_CMAC eml__AmountOfSubstanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AmountOfSubstanceUom uom;	/* required attribute of XSD type eml:AmountOfSubstanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceMeasure (323)
	virtual int soap_type(void) const { return 323; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AmountOfSubstanceMeasure, default initialized and not managed by a soap context
	virtual eml__AmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstanceMeasure); }
	         eml__AmountOfSubstanceMeasure() { eml__AmountOfSubstanceMeasure::soap_default(NULL); }
	virtual ~eml__AmountOfSubstanceMeasure() { }
	friend eml__AmountOfSubstanceMeasure *soap_instantiate_eml__AmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1107 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthMeasure (324)
/* eml:TimePerLengthMeasure simple type: */
class SOAP_CMAC eml__TimePerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__TimePerLengthUom uom;	/* required attribute of XSD type eml:TimePerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthMeasure (324)
	virtual int soap_type(void) const { return 324; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__TimePerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__TimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimePerLengthMeasure); }
	         eml__TimePerLengthMeasure() { eml__TimePerLengthMeasure::soap_default(NULL); }
	virtual ~eml__TimePerLengthMeasure() { }
	friend eml__TimePerLengthMeasure *soap_instantiate_eml__TimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1110 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeMeasure (325)
/* eml:ReciprocalMassTimeMeasure simple type: */
class SOAP_CMAC eml__ReciprocalMassTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReciprocalMassTimeUom uom;	/* required attribute of XSD type eml:ReciprocalMassTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeMeasure (325)
	virtual int soap_type(void) const { return 325; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReciprocalMassTimeMeasure, default initialized and not managed by a soap context
	virtual eml__ReciprocalMassTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalMassTimeMeasure); }
	         eml__ReciprocalMassTimeMeasure() { eml__ReciprocalMassTimeMeasure::soap_default(NULL); }
	virtual ~eml__ReciprocalMassTimeMeasure() { }
	friend eml__ReciprocalMassTimeMeasure *soap_instantiate_eml__ReciprocalMassTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1113 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeMeasure (326)
/* eml:ReciprocalVolumeMeasure simple type: */
class SOAP_CMAC eml__ReciprocalVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReciprocalVolumeUom uom;	/* required attribute of XSD type eml:ReciprocalVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeMeasure (326)
	virtual int soap_type(void) const { return 326; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReciprocalVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__ReciprocalVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalVolumeMeasure); }
	         eml__ReciprocalVolumeMeasure() { eml__ReciprocalVolumeMeasure::soap_default(NULL); }
	virtual ~eml__ReciprocalVolumeMeasure() { }
	friend eml__ReciprocalVolumeMeasure *soap_instantiate_eml__ReciprocalVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1116 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceMeasure (327)
/* eml:ForcePerForceMeasure simple type: */
class SOAP_CMAC eml__ForcePerForceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ForcePerForceUom uom;	/* required attribute of XSD type eml:ForcePerForceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceMeasure (327)
	virtual int soap_type(void) const { return 327; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ForcePerForceMeasure, default initialized and not managed by a soap context
	virtual eml__ForcePerForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForcePerForceMeasure); }
	         eml__ForcePerForceMeasure() { eml__ForcePerForceMeasure::soap_default(NULL); }
	virtual ~eml__ForcePerForceMeasure() { }
	friend eml__ForcePerForceMeasure *soap_instantiate_eml__ForcePerForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1119 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionMeasure (328)
/* eml:LinearThermalExpansionMeasure simple type: */
class SOAP_CMAC eml__LinearThermalExpansionMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LinearThermalExpansionUom uom;	/* required attribute of XSD type eml:LinearThermalExpansionUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionMeasure (328)
	virtual int soap_type(void) const { return 328; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LinearThermalExpansionMeasure, default initialized and not managed by a soap context
	virtual eml__LinearThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LinearThermalExpansionMeasure); }
	         eml__LinearThermalExpansionMeasure() { eml__LinearThermalExpansionMeasure::soap_default(NULL); }
	virtual ~eml__LinearThermalExpansionMeasure() { }
	friend eml__LinearThermalExpansionMeasure *soap_instantiate_eml__LinearThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1122 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthMeasure (329)
/* eml:EnergyPerLengthMeasure simple type: */
class SOAP_CMAC eml__EnergyPerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__EnergyPerLengthUom uom;	/* required attribute of XSD type eml:EnergyPerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthMeasure (329)
	virtual int soap_type(void) const { return 329; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__EnergyPerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__EnergyPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerLengthMeasure); }
	         eml__EnergyPerLengthMeasure() { eml__EnergyPerLengthMeasure::soap_default(NULL); }
	virtual ~eml__EnergyPerLengthMeasure() { }
	friend eml__EnergyPerLengthMeasure *soap_instantiate_eml__EnergyPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1125 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeMeasure (330)
/* eml:TemperatureIntervalPerTimeMeasure simple type: */
class SOAP_CMAC eml__TemperatureIntervalPerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__TemperatureIntervalPerTimeUom uom;	/* required attribute of XSD type eml:TemperatureIntervalPerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeMeasure (330)
	virtual int soap_type(void) const { return 330; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__TemperatureIntervalPerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__TemperatureIntervalPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TemperatureIntervalPerTimeMeasure); }
	         eml__TemperatureIntervalPerTimeMeasure() { eml__TemperatureIntervalPerTimeMeasure::soap_default(NULL); }
	virtual ~eml__TemperatureIntervalPerTimeMeasure() { }
	friend eml__TemperatureIntervalPerTimeMeasure *soap_instantiate_eml__TemperatureIntervalPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1128 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceMeasure (331)
/* eml:ThermalConductanceMeasure simple type: */
class SOAP_CMAC eml__ThermalConductanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ThermalConductanceUom uom;	/* required attribute of XSD type eml:ThermalConductanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceMeasure (331)
	virtual int soap_type(void) const { return 331; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ThermalConductanceMeasure, default initialized and not managed by a soap context
	virtual eml__ThermalConductanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalConductanceMeasure); }
	         eml__ThermalConductanceMeasure() { eml__ThermalConductanceMeasure::soap_default(NULL); }
	virtual ~eml__ThermalConductanceMeasure() { }
	friend eml__ThermalConductanceMeasure *soap_instantiate_eml__ThermalConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1131 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleMeasure (332)
/* eml:SolidAngleMeasure simple type: */
class SOAP_CMAC eml__SolidAngleMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__SolidAngleUom uom;	/* required attribute of XSD type eml:SolidAngleUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleMeasure (332)
	virtual int soap_type(void) const { return 332; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__SolidAngleMeasure, default initialized and not managed by a soap context
	virtual eml__SolidAngleMeasure *soap_alloc(void) const { return SOAP_NEW(eml__SolidAngleMeasure); }
	         eml__SolidAngleMeasure() { eml__SolidAngleMeasure::soap_default(NULL); }
	virtual ~eml__SolidAngleMeasure() { }
	friend eml__SolidAngleMeasure *soap_instantiate_eml__SolidAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1134 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureMeasure (333)
/* eml:EnergyLengthPerTimeAreaTemperatureMeasure simple type: */
class SOAP_CMAC eml__EnergyLengthPerTimeAreaTemperatureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__EnergyLengthPerTimeAreaTemperatureUom uom;	/* required attribute of XSD type eml:EnergyLengthPerTimeAreaTemperatureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureMeasure (333)
	virtual int soap_type(void) const { return 333; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__EnergyLengthPerTimeAreaTemperatureMeasure, default initialized and not managed by a soap context
	virtual eml__EnergyLengthPerTimeAreaTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyLengthPerTimeAreaTemperatureMeasure); }
	         eml__EnergyLengthPerTimeAreaTemperatureMeasure() { eml__EnergyLengthPerTimeAreaTemperatureMeasure::soap_default(NULL); }
	virtual ~eml__EnergyLengthPerTimeAreaTemperatureMeasure() { }
	friend eml__EnergyLengthPerTimeAreaTemperatureMeasure *soap_instantiate_eml__EnergyLengthPerTimeAreaTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1137 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerMeasure (334)
/* eml:PowerMeasure simple type: */
class SOAP_CMAC eml__PowerMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PowerUom uom;	/* required attribute of XSD type eml:PowerUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerMeasure (334)
	virtual int soap_type(void) const { return 334; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PowerMeasure, default initialized and not managed by a soap context
	virtual eml__PowerMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PowerMeasure); }
	         eml__PowerMeasure() { eml__PowerMeasure::soap_default(NULL); }
	virtual ~eml__PowerMeasure() { }
	friend eml__PowerMeasure *soap_instantiate_eml__PowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1140 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationMeasure (335)
/* eml:VolumePerRotationMeasure simple type: */
class SOAP_CMAC eml__VolumePerRotationMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerRotationUom uom;	/* required attribute of XSD type eml:VolumePerRotationUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationMeasure (335)
	virtual int soap_type(void) const { return 335; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerRotationMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerRotationMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerRotationMeasure); }
	         eml__VolumePerRotationMeasure() { eml__VolumePerRotationMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerRotationMeasure() { }
	friend eml__VolumePerRotationMeasure *soap_instantiate_eml__VolumePerRotationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1143 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaMeasure (336)
/* eml:ElectricChargePerAreaMeasure simple type: */
class SOAP_CMAC eml__ElectricChargePerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricChargePerAreaUom uom;	/* required attribute of XSD type eml:ElectricChargePerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaMeasure (336)
	virtual int soap_type(void) const { return 336; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricChargePerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricChargePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricChargePerAreaMeasure); }
	         eml__ElectricChargePerAreaMeasure() { eml__ElectricChargePerAreaMeasure::soap_default(NULL); }
	virtual ~eml__ElectricChargePerAreaMeasure() { }
	friend eml__ElectricChargePerAreaMeasure *soap_instantiate_eml__ElectricChargePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1146 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureMeasure (337)
/* eml:LightExposureMeasure simple type: */
class SOAP_CMAC eml__LightExposureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LightExposureUom uom;	/* required attribute of XSD type eml:LightExposureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureMeasure (337)
	virtual int soap_type(void) const { return 337; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LightExposureMeasure, default initialized and not managed by a soap context
	virtual eml__LightExposureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LightExposureMeasure); }
	         eml__LightExposureMeasure() { eml__LightExposureMeasure::soap_default(NULL); }
	virtual ~eml__LightExposureMeasure() { }
	friend eml__LightExposureMeasure *soap_instantiate_eml__LightExposureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1149 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentMeasure (338)
/* eml:ElectricCurrentMeasure simple type: */
class SOAP_CMAC eml__ElectricCurrentMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricCurrentUom uom;	/* required attribute of XSD type eml:ElectricCurrentUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentMeasure (338)
	virtual int soap_type(void) const { return 338; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricCurrentMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricCurrentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricCurrentMeasure); }
	         eml__ElectricCurrentMeasure() { eml__ElectricCurrentMeasure::soap_default(NULL); }
	virtual ~eml__ElectricCurrentMeasure() { }
	friend eml__ElectricCurrentMeasure *soap_instantiate_eml__ElectricCurrentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1152 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxMeasure (339)
/* eml:LuminousFluxMeasure simple type: */
class SOAP_CMAC eml__LuminousFluxMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LuminousFluxUom uom;	/* required attribute of XSD type eml:LuminousFluxUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxMeasure (339)
	virtual int soap_type(void) const { return 339; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LuminousFluxMeasure, default initialized and not managed by a soap context
	virtual eml__LuminousFluxMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LuminousFluxMeasure); }
	         eml__LuminousFluxMeasure() { eml__LuminousFluxMeasure::soap_default(NULL); }
	virtual ~eml__LuminousFluxMeasure() { }
	friend eml__LuminousFluxMeasure *soap_instantiate_eml__LuminousFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1155 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityMeasure (340)
/* eml:HeatCapacityMeasure simple type: */
class SOAP_CMAC eml__HeatCapacityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__HeatCapacityUom uom;	/* required attribute of XSD type eml:HeatCapacityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityMeasure (340)
	virtual int soap_type(void) const { return 340; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__HeatCapacityMeasure, default initialized and not managed by a soap context
	virtual eml__HeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__HeatCapacityMeasure); }
	         eml__HeatCapacityMeasure() { eml__HeatCapacityMeasure::soap_default(NULL); }
	virtual ~eml__HeatCapacityMeasure() { }
	friend eml__HeatCapacityMeasure *soap_instantiate_eml__HeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1158 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthMeasure (341)
/* eml:ElectricResistancePerLengthMeasure simple type: */
class SOAP_CMAC eml__ElectricResistancePerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricResistancePerLengthUom uom;	/* required attribute of XSD type eml:ElectricResistancePerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthMeasure (341)
	virtual int soap_type(void) const { return 341; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricResistancePerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricResistancePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricResistancePerLengthMeasure); }
	         eml__ElectricResistancePerLengthMeasure() { eml__ElectricResistancePerLengthMeasure::soap_default(NULL); }
	virtual ~eml__ElectricResistancePerLengthMeasure() { }
	friend eml__ElectricResistancePerLengthMeasure *soap_instantiate_eml__ElectricResistancePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1161 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseMeasure (342)
/* eml:AbsorbedDoseMeasure simple type: */
class SOAP_CMAC eml__AbsorbedDoseMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AbsorbedDoseUom uom;	/* required attribute of XSD type eml:AbsorbedDoseUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseMeasure (342)
	virtual int soap_type(void) const { return 342; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AbsorbedDoseMeasure, default initialized and not managed by a soap context
	virtual eml__AbsorbedDoseMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AbsorbedDoseMeasure); }
	         eml__AbsorbedDoseMeasure() { eml__AbsorbedDoseMeasure::soap_default(NULL); }
	virtual ~eml__AbsorbedDoseMeasure() { }
	friend eml__AbsorbedDoseMeasure *soap_instantiate_eml__AbsorbedDoseMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1164 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureMeasure (343)
/* eml:TemperatureIntervalPerPressureMeasure simple type: */
class SOAP_CMAC eml__TemperatureIntervalPerPressureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__TemperatureIntervalPerPressureUom uom;	/* required attribute of XSD type eml:TemperatureIntervalPerPressureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureMeasure (343)
	virtual int soap_type(void) const { return 343; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__TemperatureIntervalPerPressureMeasure, default initialized and not managed by a soap context
	virtual eml__TemperatureIntervalPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TemperatureIntervalPerPressureMeasure); }
	         eml__TemperatureIntervalPerPressureMeasure() { eml__TemperatureIntervalPerPressureMeasure::soap_default(NULL); }
	virtual ~eml__TemperatureIntervalPerPressureMeasure() { }
	friend eml__TemperatureIntervalPerPressureMeasure *soap_instantiate_eml__TemperatureIntervalPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1167 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalMeasure (344)
/* eml:AttenuationPerFrequencyIntervalMeasure simple type: */
class SOAP_CMAC eml__AttenuationPerFrequencyIntervalMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AttenuationPerFrequencyIntervalUom uom;	/* required attribute of XSD type eml:AttenuationPerFrequencyIntervalUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalMeasure (344)
	virtual int soap_type(void) const { return 344; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AttenuationPerFrequencyIntervalMeasure, default initialized and not managed by a soap context
	virtual eml__AttenuationPerFrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AttenuationPerFrequencyIntervalMeasure); }
	         eml__AttenuationPerFrequencyIntervalMeasure() { eml__AttenuationPerFrequencyIntervalMeasure::soap_default(NULL); }
	virtual ~eml__AttenuationPerFrequencyIntervalMeasure() { }
	friend eml__AttenuationPerFrequencyIntervalMeasure *soap_instantiate_eml__AttenuationPerFrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1170 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceMeasure (345)
/* eml:ThermalResistanceMeasure simple type: */
class SOAP_CMAC eml__ThermalResistanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ThermalResistanceUom uom;	/* required attribute of XSD type eml:ThermalResistanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceMeasure (345)
	virtual int soap_type(void) const { return 345; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ThermalResistanceMeasure, default initialized and not managed by a soap context
	virtual eml__ThermalResistanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalResistanceMeasure); }
	         eml__ThermalResistanceMeasure() { eml__ThermalResistanceMeasure::soap_default(NULL); }
	virtual ~eml__ThermalResistanceMeasure() { }
	friend eml__ThermalResistanceMeasure *soap_instantiate_eml__ThermalResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1173 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthMeasure (346)
/* eml:AnglePerLengthMeasure simple type: */
class SOAP_CMAC eml__AnglePerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AnglePerLengthUom uom;	/* required attribute of XSD type eml:AnglePerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthMeasure (346)
	virtual int soap_type(void) const { return 346; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AnglePerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__AnglePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AnglePerLengthMeasure); }
	         eml__AnglePerLengthMeasure() { eml__AnglePerLengthMeasure::soap_default(NULL); }
	virtual ~eml__AnglePerLengthMeasure() { }
	friend eml__AnglePerLengthMeasure *soap_instantiate_eml__AnglePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1176 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeMeasure (347)
/* eml:LengthPerTimeMeasure simple type: */
class SOAP_CMAC eml__LengthPerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LengthPerTimeUom uom;	/* required attribute of XSD type eml:LengthPerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeMeasure (347)
	virtual int soap_type(void) const { return 347; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LengthPerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__LengthPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerTimeMeasure); }
	         eml__LengthPerTimeMeasure() { eml__LengthPerTimeMeasure::soap_default(NULL); }
	virtual ~eml__LengthPerTimeMeasure() { }
	friend eml__LengthPerTimeMeasure *soap_instantiate_eml__LengthPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1179 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthMeasure (348)
/* eml:MassPerLengthMeasure simple type: */
class SOAP_CMAC eml__MassPerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassPerLengthUom uom;	/* required attribute of XSD type eml:MassPerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthMeasure (348)
	virtual int soap_type(void) const { return 348; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassPerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__MassPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerLengthMeasure); }
	         eml__MassPerLengthMeasure() { eml__MassPerLengthMeasure::soap_default(NULL); }
	virtual ~eml__MassPerLengthMeasure() { }
	friend eml__MassPerLengthMeasure *soap_instantiate_eml__MassPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1182 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaMeasure (349)
/* eml:EnergyPerAreaMeasure simple type: */
class SOAP_CMAC eml__EnergyPerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__EnergyPerAreaUom uom;	/* required attribute of XSD type eml:EnergyPerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaMeasure (349)
	virtual int soap_type(void) const { return 349; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__EnergyPerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__EnergyPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerAreaMeasure); }
	         eml__EnergyPerAreaMeasure() { eml__EnergyPerAreaMeasure::soap_default(NULL); }
	virtual ~eml__EnergyPerAreaMeasure() { }
	friend eml__EnergyPerAreaMeasure *soap_instantiate_eml__EnergyPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1185 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaMeasure (350)
/* eml:AreaPerAreaMeasure simple type: */
class SOAP_CMAC eml__AreaPerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AreaPerAreaUom uom;	/* required attribute of XSD type eml:AreaPerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaMeasure (350)
	virtual int soap_type(void) const { return 350; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AreaPerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__AreaPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerAreaMeasure); }
	         eml__AreaPerAreaMeasure() { eml__AreaPerAreaMeasure::soap_default(NULL); }
	virtual ~eml__AreaPerAreaMeasure() { }
	friend eml__AreaPerAreaMeasure *soap_instantiate_eml__AreaPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1188 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceMeasure (351)
/* eml:ReluctanceMeasure simple type: */
class SOAP_CMAC eml__ReluctanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReluctanceUom uom;	/* required attribute of XSD type eml:ReluctanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceMeasure (351)
	virtual int soap_type(void) const { return 351; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReluctanceMeasure, default initialized and not managed by a soap context
	virtual eml__ReluctanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReluctanceMeasure); }
	         eml__ReluctanceMeasure() { eml__ReluctanceMeasure::soap_default(NULL); }
	virtual ~eml__ReluctanceMeasure() { }
	friend eml__ReluctanceMeasure *soap_instantiate_eml__ReluctanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1191 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureMeasure (352)
/* eml:ThermodynamicTemperatureMeasure simple type: */
class SOAP_CMAC eml__ThermodynamicTemperatureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ThermodynamicTemperatureUom uom;	/* required attribute of XSD type eml:ThermodynamicTemperatureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureMeasure (352)
	virtual int soap_type(void) const { return 352; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ThermodynamicTemperatureMeasure, default initialized and not managed by a soap context
	virtual eml__ThermodynamicTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermodynamicTemperatureMeasure); }
	         eml__ThermodynamicTemperatureMeasure() { eml__ThermodynamicTemperatureMeasure::soap_default(NULL); }
	virtual ~eml__ThermodynamicTemperatureMeasure() { }
	friend eml__ThermodynamicTemperatureMeasure *soap_instantiate_eml__ThermodynamicTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1194 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityMeasure (353)
/* eml:PermittivityMeasure simple type: */
class SOAP_CMAC eml__PermittivityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PermittivityUom uom;	/* required attribute of XSD type eml:PermittivityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityMeasure (353)
	virtual int soap_type(void) const { return 353; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PermittivityMeasure, default initialized and not managed by a soap context
	virtual eml__PermittivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PermittivityMeasure); }
	         eml__PermittivityMeasure() { eml__PermittivityMeasure::soap_default(NULL); }
	virtual ~eml__PermittivityMeasure() { }
	friend eml__PermittivityMeasure *soap_instantiate_eml__PermittivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1197 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeMeasure (354)
/* eml:PressureTimePerVolumeMeasure simple type: */
class SOAP_CMAC eml__PressureTimePerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PressureTimePerVolumeUom uom;	/* required attribute of XSD type eml:PressureTimePerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeMeasure (354)
	virtual int soap_type(void) const { return 354; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PressureTimePerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__PressureTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressureTimePerVolumeMeasure); }
	         eml__PressureTimePerVolumeMeasure() { eml__PressureTimePerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__PressureTimePerVolumeMeasure() { }
	friend eml__PressureTimePerVolumeMeasure *soap_instantiate_eml__PressureTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1200 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentMeasure (355)
/* eml:DipoleMomentMeasure simple type: */
class SOAP_CMAC eml__DipoleMomentMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__DipoleMomentUom uom;	/* required attribute of XSD type eml:DipoleMomentUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentMeasure (355)
	virtual int soap_type(void) const { return 355; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__DipoleMomentMeasure, default initialized and not managed by a soap context
	virtual eml__DipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DipoleMomentMeasure); }
	         eml__DipoleMomentMeasure() { eml__DipoleMomentMeasure::soap_default(NULL); }
	virtual ~eml__DipoleMomentMeasure() { }
	friend eml__DipoleMomentMeasure *soap_instantiate_eml__DipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1203 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceMeasure (356)
/* eml:RadianceMeasure simple type: */
class SOAP_CMAC eml__RadianceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__RadianceUom uom;	/* required attribute of XSD type eml:RadianceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceMeasure (356)
	virtual int soap_type(void) const { return 356; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__RadianceMeasure, default initialized and not managed by a soap context
	virtual eml__RadianceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__RadianceMeasure); }
	         eml__RadianceMeasure() { eml__RadianceMeasure::soap_default(NULL); }
	virtual ~eml__RadianceMeasure() { }
	friend eml__RadianceMeasure *soap_instantiate_eml__RadianceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1206 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassMeasure (357)
/* eml:AreaPerMassMeasure simple type: */
class SOAP_CMAC eml__AreaPerMassMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AreaPerMassUom uom;	/* required attribute of XSD type eml:AreaPerMassUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassMeasure (357)
	virtual int soap_type(void) const { return 357; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AreaPerMassMeasure, default initialized and not managed by a soap context
	virtual eml__AreaPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerMassMeasure); }
	         eml__AreaPerMassMeasure() { eml__AreaPerMassMeasure::soap_default(NULL); }
	virtual ~eml__AreaPerMassMeasure() { }
	friend eml__AreaPerMassMeasure *soap_instantiate_eml__AreaPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1209 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeMeasure (358)
/* eml:EnergyPerMassPerTimeMeasure simple type: */
class SOAP_CMAC eml__EnergyPerMassPerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__EnergyPerMassPerTimeUom uom;	/* required attribute of XSD type eml:EnergyPerMassPerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeMeasure (358)
	virtual int soap_type(void) const { return 358; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__EnergyPerMassPerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__EnergyPerMassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerMassPerTimeMeasure); }
	         eml__EnergyPerMassPerTimeMeasure() { eml__EnergyPerMassPerTimeMeasure::soap_default(NULL); }
	virtual ~eml__EnergyPerMassPerTimeMeasure() { }
	friend eml__EnergyPerMassPerTimeMeasure *soap_instantiate_eml__EnergyPerMassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1212 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityMeasure (359)
/* eml:ElectricCurrentDensityMeasure simple type: */
class SOAP_CMAC eml__ElectricCurrentDensityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricCurrentDensityUom uom;	/* required attribute of XSD type eml:ElectricCurrentDensityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityMeasure (359)
	virtual int soap_type(void) const { return 359; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricCurrentDensityMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricCurrentDensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricCurrentDensityMeasure); }
	         eml__ElectricCurrentDensityMeasure() { eml__ElectricCurrentDensityMeasure::soap_default(NULL); }
	virtual ~eml__ElectricCurrentDensityMeasure() { }
	friend eml__ElectricCurrentDensityMeasure *soap_instantiate_eml__ElectricCurrentDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1215 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassMeasure (360)
/* eml:MassPerMassMeasure simple type: */
class SOAP_CMAC eml__MassPerMassMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassPerMassUom uom;	/* required attribute of XSD type eml:MassPerMassUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassMeasure (360)
	virtual int soap_type(void) const { return 360; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassPerMassMeasure, default initialized and not managed by a soap context
	virtual eml__MassPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerMassMeasure); }
	         eml__MassPerMassMeasure() { eml__MassPerMassMeasure::soap_default(NULL); }
	virtual ~eml__MassPerMassMeasure() { }
	friend eml__MassPerMassMeasure *soap_instantiate_eml__MassPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1218 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedMeasure (361)
/* eml:DataTransferSpeedMeasure simple type: */
class SOAP_CMAC eml__DataTransferSpeedMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__DataTransferSpeedUom uom;	/* required attribute of XSD type eml:DataTransferSpeedUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedMeasure (361)
	virtual int soap_type(void) const { return 361; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__DataTransferSpeedMeasure, default initialized and not managed by a soap context
	virtual eml__DataTransferSpeedMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DataTransferSpeedMeasure); }
	         eml__DataTransferSpeedMeasure() { eml__DataTransferSpeedMeasure::soap_default(NULL); }
	virtual ~eml__DataTransferSpeedMeasure() { }
	friend eml__DataTransferSpeedMeasure *soap_instantiate_eml__DataTransferSpeedMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1221 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentMeasure (362)
/* eml:MagneticDipoleMomentMeasure simple type: */
class SOAP_CMAC eml__MagneticDipoleMomentMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MagneticDipoleMomentUom uom;	/* required attribute of XSD type eml:MagneticDipoleMomentUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentMeasure (362)
	virtual int soap_type(void) const { return 362; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MagneticDipoleMomentMeasure, default initialized and not managed by a soap context
	virtual eml__MagneticDipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticDipoleMomentMeasure); }
	         eml__MagneticDipoleMomentMeasure() { eml__MagneticDipoleMomentMeasure::soap_default(NULL); }
	virtual ~eml__MagneticDipoleMomentMeasure() { }
	friend eml__MagneticDipoleMomentMeasure *soap_instantiate_eml__MagneticDipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1224 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyMeasure (363)
/* eml:MassPerEnergyMeasure simple type: */
class SOAP_CMAC eml__MassPerEnergyMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassPerEnergyUom uom;	/* required attribute of XSD type eml:MassPerEnergyUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyMeasure (363)
	virtual int soap_type(void) const { return 363; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassPerEnergyMeasure, default initialized and not managed by a soap context
	virtual eml__MassPerEnergyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerEnergyMeasure); }
	         eml__MassPerEnergyMeasure() { eml__MassPerEnergyMeasure::soap_default(NULL); }
	virtual ~eml__MassPerEnergyMeasure() { }
	friend eml__MassPerEnergyMeasure *soap_instantiate_eml__MassPerEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1227 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityMeasure (364)
/* eml:MagneticPermeabilityMeasure simple type: */
class SOAP_CMAC eml__MagneticPermeabilityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MagneticPermeabilityUom uom;	/* required attribute of XSD type eml:MagneticPermeabilityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityMeasure (364)
	virtual int soap_type(void) const { return 364; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MagneticPermeabilityMeasure, default initialized and not managed by a soap context
	virtual eml__MagneticPermeabilityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticPermeabilityMeasure); }
	         eml__MagneticPermeabilityMeasure() { eml__MagneticPermeabilityMeasure::soap_default(NULL); }
	virtual ~eml__MagneticPermeabilityMeasure() { }
	friend eml__MagneticPermeabilityMeasure *soap_instantiate_eml__MagneticPermeabilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1230 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityMeasure (365)
/* eml:APIGravityMeasure simple type: */
class SOAP_CMAC eml__APIGravityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__APIGravityUom uom;	/* required attribute of XSD type eml:APIGravityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityMeasure (365)
	virtual int soap_type(void) const { return 365; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__APIGravityMeasure, default initialized and not managed by a soap context
	virtual eml__APIGravityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__APIGravityMeasure); }
	         eml__APIGravityMeasure() { eml__APIGravityMeasure::soap_default(NULL); }
	virtual ~eml__APIGravityMeasure() { }
	friend eml__APIGravityMeasure *soap_instantiate_eml__APIGravityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1233 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthMeasure (366)
/* eml:VolumePerLengthMeasure simple type: */
class SOAP_CMAC eml__VolumePerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerLengthUom uom;	/* required attribute of XSD type eml:VolumePerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthMeasure (366)
	virtual int soap_type(void) const { return 366; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerLengthMeasure); }
	         eml__VolumePerLengthMeasure() { eml__VolumePerLengthMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerLengthMeasure() { }
	friend eml__VolumePerLengthMeasure *soap_instantiate_eml__VolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1236 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeMeasure (367)
/* eml:VolumeMeasure simple type: */
class SOAP_CMAC eml__VolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumeUom uom;	/* required attribute of XSD type eml:VolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeMeasure (367)
	virtual int soap_type(void) const { return 367; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumeMeasure, default initialized and not managed by a soap context
	virtual eml__VolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumeMeasure); }
	         eml__VolumeMeasure() { eml__VolumeMeasure::soap_default(NULL); }
	virtual ~eml__VolumeMeasure() { }
	friend eml__VolumeMeasure *soap_instantiate_eml__VolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1239 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeMeasure (368)
/* eml:VolumePerTimePerVolumeMeasure simple type: */
class SOAP_CMAC eml__VolumePerTimePerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerTimePerVolumeUom uom;	/* required attribute of XSD type eml:VolumePerTimePerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeMeasure (368)
	virtual int soap_type(void) const { return 368; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerTimePerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerVolumeMeasure); }
	         eml__VolumePerTimePerVolumeMeasure() { eml__VolumePerTimePerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerTimePerVolumeMeasure() { }
	friend eml__VolumePerTimePerVolumeMeasure *soap_instantiate_eml__VolumePerTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1242 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureMeasure (369)
/* eml:VolumePerTimePerPressureMeasure simple type: */
class SOAP_CMAC eml__VolumePerTimePerPressureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerTimePerPressureUom uom;	/* required attribute of XSD type eml:VolumePerTimePerPressureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureMeasure (369)
	virtual int soap_type(void) const { return 369; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerTimePerPressureMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerTimePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerPressureMeasure); }
	         eml__VolumePerTimePerPressureMeasure() { eml__VolumePerTimePerPressureMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerTimePerPressureMeasure() { }
	friend eml__VolumePerTimePerPressureMeasure *soap_instantiate_eml__VolumePerTimePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1245 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeMeasure (370)
/* eml:TimeMeasure simple type: */
class SOAP_CMAC eml__TimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__TimeUom uom;	/* required attribute of XSD type eml:TimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeMeasure (370)
	virtual int soap_type(void) const { return 370; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__TimeMeasure, default initialized and not managed by a soap context
	virtual eml__TimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimeMeasure); }
	         eml__TimeMeasure() { eml__TimeMeasure::soap_default(NULL); }
	virtual ~eml__TimeMeasure() { }
	friend eml__TimeMeasure *soap_instantiate_eml__TimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1248 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceMeasure (371)
/* eml:MomentOfForceMeasure simple type: */
class SOAP_CMAC eml__MomentOfForceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MomentOfForceUom uom;	/* required attribute of XSD type eml:MomentOfForceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceMeasure (371)
	virtual int soap_type(void) const { return 371; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MomentOfForceMeasure, default initialized and not managed by a soap context
	virtual eml__MomentOfForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MomentOfForceMeasure); }
	         eml__MomentOfForceMeasure() { eml__MomentOfForceMeasure::soap_default(NULL); }
	virtual ~eml__MomentOfForceMeasure() { }
	friend eml__MomentOfForceMeasure *soap_instantiate_eml__MomentOfForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1251 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceMeasure (372)
/* eml:LuminanceMeasure simple type: */
class SOAP_CMAC eml__LuminanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LuminanceUom uom;	/* required attribute of XSD type eml:LuminanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceMeasure (372)
	virtual int soap_type(void) const { return 372; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LuminanceMeasure, default initialized and not managed by a soap context
	virtual eml__LuminanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LuminanceMeasure); }
	         eml__LuminanceMeasure() { eml__LuminanceMeasure::soap_default(NULL); }
	virtual ~eml__LuminanceMeasure() { }
	friend eml__LuminanceMeasure *soap_instantiate_eml__LuminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1254 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeMeasure (373)
/* eml:ForcePerVolumeMeasure simple type: */
class SOAP_CMAC eml__ForcePerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ForcePerVolumeUom uom;	/* required attribute of XSD type eml:ForcePerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeMeasure (373)
	virtual int soap_type(void) const { return 373; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ForcePerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__ForcePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForcePerVolumeMeasure); }
	         eml__ForcePerVolumeMeasure() { eml__ForcePerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__ForcePerVolumeMeasure() { }
	friend eml__ForcePerVolumeMeasure *soap_instantiate_eml__ForcePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1257 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityMeasure (374)
/* eml:MolarHeatCapacityMeasure simple type: */
class SOAP_CMAC eml__MolarHeatCapacityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MolarHeatCapacityUom uom;	/* required attribute of XSD type eml:MolarHeatCapacityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityMeasure (374)
	virtual int soap_type(void) const { return 374; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MolarHeatCapacityMeasure, default initialized and not managed by a soap context
	virtual eml__MolarHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MolarHeatCapacityMeasure); }
	         eml__MolarHeatCapacityMeasure() { eml__MolarHeatCapacityMeasure::soap_default(NULL); }
	virtual ~eml__MolarHeatCapacityMeasure() { }
	friend eml__MolarHeatCapacityMeasure *soap_instantiate_eml__MolarHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1260 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageMeasure (375)
/* eml:DigitalStorageMeasure simple type: */
class SOAP_CMAC eml__DigitalStorageMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__DigitalStorageUom uom;	/* required attribute of XSD type eml:DigitalStorageUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageMeasure (375)
	virtual int soap_type(void) const { return 375; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__DigitalStorageMeasure, default initialized and not managed by a soap context
	virtual eml__DigitalStorageMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DigitalStorageMeasure); }
	         eml__DigitalStorageMeasure() { eml__DigitalStorageMeasure::soap_default(NULL); }
	virtual ~eml__DigitalStorageMeasure() { }
	friend eml__DigitalStorageMeasure *soap_instantiate_eml__DigitalStorageMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1263 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeMeasure (376)
/* eml:ElectricChargeMeasure simple type: */
class SOAP_CMAC eml__ElectricChargeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricChargeUom uom;	/* required attribute of XSD type eml:ElectricChargeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeMeasure (376)
	virtual int soap_type(void) const { return 376; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricChargeMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricChargeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricChargeMeasure); }
	         eml__ElectricChargeMeasure() { eml__ElectricChargeMeasure::soap_default(NULL); }
	virtual ~eml__ElectricChargeMeasure() { }
	friend eml__ElectricChargeMeasure *soap_instantiate_eml__ElectricChargeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1266 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityMeasure (377)
/* eml:LuminousIntensityMeasure simple type: */
class SOAP_CMAC eml__LuminousIntensityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LuminousIntensityUom uom;	/* required attribute of XSD type eml:LuminousIntensityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityMeasure (377)
	virtual int soap_type(void) const { return 377; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LuminousIntensityMeasure, default initialized and not managed by a soap context
	virtual eml__LuminousIntensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LuminousIntensityMeasure); }
	         eml__LuminousIntensityMeasure() { eml__LuminousIntensityMeasure::soap_default(NULL); }
	virtual ~eml__LuminousIntensityMeasure() { }
	friend eml__LuminousIntensityMeasure *soap_instantiate_eml__LuminousIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1269 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyMeasure (378)
/* eml:MolarEnergyMeasure simple type: */
class SOAP_CMAC eml__MolarEnergyMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MolarEnergyUom uom;	/* required attribute of XSD type eml:MolarEnergyUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyMeasure (378)
	virtual int soap_type(void) const { return 378; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MolarEnergyMeasure, default initialized and not managed by a soap context
	virtual eml__MolarEnergyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MolarEnergyMeasure); }
	         eml__MolarEnergyMeasure() { eml__MolarEnergyMeasure::soap_default(NULL); }
	virtual ~eml__MolarEnergyMeasure() { }
	friend eml__MolarEnergyMeasure *soap_instantiate_eml__MolarEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1272 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeMeasure (379)
/* eml:LengthPerVolumeMeasure simple type: */
class SOAP_CMAC eml__LengthPerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LengthPerVolumeUom uom;	/* required attribute of XSD type eml:LengthPerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeMeasure (379)
	virtual int soap_type(void) const { return 379; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LengthPerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__LengthPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerVolumeMeasure); }
	         eml__LengthPerVolumeMeasure() { eml__LengthPerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__LengthPerVolumeMeasure() { }
	friend eml__LengthPerVolumeMeasure *soap_instantiate_eml__LengthPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1275 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaMeasure (380)
/* eml:SecondMomentOfAreaMeasure simple type: */
class SOAP_CMAC eml__SecondMomentOfAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__SecondMomentOfAreaUom uom;	/* required attribute of XSD type eml:SecondMomentOfAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaMeasure (380)
	virtual int soap_type(void) const { return 380; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__SecondMomentOfAreaMeasure, default initialized and not managed by a soap context
	virtual eml__SecondMomentOfAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__SecondMomentOfAreaMeasure); }
	         eml__SecondMomentOfAreaMeasure() { eml__SecondMomentOfAreaMeasure::soap_default(NULL); }
	virtual ~eml__SecondMomentOfAreaMeasure() { }
	friend eml__SecondMomentOfAreaMeasure *soap_instantiate_eml__SecondMomentOfAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1278 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityMeasure (381)
/* eml:MagneticFluxDensityMeasure simple type: */
class SOAP_CMAC eml__MagneticFluxDensityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MagneticFluxDensityUom uom;	/* required attribute of XSD type eml:MagneticFluxDensityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityMeasure (381)
	virtual int soap_type(void) const { return 381; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MagneticFluxDensityMeasure, default initialized and not managed by a soap context
	virtual eml__MagneticFluxDensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticFluxDensityMeasure); }
	         eml__MagneticFluxDensityMeasure() { eml__MagneticFluxDensityMeasure::soap_default(NULL); }
	virtual ~eml__MagneticFluxDensityMeasure() { }
	friend eml__MagneticFluxDensityMeasure *soap_instantiate_eml__MagneticFluxDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1281 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaMeasure (382)
/* eml:VolumePerAreaMeasure simple type: */
class SOAP_CMAC eml__VolumePerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerAreaUom uom;	/* required attribute of XSD type eml:VolumePerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaMeasure (382)
	virtual int soap_type(void) const { return 382; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerAreaMeasure); }
	         eml__VolumePerAreaMeasure() { eml__VolumePerAreaMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerAreaMeasure() { }
	friend eml__VolumePerAreaMeasure *soap_instantiate_eml__VolumePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1284 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightMeasure (383)
/* eml:QuantityOfLightMeasure simple type: */
class SOAP_CMAC eml__QuantityOfLightMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__QuantityOfLightUom uom;	/* required attribute of XSD type eml:QuantityOfLightUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightMeasure (383)
	virtual int soap_type(void) const { return 383; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__QuantityOfLightMeasure, default initialized and not managed by a soap context
	virtual eml__QuantityOfLightMeasure *soap_alloc(void) const { return SOAP_NEW(eml__QuantityOfLightMeasure); }
	         eml__QuantityOfLightMeasure() { eml__QuantityOfLightMeasure::soap_default(NULL); }
	virtual ~eml__QuantityOfLightMeasure() { }
	friend eml__QuantityOfLightMeasure *soap_instantiate_eml__QuantityOfLightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1287 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyMeasure (384)
/* eml:LuminousEfficacyMeasure simple type: */
class SOAP_CMAC eml__LuminousEfficacyMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LuminousEfficacyUom uom;	/* required attribute of XSD type eml:LuminousEfficacyUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyMeasure (384)
	virtual int soap_type(void) const { return 384; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LuminousEfficacyMeasure, default initialized and not managed by a soap context
	virtual eml__LuminousEfficacyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LuminousEfficacyMeasure); }
	         eml__LuminousEfficacyMeasure() { eml__LuminousEfficacyMeasure::soap_default(NULL); }
	virtual ~eml__LuminousEfficacyMeasure() { }
	friend eml__LuminousEfficacyMeasure *soap_instantiate_eml__LuminousEfficacyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1290 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeMeasure (385)
/* eml:AreaPerTimeMeasure simple type: */
class SOAP_CMAC eml__AreaPerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AreaPerTimeUom uom;	/* required attribute of XSD type eml:AreaPerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeMeasure (385)
	virtual int soap_type(void) const { return 385; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AreaPerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__AreaPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerTimeMeasure); }
	         eml__AreaPerTimeMeasure() { eml__AreaPerTimeMeasure::soap_default(NULL); }
	virtual ~eml__AreaPerTimeMeasure() { }
	friend eml__AreaPerTimeMeasure *soap_instantiate_eml__AreaPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1293 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateMeasure (386)
/* eml:VolumeFlowRatePerVolumeFlowRateMeasure simple type: */
class SOAP_CMAC eml__VolumeFlowRatePerVolumeFlowRateMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumeFlowRatePerVolumeFlowRateUom uom;	/* required attribute of XSD type eml:VolumeFlowRatePerVolumeFlowRateUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateMeasure (386)
	virtual int soap_type(void) const { return 386; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumeFlowRatePerVolumeFlowRateMeasure, default initialized and not managed by a soap context
	virtual eml__VolumeFlowRatePerVolumeFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumeFlowRatePerVolumeFlowRateMeasure); }
	         eml__VolumeFlowRatePerVolumeFlowRateMeasure() { eml__VolumeFlowRatePerVolumeFlowRateMeasure::soap_default(NULL); }
	virtual ~eml__VolumeFlowRatePerVolumeFlowRateMeasure() { }
	friend eml__VolumeFlowRatePerVolumeFlowRateMeasure *soap_instantiate_eml__VolumeFlowRatePerVolumeFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1296 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumMeasure (387)
/* eml:MomentumMeasure simple type: */
class SOAP_CMAC eml__MomentumMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MomentumUom uom;	/* required attribute of XSD type eml:MomentumUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumMeasure (387)
	virtual int soap_type(void) const { return 387; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MomentumMeasure, default initialized and not managed by a soap context
	virtual eml__MomentumMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MomentumMeasure); }
	         eml__MomentumMeasure() { eml__MomentumMeasure::soap_default(NULL); }
	virtual ~eml__MomentumMeasure() { }
	friend eml__MomentumMeasure *soap_instantiate_eml__MomentumMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1299 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeMeasure (388)
/* eml:PowerPerVolumeMeasure simple type: */
class SOAP_CMAC eml__PowerPerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PowerPerVolumeUom uom;	/* required attribute of XSD type eml:PowerPerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeMeasure (388)
	virtual int soap_type(void) const { return 388; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PowerPerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__PowerPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PowerPerVolumeMeasure); }
	         eml__PowerPerVolumeMeasure() { eml__PowerPerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__PowerPerVolumeMeasure() { }
	friend eml__PowerPerVolumeMeasure *soap_instantiate_eml__PowerPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1302 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityMeasure (389)
/* eml:ThermalDiffusivityMeasure simple type: */
class SOAP_CMAC eml__ThermalDiffusivityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ThermalDiffusivityUom uom;	/* required attribute of XSD type eml:ThermalDiffusivityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityMeasure (389)
	virtual int soap_type(void) const { return 389; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ThermalDiffusivityMeasure, default initialized and not managed by a soap context
	virtual eml__ThermalDiffusivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalDiffusivityMeasure); }
	         eml__ThermalDiffusivityMeasure() { eml__ThermalDiffusivityMeasure::soap_default(NULL); }
	virtual ~eml__ThermalDiffusivityMeasure() { }
	friend eml__ThermalDiffusivityMeasure *soap_instantiate_eml__ThermalDiffusivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1305 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthMeasure (390)
/* eml:LogarithmicPowerRatioPerLengthMeasure simple type: */
class SOAP_CMAC eml__LogarithmicPowerRatioPerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LogarithmicPowerRatioPerLengthUom uom;	/* required attribute of XSD type eml:LogarithmicPowerRatioPerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthMeasure (390)
	virtual int soap_type(void) const { return 390; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LogarithmicPowerRatioPerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__LogarithmicPowerRatioPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LogarithmicPowerRatioPerLengthMeasure); }
	         eml__LogarithmicPowerRatioPerLengthMeasure() { eml__LogarithmicPowerRatioPerLengthMeasure::soap_default(NULL); }
	virtual ~eml__LogarithmicPowerRatioPerLengthMeasure() { }
	friend eml__LogarithmicPowerRatioPerLengthMeasure *soap_instantiate_eml__LogarithmicPowerRatioPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1308 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeMeasure (391)
/* eml:ReciprocalTimeMeasure simple type: */
class SOAP_CMAC eml__ReciprocalTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReciprocalTimeUom uom;	/* required attribute of XSD type eml:ReciprocalTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeMeasure (391)
	virtual int soap_type(void) const { return 391; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReciprocalTimeMeasure, default initialized and not managed by a soap context
	virtual eml__ReciprocalTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalTimeMeasure); }
	         eml__ReciprocalTimeMeasure() { eml__ReciprocalTimeMeasure::soap_default(NULL); }
	virtual ~eml__ReciprocalTimeMeasure() { }
	friend eml__ReciprocalTimeMeasure *soap_instantiate_eml__ReciprocalTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1311 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityMeasure (392)
/* eml:SpecificHeatCapacityMeasure simple type: */
class SOAP_CMAC eml__SpecificHeatCapacityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__SpecificHeatCapacityUom uom;	/* required attribute of XSD type eml:SpecificHeatCapacityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityMeasure (392)
	virtual int soap_type(void) const { return 392; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__SpecificHeatCapacityMeasure, default initialized and not managed by a soap context
	virtual eml__SpecificHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__SpecificHeatCapacityMeasure); }
	         eml__SpecificHeatCapacityMeasure() { eml__SpecificHeatCapacityMeasure::soap_default(NULL); }
	virtual ~eml__SpecificHeatCapacityMeasure() { }
	friend eml__SpecificHeatCapacityMeasure *soap_instantiate_eml__SpecificHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1314 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropMeasure (393)
/* eml:PotentialDifferencePerPowerDropMeasure simple type: */
class SOAP_CMAC eml__PotentialDifferencePerPowerDropMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PotentialDifferencePerPowerDropUom uom;	/* required attribute of XSD type eml:PotentialDifferencePerPowerDropUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropMeasure (393)
	virtual int soap_type(void) const { return 393; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PotentialDifferencePerPowerDropMeasure, default initialized and not managed by a soap context
	virtual eml__PotentialDifferencePerPowerDropMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PotentialDifferencePerPowerDropMeasure); }
	         eml__PotentialDifferencePerPowerDropMeasure() { eml__PotentialDifferencePerPowerDropMeasure::soap_default(NULL); }
	virtual ~eml__PotentialDifferencePerPowerDropMeasure() { }
	friend eml__PotentialDifferencePerPowerDropMeasure *soap_instantiate_eml__PotentialDifferencePerPowerDropMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1317 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaMeasure (394)
/* eml:MomentOfInertiaMeasure simple type: */
class SOAP_CMAC eml__MomentOfInertiaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MomentOfInertiaUom uom;	/* required attribute of XSD type eml:MomentOfInertiaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaMeasure (394)
	virtual int soap_type(void) const { return 394; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MomentOfInertiaMeasure, default initialized and not managed by a soap context
	virtual eml__MomentOfInertiaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MomentOfInertiaMeasure); }
	         eml__MomentOfInertiaMeasure() { eml__MomentOfInertiaMeasure::soap_default(NULL); }
	virtual ~eml__MomentOfInertiaMeasure() { }
	friend eml__MomentOfInertiaMeasure *soap_instantiate_eml__MomentOfInertiaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1320 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthMeasure (395)
/* eml:MassPerTimePerLengthMeasure simple type: */
class SOAP_CMAC eml__MassPerTimePerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassPerTimePerLengthUom uom;	/* required attribute of XSD type eml:MassPerTimePerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthMeasure (395)
	virtual int soap_type(void) const { return 395; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassPerTimePerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__MassPerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerTimePerLengthMeasure); }
	         eml__MassPerTimePerLengthMeasure() { eml__MassPerTimePerLengthMeasure::soap_default(NULL); }
	virtual ~eml__MassPerTimePerLengthMeasure() { }
	friend eml__MassPerTimePerLengthMeasure *soap_instantiate_eml__MassPerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1323 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightMeasure (396)
/* eml:MolecularWeightMeasure simple type: */
class SOAP_CMAC eml__MolecularWeightMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MolecularWeightUom uom;	/* required attribute of XSD type eml:MolecularWeightUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightMeasure (396)
	virtual int soap_type(void) const { return 396; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MolecularWeightMeasure, default initialized and not managed by a soap context
	virtual eml__MolecularWeightMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MolecularWeightMeasure); }
	         eml__MolecularWeightMeasure() { eml__MolecularWeightMeasure::soap_default(NULL); }
	virtual ~eml__MolecularWeightMeasure() { }
	friend eml__MolecularWeightMeasure *soap_instantiate_eml__MolecularWeightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1326 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityMeasure (397)
/* eml:ActivityOfRadioactivityMeasure simple type: */
class SOAP_CMAC eml__ActivityOfRadioactivityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ActivityOfRadioactivityUom uom;	/* required attribute of XSD type eml:ActivityOfRadioactivityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityMeasure (397)
	virtual int soap_type(void) const { return 397; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ActivityOfRadioactivityMeasure, default initialized and not managed by a soap context
	virtual eml__ActivityOfRadioactivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ActivityOfRadioactivityMeasure); }
	         eml__ActivityOfRadioactivityMeasure() { eml__ActivityOfRadioactivityMeasure::soap_default(NULL); }
	virtual ~eml__ActivityOfRadioactivityMeasure() { }
	friend eml__ActivityOfRadioactivityMeasure *soap_instantiate_eml__ActivityOfRadioactivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1329 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeMeasure (398)
/* eml:SignalingEventPerTimeMeasure simple type: */
class SOAP_CMAC eml__SignalingEventPerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__SignalingEventPerTimeUom uom;	/* required attribute of XSD type eml:SignalingEventPerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeMeasure (398)
	virtual int soap_type(void) const { return 398; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__SignalingEventPerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__SignalingEventPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__SignalingEventPerTimeMeasure); }
	         eml__SignalingEventPerTimeMeasure() { eml__SignalingEventPerTimeMeasure::soap_default(NULL); }
	virtual ~eml__SignalingEventPerTimeMeasure() { }
	friend eml__SignalingEventPerTimeMeasure *soap_instantiate_eml__SignalingEventPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1332 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyMeasure (399)
/* eml:FrequencyMeasure simple type: */
class SOAP_CMAC eml__FrequencyMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__FrequencyUom uom;	/* required attribute of XSD type eml:FrequencyUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyMeasure (399)
	virtual int soap_type(void) const { return 399; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__FrequencyMeasure, default initialized and not managed by a soap context
	virtual eml__FrequencyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__FrequencyMeasure); }
	         eml__FrequencyMeasure() { eml__FrequencyMeasure::soap_default(NULL); }
	virtual ~eml__FrequencyMeasure() { }
	friend eml__FrequencyMeasure *soap_instantiate_eml__FrequencyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1335 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalMeasure (400)
/* eml:FrequencyIntervalMeasure simple type: */
class SOAP_CMAC eml__FrequencyIntervalMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__FrequencyIntervalUom uom;	/* required attribute of XSD type eml:FrequencyIntervalUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalMeasure (400)
	virtual int soap_type(void) const { return 400; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__FrequencyIntervalMeasure, default initialized and not managed by a soap context
	virtual eml__FrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW(eml__FrequencyIntervalMeasure); }
	         eml__FrequencyIntervalMeasure() { eml__FrequencyIntervalMeasure::soap_default(NULL); }
	virtual ~eml__FrequencyIntervalMeasure() { }
	friend eml__FrequencyIntervalMeasure *soap_instantiate_eml__FrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1338 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceMeasure (401)
/* eml:CapacitanceMeasure simple type: */
class SOAP_CMAC eml__CapacitanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__CapacitanceUom uom;	/* required attribute of XSD type eml:CapacitanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceMeasure (401)
	virtual int soap_type(void) const { return 401; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__CapacitanceMeasure, default initialized and not managed by a soap context
	virtual eml__CapacitanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__CapacitanceMeasure); }
	         eml__CapacitanceMeasure() { eml__CapacitanceMeasure::soap_default(NULL); }
	virtual ~eml__CapacitanceMeasure() { }
	friend eml__CapacitanceMeasure *soap_instantiate_eml__CapacitanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1341 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityMeasure (402)
/* eml:ElectricalResistivityMeasure simple type: */
class SOAP_CMAC eml__ElectricalResistivityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricalResistivityUom uom;	/* required attribute of XSD type eml:ElectricalResistivityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityMeasure (402)
	virtual int soap_type(void) const { return 402; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricalResistivityMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricalResistivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricalResistivityMeasure); }
	         eml__ElectricalResistivityMeasure() { eml__ElectricalResistivityMeasure::soap_default(NULL); }
	virtual ~eml__ElectricalResistivityMeasure() { }
	friend eml__ElectricalResistivityMeasure *soap_instantiate_eml__ElectricalResistivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1344 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthMeasure (403)
/* eml:MassLengthMeasure simple type: */
class SOAP_CMAC eml__MassLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassLengthUom uom;	/* required attribute of XSD type eml:MassLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthMeasure (403)
	virtual int soap_type(void) const { return 403; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassLengthMeasure, default initialized and not managed by a soap context
	virtual eml__MassLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassLengthMeasure); }
	         eml__MassLengthMeasure() { eml__MassLengthMeasure::soap_default(NULL); }
	virtual ~eml__MassLengthMeasure() { }
	friend eml__MassLengthMeasure *soap_instantiate_eml__MassLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1347 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaMeasure (404)
/* eml:ReciprocalAreaMeasure simple type: */
class SOAP_CMAC eml__ReciprocalAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReciprocalAreaUom uom;	/* required attribute of XSD type eml:ReciprocalAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaMeasure (404)
	virtual int soap_type(void) const { return 404; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReciprocalAreaMeasure, default initialized and not managed by a soap context
	virtual eml__ReciprocalAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalAreaMeasure); }
	         eml__ReciprocalAreaMeasure() { eml__ReciprocalAreaMeasure::soap_default(NULL); }
	virtual ~eml__ReciprocalAreaMeasure() { }
	friend eml__ReciprocalAreaMeasure *soap_instantiate_eml__ReciprocalAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1350 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityMeasure (405)
/* eml:KinematicViscosityMeasure simple type: */
class SOAP_CMAC eml__KinematicViscosityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__KinematicViscosityUom uom;	/* required attribute of XSD type eml:KinematicViscosityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityMeasure (405)
	virtual int soap_type(void) const { return 405; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__KinematicViscosityMeasure, default initialized and not managed by a soap context
	virtual eml__KinematicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__KinematicViscosityMeasure); }
	         eml__KinematicViscosityMeasure() { eml__KinematicViscosityMeasure::soap_default(NULL); }
	virtual ~eml__KinematicViscosityMeasure() { }
	friend eml__KinematicViscosityMeasure *soap_instantiate_eml__KinematicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1353 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceMeasure (406)
/* eml:InductanceMeasure simple type: */
class SOAP_CMAC eml__InductanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__InductanceUom uom;	/* required attribute of XSD type eml:InductanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceMeasure (406)
	virtual int soap_type(void) const { return 406; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__InductanceMeasure, default initialized and not managed by a soap context
	virtual eml__InductanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__InductanceMeasure); }
	         eml__InductanceMeasure() { eml__InductanceMeasure::soap_default(NULL); }
	virtual ~eml__InductanceMeasure() { }
	friend eml__InductanceMeasure *soap_instantiate_eml__InductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1356 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeMeasure (407)
/* eml:TimePerVolumeMeasure simple type: */
class SOAP_CMAC eml__TimePerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__TimePerVolumeUom uom;	/* required attribute of XSD type eml:TimePerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeMeasure (407)
	virtual int soap_type(void) const { return 407; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__TimePerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__TimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimePerVolumeMeasure); }
	         eml__TimePerVolumeMeasure() { eml__TimePerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__TimePerVolumeMeasure() { }
	friend eml__TimePerVolumeMeasure *soap_instantiate_eml__TimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1359 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentMeasure (408)
/* eml:ElectromagneticMomentMeasure simple type: */
class SOAP_CMAC eml__ElectromagneticMomentMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectromagneticMomentUom uom;	/* required attribute of XSD type eml:ElectromagneticMomentUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentMeasure (408)
	virtual int soap_type(void) const { return 408; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectromagneticMomentMeasure, default initialized and not managed by a soap context
	virtual eml__ElectromagneticMomentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectromagneticMomentMeasure); }
	         eml__ElectromagneticMomentMeasure() { eml__ElectromagneticMomentMeasure::soap_default(NULL); }
	virtual ~eml__ElectromagneticMomentMeasure() { }
	friend eml__ElectromagneticMomentMeasure *soap_instantiate_eml__ElectromagneticMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1362 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeMeasure (409)
/* eml:EnergyPerVolumeMeasure simple type: */
class SOAP_CMAC eml__EnergyPerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__EnergyPerVolumeUom uom;	/* required attribute of XSD type eml:EnergyPerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeMeasure (409)
	virtual int soap_type(void) const { return 409; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__EnergyPerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__EnergyPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerVolumeMeasure); }
	         eml__EnergyPerVolumeMeasure() { eml__EnergyPerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__EnergyPerVolumeMeasure() { }
	friend eml__EnergyPerVolumeMeasure *soap_instantiate_eml__EnergyPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1365 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeMeasure (410)
/* eml:ElectricChargePerVolumeMeasure simple type: */
class SOAP_CMAC eml__ElectricChargePerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricChargePerVolumeUom uom;	/* required attribute of XSD type eml:ElectricChargePerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeMeasure (410)
	virtual int soap_type(void) const { return 410; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricChargePerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricChargePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricChargePerVolumeMeasure); }
	         eml__ElectricChargePerVolumeMeasure() { eml__ElectricChargePerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__ElectricChargePerVolumeMeasure() { }
	friend eml__ElectricChargePerVolumeMeasure *soap_instantiate_eml__ElectricChargePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1368 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientMeasure (411)
/* eml:VolumetricHeatTransferCoefficientMeasure simple type: */
class SOAP_CMAC eml__VolumetricHeatTransferCoefficientMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumetricHeatTransferCoefficientUom uom;	/* required attribute of XSD type eml:VolumetricHeatTransferCoefficientUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientMeasure (411)
	virtual int soap_type(void) const { return 411; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumetricHeatTransferCoefficientMeasure, default initialized and not managed by a soap context
	virtual eml__VolumetricHeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumetricHeatTransferCoefficientMeasure); }
	         eml__VolumetricHeatTransferCoefficientMeasure() { eml__VolumetricHeatTransferCoefficientMeasure::soap_default(NULL); }
	virtual ~eml__VolumetricHeatTransferCoefficientMeasure() { }
	friend eml__VolumetricHeatTransferCoefficientMeasure *soap_instantiate_eml__VolumetricHeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1371 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeMeasure (412)
/* eml:PressurePerVolumeMeasure simple type: */
class SOAP_CMAC eml__PressurePerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PressurePerVolumeUom uom;	/* required attribute of XSD type eml:PressurePerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeMeasure (412)
	virtual int soap_type(void) const { return 412; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PressurePerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__PressurePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressurePerVolumeMeasure); }
	         eml__PressurePerVolumeMeasure() { eml__PressurePerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__PressurePerVolumeMeasure() { }
	friend eml__PressurePerVolumeMeasure *soap_instantiate_eml__PressurePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1374 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassMeasure (413)
/* eml:TimePerMassMeasure simple type: */
class SOAP_CMAC eml__TimePerMassMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__TimePerMassUom uom;	/* required attribute of XSD type eml:TimePerMassUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassMeasure (413)
	virtual int soap_type(void) const { return 413; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__TimePerMassMeasure, default initialized and not managed by a soap context
	virtual eml__TimePerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimePerMassMeasure); }
	         eml__TimePerMassMeasure() { eml__TimePerMassMeasure::soap_default(NULL); }
	virtual ~eml__TimePerMassMeasure() { }
	friend eml__TimePerMassMeasure *soap_instantiate_eml__TimePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1377 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthMeasure (414)
/* eml:ReciprocalLengthMeasure simple type: */
class SOAP_CMAC eml__ReciprocalLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReciprocalLengthUom uom;	/* required attribute of XSD type eml:ReciprocalLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthMeasure (414)
	virtual int soap_type(void) const { return 414; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReciprocalLengthMeasure, default initialized and not managed by a soap context
	virtual eml__ReciprocalLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalLengthMeasure); }
	         eml__ReciprocalLengthMeasure() { eml__ReciprocalLengthMeasure::soap_default(NULL); }
	virtual ~eml__ReciprocalLengthMeasure() { }
	friend eml__ReciprocalLengthMeasure *soap_instantiate_eml__ReciprocalLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1380 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityMeasure (415)
/* eml:DynamicViscosityMeasure simple type: */
class SOAP_CMAC eml__DynamicViscosityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__DynamicViscosityUom uom;	/* required attribute of XSD type eml:DynamicViscosityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityMeasure (415)
	virtual int soap_type(void) const { return 415; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__DynamicViscosityMeasure, default initialized and not managed by a soap context
	virtual eml__DynamicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DynamicViscosityMeasure); }
	         eml__DynamicViscosityMeasure() { eml__DynamicViscosityMeasure::soap_default(NULL); }
	virtual ~eml__DynamicViscosityMeasure() { }
	friend eml__DynamicViscosityMeasure *soap_instantiate_eml__DynamicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1383 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceMeasure (416)
/* eml:ReciprocalElectricPotentialDifferenceMeasure simple type: */
class SOAP_CMAC eml__ReciprocalElectricPotentialDifferenceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReciprocalElectricPotentialDifferenceUom uom;	/* required attribute of XSD type eml:ReciprocalElectricPotentialDifferenceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceMeasure (416)
	virtual int soap_type(void) const { return 416; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReciprocalElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
	virtual eml__ReciprocalElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalElectricPotentialDifferenceMeasure); }
	         eml__ReciprocalElectricPotentialDifferenceMeasure() { eml__ReciprocalElectricPotentialDifferenceMeasure::soap_default(NULL); }
	virtual ~eml__ReciprocalElectricPotentialDifferenceMeasure() { }
	friend eml__ReciprocalElectricPotentialDifferenceMeasure *soap_instantiate_eml__ReciprocalElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1386 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassMeasure (417)
/* eml:ElectricChargePerMassMeasure simple type: */
class SOAP_CMAC eml__ElectricChargePerMassMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricChargePerMassUom uom;	/* required attribute of XSD type eml:ElectricChargePerMassUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassMeasure (417)
	virtual int soap_type(void) const { return 417; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricChargePerMassMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricChargePerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricChargePerMassMeasure); }
	         eml__ElectricChargePerMassMeasure() { eml__ElectricChargePerMassMeasure::soap_default(NULL); }
	virtual ~eml__ElectricChargePerMassMeasure() { }
	friend eml__ElectricChargePerMassMeasure *soap_instantiate_eml__ElectricChargePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1389 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayMeasure (418)
/* eml:APIGammaRayMeasure simple type: */
class SOAP_CMAC eml__APIGammaRayMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__APIGammaRayUom uom;	/* required attribute of XSD type eml:APIGammaRayUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayMeasure (418)
	virtual int soap_type(void) const { return 418; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__APIGammaRayMeasure, default initialized and not managed by a soap context
	virtual eml__APIGammaRayMeasure *soap_alloc(void) const { return SOAP_NEW(eml__APIGammaRayMeasure); }
	         eml__APIGammaRayMeasure() { eml__APIGammaRayMeasure::soap_default(NULL); }
	virtual ~eml__APIGammaRayMeasure() { }
	friend eml__APIGammaRayMeasure *soap_instantiate_eml__APIGammaRayMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1392 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientMeasure (419)
/* eml:DiffusionCoefficientMeasure simple type: */
class SOAP_CMAC eml__DiffusionCoefficientMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__DiffusionCoefficientUom uom;	/* required attribute of XSD type eml:DiffusionCoefficientUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientMeasure (419)
	virtual int soap_type(void) const { return 419; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__DiffusionCoefficientMeasure, default initialized and not managed by a soap context
	virtual eml__DiffusionCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DiffusionCoefficientMeasure); }
	         eml__DiffusionCoefficientMeasure() { eml__DiffusionCoefficientMeasure::soap_default(NULL); }
	virtual ~eml__DiffusionCoefficientMeasure() { }
	friend eml__DiffusionCoefficientMeasure *soap_instantiate_eml__DiffusionCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1395 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceMeasure (420)
/* eml:ElectricPotentialDifferenceMeasure simple type: */
class SOAP_CMAC eml__ElectricPotentialDifferenceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricPotentialDifferenceUom uom;	/* required attribute of XSD type eml:ElectricPotentialDifferenceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceMeasure (420)
	virtual int soap_type(void) const { return 420; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricPotentialDifferenceMeasure); }
	         eml__ElectricPotentialDifferenceMeasure() { eml__ElectricPotentialDifferenceMeasure::soap_default(NULL); }
	virtual ~eml__ElectricPotentialDifferenceMeasure() { }
	friend eml__ElectricPotentialDifferenceMeasure *soap_instantiate_eml__ElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1398 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityMeasure (421)
/* eml:IsothermalCompressibilityMeasure simple type: */
class SOAP_CMAC eml__IsothermalCompressibilityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__IsothermalCompressibilityUom uom;	/* required attribute of XSD type eml:IsothermalCompressibilityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityMeasure (421)
	virtual int soap_type(void) const { return 421; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__IsothermalCompressibilityMeasure, default initialized and not managed by a soap context
	virtual eml__IsothermalCompressibilityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__IsothermalCompressibilityMeasure); }
	         eml__IsothermalCompressibilityMeasure() { eml__IsothermalCompressibilityMeasure::soap_default(NULL); }
	virtual ~eml__IsothermalCompressibilityMeasure() { }
	friend eml__IsothermalCompressibilityMeasure *soap_instantiate_eml__IsothermalCompressibilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1401 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthMeasure (422)
/* eml:MassPerVolumePerLengthMeasure simple type: */
class SOAP_CMAC eml__MassPerVolumePerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassPerVolumePerLengthUom uom;	/* required attribute of XSD type eml:MassPerVolumePerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthMeasure (422)
	virtual int soap_type(void) const { return 422; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassPerVolumePerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__MassPerVolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerVolumePerLengthMeasure); }
	         eml__MassPerVolumePerLengthMeasure() { eml__MassPerVolumePerLengthMeasure::soap_default(NULL); }
	virtual ~eml__MassPerVolumePerLengthMeasure() { }
	friend eml__MassPerVolumePerLengthMeasure *soap_instantiate_eml__MassPerVolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1404 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeMeasure (423)
/* eml:PressurePerTimeMeasure simple type: */
class SOAP_CMAC eml__PressurePerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PressurePerTimeUom uom;	/* required attribute of XSD type eml:PressurePerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeMeasure (423)
	virtual int soap_type(void) const { return 423; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PressurePerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__PressurePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressurePerTimeMeasure); }
	         eml__PressurePerTimeMeasure() { eml__PressurePerTimeMeasure::soap_default(NULL); }
	virtual ~eml__PressurePerTimeMeasure() { }
	friend eml__PressurePerTimeMeasure *soap_instantiate_eml__PressurePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1407 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthMeasure (424)
/* eml:ForcePerLengthMeasure simple type: */
class SOAP_CMAC eml__ForcePerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ForcePerLengthUom uom;	/* required attribute of XSD type eml:ForcePerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthMeasure (424)
	virtual int soap_type(void) const { return 424; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ForcePerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__ForcePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForcePerLengthMeasure); }
	         eml__ForcePerLengthMeasure() { eml__ForcePerLengthMeasure::soap_default(NULL); }
	virtual ~eml__ForcePerLengthMeasure() { }
	friend eml__ForcePerLengthMeasure *soap_instantiate_eml__ForcePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1410 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeMeasure (425)
/* eml:AmountOfSubstancePerTimeMeasure simple type: */
class SOAP_CMAC eml__AmountOfSubstancePerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AmountOfSubstancePerTimeUom uom;	/* required attribute of XSD type eml:AmountOfSubstancePerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeMeasure (425)
	virtual int soap_type(void) const { return 425; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AmountOfSubstancePerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__AmountOfSubstancePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerTimeMeasure); }
	         eml__AmountOfSubstancePerTimeMeasure() { eml__AmountOfSubstancePerTimeMeasure::soap_default(NULL); }
	virtual ~eml__AmountOfSubstancePerTimeMeasure() { }
	friend eml__AmountOfSubstancePerTimeMeasure *soap_instantiate_eml__AmountOfSubstancePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1413 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureMeasure (426)
/* eml:LengthPerTemperatureMeasure simple type: */
class SOAP_CMAC eml__LengthPerTemperatureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LengthPerTemperatureUom uom;	/* required attribute of XSD type eml:LengthPerTemperatureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureMeasure (426)
	virtual int soap_type(void) const { return 426; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LengthPerTemperatureMeasure, default initialized and not managed by a soap context
	virtual eml__LengthPerTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerTemperatureMeasure); }
	         eml__LengthPerTemperatureMeasure() { eml__LengthPerTemperatureMeasure::soap_default(NULL); }
	virtual ~eml__LengthPerTemperatureMeasure() { }
	friend eml__LengthPerTemperatureMeasure *soap_instantiate_eml__LengthPerTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1416 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthMeasure (427)
/* eml:VolumePerTimeLengthMeasure simple type: */
class SOAP_CMAC eml__VolumePerTimeLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerTimeLengthUom uom;	/* required attribute of XSD type eml:VolumePerTimeLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthMeasure (427)
	virtual int soap_type(void) const { return 427; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerTimeLengthMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerTimeLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimeLengthMeasure); }
	         eml__VolumePerTimeLengthMeasure() { eml__VolumePerTimeLengthMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerTimeLengthMeasure() { }
	friend eml__VolumePerTimeLengthMeasure *soap_instantiate_eml__VolumePerTimeLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1419 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaMeasure (428)
/* eml:PressureSquaredPerForceTimePerAreaMeasure simple type: */
class SOAP_CMAC eml__PressureSquaredPerForceTimePerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PressureSquaredPerForceTimePerAreaUom uom;	/* required attribute of XSD type eml:PressureSquaredPerForceTimePerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaMeasure (428)
	virtual int soap_type(void) const { return 428; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PressureSquaredPerForceTimePerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__PressureSquaredPerForceTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressureSquaredPerForceTimePerAreaMeasure); }
	         eml__PressureSquaredPerForceTimePerAreaMeasure() { eml__PressureSquaredPerForceTimePerAreaMeasure::soap_default(NULL); }
	virtual ~eml__PressureSquaredPerForceTimePerAreaMeasure() { }
	friend eml__PressureSquaredPerForceTimePerAreaMeasure *soap_instantiate_eml__PressureSquaredPerForceTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1422 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeMeasure (429)
/* eml:AnglePerVolumeMeasure simple type: */
class SOAP_CMAC eml__AnglePerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AnglePerVolumeUom uom;	/* required attribute of XSD type eml:AnglePerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeMeasure (429)
	virtual int soap_type(void) const { return 429; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AnglePerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__AnglePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AnglePerVolumeMeasure); }
	         eml__AnglePerVolumeMeasure() { eml__AnglePerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__AnglePerVolumeMeasure() { }
	friend eml__AnglePerVolumeMeasure *soap_instantiate_eml__AnglePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1425 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureMeasure (430)
/* eml:LengthPerPressureMeasure simple type: */
class SOAP_CMAC eml__LengthPerPressureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LengthPerPressureUom uom;	/* required attribute of XSD type eml:LengthPerPressureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureMeasure (430)
	virtual int soap_type(void) const { return 430; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LengthPerPressureMeasure, default initialized and not managed by a soap context
	virtual eml__LengthPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerPressureMeasure); }
	         eml__LengthPerPressureMeasure() { eml__LengthPerPressureMeasure::soap_default(NULL); }
	virtual ~eml__LengthPerPressureMeasure() { }
	friend eml__LengthPerPressureMeasure *soap_instantiate_eml__LengthPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1428 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityMeasure (431)
/* eml:ThermalConductivityMeasure simple type: */
class SOAP_CMAC eml__ThermalConductivityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ThermalConductivityUom uom;	/* required attribute of XSD type eml:ThermalConductivityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityMeasure (431)
	virtual int soap_type(void) const { return 431; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ThermalConductivityMeasure, default initialized and not managed by a soap context
	virtual eml__ThermalConductivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalConductivityMeasure); }
	         eml__ThermalConductivityMeasure() { eml__ThermalConductivityMeasure::soap_default(NULL); }
	virtual ~eml__ThermalConductivityMeasure() { }
	friend eml__ThermalConductivityMeasure *soap_instantiate_eml__ThermalConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1431 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassMeasure (432)
/* eml:MassMeasure simple type: */
class SOAP_CMAC eml__MassMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassUom uom;	/* required attribute of XSD type eml:MassUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassMeasure (432)
	virtual int soap_type(void) const { return 432; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassMeasure, default initialized and not managed by a soap context
	virtual eml__MassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassMeasure); }
	         eml__MassMeasure() { eml__MassMeasure::soap_default(NULL); }
	virtual ~eml__MassMeasure() { }
	friend eml__MassMeasure *soap_instantiate_eml__MassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1434 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerMeasure (433)
/* eml:NormalizedPowerMeasure simple type: */
class SOAP_CMAC eml__NormalizedPowerMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__NormalizedPowerUom uom;	/* required attribute of XSD type eml:NormalizedPowerUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerMeasure (433)
	virtual int soap_type(void) const { return 433; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__NormalizedPowerMeasure, default initialized and not managed by a soap context
	virtual eml__NormalizedPowerMeasure *soap_alloc(void) const { return SOAP_NEW(eml__NormalizedPowerMeasure); }
	         eml__NormalizedPowerMeasure() { eml__NormalizedPowerMeasure::soap_default(NULL); }
	virtual ~eml__NormalizedPowerMeasure() { }
	friend eml__NormalizedPowerMeasure *soap_instantiate_eml__NormalizedPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1437 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioMeasure (434)
/* eml:LogarithmicPowerRatioMeasure simple type: */
class SOAP_CMAC eml__LogarithmicPowerRatioMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LogarithmicPowerRatioUom uom;	/* required attribute of XSD type eml:LogarithmicPowerRatioUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioMeasure (434)
	virtual int soap_type(void) const { return 434; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LogarithmicPowerRatioMeasure, default initialized and not managed by a soap context
	virtual eml__LogarithmicPowerRatioMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LogarithmicPowerRatioMeasure); }
	         eml__LogarithmicPowerRatioMeasure() { eml__LogarithmicPowerRatioMeasure::soap_default(NULL); }
	virtual ~eml__LogarithmicPowerRatioMeasure() { }
	friend eml__LogarithmicPowerRatioMeasure *soap_instantiate_eml__LogarithmicPowerRatioMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1440 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationMeasure (435)
/* eml:AngularAccelerationMeasure simple type: */
class SOAP_CMAC eml__AngularAccelerationMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AngularAccelerationUom uom;	/* required attribute of XSD type eml:AngularAccelerationUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationMeasure (435)
	virtual int soap_type(void) const { return 435; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AngularAccelerationMeasure, default initialized and not managed by a soap context
	virtual eml__AngularAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AngularAccelerationMeasure); }
	         eml__AngularAccelerationMeasure() { eml__AngularAccelerationMeasure::soap_default(NULL); }
	virtual ~eml__AngularAccelerationMeasure() { }
	friend eml__AngularAccelerationMeasure *soap_instantiate_eml__AngularAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1443 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassMeasure (436)
/* eml:ReciprocalMassMeasure simple type: */
class SOAP_CMAC eml__ReciprocalMassMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReciprocalMassUom uom;	/* required attribute of XSD type eml:ReciprocalMassUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassMeasure (436)
	virtual int soap_type(void) const { return 436; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReciprocalMassMeasure, default initialized and not managed by a soap context
	virtual eml__ReciprocalMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalMassMeasure); }
	         eml__ReciprocalMassMeasure() { eml__ReciprocalMassMeasure::soap_default(NULL); }
	virtual ~eml__ReciprocalMassMeasure() { }
	friend eml__ReciprocalMassMeasure *soap_instantiate_eml__ReciprocalMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1446 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceMeasure (437)
/* eml:ReciprocalForceMeasure simple type: */
class SOAP_CMAC eml__ReciprocalForceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ReciprocalForceUom uom;	/* required attribute of XSD type eml:ReciprocalForceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceMeasure (437)
	virtual int soap_type(void) const { return 437; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ReciprocalForceMeasure, default initialized and not managed by a soap context
	virtual eml__ReciprocalForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalForceMeasure); }
	         eml__ReciprocalForceMeasure() { eml__ReciprocalForceMeasure::soap_default(NULL); }
	virtual ~eml__ReciprocalForceMeasure() { }
	friend eml__ReciprocalForceMeasure *soap_instantiate_eml__ReciprocalForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1449 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleMeasure (438)
/* eml:PlaneAngleMeasure simple type: */
class SOAP_CMAC eml__PlaneAngleMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PlaneAngleUom uom;	/* required attribute of XSD type eml:PlaneAngleUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleMeasure (438)
	virtual int soap_type(void) const { return 438; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PlaneAngleMeasure, default initialized and not managed by a soap context
	virtual eml__PlaneAngleMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PlaneAngleMeasure); }
	         eml__PlaneAngleMeasure() { eml__PlaneAngleMeasure::soap_default(NULL); }
	virtual ~eml__PlaneAngleMeasure() { }
	friend eml__PlaneAngleMeasure *soap_instantiate_eml__PlaneAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1452 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaMeasure (439)
/* eml:EnergyLengthPerAreaMeasure simple type: */
class SOAP_CMAC eml__EnergyLengthPerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__EnergyLengthPerAreaUom uom;	/* required attribute of XSD type eml:EnergyLengthPerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaMeasure (439)
	virtual int soap_type(void) const { return 439; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__EnergyLengthPerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__EnergyLengthPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyLengthPerAreaMeasure); }
	         eml__EnergyLengthPerAreaMeasure() { eml__EnergyLengthPerAreaMeasure::soap_default(NULL); }
	virtual ~eml__EnergyLengthPerAreaMeasure() { }
	friend eml__EnergyLengthPerAreaMeasure *soap_instantiate_eml__EnergyLengthPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1455 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassMeasure (440)
/* eml:EnergyPerMassMeasure simple type: */
class SOAP_CMAC eml__EnergyPerMassMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__EnergyPerMassUom uom;	/* required attribute of XSD type eml:EnergyPerMassUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassMeasure (440)
	virtual int soap_type(void) const { return 440; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__EnergyPerMassMeasure, default initialized and not managed by a soap context
	virtual eml__EnergyPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerMassMeasure); }
	         eml__EnergyPerMassMeasure() { eml__EnergyPerMassMeasure::soap_default(NULL); }
	virtual ~eml__EnergyPerMassMeasure() { }
	friend eml__EnergyPerMassMeasure *soap_instantiate_eml__EnergyPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1458 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityMeasure (441)
/* eml:AngularVelocityMeasure simple type: */
class SOAP_CMAC eml__AngularVelocityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AngularVelocityUom uom;	/* required attribute of XSD type eml:AngularVelocityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityMeasure (441)
	virtual int soap_type(void) const { return 441; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AngularVelocityMeasure, default initialized and not managed by a soap context
	virtual eml__AngularVelocityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AngularVelocityMeasure); }
	         eml__AngularVelocityMeasure() { eml__AngularVelocityMeasure::soap_default(NULL); }
	virtual ~eml__AngularVelocityMeasure() { }
	friend eml__AngularVelocityMeasure *soap_instantiate_eml__AngularVelocityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1461 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityMeasure (442)
/* eml:ElectricConductivityMeasure simple type: */
class SOAP_CMAC eml__ElectricConductivityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricConductivityUom uom;	/* required attribute of XSD type eml:ElectricConductivityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityMeasure (442)
	virtual int soap_type(void) const { return 442; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricConductivityMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricConductivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricConductivityMeasure); }
	         eml__ElectricConductivityMeasure() { eml__ElectricConductivityMeasure::soap_default(NULL); }
	virtual ~eml__ElectricConductivityMeasure() { }
	friend eml__ElectricConductivityMeasure *soap_instantiate_eml__ElectricConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1464 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceMeasure (443)
/* eml:AmountOfSubstancePerAmountOfSubstanceMeasure simple type: */
class SOAP_CMAC eml__AmountOfSubstancePerAmountOfSubstanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AmountOfSubstancePerAmountOfSubstanceUom uom;	/* required attribute of XSD type eml:AmountOfSubstancePerAmountOfSubstanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceMeasure (443)
	virtual int soap_type(void) const { return 443; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AmountOfSubstancePerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
	virtual eml__AmountOfSubstancePerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerAmountOfSubstanceMeasure); }
	         eml__AmountOfSubstancePerAmountOfSubstanceMeasure() { eml__AmountOfSubstancePerAmountOfSubstanceMeasure::soap_default(NULL); }
	virtual ~eml__AmountOfSubstancePerAmountOfSubstanceMeasure() { }
	friend eml__AmountOfSubstancePerAmountOfSubstanceMeasure *soap_instantiate_eml__AmountOfSubstancePerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1467 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthMeasure (444)
/* eml:ElectricFieldStrengthMeasure simple type: */
class SOAP_CMAC eml__ElectricFieldStrengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricFieldStrengthUom uom;	/* required attribute of XSD type eml:ElectricFieldStrengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthMeasure (444)
	virtual int soap_type(void) const { return 444; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricFieldStrengthMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricFieldStrengthMeasure); }
	         eml__ElectricFieldStrengthMeasure() { eml__ElectricFieldStrengthMeasure::soap_default(NULL); }
	virtual ~eml__ElectricFieldStrengthMeasure() { }
	friend eml__ElectricFieldStrengthMeasure *soap_instantiate_eml__ElectricFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1470 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaMeasure (445)
/* eml:PowerPerAreaMeasure simple type: */
class SOAP_CMAC eml__PowerPerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PowerPerAreaUom uom;	/* required attribute of XSD type eml:PowerPerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaMeasure (445)
	virtual int soap_type(void) const { return 445; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PowerPerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__PowerPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PowerPerAreaMeasure); }
	         eml__PowerPerAreaMeasure() { eml__PowerPerAreaMeasure::soap_default(NULL); }
	virtual ~eml__PowerPerAreaMeasure() { }
	friend eml__PowerPerAreaMeasure *soap_instantiate_eml__PowerPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1473 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthMeasure (446)
/* eml:MagneticFluxDensityPerLengthMeasure simple type: */
class SOAP_CMAC eml__MagneticFluxDensityPerLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MagneticFluxDensityPerLengthUom uom;	/* required attribute of XSD type eml:MagneticFluxDensityPerLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthMeasure (446)
	virtual int soap_type(void) const { return 446; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MagneticFluxDensityPerLengthMeasure, default initialized and not managed by a soap context
	virtual eml__MagneticFluxDensityPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticFluxDensityPerLengthMeasure); }
	         eml__MagneticFluxDensityPerLengthMeasure() { eml__MagneticFluxDensityPerLengthMeasure::soap_default(NULL); }
	virtual ~eml__MagneticFluxDensityPerLengthMeasure() { }
	friend eml__MagneticFluxDensityPerLengthMeasure *soap_instantiate_eml__MagneticFluxDensityPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1476 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureMeasure (447)
/* eml:PressureMeasure simple type: */
class SOAP_CMAC eml__PressureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PressureUom uom;	/* required attribute of XSD type eml:PressureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureMeasure (447)
	virtual int soap_type(void) const { return 447; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PressureMeasure, default initialized and not managed by a soap context
	virtual eml__PressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressureMeasure); }
	         eml__PressureMeasure() { eml__PressureMeasure::soap_default(NULL); }
	virtual ~eml__PressureMeasure() { }
	friend eml__PressureMeasure *soap_instantiate_eml__PressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1479 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthMeasure (448)
/* eml:VolumePerTimePerPressureLengthMeasure simple type: */
class SOAP_CMAC eml__VolumePerTimePerPressureLengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerTimePerPressureLengthUom uom;	/* required attribute of XSD type eml:VolumePerTimePerPressureLengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthMeasure (448)
	virtual int soap_type(void) const { return 448; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerTimePerPressureLengthMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerTimePerPressureLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerPressureLengthMeasure); }
	         eml__VolumePerTimePerPressureLengthMeasure() { eml__VolumePerTimePerPressureLengthMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerTimePerPressureLengthMeasure() { }
	friend eml__VolumePerTimePerPressureLengthMeasure *soap_instantiate_eml__VolumePerTimePerPressureLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1482 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthMeasure (449)
/* eml:MagneticFieldStrengthMeasure simple type: */
class SOAP_CMAC eml__MagneticFieldStrengthMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MagneticFieldStrengthUom uom;	/* required attribute of XSD type eml:MagneticFieldStrengthUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthMeasure (449)
	virtual int soap_type(void) const { return 449; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MagneticFieldStrengthMeasure, default initialized and not managed by a soap context
	virtual eml__MagneticFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticFieldStrengthMeasure); }
	         eml__MagneticFieldStrengthMeasure() { eml__MagneticFieldStrengthMeasure::soap_default(NULL); }
	virtual ~eml__MagneticFieldStrengthMeasure() { }
	friend eml__MagneticFieldStrengthMeasure *soap_instantiate_eml__MagneticFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1485 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockMeasure (450)
/* eml:PermeabilityRockMeasure simple type: */
class SOAP_CMAC eml__PermeabilityRockMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__PermeabilityRockUom uom;	/* required attribute of XSD type eml:PermeabilityRockUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockMeasure (450)
	virtual int soap_type(void) const { return 450; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__PermeabilityRockMeasure, default initialized and not managed by a soap context
	virtual eml__PermeabilityRockMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PermeabilityRockMeasure); }
	         eml__PermeabilityRockMeasure() { eml__PermeabilityRockMeasure::soap_default(NULL); }
	virtual ~eml__PermeabilityRockMeasure() { }
	friend eml__PermeabilityRockMeasure *soap_instantiate_eml__PermeabilityRockMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1488 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentMeasure (451)
/* eml:DoseEquivalentMeasure simple type: */
class SOAP_CMAC eml__DoseEquivalentMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__DoseEquivalentUom uom;	/* required attribute of XSD type eml:DoseEquivalentUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentMeasure (451)
	virtual int soap_type(void) const { return 451; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__DoseEquivalentMeasure, default initialized and not managed by a soap context
	virtual eml__DoseEquivalentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DoseEquivalentMeasure); }
	         eml__DoseEquivalentMeasure() { eml__DoseEquivalentMeasure::soap_default(NULL); }
	virtual ~eml__DoseEquivalentMeasure() { }
	friend eml__DoseEquivalentMeasure *soap_instantiate_eml__DoseEquivalentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1491 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaMeasure (452)
/* eml:MassPerTimePerAreaMeasure simple type: */
class SOAP_CMAC eml__MassPerTimePerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassPerTimePerAreaUom uom;	/* required attribute of XSD type eml:MassPerTimePerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaMeasure (452)
	virtual int soap_type(void) const { return 452; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassPerTimePerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__MassPerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerTimePerAreaMeasure); }
	         eml__MassPerTimePerAreaMeasure() { eml__MassPerTimePerAreaMeasure::soap_default(NULL); }
	virtual ~eml__MassPerTimePerAreaMeasure() { }
	friend eml__MassPerTimePerAreaMeasure *soap_instantiate_eml__MassPerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1494 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureMeasure (453)
/* eml:VolumePerPressureMeasure simple type: */
class SOAP_CMAC eml__VolumePerPressureMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerPressureUom uom;	/* required attribute of XSD type eml:VolumePerPressureUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureMeasure (453)
	virtual int soap_type(void) const { return 453; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerPressureMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerPressureMeasure); }
	         eml__VolumePerPressureMeasure() { eml__VolumePerPressureMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerPressureMeasure() { }
	friend eml__VolumePerPressureMeasure *soap_instantiate_eml__VolumePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1497 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaMeasure (454)
/* eml:MassPerAreaMeasure simple type: */
class SOAP_CMAC eml__MassPerAreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MassPerAreaUom uom;	/* required attribute of XSD type eml:MassPerAreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaMeasure (454)
	virtual int soap_type(void) const { return 454; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MassPerAreaMeasure, default initialized and not managed by a soap context
	virtual eml__MassPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerAreaMeasure); }
	         eml__MassPerAreaMeasure() { eml__MassPerAreaMeasure::soap_default(NULL); }
	virtual ~eml__MassPerAreaMeasure() { }
	friend eml__MassPerAreaMeasure *soap_instantiate_eml__MassPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1500 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeMeasure (455)
/* eml:AmountOfSubstancePerVolumeMeasure simple type: */
class SOAP_CMAC eml__AmountOfSubstancePerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AmountOfSubstancePerVolumeUom uom;	/* required attribute of XSD type eml:AmountOfSubstancePerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeMeasure (455)
	virtual int soap_type(void) const { return 455; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AmountOfSubstancePerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__AmountOfSubstancePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerVolumeMeasure); }
	         eml__AmountOfSubstancePerVolumeMeasure() { eml__AmountOfSubstancePerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__AmountOfSubstancePerVolumeMeasure() { }
	friend eml__AmountOfSubstancePerVolumeMeasure *soap_instantiate_eml__AmountOfSubstancePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1503 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeMeasure (456)
/* eml:TimePerTimeMeasure simple type: */
class SOAP_CMAC eml__TimePerTimeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__TimePerTimeUom uom;	/* required attribute of XSD type eml:TimePerTimeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeMeasure (456)
	virtual int soap_type(void) const { return 456; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__TimePerTimeMeasure, default initialized and not managed by a soap context
	virtual eml__TimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimePerTimeMeasure); }
	         eml__TimePerTimeMeasure() { eml__TimePerTimeMeasure::soap_default(NULL); }
	virtual ~eml__TimePerTimeMeasure() { }
	friend eml__TimePerTimeMeasure *soap_instantiate_eml__TimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1506 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeMeasure (457)
/* eml:AreaPerVolumeMeasure simple type: */
class SOAP_CMAC eml__AreaPerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AreaPerVolumeUom uom;	/* required attribute of XSD type eml:AreaPerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeMeasure (457)
	virtual int soap_type(void) const { return 457; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AreaPerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__AreaPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerVolumeMeasure); }
	         eml__AreaPerVolumeMeasure() { eml__AreaPerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__AreaPerVolumeMeasure() { }
	friend eml__AreaPerVolumeMeasure *soap_instantiate_eml__AreaPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1509 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceMeasure (458)
/* eml:ElectricResistanceMeasure simple type: */
class SOAP_CMAC eml__ElectricResistanceMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__ElectricResistanceUom uom;	/* required attribute of XSD type eml:ElectricResistanceUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceMeasure (458)
	virtual int soap_type(void) const { return 458; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__ElectricResistanceMeasure, default initialized and not managed by a soap context
	virtual eml__ElectricResistanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricResistanceMeasure); }
	         eml__ElectricResistanceMeasure() { eml__ElectricResistanceMeasure::soap_default(NULL); }
	virtual ~eml__ElectricResistanceMeasure() { }
	friend eml__ElectricResistanceMeasure *soap_instantiate_eml__ElectricResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1512 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeMeasure (459)
/* eml:VolumePerVolumeMeasure simple type: */
class SOAP_CMAC eml__VolumePerVolumeMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__VolumePerVolumeUom uom;	/* required attribute of XSD type eml:VolumePerVolumeUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeMeasure (459)
	virtual int soap_type(void) const { return 459; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__VolumePerVolumeMeasure, default initialized and not managed by a soap context
	virtual eml__VolumePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerVolumeMeasure); }
	         eml__VolumePerVolumeMeasure() { eml__VolumePerVolumeMeasure::soap_default(NULL); }
	virtual ~eml__VolumePerVolumeMeasure() { }
	friend eml__VolumePerVolumeMeasure *soap_instantiate_eml__VolumePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1515 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaMeasure (460)
/* eml:AreaMeasure simple type: */
class SOAP_CMAC eml__AreaMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__AreaUom uom;	/* required attribute of XSD type eml:AreaUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaMeasure (460)
	virtual int soap_type(void) const { return 460; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__AreaMeasure, default initialized and not managed by a soap context
	virtual eml__AreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaMeasure); }
	         eml__AreaMeasure() { eml__AreaMeasure::soap_default(NULL); }
	virtual ~eml__AreaMeasure() { }
	friend eml__AreaMeasure *soap_instantiate_eml__AreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1518 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassMeasure (461)
/* eml:LengthPerMassMeasure simple type: */
class SOAP_CMAC eml__LengthPerMassMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__LengthPerMassUom uom;	/* required attribute of XSD type eml:LengthPerMassUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassMeasure (461)
	virtual int soap_type(void) const { return 461; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__LengthPerMassMeasure, default initialized and not managed by a soap context
	virtual eml__LengthPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerMassMeasure); }
	         eml__LengthPerMassMeasure() { eml__LengthPerMassMeasure::soap_default(NULL); }
	virtual ~eml__LengthPerMassMeasure() { }
	friend eml__LengthPerMassMeasure *soap_instantiate_eml__LengthPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1521 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityMeasure (462)
/* eml:MobilityMeasure simple type: */
class SOAP_CMAC eml__MobilityMeasure
{
public:
	double __item;	/* mixed XML content */
	enum eml__MobilityUom uom;	/* required attribute of XSD type eml:MobilityUom */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityMeasure (462)
	virtual int soap_type(void) const { return 462; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type eml__MobilityMeasure, default initialized and not managed by a soap context
	virtual eml__MobilityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MobilityMeasure); }
	         eml__MobilityMeasure() { eml__MobilityMeasure::soap_default(NULL); }
	virtual ~eml__MobilityMeasure() { }
	friend eml__MobilityMeasure *soap_instantiate_eml__MobilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1533 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionType (466)
/* Type gml__DefinitionType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:DefinitionType complex type: */
class SOAP_CMAC gml__DefinitionType : public gml__DefinitionBaseType
{
public:
	std::string *remarks;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionType (466)
	virtual int soap_type(void) const { return 466; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__DefinitionType, default initialized and not managed by a soap context
	virtual gml__DefinitionType *soap_alloc(void) const { return SOAP_NEW(gml__DefinitionType); }
	         gml__DefinitionType() { gml__DefinitionType::soap_default(NULL); }
	virtual ~gml__DefinitionType() { }
	friend gml__DefinitionType *soap_instantiate_gml__DefinitionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1548 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeWithAuthorityType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeWithAuthorityType (471)
/* gml:CodeWithAuthorityType simple type: */
class SOAP_CMAC gml__CodeWithAuthorityType
{
public:
	std::string __item;	/* mixed XML content */
	std::string codeSpace;	/* required attribute of XSD type xsd:anyURI */
	std::string *codeSpace_;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeWithAuthorityType (471)
	virtual int soap_type(void) const { return 471; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CodeWithAuthorityType, default initialized and not managed by a soap context
	virtual gml__CodeWithAuthorityType *soap_alloc(void) const { return SOAP_NEW(gml__CodeWithAuthorityType); }
	         gml__CodeWithAuthorityType() { gml__CodeWithAuthorityType::soap_default(NULL); }
	virtual ~gml__CodeWithAuthorityType() { }
	friend gml__CodeWithAuthorityType *soap_instantiate_gml__CodeWithAuthorityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1554 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimePrimitiveType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimePrimitiveType (473)
/* Type gml__AbstractTimePrimitiveType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractTimePrimitiveType complex type: */
class SOAP_CMAC gml__AbstractTimePrimitiveType : public gml__AbstractTimeObjectType
{
public:
	std::vector<gml__RelatedTimeType *> relatedTime;	/* optional element of XSD type gml:RelatedTimeType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimePrimitiveType (473)
	virtual int soap_type(void) const { return 473; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractTimePrimitiveType, default initialized and not managed by a soap context
	virtual gml__AbstractTimePrimitiveType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractTimePrimitiveType); }
	         gml__AbstractTimePrimitiveType() { gml__AbstractTimePrimitiveType::soap_default(NULL); }
	virtual ~gml__AbstractTimePrimitiveType() { }
	friend gml__AbstractTimePrimitiveType *soap_instantiate_gml__AbstractTimePrimitiveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1608 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AngleType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AngleType (491)
/* Type gml__AngleType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AngleType simple type: */
class SOAP_CMAC gml__AngleType : public gml__MeasureType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AngleType (491)
	virtual int soap_type(void) const { return 491; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AngleType, default initialized and not managed by a soap context
	virtual gml__AngleType *soap_alloc(void) const { return SOAP_NEW(gml__AngleType); }
	         gml__AngleType() { gml__AngleType::soap_default(NULL); }
	virtual ~gml__AngleType() { }
	friend gml__AngleType *soap_instantiate_gml__AngleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1620 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__LengthType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__LengthType (495)
/* Type gml__LengthType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:LengthType simple type: */
class SOAP_CMAC gml__LengthType : public gml__MeasureType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__LengthType (495)
	virtual int soap_type(void) const { return 495; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__LengthType, default initialized and not managed by a soap context
	virtual gml__LengthType *soap_alloc(void) const { return SOAP_NEW(gml__LengthType); }
	         gml__LengthType() { gml__LengthType::soap_default(NULL); }
	virtual ~gml__LengthType() { }
	friend gml__LengthType *soap_instantiate_gml__LengthType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1692 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType (519)
/* Type gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:AbstractDQ_PositionalAccuracy_Type complex type: */
class SOAP_CMAC gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType : public gmd__AbstractDQ_USCOREElement_USCOREType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType (519)
	virtual int soap_type(void) const { return 519; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType, default initialized and not managed by a soap context
	virtual gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType); }
	         gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType() { gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType::soap_default(NULL); }
	virtual ~gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType() { }
	friend gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType *soap_instantiate_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:258 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertyKind (41)
/* Type resqml2__obj_USCOREPropertyKind is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_PropertyKind complex type: */
class SOAP_CMAC resqml2__obj_USCOREPropertyKind : public resqml2__AbstractResqmlDataObject
{
public:
	std::string NamingSystem;	/* required element of XSD type xsd:anyURI */
	bool IsAbstract;	/* required element of XSD type xsd:boolean */
	enum resqml2__ResqmlUom RepresentativeUom;	/* required element of XSD type resqml2:ResqmlUom */
	resqml2__AbstractPropertyKind *ParentPropertyKind;	/* required element of XSD type resqml2:AbstractPropertyKind */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertyKind (41)
	virtual int soap_type(void) const { return 41; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREPropertyKind, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREPropertyKind *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPropertyKind); }
	         resqml2__obj_USCOREPropertyKind() { resqml2__obj_USCOREPropertyKind::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREPropertyKind() { }
	friend resqml2__obj_USCOREPropertyKind *soap_instantiate_resqml2__obj_USCOREPropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:279 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyLookup (48)
/* Type resqml2__AbstractPropertyLookup is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractPropertyLookup complex type: */
class SOAP_CMAC resqml2__AbstractPropertyLookup : public resqml2__AbstractResqmlDataObject
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyLookup (48)
	virtual int soap_type(void) const { return 48; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractPropertyLookup, default initialized and not managed by a soap context
	virtual resqml2__AbstractPropertyLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractPropertyLookup); }
	         resqml2__AbstractPropertyLookup() { resqml2__AbstractPropertyLookup::soap_default(NULL); }
	virtual ~resqml2__AbstractPropertyLookup() { }
	friend resqml2__AbstractPropertyLookup *soap_instantiate_resqml2__AbstractPropertyLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:285 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertySet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertySet (50)
/* Type resqml2__obj_USCOREPropertySet is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_PropertySet complex type: */
class SOAP_CMAC resqml2__obj_USCOREPropertySet : public resqml2__AbstractResqmlDataObject
{
public:
	enum resqml2__TimeSetKind TimeSetKind;	/* required element of XSD type resqml2:TimeSetKind */
	bool HasSinglePropertyKind;	/* required element of XSD type xsd:boolean */
	bool HasMultipleRealizations;	/* required element of XSD type xsd:boolean */
	std::vector<eml__DataObjectReference *> ParentSet;	/* optional element of XSD type eml:DataObjectReference */
	std::vector<eml__DataObjectReference *> Properties;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertySet (50)
	virtual int soap_type(void) const { return 50; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREPropertySet, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREPropertySet *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPropertySet); }
	         resqml2__obj_USCOREPropertySet() { resqml2__obj_USCOREPropertySet::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREPropertySet() { }
	friend resqml2__obj_USCOREPropertySet *soap_instantiate_resqml2__obj_USCOREPropertySet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:288 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractProperty (51)
/* Type resqml2__AbstractProperty is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractProperty complex type: */
class SOAP_CMAC resqml2__AbstractProperty : public resqml2__AbstractResqmlDataObject
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	enum resqml2__IndexableElements IndexableElement;	/* required element of XSD type resqml2:IndexableElements */
	ULONG64 *RealizationIndex;	/* optional element of XSD type xsd:nonNegativeInteger */
	ULONG64 *TimeStep;	/* optional element of XSD type xsd:nonNegativeInteger */
	resqml2__TimeIndex *TimeIndex;	/* optional element of XSD type resqml2:TimeIndex */
	eml__DataObjectReference *SupportingRepresentation;	/* required element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *LocalCrs;	/* optional element of XSD type eml:DataObjectReference */
	resqml2__AbstractPropertyKind *PropertyKind;	/* required element of XSD type resqml2:AbstractPropertyKind */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractProperty (51)
	virtual int soap_type(void) const { return 51; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractProperty, default initialized and not managed by a soap context
	virtual resqml2__AbstractProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractProperty); }
	         resqml2__AbstractProperty() { resqml2__AbstractProperty::soap_default(NULL); }
	virtual ~resqml2__AbstractProperty() { }
	friend resqml2__AbstractProperty *soap_instantiate_resqml2__AbstractProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:408 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationIdentitySet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationIdentitySet (91)
/* Type resqml2__obj_USCORERepresentationIdentitySet is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_RepresentationIdentitySet complex type: */
class SOAP_CMAC resqml2__obj_USCORERepresentationIdentitySet : public resqml2__AbstractResqmlDataObject
{
public:
	std::vector<resqml2__RepresentationIdentity *> RepresentationIdentity;	/* required element of XSD type resqml2:RepresentationIdentity */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationIdentitySet (91)
	virtual int soap_type(void) const { return 91; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORERepresentationIdentitySet, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORERepresentationIdentitySet *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERepresentationIdentitySet); }
	         resqml2__obj_USCORERepresentationIdentitySet() { resqml2__obj_USCORERepresentationIdentitySet::soap_default(NULL); }
	virtual ~resqml2__obj_USCORERepresentationIdentitySet() { }
	friend resqml2__obj_USCORERepresentationIdentitySet *soap_instantiate_resqml2__obj_USCORERepresentationIdentitySet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:414 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractRepresentation (93)
/* Type resqml2__AbstractRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractRepresentation complex type: */
class SOAP_CMAC resqml2__AbstractRepresentation : public resqml2__AbstractResqmlDataObject
{
public:
	eml__DataObjectReference *RepresentedInterpretation;	/* optional element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractRepresentation (93)
	virtual int soap_type(void) const { return 93; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractRepresentation, default initialized and not managed by a soap context
	virtual resqml2__AbstractRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractRepresentation); }
	         resqml2__AbstractRepresentation() { resqml2__AbstractRepresentation::soap_default(NULL); }
	virtual ~resqml2__AbstractRepresentation() { }
	friend resqml2__AbstractRepresentation *soap_instantiate_resqml2__AbstractRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:444 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalGridSet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalGridSet (103)
/* Type resqml2__obj_USCORELocalGridSet is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_LocalGridSet complex type: */
class SOAP_CMAC resqml2__obj_USCORELocalGridSet : public resqml2__AbstractResqmlDataObject
{
public:
	resqml2__Activation *Activation;	/* optional element of XSD type resqml2:Activation */
	std::vector<eml__DataObjectReference *> ChildGrid;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalGridSet (103)
	virtual int soap_type(void) const { return 103; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORELocalGridSet, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORELocalGridSet *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORELocalGridSet); }
	         resqml2__obj_USCORELocalGridSet() { resqml2__obj_USCORELocalGridSet::soap_default(NULL); }
	virtual ~resqml2__obj_USCORELocalGridSet() { }
	friend resqml2__obj_USCORELocalGridSet *soap_instantiate_resqml2__obj_USCORELocalGridSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:537 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridGeometry (134)
/* Type resqml2__UnstructuredGridGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:UnstructuredGridGeometry complex type: */
class SOAP_CMAC resqml2__UnstructuredGridGeometry : public resqml2__AbstractGridGeometry
{
public:
	enum resqml2__CellShape CellShape;	/* required element of XSD type resqml2:CellShape */
	ULONG64 NodeCount;	/* required element of XSD type xsd:positiveInteger */
	ULONG64 FaceCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__ResqmlJaggedArray *NodesPerFace;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	resqml2__ResqmlJaggedArray *FacesPerCell;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	resqml2__AbstractBooleanArray *CellFaceIsRightHanded;	/* required element of XSD type resqml2:AbstractBooleanArray */
	resqml2__UnstructuredGridHingeNodeFaces *HingeNodeFaces;	/* optional element of XSD type resqml2:UnstructuredGridHingeNodeFaces */
	resqml2__UnstructuredSubnodeTopology *SubnodeTopology;	/* optional element of XSD type resqml2:UnstructuredSubnodeTopology */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridGeometry (134)
	virtual int soap_type(void) const { return 134; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__UnstructuredGridGeometry, default initialized and not managed by a soap context
	virtual resqml2__UnstructuredGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredGridGeometry); }
	         resqml2__UnstructuredGridGeometry() { resqml2__UnstructuredGridGeometry::soap_default(NULL); }
	virtual ~resqml2__UnstructuredGridGeometry() { }
	friend resqml2__UnstructuredGridGeometry *soap_instantiate_resqml2__UnstructuredGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:582 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridGeometry (149)
/* Type resqml2__AbstractColumnLayerGridGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractColumnLayerGridGeometry complex type: */
class SOAP_CMAC resqml2__AbstractColumnLayerGridGeometry : public resqml2__AbstractGridGeometry
{
public:
	enum resqml2__KDirection KDirection;	/* required element of XSD type resqml2:KDirection */
	resqml2__AbstractBooleanArray *PillarGeometryIsDefined;	/* required element of XSD type resqml2:AbstractBooleanArray */
	enum resqml2__PillarShape PillarShape;	/* required element of XSD type resqml2:PillarShape */
	resqml2__AbstractBooleanArray *CellGeometryIsDefined;	/* optional element of XSD type resqml2:AbstractBooleanArray */
	resqml2__AbstractBooleanArray *NodeIsColocatedInKDirection;	/* optional element of XSD type resqml2:AbstractBooleanArray */
	resqml2__AbstractBooleanArray *NodeIsColocatedOnKEdge;	/* optional element of XSD type resqml2:AbstractBooleanArray */
	resqml2__ColumnLayerSubnodeTopology *SubnodeTopology;	/* optional element of XSD type resqml2:ColumnLayerSubnodeTopology */
	resqml2__ColumnLayerSplitCoordinateLines *SplitCoordinateLines;	/* optional element of XSD type resqml2:ColumnLayerSplitCoordinateLines */
	resqml2__SplitNodePatch *SplitNodes;	/* optional element of XSD type resqml2:SplitNodePatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridGeometry (149)
	virtual int soap_type(void) const { return 149; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractColumnLayerGridGeometry, default initialized and not managed by a soap context
	virtual resqml2__AbstractColumnLayerGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractColumnLayerGridGeometry); }
	         resqml2__AbstractColumnLayerGridGeometry() { resqml2__AbstractColumnLayerGridGeometry::soap_default(NULL); }
	virtual ~resqml2__AbstractColumnLayerGridGeometry() { }
	friend resqml2__AbstractColumnLayerGridGeometry *soap_instantiate_resqml2__AbstractColumnLayerGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:588 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeatureInterpretation (151)
/* Type resqml2__AbstractFeatureInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractFeatureInterpretation complex type: */
class SOAP_CMAC resqml2__AbstractFeatureInterpretation : public resqml2__AbstractResqmlDataObject
{
public:
	enum resqml2__Domain Domain;	/* required element of XSD type resqml2:Domain */
	eml__DataObjectReference *InterpretedFeature;	/* required element of XSD type eml:DataObjectReference */
	resqml2__TimeInterval *HasOccuredDuring;	/* optional element of XSD type resqml2:TimeInterval */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeatureInterpretation (151)
	virtual int soap_type(void) const { return 151; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractFeatureInterpretation, default initialized and not managed by a soap context
	virtual resqml2__AbstractFeatureInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractFeatureInterpretation); }
	         resqml2__AbstractFeatureInterpretation() { resqml2__AbstractFeatureInterpretation::soap_default(NULL); }
	virtual ~resqml2__AbstractFeatureInterpretation() { }
	friend resqml2__AbstractFeatureInterpretation *soap_instantiate_resqml2__AbstractFeatureInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:636 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumn (167)
/* Type resqml2__obj_USCOREStratigraphicColumn is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_StratigraphicColumn complex type: */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicColumn : public resqml2__AbstractResqmlDataObject
{
public:
	std::vector<eml__DataObjectReference *> Ranks;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumn (167)
	virtual int soap_type(void) const { return 167; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREStratigraphicColumn, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREStratigraphicColumn *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicColumn); }
	         resqml2__obj_USCOREStratigraphicColumn() { resqml2__obj_USCOREStratigraphicColumn::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREStratigraphicColumn() { }
	friend resqml2__obj_USCOREStratigraphicColumn *soap_instantiate_resqml2__obj_USCOREStratigraphicColumn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:690 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGlobalChronostratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGlobalChronostratigraphicColumn (185)
/* Type resqml2__obj_USCOREGlobalChronostratigraphicColumn is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GlobalChronostratigraphicColumn complex type: */
class SOAP_CMAC resqml2__obj_USCOREGlobalChronostratigraphicColumn : public resqml2__AbstractResqmlDataObject
{
public:
	std::vector<resqml2__ChronostratigraphicRank *> ChronostratigraphicColumnComponent;	/* required element of XSD type resqml2:ChronostratigraphicRank */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGlobalChronostratigraphicColumn (185)
	virtual int soap_type(void) const { return 185; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGlobalChronostratigraphicColumn, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGlobalChronostratigraphicColumn *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGlobalChronostratigraphicColumn); }
	         resqml2__obj_USCOREGlobalChronostratigraphicColumn() { resqml2__obj_USCOREGlobalChronostratigraphicColumn::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGlobalChronostratigraphicColumn() { }
	friend resqml2__obj_USCOREGlobalChronostratigraphicColumn *soap_instantiate_resqml2__obj_USCOREGlobalChronostratigraphicColumn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:711 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeature (192)
/* Type resqml2__AbstractFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractFeature complex type: */
class SOAP_CMAC resqml2__AbstractFeature : public resqml2__AbstractResqmlDataObject
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeature (192)
	virtual int soap_type(void) const { return 192; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractFeature, default initialized and not managed by a soap context
	virtual resqml2__AbstractFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractFeature); }
	         resqml2__AbstractFeature() { resqml2__AbstractFeature::soap_default(NULL); }
	virtual ~resqml2__AbstractFeature() { }
	friend resqml2__AbstractFeature *soap_instantiate_resqml2__AbstractFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:729 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractLocal3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractLocal3dCrs (198)
/* Type resqml2__AbstractLocal3dCrs is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractLocal3dCrs complex type: */
class SOAP_CMAC resqml2__AbstractLocal3dCrs : public resqml2__AbstractResqmlDataObject
{
public:
	double YOffset;	/* required element of XSD type xsd:double */
	double ZOffset;	/* required element of XSD type xsd:double */
	eml__PlaneAngleMeasure *ArealRotation;	/* required element of XSD type eml:PlaneAngleMeasure */
	enum eml__AxisOrder2d ProjectedAxisOrder;	/* required element of XSD type eml:AxisOrder2d */
	enum eml__LengthUom ProjectedUom;	/* required element of XSD type eml:LengthUom */
	enum eml__LengthUom VerticalUom;	/* required element of XSD type eml:LengthUom */
	double XOffset;	/* required element of XSD type xsd:double */
	bool ZIncreasingDownward;	/* required element of XSD type xsd:boolean */
	eml__AbstractVerticalCrs *VerticalCrs;	/* required element of XSD type eml:AbstractVerticalCrs */
	eml__AbstractProjectedCrs *ProjectedCrs;	/* required element of XSD type eml:AbstractProjectedCrs */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractLocal3dCrs (198)
	virtual int soap_type(void) const { return 198; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractLocal3dCrs, default initialized and not managed by a soap context
	virtual resqml2__AbstractLocal3dCrs *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractLocal3dCrs); }
	         resqml2__AbstractLocal3dCrs() { resqml2__AbstractLocal3dCrs::soap_default(NULL); }
	virtual ~resqml2__AbstractLocal3dCrs() { }
	friend resqml2__AbstractLocal3dCrs *soap_instantiate_resqml2__AbstractLocal3dCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:741 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETimeSeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETimeSeries (202)
/* Type resqml2__obj_USCORETimeSeries is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_TimeSeries complex type: */
class SOAP_CMAC resqml2__obj_USCORETimeSeries : public resqml2__AbstractResqmlDataObject
{
public:
	std::vector<resqml2__Timestamp *> Time;	/* required element of XSD type resqml2:Timestamp */
	resqml2__TimeSeriesParentage *TimeSeriesParentage;	/* optional element of XSD type resqml2:TimeSeriesParentage */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETimeSeries (202)
	virtual int soap_type(void) const { return 202; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORETimeSeries, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORETimeSeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETimeSeries); }
	         resqml2__obj_USCORETimeSeries() { resqml2__obj_USCORETimeSeries::soap_default(NULL); }
	virtual ~resqml2__obj_USCORETimeSeries() { }
	friend resqml2__obj_USCORETimeSeries *soap_instantiate_resqml2__obj_USCORETimeSeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:762 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREMdDatum
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREMdDatum (209)
/* Type resqml2__obj_USCOREMdDatum is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_MdDatum complex type: */
class SOAP_CMAC resqml2__obj_USCOREMdDatum : public resqml2__AbstractResqmlDataObject
{
public:
	resqml2__Point3d *Location;	/* required element of XSD type resqml2:Point3d */
	enum resqml2__MdReference MdReference;	/* required element of XSD type resqml2:MdReference */
	eml__DataObjectReference *LocalCrs;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREMdDatum (209)
	virtual int soap_type(void) const { return 209; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREMdDatum, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREMdDatum *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREMdDatum); }
	         resqml2__obj_USCOREMdDatum() { resqml2__obj_USCOREMdDatum::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREMdDatum() { }
	friend resqml2__obj_USCOREMdDatum *soap_instantiate_resqml2__obj_USCOREMdDatum(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:765 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreMarker
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreMarker (210)
/* Type resqml2__WellboreMarker is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:WellboreMarker complex type: */
class SOAP_CMAC resqml2__WellboreMarker : public resqml2__AbstractResqmlDataObject
{
public:
	enum resqml2__FluidContact *FluidContact;	/* optional element of XSD type resqml2:FluidContact */
	enum resqml2__FluidMarker *FluidMarker;	/* optional element of XSD type resqml2:FluidMarker */
	enum resqml2__GeologicBoundaryKind *GeologicBoundaryKind;	/* optional element of XSD type resqml2:GeologicBoundaryKind */
	eml__DataObjectReference *WitsmlFormationMarker;	/* optional element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *Interpretation;	/* optional element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreMarker (210)
	virtual int soap_type(void) const { return 210; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__WellboreMarker, default initialized and not managed by a soap context
	virtual resqml2__WellboreMarker *soap_alloc(void) const { return SOAP_NEW(resqml2__WellboreMarker); }
	         resqml2__WellboreMarker() { resqml2__WellboreMarker::soap_default(NULL); }
	virtual ~resqml2__WellboreMarker() { }
	friend resqml2__WellboreMarker *soap_instantiate_resqml2__WellboreMarker(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:885 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivity (250)
/* Type resqml2__obj_USCOREActivity is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_Activity complex type: */
class SOAP_CMAC resqml2__obj_USCOREActivity : public resqml2__AbstractResqmlDataObject
{
public:
	eml__DataObjectReference *Parent;	/* optional element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *ActivityDescriptor;	/* required element of XSD type eml:DataObjectReference */
	std::vector<resqml2__AbstractActivityParameter *> Parameter;	/* required element of XSD type resqml2:AbstractActivityParameter */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivity (250)
	virtual int soap_type(void) const { return 250; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREActivity, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREActivity *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREActivity); }
	         resqml2__obj_USCOREActivity() { resqml2__obj_USCOREActivity::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREActivity() { }
	friend resqml2__obj_USCOREActivity *soap_instantiate_resqml2__obj_USCOREActivity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:912 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivityTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivityTemplate (259)
/* Type resqml2__obj_USCOREActivityTemplate is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_ActivityTemplate complex type: */
class SOAP_CMAC resqml2__obj_USCOREActivityTemplate : public resqml2__AbstractResqmlDataObject
{
public:
	std::vector<resqml2__ParameterTemplate *> Parameter;	/* required element of XSD type resqml2:ParameterTemplate */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivityTemplate (259)
	virtual int soap_type(void) const { return 259; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREActivityTemplate, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREActivityTemplate *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREActivityTemplate); }
	         resqml2__obj_USCOREActivityTemplate() { resqml2__obj_USCOREActivityTemplate::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREActivityTemplate() { }
	friend resqml2__obj_USCOREActivityTemplate *soap_instantiate_resqml2__obj_USCOREActivityTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1530 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__IdentifiedObjectType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__IdentifiedObjectType (465)
/* Type gml__IdentifiedObjectType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:IdentifiedObjectType complex type: */
class SOAP_CMAC gml__IdentifiedObjectType : public gml__DefinitionType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__IdentifiedObjectType (465)
	virtual int soap_type(void) const { return 465; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__IdentifiedObjectType, default initialized and not managed by a soap context
	virtual gml__IdentifiedObjectType *soap_alloc(void) const { return SOAP_NEW(gml__IdentifiedObjectType); }
	         gml__IdentifiedObjectType() { gml__IdentifiedObjectType::soap_default(NULL); }
	virtual ~gml__IdentifiedObjectType() { }
	friend gml__IdentifiedObjectType *soap_instantiate_gml__IdentifiedObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:213 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDoubleTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDoubleTableLookup (26)
/* Type resqml2__obj_USCOREDoubleTableLookup is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_DoubleTableLookup complex type: */
class SOAP_CMAC resqml2__obj_USCOREDoubleTableLookup : public resqml2__AbstractPropertyLookup
{
public:
	std::vector<resqml2__DoubleLookup *> Value;	/* required element of XSD type resqml2:DoubleLookup */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDoubleTableLookup (26)
	virtual int soap_type(void) const { return 26; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREDoubleTableLookup, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREDoubleTableLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREDoubleTableLookup); }
	         resqml2__obj_USCOREDoubleTableLookup() { resqml2__obj_USCOREDoubleTableLookup::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREDoubleTableLookup() { }
	friend resqml2__obj_USCOREDoubleTableLookup *soap_instantiate_resqml2__obj_USCOREDoubleTableLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:228 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointsProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointsProperty (31)
/* Type resqml2__obj_USCOREPointsProperty is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_PointsProperty complex type: */
class SOAP_CMAC resqml2__obj_USCOREPointsProperty : public resqml2__AbstractProperty
{
public:
	std::vector<resqml2__PatchOfPoints *> PatchOfPoints;	/* required element of XSD type resqml2:PatchOfPoints */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointsProperty (31)
	virtual int soap_type(void) const { return 31; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREPointsProperty, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREPointsProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPointsProperty); }
	         resqml2__obj_USCOREPointsProperty() { resqml2__obj_USCOREPointsProperty::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREPointsProperty() { }
	friend resqml2__obj_USCOREPointsProperty *soap_instantiate_resqml2__obj_USCOREPointsProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:261 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStringTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStringTableLookup (42)
/* Type resqml2__obj_USCOREStringTableLookup is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_StringTableLookup complex type: */
class SOAP_CMAC resqml2__obj_USCOREStringTableLookup : public resqml2__AbstractPropertyLookup
{
public:
	std::vector<resqml2__StringLookup *> Value;	/* required element of XSD type resqml2:StringLookup */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStringTableLookup (42)
	virtual int soap_type(void) const { return 42; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREStringTableLookup, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREStringTableLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStringTableLookup); }
	         resqml2__obj_USCOREStringTableLookup() { resqml2__obj_USCOREStringTableLookup::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREStringTableLookup() { }
	friend resqml2__obj_USCOREStringTableLookup *soap_instantiate_resqml2__obj_USCOREStringTableLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:303 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValuesProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValuesProperty (56)
/* Type resqml2__AbstractValuesProperty is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractValuesProperty complex type: */
class SOAP_CMAC resqml2__AbstractValuesProperty : public resqml2__AbstractProperty
{
public:
	std::vector<resqml2__PatchOfValues *> PatchOfValues;	/* required element of XSD type resqml2:PatchOfValues */
	std::vector<resqml2__PropertyKindFacet *> Facet;	/* optional element of XSD type resqml2:PropertyKindFacet */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValuesProperty (56)
	virtual int soap_type(void) const { return 56; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractValuesProperty, default initialized and not managed by a soap context
	virtual resqml2__AbstractValuesProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractValuesProperty); }
	         resqml2__AbstractValuesProperty() { resqml2__AbstractValuesProperty::soap_default(NULL); }
	virtual ~resqml2__AbstractValuesProperty() { }
	friend resqml2__AbstractValuesProperty *soap_instantiate_resqml2__AbstractValuesProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:399 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationSetRepresentation (88)
/* Type resqml2__obj_USCORERepresentationSetRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_RepresentationSetRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCORERepresentationSetRepresentation : public resqml2__AbstractRepresentation
{
public:
	bool IsHomogeneous;	/* required element of XSD type xsd:boolean */
	std::vector<eml__DataObjectReference *> Representation;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationSetRepresentation (88)
	virtual int soap_type(void) const { return 88; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORERepresentationSetRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORERepresentationSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERepresentationSetRepresentation); }
	         resqml2__obj_USCORERepresentationSetRepresentation() { resqml2__obj_USCORERepresentationSetRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORERepresentationSetRepresentation() { }
	friend resqml2__obj_USCORERepresentationSetRepresentation *soap_instantiate_resqml2__obj_USCORERepresentationSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:402 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERedefinedGeometryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERedefinedGeometryRepresentation (89)
/* Type resqml2__obj_USCORERedefinedGeometryRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_RedefinedGeometryRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCORERedefinedGeometryRepresentation : public resqml2__AbstractRepresentation
{
public:
	std::vector<resqml2__PatchOfGeometry *> PatchOfGeometry;	/* required element of XSD type resqml2:PatchOfGeometry */
	eml__DataObjectReference *SupportingRepresentation;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERedefinedGeometryRepresentation (89)
	virtual int soap_type(void) const { return 89; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORERedefinedGeometryRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORERedefinedGeometryRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERedefinedGeometryRepresentation); }
	         resqml2__obj_USCORERedefinedGeometryRepresentation() { resqml2__obj_USCORERedefinedGeometryRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORERedefinedGeometryRepresentation() { }
	friend resqml2__obj_USCORERedefinedGeometryRepresentation *soap_instantiate_resqml2__obj_USCORERedefinedGeometryRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:420 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESubRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESubRepresentation (95)
/* Type resqml2__obj_USCORESubRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_SubRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCORESubRepresentation : public resqml2__AbstractRepresentation
{
public:
	resqml2__AdditionalGridTopology *AdditionalGridTopology;	/* optional element of XSD type resqml2:AdditionalGridTopology */
	eml__DataObjectReference *SupportingRepresentation;	/* required element of XSD type eml:DataObjectReference */
	std::vector<resqml2__SubRepresentationPatch *> SubRepresentationPatch;	/* required element of XSD type resqml2:SubRepresentationPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESubRepresentation (95)
	virtual int soap_type(void) const { return 95; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORESubRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORESubRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESubRepresentation); }
	         resqml2__obj_USCORESubRepresentation() { resqml2__obj_USCORESubRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORESubRepresentation() { }
	friend resqml2__obj_USCORESubRepresentation *soap_instantiate_resqml2__obj_USCORESubRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:447 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridRepresentation (104)
/* Type resqml2__AbstractGridRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractGridRepresentation complex type: */
class SOAP_CMAC resqml2__AbstractGridRepresentation : public resqml2__AbstractRepresentation
{
public:
	resqml2__CellFluidPhaseUnits *CellFluidPhaseUnits;	/* optional element of XSD type resqml2:CellFluidPhaseUnits */
	resqml2__AbstractParentWindow *ParentWindow;	/* optional element of XSD type resqml2:AbstractParentWindow */
	resqml2__CellStratigraphicUnits *CellStratigraphicUnits;	/* optional element of XSD type resqml2:CellStratigraphicUnits */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridRepresentation (104)
	virtual int soap_type(void) const { return 104; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractGridRepresentation, default initialized and not managed by a soap context
	virtual resqml2__AbstractGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractGridRepresentation); }
	         resqml2__AbstractGridRepresentation() { resqml2__AbstractGridRepresentation::soap_default(NULL); }
	virtual ~resqml2__AbstractGridRepresentation() { }
	friend resqml2__AbstractGridRepresentation *soap_instantiate_resqml2__AbstractGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:516 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerGridGeometry (127)
/* Type resqml2__UnstructuredColumnLayerGridGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:UnstructuredColumnLayerGridGeometry complex type: */
class SOAP_CMAC resqml2__UnstructuredColumnLayerGridGeometry : public resqml2__AbstractColumnLayerGridGeometry
{
public:
	enum resqml2__ColumnShape ColumnShape;	/* required element of XSD type resqml2:ColumnShape */
	ULONG64 PillarCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__ResqmlJaggedArray *PillarsPerColumn;	/* required element of XSD type resqml2:ResqmlJaggedArray */
	resqml2__AbstractBooleanArray *ColumnIsRightHanded;	/* required element of XSD type resqml2:AbstractBooleanArray */
	resqml2__UnstructuredColumnEdges *ColumnEdges;	/* optional element of XSD type resqml2:UnstructuredColumnEdges */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerGridGeometry (127)
	virtual int soap_type(void) const { return 127; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__UnstructuredColumnLayerGridGeometry, default initialized and not managed by a soap context
	virtual resqml2__UnstructuredColumnLayerGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredColumnLayerGridGeometry); }
	         resqml2__UnstructuredColumnLayerGridGeometry() { resqml2__UnstructuredColumnLayerGridGeometry::soap_default(NULL); }
	virtual ~resqml2__UnstructuredColumnLayerGridGeometry() { }
	friend resqml2__UnstructuredColumnLayerGridGeometry *soap_instantiate_resqml2__UnstructuredColumnLayerGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:519 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkGridGeometry (128)
/* Type resqml2__IjkGridGeometry is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:IjkGridGeometry complex type: */
class SOAP_CMAC resqml2__IjkGridGeometry : public resqml2__AbstractColumnLayerGridGeometry
{
public:
	bool GridIsRighthanded;	/* required element of XSD type xsd:boolean */
	resqml2__IjGaps *IjGaps;	/* optional element of XSD type resqml2:IjGaps */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkGridGeometry (128)
	virtual int soap_type(void) const { return 128; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__IjkGridGeometry, default initialized and not managed by a soap context
	virtual resqml2__IjkGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__IjkGridGeometry); }
	         resqml2__IjkGridGeometry() { resqml2__IjkGridGeometry::soap_default(NULL); }
	virtual ~resqml2__IjkGridGeometry() { }
	friend resqml2__IjkGridGeometry *soap_instantiate_resqml2__IjkGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:558 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGridConnectionSetRepresentation (141)
/* Type resqml2__obj_USCOREGridConnectionSetRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GridConnectionSetRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREGridConnectionSetRepresentation : public resqml2__AbstractRepresentation
{
public:
	ULONG64 Count;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractIntegerArray *CellIndexPairs;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *GridIndexPairs;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *LocalFacePerCellIndexPairs;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__ConnectionInterpretations *ConnectionInterpretations;	/* optional element of XSD type resqml2:ConnectionInterpretations */
	std::vector<eml__DataObjectReference *> Grid;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGridConnectionSetRepresentation (141)
	virtual int soap_type(void) const { return 141; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGridConnectionSetRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGridConnectionSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGridConnectionSetRepresentation); }
	         resqml2__obj_USCOREGridConnectionSetRepresentation() { resqml2__obj_USCOREGridConnectionSetRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGridConnectionSetRepresentation() { }
	friend resqml2__obj_USCOREGridConnectionSetRepresentation *soap_instantiate_resqml2__obj_USCOREGridConnectionSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:597 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractOrganizationInterpretation (154)
/* Type resqml2__AbstractOrganizationInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractOrganizationInterpretation complex type: */
class SOAP_CMAC resqml2__AbstractOrganizationInterpretation : public resqml2__AbstractFeatureInterpretation
{
public:
	std::vector<resqml2__AbstractContactInterpretationPart *> ContactInterpretation;	/* optional element of XSD type resqml2:AbstractContactInterpretationPart */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractOrganizationInterpretation (154)
	virtual int soap_type(void) const { return 154; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractOrganizationInterpretation, default initialized and not managed by a soap context
	virtual resqml2__AbstractOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractOrganizationInterpretation); }
	         resqml2__AbstractOrganizationInterpretation() { resqml2__AbstractOrganizationInterpretation::soap_default(NULL); }
	virtual ~resqml2__AbstractOrganizationInterpretation() { }
	friend resqml2__AbstractOrganizationInterpretation *soap_instantiate_resqml2__AbstractOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:612 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGenericFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGenericFeatureInterpretation (159)
/* Type resqml2__obj_USCOREGenericFeatureInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GenericFeatureInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREGenericFeatureInterpretation : public resqml2__AbstractFeatureInterpretation
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGenericFeatureInterpretation (159)
	virtual int soap_type(void) const { return 159; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGenericFeatureInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGenericFeatureInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGenericFeatureInterpretation); }
	         resqml2__obj_USCOREGenericFeatureInterpretation() { resqml2__obj_USCOREGenericFeatureInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGenericFeatureInterpretation() { }
	friend resqml2__obj_USCOREGenericFeatureInterpretation *soap_instantiate_resqml2__obj_USCOREGenericFeatureInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:615 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreInterpretation (160)
/* Type resqml2__obj_USCOREWellboreInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_WellboreInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREWellboreInterpretation : public resqml2__AbstractFeatureInterpretation
{
public:
	bool IsDrilled;	/* required element of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreInterpretation (160)
	virtual int soap_type(void) const { return 160; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREWellboreInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREWellboreInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreInterpretation); }
	         resqml2__obj_USCOREWellboreInterpretation() { resqml2__obj_USCOREWellboreInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREWellboreInterpretation() { }
	friend resqml2__obj_USCOREWellboreInterpretation *soap_instantiate_resqml2__obj_USCOREWellboreInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:642 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeatureInterpretation (169)
/* Type resqml2__obj_USCOREBoundaryFeatureInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_BoundaryFeatureInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREBoundaryFeatureInterpretation : public resqml2__AbstractFeatureInterpretation
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeatureInterpretation (169)
	virtual int soap_type(void) const { return 169; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREBoundaryFeatureInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREBoundaryFeatureInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREBoundaryFeatureInterpretation); }
	         resqml2__obj_USCOREBoundaryFeatureInterpretation() { resqml2__obj_USCOREBoundaryFeatureInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREBoundaryFeatureInterpretation() { }
	friend resqml2__obj_USCOREBoundaryFeatureInterpretation *soap_instantiate_resqml2__obj_USCOREBoundaryFeatureInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:648 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREEarthModelInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREEarthModelInterpretation (171)
/* Type resqml2__obj_USCOREEarthModelInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_EarthModelInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREEarthModelInterpretation : public resqml2__AbstractFeatureInterpretation
{
public:
	std::vector<eml__DataObjectReference *> StratigraphicOccurrences;	/* optional element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *StratigraphicColumn;	/* optional element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *Structure;	/* optional element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *Fluid;	/* optional element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREEarthModelInterpretation (171)
	virtual int soap_type(void) const { return 171; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREEarthModelInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREEarthModelInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREEarthModelInterpretation); }
	         resqml2__obj_USCOREEarthModelInterpretation() { resqml2__obj_USCOREEarthModelInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREEarthModelInterpretation() { }
	friend resqml2__obj_USCOREEarthModelInterpretation *soap_instantiate_resqml2__obj_USCOREEarthModelInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:666 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitInterpretation (177)
/* Type resqml2__obj_USCOREGeologicUnitInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GeologicUnitInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREGeologicUnitInterpretation : public resqml2__AbstractFeatureInterpretation
{
public:
	enum resqml2__GeologicUnitComposition *GeologicUnitComposition;	/* optional element of XSD type resqml2:GeologicUnitComposition */
	enum resqml2__GeologicUnitMaterialImplacement *GeologicUnitMaterialImplacement;	/* optional element of XSD type resqml2:GeologicUnitMaterialImplacement */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitInterpretation (177)
	virtual int soap_type(void) const { return 177; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGeologicUnitInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGeologicUnitInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeologicUnitInterpretation); }
	         resqml2__obj_USCOREGeologicUnitInterpretation() { resqml2__obj_USCOREGeologicUnitInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGeologicUnitInterpretation() { }
	friend resqml2__obj_USCOREGeologicUnitInterpretation *soap_instantiate_resqml2__obj_USCOREGeologicUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:696 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeologicFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeologicFeature (187)
/* Type resqml2__AbstractGeologicFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractGeologicFeature complex type: */
class SOAP_CMAC resqml2__AbstractGeologicFeature : public resqml2__AbstractFeature
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeologicFeature (187)
	virtual int soap_type(void) const { return 187; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractGeologicFeature, default initialized and not managed by a soap context
	virtual resqml2__AbstractGeologicFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractGeologicFeature); }
	         resqml2__AbstractGeologicFeature() { resqml2__AbstractGeologicFeature::soap_default(NULL); }
	virtual ~resqml2__AbstractGeologicFeature() { }
	friend resqml2__AbstractGeologicFeature *soap_instantiate_resqml2__AbstractGeologicFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:720 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalTime3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalTime3dCrs (195)
/* Type resqml2__obj_USCORELocalTime3dCrs is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_LocalTime3dCrs complex type: */
class SOAP_CMAC resqml2__obj_USCORELocalTime3dCrs : public resqml2__AbstractLocal3dCrs
{
public:
	enum eml__TimeUom TimeUom;	/* required element of XSD type eml:TimeUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalTime3dCrs (195)
	virtual int soap_type(void) const { return 195; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORELocalTime3dCrs, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORELocalTime3dCrs *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORELocalTime3dCrs); }
	         resqml2__obj_USCORELocalTime3dCrs() { resqml2__obj_USCORELocalTime3dCrs::soap_default(NULL); }
	virtual ~resqml2__obj_USCORELocalTime3dCrs() { }
	friend resqml2__obj_USCORELocalTime3dCrs *soap_instantiate_resqml2__obj_USCORELocalTime3dCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:738 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalDepth3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalDepth3dCrs (201)
/* Type resqml2__obj_USCORELocalDepth3dCrs is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_LocalDepth3dCrs complex type: */
class SOAP_CMAC resqml2__obj_USCORELocalDepth3dCrs : public resqml2__AbstractLocal3dCrs
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalDepth3dCrs (201)
	virtual int soap_type(void) const { return 201; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORELocalDepth3dCrs, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORELocalDepth3dCrs *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORELocalDepth3dCrs); }
	         resqml2__obj_USCORELocalDepth3dCrs() { resqml2__obj_USCORELocalDepth3dCrs::soap_default(NULL); }
	virtual ~resqml2__obj_USCORELocalDepth3dCrs() { }
	friend resqml2__obj_USCORELocalDepth3dCrs *soap_instantiate_resqml2__obj_USCORELocalDepth3dCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:753 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDeviationSurveyRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDeviationSurveyRepresentation (206)
/* Type resqml2__obj_USCOREDeviationSurveyRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_DeviationSurveyRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREDeviationSurveyRepresentation : public resqml2__AbstractRepresentation
{
public:
	eml__DataObjectReference *WitsmlDeviationSurvey;	/* optional element of XSD type eml:DataObjectReference */
	bool IsFinal;	/* required element of XSD type xsd:boolean */
	ULONG64 StationCount;	/* required element of XSD type xsd:positiveInteger */
	enum eml__LengthUom MdUom;	/* required element of XSD type eml:LengthUom */
	resqml2__AbstractDoubleArray *Mds;	/* required element of XSD type resqml2:AbstractDoubleArray */
	resqml2__Point3d *FirstStationLocation;	/* required element of XSD type resqml2:Point3d */
	enum eml__PlaneAngleUom AngleUom;	/* required element of XSD type eml:PlaneAngleUom */
	resqml2__AbstractDoubleArray *Azimuths;	/* required element of XSD type resqml2:AbstractDoubleArray */
	resqml2__AbstractDoubleArray *Inclinations;	/* required element of XSD type resqml2:AbstractDoubleArray */
	eml__DataObjectReference *MdDatum;	/* required element of XSD type eml:DataObjectReference */
	resqml2__TimeIndex *TimeIndex;	/* optional element of XSD type resqml2:TimeIndex */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDeviationSurveyRepresentation (206)
	virtual int soap_type(void) const { return 206; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREDeviationSurveyRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREDeviationSurveyRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREDeviationSurveyRepresentation); }
	         resqml2__obj_USCOREDeviationSurveyRepresentation() { resqml2__obj_USCOREDeviationSurveyRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREDeviationSurveyRepresentation() { }
	friend resqml2__obj_USCOREDeviationSurveyRepresentation *soap_instantiate_resqml2__obj_USCOREDeviationSurveyRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:756 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFrameRepresentation (207)
/* Type resqml2__obj_USCOREWellboreFrameRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_WellboreFrameRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREWellboreFrameRepresentation : public resqml2__AbstractRepresentation
{
public:
	ULONG64 NodeCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__AbstractDoubleArray *NodeMd;	/* required element of XSD type resqml2:AbstractDoubleArray */
	eml__DataObjectReference *WitsmlLogReference;	/* optional element of XSD type eml:DataObjectReference */
	resqml2__IntervalStratigraphicUnits *IntervalStratigraphiUnits;	/* optional element of XSD type resqml2:IntervalStratigraphicUnits */
	resqml2__CellFluidPhaseUnits *CellFluidPhaseUnits;	/* optional element of XSD type resqml2:CellFluidPhaseUnits */
	eml__DataObjectReference *Trajectory;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFrameRepresentation (207)
	virtual int soap_type(void) const { return 207; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREWellboreFrameRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREWellboreFrameRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreFrameRepresentation); }
	         resqml2__obj_USCOREWellboreFrameRepresentation() { resqml2__obj_USCOREWellboreFrameRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREWellboreFrameRepresentation() { }
	friend resqml2__obj_USCOREWellboreFrameRepresentation *soap_instantiate_resqml2__obj_USCOREWellboreFrameRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:759 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreTrajectoryRepresentation (208)
/* Type resqml2__obj_USCOREWellboreTrajectoryRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_WellboreTrajectoryRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREWellboreTrajectoryRepresentation : public resqml2__AbstractRepresentation
{
public:
	double StartMd;	/* required element of XSD type xsd:double */
	double FinishMd;	/* required element of XSD type xsd:double */
	enum eml__LengthUom MdUom;	/* required element of XSD type eml:LengthUom */
	enum resqml2__MdDomain *MdDomain;	/* optional element of XSD type resqml2:MdDomain */
	eml__DataObjectReference *WitsmlTrajectory;	/* optional element of XSD type eml:DataObjectReference */
	resqml2__AbstractParametricLineGeometry *Geometry;	/* optional element of XSD type resqml2:AbstractParametricLineGeometry */
	eml__DataObjectReference *MdDatum;	/* required element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *DeviationSurvey;	/* optional element of XSD type eml:DataObjectReference */
	resqml2__WellboreTrajectoryParentIntersection *ParentIntersection;	/* optional element of XSD type resqml2:WellboreTrajectoryParentIntersection */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreTrajectoryRepresentation (208)
	virtual int soap_type(void) const { return 208; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREWellboreTrajectoryRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREWellboreTrajectoryRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreTrajectoryRepresentation); }
	         resqml2__obj_USCOREWellboreTrajectoryRepresentation() { resqml2__obj_USCOREWellboreTrajectoryRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREWellboreTrajectoryRepresentation() { }
	friend resqml2__obj_USCOREWellboreTrajectoryRepresentation *soap_instantiate_resqml2__obj_USCOREWellboreTrajectoryRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:795 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointSetRepresentation (220)
/* Type resqml2__obj_USCOREPointSetRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_PointSetRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREPointSetRepresentation : public resqml2__AbstractRepresentation
{
public:
	std::vector<resqml2__NodePatch *> NodePatch;	/* required element of XSD type resqml2:NodePatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointSetRepresentation (220)
	virtual int soap_type(void) const { return 220; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREPointSetRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREPointSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPointSetRepresentation); }
	         resqml2__obj_USCOREPointSetRepresentation() { resqml2__obj_USCOREPointSetRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREPointSetRepresentation() { }
	friend resqml2__obj_USCOREPointSetRepresentation *soap_instantiate_resqml2__obj_USCOREPointSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:810 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineSetRepresentation (225)
/* Type resqml2__obj_USCOREPolylineSetRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_PolylineSetRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREPolylineSetRepresentation : public resqml2__AbstractRepresentation
{
public:
	enum resqml2__LineRole *LineRole;	/* optional element of XSD type resqml2:LineRole */
	std::vector<resqml2__PolylineSetPatch *> LinePatch;	/* required element of XSD type resqml2:PolylineSetPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineSetRepresentation (225)
	virtual int soap_type(void) const { return 225; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREPolylineSetRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREPolylineSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPolylineSetRepresentation); }
	         resqml2__obj_USCOREPolylineSetRepresentation() { resqml2__obj_USCOREPolylineSetRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREPolylineSetRepresentation() { }
	friend resqml2__obj_USCOREPolylineSetRepresentation *soap_instantiate_resqml2__obj_USCOREPolylineSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:822 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineRepresentation (229)
/* Type resqml2__obj_USCOREPolylineRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_PolylineRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREPolylineRepresentation : public resqml2__AbstractRepresentation
{
public:
	enum resqml2__LineRole *LineRole;	/* optional element of XSD type resqml2:LineRole */
	bool IsClosed;	/* required element of XSD type xsd:boolean */
	resqml2__NodePatch *NodePatch;	/* required element of XSD type resqml2:NodePatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineRepresentation (229)
	virtual int soap_type(void) const { return 229; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREPolylineRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREPolylineRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPolylineRepresentation); }
	         resqml2__obj_USCOREPolylineRepresentation() { resqml2__obj_USCOREPolylineRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREPolylineRepresentation() { }
	friend resqml2__obj_USCOREPolylineRepresentation *soap_instantiate_resqml2__obj_USCOREPolylineRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:831 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceRepresentation (232)
/* Type resqml2__AbstractSurfaceRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractSurfaceRepresentation complex type: */
class SOAP_CMAC resqml2__AbstractSurfaceRepresentation : public resqml2__AbstractRepresentation
{
public:
	enum resqml2__SurfaceRole SurfaceRole;	/* required element of XSD type resqml2:SurfaceRole */
	std::vector<resqml2__PatchBoundaries *> Boundaries;	/* optional element of XSD type resqml2:PatchBoundaries */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceRepresentation (232)
	virtual int soap_type(void) const { return 232; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractSurfaceRepresentation, default initialized and not managed by a soap context
	virtual resqml2__AbstractSurfaceRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractSurfaceRepresentation); }
	         resqml2__AbstractSurfaceRepresentation() { resqml2__AbstractSurfaceRepresentation::soap_default(NULL); }
	virtual ~resqml2__AbstractSurfaceRepresentation() { }
	friend resqml2__AbstractSurfaceRepresentation *soap_instantiate_resqml2__AbstractSurfaceRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:852 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTechnicalFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTechnicalFeature (239)
/* Type resqml2__AbstractTechnicalFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractTechnicalFeature complex type: */
class SOAP_CMAC resqml2__AbstractTechnicalFeature : public resqml2__AbstractFeature
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTechnicalFeature (239)
	virtual int soap_type(void) const { return 239; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractTechnicalFeature, default initialized and not managed by a soap context
	virtual resqml2__AbstractTechnicalFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractTechnicalFeature); }
	         resqml2__AbstractTechnicalFeature() { resqml2__AbstractTechnicalFeature::soap_default(NULL); }
	virtual ~resqml2__AbstractTechnicalFeature() { }
	friend resqml2__AbstractTechnicalFeature *soap_instantiate_resqml2__AbstractTechnicalFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:921 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesRepresentation (262)
/* Type resqml2__obj_USCOREStreamlinesRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_StreamlinesRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREStreamlinesRepresentation : public resqml2__AbstractRepresentation
{
public:
	ULONG64 LineCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__StreamlineWellbores *StreamlineWellbores;	/* optional element of XSD type resqml2:StreamlineWellbores */
	resqml2__StreamlinePolylineSetPatch *Geometry;	/* optional element of XSD type resqml2:StreamlinePolylineSetPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesRepresentation (262)
	virtual int soap_type(void) const { return 262; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREStreamlinesRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREStreamlinesRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStreamlinesRepresentation); }
	         resqml2__obj_USCOREStreamlinesRepresentation() { resqml2__obj_USCOREStreamlinesRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREStreamlinesRepresentation() { }
	friend resqml2__obj_USCOREStreamlinesRepresentation *soap_instantiate_resqml2__obj_USCOREStreamlinesRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1527 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCRSType (464)
/* Type gml__AbstractCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractCRSType complex type: */
class SOAP_CMAC gml__AbstractCRSType : public gml__IdentifiedObjectType
{
public:
	std::vector<_gml__domainOfValidity *> domainOfValidity;	/* optional element of XSD type gml:domainOfValidity */
	std::vector<std::string> scope;	/* required element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCRSType (464)
	virtual int soap_type(void) const { return 464; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractCRSType, default initialized and not managed by a soap context
	virtual gml__AbstractCRSType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCRSType); }
	         gml__AbstractCRSType() { gml__AbstractCRSType::soap_default(NULL); }
	virtual ~gml__AbstractCRSType() { }
	friend gml__AbstractCRSType *soap_instantiate_gml__AbstractCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1572 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateSystemType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateSystemType (479)
/* Type gml__AbstractCoordinateSystemType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractCoordinateSystemType complex type: */
class SOAP_CMAC gml__AbstractCoordinateSystemType : public gml__IdentifiedObjectType
{
public:
	std::vector<gml__CoordinateSystemAxisPropertyType *> axis;	/* required element of XSD type gml:CoordinateSystemAxisPropertyType */
	enum gml__AggregationType *aggregationType;	/* optional attribute of XSD type gml:AggregationType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateSystemType (479)
	virtual int soap_type(void) const { return 479; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractCoordinateSystemType, default initialized and not managed by a soap context
	virtual gml__AbstractCoordinateSystemType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCoordinateSystemType); }
	         gml__AbstractCoordinateSystemType() { gml__AbstractCoordinateSystemType::soap_default(NULL); }
	virtual ~gml__AbstractCoordinateSystemType() { }
	friend gml__AbstractCoordinateSystemType *soap_instantiate_gml__AbstractCoordinateSystemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1578 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisType (481)
/* Type gml__CoordinateSystemAxisType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:CoordinateSystemAxisType complex type: */
class SOAP_CMAC gml__CoordinateSystemAxisType : public gml__IdentifiedObjectType
{
public:
	gml__CodeType *axisAbbrev;	/* required element of XSD type gml:CodeType */
	gml__CodeWithAuthorityType *axisDirection;	/* required element of XSD type gml:CodeWithAuthorityType */
	double *minimumValue;	/* optional element of XSD type xsd:double */
	double *maximumValue;	/* optional element of XSD type xsd:double */
	gml__CodeWithAuthorityType *rangeMeaning;	/* optional element of XSD type gml:CodeWithAuthorityType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisType (481)
	virtual int soap_type(void) const { return 481; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CoordinateSystemAxisType, default initialized and not managed by a soap context
	virtual gml__CoordinateSystemAxisType *soap_alloc(void) const { return SOAP_NEW(gml__CoordinateSystemAxisType); }
	         gml__CoordinateSystemAxisType() { gml__CoordinateSystemAxisType::soap_default(NULL); }
	virtual ~gml__CoordinateSystemAxisType() { }
	friend gml__CoordinateSystemAxisType *soap_instantiate_gml__CoordinateSystemAxisType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1599 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractDatumType (488)
/* Type gml__AbstractDatumType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractDatumType complex type: */
class SOAP_CMAC gml__AbstractDatumType : public gml__IdentifiedObjectType
{
public:
	_gml__domainOfValidity *domainOfValidity;	/* optional element of XSD type gml:domainOfValidity */
	std::vector<std::string> scope;	/* required element of XSD type xsd:string */
	gml__CodeType *anchorDefinition;	/* optional element of XSD type gml:CodeType */
	std::string *realizationEpoch;	/* optional element of XSD type xsd:date */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractDatumType (488)
	virtual int soap_type(void) const { return 488; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractDatumType, default initialized and not managed by a soap context
	virtual gml__AbstractDatumType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractDatumType); }
	         gml__AbstractDatumType() { gml__AbstractDatumType::soap_default(NULL); }
	virtual ~gml__AbstractDatumType() { }
	friend gml__AbstractDatumType *soap_instantiate_gml__AbstractDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1605 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianType (490)
/* Type gml__PrimeMeridianType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:PrimeMeridianType complex type: */
class SOAP_CMAC gml__PrimeMeridianType : public gml__IdentifiedObjectType
{
public:
	gml__AngleType *greenwichLongitude;	/* required element of XSD type gml:AngleType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianType (490)
	virtual int soap_type(void) const { return 490; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__PrimeMeridianType, default initialized and not managed by a soap context
	virtual gml__PrimeMeridianType *soap_alloc(void) const { return SOAP_NEW(gml__PrimeMeridianType); }
	         gml__PrimeMeridianType() { gml__PrimeMeridianType::soap_default(NULL); }
	virtual ~gml__PrimeMeridianType() { }
	friend gml__PrimeMeridianType *soap_instantiate_gml__PrimeMeridianType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1617 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidType (494)
/* Type gml__EllipsoidType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:EllipsoidType complex type: */
class SOAP_CMAC gml__EllipsoidType : public gml__IdentifiedObjectType
{
public:
	gml__MeasureType *semiMajorAxis;	/* required element of XSD type gml:MeasureType */
	_gml__secondDefiningParameter *secondDefiningParameter;	/* required element of XSD type gml:secondDefiningParameter */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidType (494)
	virtual int soap_type(void) const { return 494; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__EllipsoidType, default initialized and not managed by a soap context
	virtual gml__EllipsoidType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidType); }
	         gml__EllipsoidType() { gml__EllipsoidType::soap_default(NULL); }
	virtual ~gml__EllipsoidType() { }
	friend gml__EllipsoidType *soap_instantiate_gml__EllipsoidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1635 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateOperationType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateOperationType (500)
/* Type gml__AbstractCoordinateOperationType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractCoordinateOperationType complex type: */
class SOAP_CMAC gml__AbstractCoordinateOperationType : public gml__IdentifiedObjectType
{
public:
	_gml__domainOfValidity *domainOfValidity;	/* optional element of XSD type gml:domainOfValidity */
	std::vector<std::string> scope;	/* required element of XSD type xsd:string */
	std::string *operationVersion;	/* optional element of XSD type xsd:string */
	std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;	/* optional element of XSD type gml:coordinateOperationAccuracy */
	gml__CRSPropertyType *sourceCRS;	/* optional element of XSD type gml:CRSPropertyType */
	gml__CRSPropertyType *targetCRS;	/* optional element of XSD type gml:CRSPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateOperationType (500)
	virtual int soap_type(void) const { return 500; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractCoordinateOperationType, default initialized and not managed by a soap context
	virtual gml__AbstractCoordinateOperationType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCoordinateOperationType); }
	         gml__AbstractCoordinateOperationType() { gml__AbstractCoordinateOperationType::soap_default(NULL); }
	virtual ~gml__AbstractCoordinateOperationType() { }
	friend gml__AbstractCoordinateOperationType *soap_instantiate_gml__AbstractCoordinateOperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:222 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousProperty (29)
/* Type resqml2__obj_USCOREContinuousProperty is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_ContinuousProperty complex type: */
class SOAP_CMAC resqml2__obj_USCOREContinuousProperty : public resqml2__AbstractValuesProperty
{
public:
	std::vector<double> MinimumValue;	/* optional element of XSD type xsd:double */
	std::vector<double> MaximumValue;	/* optional element of XSD type xsd:double */
	enum resqml2__ResqmlUom UOM;	/* required element of XSD type resqml2:ResqmlUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousProperty (29)
	virtual int soap_type(void) const { return 29; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREContinuousProperty, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREContinuousProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREContinuousProperty); }
	         resqml2__obj_USCOREContinuousProperty() { resqml2__obj_USCOREContinuousProperty::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREContinuousProperty() { }
	friend resqml2__obj_USCOREContinuousProperty *soap_instantiate_resqml2__obj_USCOREContinuousProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:243 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentProperty (36)
/* Type resqml2__obj_USCORECommentProperty is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_CommentProperty complex type: */
class SOAP_CMAC resqml2__obj_USCORECommentProperty : public resqml2__AbstractValuesProperty
{
public:
	std::string *Language;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentProperty (36)
	virtual int soap_type(void) const { return 36; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORECommentProperty, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORECommentProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORECommentProperty); }
	         resqml2__obj_USCORECommentProperty() { resqml2__obj_USCORECommentProperty::soap_default(NULL); }
	virtual ~resqml2__obj_USCORECommentProperty() { }
	friend resqml2__obj_USCORECommentProperty *soap_instantiate_resqml2__obj_USCORECommentProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:246 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscreteProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscreteProperty (37)
/* Type resqml2__obj_USCOREDiscreteProperty is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_DiscreteProperty complex type: */
class SOAP_CMAC resqml2__obj_USCOREDiscreteProperty : public resqml2__AbstractValuesProperty
{
public:
	std::vector<LONG64> MinimumValue;	/* optional element of XSD type xsd:integer */
	std::vector<LONG64> MaximumValue;	/* optional element of XSD type xsd:integer */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscreteProperty (37)
	virtual int soap_type(void) const { return 37; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREDiscreteProperty, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREDiscreteProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREDiscreteProperty); }
	         resqml2__obj_USCOREDiscreteProperty() { resqml2__obj_USCOREDiscreteProperty::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREDiscreteProperty() { }
	friend resqml2__obj_USCOREDiscreteProperty *soap_instantiate_resqml2__obj_USCOREDiscreteProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:249 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalProperty (38)
/* Type resqml2__obj_USCORECategoricalProperty is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_CategoricalProperty complex type: */
class SOAP_CMAC resqml2__obj_USCORECategoricalProperty : public resqml2__AbstractValuesProperty
{
public:
	eml__DataObjectReference *Lookup;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalProperty (38)
	virtual int soap_type(void) const { return 38; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORECategoricalProperty, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORECategoricalProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORECategoricalProperty); }
	         resqml2__obj_USCORECategoricalProperty() { resqml2__obj_USCORECategoricalProperty::soap_default(NULL); }
	virtual ~resqml2__obj_USCORECategoricalProperty() { }
	friend resqml2__obj_USCORECategoricalProperty *soap_instantiate_resqml2__obj_USCORECategoricalProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:423 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredGridRepresentation (96)
/* Type resqml2__obj_USCOREUnstructuredGridRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_UnstructuredGridRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREUnstructuredGridRepresentation : public resqml2__AbstractGridRepresentation
{
public:
	ULONG64 CellCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__UnstructuredGridGeometry *Geometry;	/* optional element of XSD type resqml2:UnstructuredGridGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredGridRepresentation (96)
	virtual int soap_type(void) const { return 96; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREUnstructuredGridRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREUnstructuredGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREUnstructuredGridRepresentation); }
	         resqml2__obj_USCOREUnstructuredGridRepresentation() { resqml2__obj_USCOREUnstructuredGridRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREUnstructuredGridRepresentation() { }
	friend resqml2__obj_USCOREUnstructuredGridRepresentation *soap_instantiate_resqml2__obj_USCOREUnstructuredGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:429 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGpGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGpGridRepresentation (98)
/* Type resqml2__obj_USCOREGpGridRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GpGridRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREGpGridRepresentation : public resqml2__AbstractGridRepresentation
{
public:
	std::vector<resqml2__GpGridColumnLayerGrid *> ColumnLayerGrid;	/* optional element of XSD type resqml2:GpGridColumnLayerGrid */
	std::vector<resqml2__GpGridUnstructuredGridPatch *> UnstructuredGridPatch;	/* optional element of XSD type resqml2:GpGridUnstructuredGridPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGpGridRepresentation (98)
	virtual int soap_type(void) const { return 98; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGpGridRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGpGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGpGridRepresentation); }
	         resqml2__obj_USCOREGpGridRepresentation() { resqml2__obj_USCOREGpGridRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGpGridRepresentation() { }
	friend resqml2__obj_USCOREGpGridRepresentation *soap_instantiate_resqml2__obj_USCOREGpGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:525 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTruncatedColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTruncatedColumnLayerGridRepresentation (130)
/* Type resqml2__AbstractTruncatedColumnLayerGridRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractTruncatedColumnLayerGridRepresentation complex type: */
class SOAP_CMAC resqml2__AbstractTruncatedColumnLayerGridRepresentation : public resqml2__AbstractGridRepresentation
{
public:
	ULONG64 Nk;	/* required element of XSD type xsd:positiveInteger */
	resqml2__TruncationCellPatch *TruncationCells;	/* required element of XSD type resqml2:TruncationCellPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTruncatedColumnLayerGridRepresentation (130)
	virtual int soap_type(void) const { return 130; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractTruncatedColumnLayerGridRepresentation, default initialized and not managed by a soap context
	virtual resqml2__AbstractTruncatedColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractTruncatedColumnLayerGridRepresentation); }
	         resqml2__AbstractTruncatedColumnLayerGridRepresentation() { resqml2__AbstractTruncatedColumnLayerGridRepresentation::soap_default(NULL); }
	virtual ~resqml2__AbstractTruncatedColumnLayerGridRepresentation() { }
	friend resqml2__AbstractTruncatedColumnLayerGridRepresentation *soap_instantiate_resqml2__AbstractTruncatedColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:549 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridRepresentation (138)
/* Type resqml2__AbstractColumnLayerGridRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractColumnLayerGridRepresentation complex type: */
class SOAP_CMAC resqml2__AbstractColumnLayerGridRepresentation : public resqml2__AbstractGridRepresentation
{
public:
	ULONG64 Nk;	/* required element of XSD type xsd:positiveInteger */
	resqml2__IntervalStratigraphicUnits *IntervalStratigraphicUnits;	/* optional element of XSD type resqml2:IntervalStratigraphicUnits */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridRepresentation (138)
	virtual int soap_type(void) const { return 138; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractColumnLayerGridRepresentation, default initialized and not managed by a soap context
	virtual resqml2__AbstractColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractColumnLayerGridRepresentation); }
	         resqml2__AbstractColumnLayerGridRepresentation() { resqml2__AbstractColumnLayerGridRepresentation::soap_default(NULL); }
	virtual ~resqml2__AbstractColumnLayerGridRepresentation() { }
	friend resqml2__AbstractColumnLayerGridRepresentation *soap_instantiate_resqml2__AbstractColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:591 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidOrganizationInterpretation (152)
/* Type resqml2__obj_USCORERockFluidOrganizationInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_RockFluidOrganizationInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCORERockFluidOrganizationInterpretation : public resqml2__AbstractOrganizationInterpretation
{
public:
	resqml2__RockFluidUnitInterpretationIndex *RockFluidUnitIndex;	/* required element of XSD type resqml2:RockFluidUnitInterpretationIndex */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidOrganizationInterpretation (152)
	virtual int soap_type(void) const { return 152; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORERockFluidOrganizationInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORERockFluidOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERockFluidOrganizationInterpretation); }
	         resqml2__obj_USCORERockFluidOrganizationInterpretation() { resqml2__obj_USCORERockFluidOrganizationInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORERockFluidOrganizationInterpretation() { }
	friend resqml2__obj_USCORERockFluidOrganizationInterpretation *soap_instantiate_resqml2__obj_USCORERockFluidOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:609 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitInterpretation (158)
/* Type resqml2__obj_USCORERockFluidUnitInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_RockFluidUnitInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCORERockFluidUnitInterpretation : public resqml2__obj_USCOREGeologicUnitInterpretation
{
public:
	enum resqml2__Phase *Phase;	/* optional element of XSD type resqml2:Phase */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitInterpretation (158)
	virtual int soap_type(void) const { return 158; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORERockFluidUnitInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORERockFluidUnitInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERockFluidUnitInterpretation); }
	         resqml2__obj_USCORERockFluidUnitInterpretation() { resqml2__obj_USCORERockFluidUnitInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORERockFluidUnitInterpretation() { }
	friend resqml2__obj_USCORERockFluidUnitInterpretation *soap_instantiate_resqml2__obj_USCORERockFluidUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:621 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyBoundaryInterpretation (162)
/* Type resqml2__obj_USCOREGeobodyBoundaryInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GeobodyBoundaryInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREGeobodyBoundaryInterpretation : public resqml2__obj_USCOREBoundaryFeatureInterpretation
{
public:
	std::vector<enum resqml2__BoundaryRelation> BoundaryRelation;	/* optional element of XSD type resqml2:BoundaryRelation */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyBoundaryInterpretation (162)
	virtual int soap_type(void) const { return 162; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGeobodyBoundaryInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGeobodyBoundaryInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeobodyBoundaryInterpretation); }
	         resqml2__obj_USCOREGeobodyBoundaryInterpretation() { resqml2__obj_USCOREGeobodyBoundaryInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGeobodyBoundaryInterpretation() { }
	friend resqml2__obj_USCOREGeobodyBoundaryInterpretation *soap_instantiate_resqml2__obj_USCOREGeobodyBoundaryInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:624 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStructuralOrganizationInterpretation (163)
/* Type resqml2__obj_USCOREStructuralOrganizationInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_StructuralOrganizationInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREStructuralOrganizationInterpretation : public resqml2__AbstractOrganizationInterpretation
{
public:
	enum resqml2__OrderingCriteria OrderingCriteria;	/* required element of XSD type resqml2:OrderingCriteria */
	std::vector<eml__DataObjectReference *> Faults;	/* optional element of XSD type eml:DataObjectReference */
	std::vector<resqml2__HorizonInterpretationIndex *> Horizons;	/* optional element of XSD type resqml2:HorizonInterpretationIndex */
	std::vector<eml__DataObjectReference *> Sides;	/* optional element of XSD type eml:DataObjectReference */
	std::vector<eml__DataObjectReference *> TopFrontier;	/* optional element of XSD type eml:DataObjectReference */
	std::vector<eml__DataObjectReference *> BottomFrontier;	/* optional element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStructuralOrganizationInterpretation (163)
	virtual int soap_type(void) const { return 163; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREStructuralOrganizationInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREStructuralOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStructuralOrganizationInterpretation); }
	         resqml2__obj_USCOREStructuralOrganizationInterpretation() { resqml2__obj_USCOREStructuralOrganizationInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREStructuralOrganizationInterpretation() { }
	friend resqml2__obj_USCOREStructuralOrganizationInterpretation *soap_instantiate_resqml2__obj_USCOREStructuralOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:633 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFaultInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFaultInterpretation (166)
/* Type resqml2__obj_USCOREFaultInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_FaultInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREFaultInterpretation : public resqml2__obj_USCOREBoundaryFeatureInterpretation
{
public:
	bool *IsListric;	/* optional element of XSD type xsd:boolean */
	eml__LengthMeasure *MaximumThrow;	/* optional element of XSD type eml:LengthMeasure */
	eml__PlaneAngleMeasure *MeanAzimuth;	/* optional element of XSD type eml:PlaneAngleMeasure */
	eml__PlaneAngleMeasure *MeanDip;	/* optional element of XSD type eml:PlaneAngleMeasure */
	std::vector<resqml2__FaultThrow *> ThrowInterpretation;	/* optional element of XSD type resqml2:FaultThrow */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFaultInterpretation (166)
	virtual int soap_type(void) const { return 166; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREFaultInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREFaultInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREFaultInterpretation); }
	         resqml2__obj_USCOREFaultInterpretation() { resqml2__obj_USCOREFaultInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREFaultInterpretation() { }
	friend resqml2__obj_USCOREFaultInterpretation *soap_instantiate_resqml2__obj_USCOREFaultInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:639 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyInterpretation (168)
/* Type resqml2__obj_USCOREGeobodyInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GeobodyInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREGeobodyInterpretation : public resqml2__obj_USCOREGeologicUnitInterpretation
{
public:
	enum resqml2__Geobody3dShape *Geobody3dShape;	/* optional element of XSD type resqml2:Geobody3dShape */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyInterpretation (168)
	virtual int soap_type(void) const { return 168; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGeobodyInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGeobodyInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeobodyInterpretation); }
	         resqml2__obj_USCOREGeobodyInterpretation() { resqml2__obj_USCOREGeobodyInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGeobodyInterpretation() { }
	friend resqml2__obj_USCOREGeobodyInterpretation *soap_instantiate_resqml2__obj_USCOREGeobodyInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:657 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractStratigraphicOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractStratigraphicOrganizationInterpretation (174)
/* Type resqml2__AbstractStratigraphicOrganizationInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractStratigraphicOrganizationInterpretation complex type: */
class SOAP_CMAC resqml2__AbstractStratigraphicOrganizationInterpretation : public resqml2__AbstractOrganizationInterpretation
{
public:
	enum resqml2__OrderingCriteria OrderingCriteria;	/* required element of XSD type resqml2:OrderingCriteria */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractStratigraphicOrganizationInterpretation (174)
	virtual int soap_type(void) const { return 174; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractStratigraphicOrganizationInterpretation, default initialized and not managed by a soap context
	virtual resqml2__AbstractStratigraphicOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractStratigraphicOrganizationInterpretation); }
	         resqml2__AbstractStratigraphicOrganizationInterpretation() { resqml2__AbstractStratigraphicOrganizationInterpretation::soap_default(NULL); }
	virtual ~resqml2__AbstractStratigraphicOrganizationInterpretation() { }
	friend resqml2__AbstractStratigraphicOrganizationInterpretation *soap_instantiate_resqml2__AbstractStratigraphicOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:663 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREHorizonInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREHorizonInterpretation (176)
/* Type resqml2__obj_USCOREHorizonInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_HorizonInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREHorizonInterpretation : public resqml2__obj_USCOREBoundaryFeatureInterpretation
{
public:
	std::vector<enum resqml2__BoundaryRelation> BoundaryRelation;	/* optional element of XSD type resqml2:BoundaryRelation */
	enum resqml2__SequenceStratigraphySurface *SequenceStratigraphySurface;	/* optional element of XSD type resqml2:SequenceStratigraphySurface */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREHorizonInterpretation (176)
	virtual int soap_type(void) const { return 176; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREHorizonInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREHorizonInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREHorizonInterpretation); }
	         resqml2__obj_USCOREHorizonInterpretation() { resqml2__obj_USCOREHorizonInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREHorizonInterpretation() { }
	friend resqml2__obj_USCOREHorizonInterpretation *soap_instantiate_resqml2__obj_USCOREHorizonInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:669 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitInterpretation (178)
/* Type resqml2__obj_USCOREStratigraphicUnitInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_StratigraphicUnitInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicUnitInterpretation : public resqml2__obj_USCOREGeologicUnitInterpretation
{
public:
	enum resqml2__DepositionMode *DepositionMode;	/* optional element of XSD type resqml2:DepositionMode */
	eml__LengthMeasure *MaxThickness;	/* optional element of XSD type eml:LengthMeasure */
	eml__LengthMeasure *MinThickness;	/* optional element of XSD type eml:LengthMeasure */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitInterpretation (178)
	virtual int soap_type(void) const { return 178; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREStratigraphicUnitInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREStratigraphicUnitInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicUnitInterpretation); }
	         resqml2__obj_USCOREStratigraphicUnitInterpretation() { resqml2__obj_USCOREStratigraphicUnitInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREStratigraphicUnitInterpretation() { }
	friend resqml2__obj_USCOREStratigraphicUnitInterpretation *soap_instantiate_resqml2__obj_USCOREStratigraphicUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:678 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitFeature (181)
/* Type resqml2__obj_USCOREGeologicUnitFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GeologicUnitFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREGeologicUnitFeature : public resqml2__AbstractGeologicFeature
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitFeature (181)
	virtual int soap_type(void) const { return 181; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGeologicUnitFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGeologicUnitFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeologicUnitFeature); }
	         resqml2__obj_USCOREGeologicUnitFeature() { resqml2__obj_USCOREGeologicUnitFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGeologicUnitFeature() { }
	friend resqml2__obj_USCOREGeologicUnitFeature *soap_instantiate_resqml2__obj_USCOREGeologicUnitFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:684 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeature (183)
/* Type resqml2__obj_USCOREBoundaryFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_BoundaryFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREBoundaryFeature : public resqml2__AbstractGeologicFeature
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeature (183)
	virtual int soap_type(void) const { return 183; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREBoundaryFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREBoundaryFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREBoundaryFeature); }
	         resqml2__obj_USCOREBoundaryFeature() { resqml2__obj_USCOREBoundaryFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREBoundaryFeature() { }
	friend resqml2__obj_USCOREBoundaryFeature *soap_instantiate_resqml2__obj_USCOREBoundaryFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:705 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREOrganizationFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREOrganizationFeature (190)
/* Type resqml2__obj_USCOREOrganizationFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_OrganizationFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREOrganizationFeature : public resqml2__AbstractGeologicFeature
{
public:
	enum resqml2__OrganizationKind OrganizationKind;	/* required element of XSD type resqml2:OrganizationKind */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREOrganizationFeature (190)
	virtual int soap_type(void) const { return 190; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREOrganizationFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREOrganizationFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREOrganizationFeature); }
	         resqml2__obj_USCOREOrganizationFeature() { resqml2__obj_USCOREOrganizationFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREOrganizationFeature() { }
	friend resqml2__obj_USCOREOrganizationFeature *soap_instantiate_resqml2__obj_USCOREOrganizationFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:747 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBlockedWellboreRepresentation (204)
/* Type resqml2__obj_USCOREBlockedWellboreRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_BlockedWellboreRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREBlockedWellboreRepresentation : public resqml2__obj_USCOREWellboreFrameRepresentation
{
public:
	ULONG64 CellCount;	/* required element of XSD type xsd:nonNegativeInteger */
	resqml2__AbstractIntegerArray *CellIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *GridIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	resqml2__AbstractIntegerArray *LocalFacePairPerCellIndices;	/* required element of XSD type resqml2:AbstractIntegerArray */
	std::vector<eml__DataObjectReference *> Grid;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBlockedWellboreRepresentation (204)
	virtual int soap_type(void) const { return 204; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREBlockedWellboreRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREBlockedWellboreRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREBlockedWellboreRepresentation); }
	         resqml2__obj_USCOREBlockedWellboreRepresentation() { resqml2__obj_USCOREBlockedWellboreRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREBlockedWellboreRepresentation() { }
	friend resqml2__obj_USCOREBlockedWellboreRepresentation *soap_instantiate_resqml2__obj_USCOREBlockedWellboreRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:768 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreMarkerFrameRepresentation (211)
/* Type resqml2__obj_USCOREWellboreMarkerFrameRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_WellboreMarkerFrameRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREWellboreMarkerFrameRepresentation : public resqml2__obj_USCOREWellboreFrameRepresentation
{
public:
	std::vector<resqml2__WellboreMarker *> WellboreMarker;	/* required element of XSD type resqml2:WellboreMarker */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreMarkerFrameRepresentation (211)
	virtual int soap_type(void) const { return 211; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREWellboreMarkerFrameRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREWellboreMarkerFrameRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreMarkerFrameRepresentation); }
	         resqml2__obj_USCOREWellboreMarkerFrameRepresentation() { resqml2__obj_USCOREWellboreMarkerFrameRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREWellboreMarkerFrameRepresentation() { }
	friend resqml2__obj_USCOREWellboreMarkerFrameRepresentation *soap_instantiate_resqml2__obj_USCOREWellboreMarkerFrameRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:774 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETriangulatedSetRepresentation (213)
/* Type resqml2__obj_USCORETriangulatedSetRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_TriangulatedSetRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCORETriangulatedSetRepresentation : public resqml2__AbstractSurfaceRepresentation
{
public:
	std::vector<resqml2__TrianglePatch *> TrianglePatch;	/* required element of XSD type resqml2:TrianglePatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETriangulatedSetRepresentation (213)
	virtual int soap_type(void) const { return 213; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORETriangulatedSetRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORETriangulatedSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETriangulatedSetRepresentation); }
	         resqml2__obj_USCORETriangulatedSetRepresentation() { resqml2__obj_USCORETriangulatedSetRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORETriangulatedSetRepresentation() { }
	friend resqml2__obj_USCORETriangulatedSetRepresentation *soap_instantiate_resqml2__obj_USCORETriangulatedSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:786 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPlaneSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPlaneSetRepresentation (217)
/* Type resqml2__obj_USCOREPlaneSetRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_PlaneSetRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREPlaneSetRepresentation : public resqml2__AbstractSurfaceRepresentation
{
public:
	std::vector<resqml2__AbstractPlaneGeometry *> Planes;	/* required element of XSD type resqml2:AbstractPlaneGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPlaneSetRepresentation (217)
	virtual int soap_type(void) const { return 217; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREPlaneSetRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREPlaneSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPlaneSetRepresentation); }
	         resqml2__obj_USCOREPlaneSetRepresentation() { resqml2__obj_USCOREPlaneSetRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREPlaneSetRepresentation() { }
	friend resqml2__obj_USCOREPlaneSetRepresentation *soap_instantiate_resqml2__obj_USCOREPlaneSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:792 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceFrameworkRepresentation (219)
/* Type resqml2__AbstractSurfaceFrameworkRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractSurfaceFrameworkRepresentation complex type: */
class SOAP_CMAC resqml2__AbstractSurfaceFrameworkRepresentation : public resqml2__obj_USCORERepresentationSetRepresentation
{
public:
	std::vector<resqml2__ContactIdentity *> ContactIdentity;	/* optional element of XSD type resqml2:ContactIdentity */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceFrameworkRepresentation (219)
	virtual int soap_type(void) const { return 219; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractSurfaceFrameworkRepresentation, default initialized and not managed by a soap context
	virtual resqml2__AbstractSurfaceFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractSurfaceFrameworkRepresentation); }
	         resqml2__AbstractSurfaceFrameworkRepresentation() { resqml2__AbstractSurfaceFrameworkRepresentation::soap_default(NULL); }
	virtual ~resqml2__AbstractSurfaceFrameworkRepresentation() { }
	friend resqml2__AbstractSurfaceFrameworkRepresentation *soap_instantiate_resqml2__AbstractSurfaceFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:798 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedVolumeFrameworkRepresentation (221)
/* Type resqml2__obj_USCORESealedVolumeFrameworkRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_SealedVolumeFrameworkRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCORESealedVolumeFrameworkRepresentation : public resqml2__obj_USCORERepresentationSetRepresentation
{
public:
	eml__DataObjectReference *BasedOn;	/* required element of XSD type eml:DataObjectReference */
	std::vector<resqml2__VolumeShell *> Shells;	/* required element of XSD type resqml2:VolumeShell */
	std::vector<resqml2__VolumeRegion *> Regions;	/* required element of XSD type resqml2:VolumeRegion */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedVolumeFrameworkRepresentation (221)
	virtual int soap_type(void) const { return 221; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORESealedVolumeFrameworkRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORESealedVolumeFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESealedVolumeFrameworkRepresentation); }
	         resqml2__obj_USCORESealedVolumeFrameworkRepresentation() { resqml2__obj_USCORESealedVolumeFrameworkRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORESealedVolumeFrameworkRepresentation() { }
	friend resqml2__obj_USCORESealedVolumeFrameworkRepresentation *soap_instantiate_resqml2__obj_USCORESealedVolumeFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:825 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dRepresentation (230)
/* Type resqml2__obj_USCOREGrid2dRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_Grid2dRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREGrid2dRepresentation : public resqml2__AbstractSurfaceRepresentation
{
public:
	resqml2__Grid2dPatch *Grid2dPatch;	/* required element of XSD type resqml2:Grid2dPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dRepresentation (230)
	virtual int soap_type(void) const { return 230; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGrid2dRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGrid2dRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGrid2dRepresentation); }
	         resqml2__obj_USCOREGrid2dRepresentation() { resqml2__obj_USCOREGrid2dRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGrid2dRepresentation() { }
	friend resqml2__obj_USCOREGrid2dRepresentation *soap_instantiate_resqml2__obj_USCOREGrid2dRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:837 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dSetRepresentation (234)
/* Type resqml2__obj_USCOREGrid2dSetRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_Grid2dSetRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREGrid2dSetRepresentation : public resqml2__AbstractSurfaceRepresentation
{
public:
	std::vector<resqml2__Grid2dPatch *> Grid2dPatch;	/* required element of XSD type resqml2:Grid2dPatch */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dSetRepresentation (234)
	virtual int soap_type(void) const { return 234; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGrid2dSetRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGrid2dSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGrid2dSetRepresentation); }
	         resqml2__obj_USCOREGrid2dSetRepresentation() { resqml2__obj_USCOREGrid2dSetRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGrid2dSetRepresentation() { }
	friend resqml2__obj_USCOREGrid2dSetRepresentation *soap_instantiate_resqml2__obj_USCOREGrid2dSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:855 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFrontierFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFrontierFeature (240)
/* Type resqml2__obj_USCOREFrontierFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_FrontierFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREFrontierFeature : public resqml2__AbstractTechnicalFeature
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFrontierFeature (240)
	virtual int soap_type(void) const { return 240; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREFrontierFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREFrontierFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREFrontierFeature); }
	         resqml2__obj_USCOREFrontierFeature() { resqml2__obj_USCOREFrontierFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREFrontierFeature() { }
	friend resqml2__obj_USCOREFrontierFeature *soap_instantiate_resqml2__obj_USCOREFrontierFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:864 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFeature (243)
/* Type resqml2__obj_USCOREWellboreFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_WellboreFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREWellboreFeature : public resqml2__AbstractTechnicalFeature
{
public:
	resqml2__WitsmlWellboreReference *WitsmlWellbore;	/* optional element of XSD type resqml2:WitsmlWellboreReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFeature (243)
	virtual int soap_type(void) const { return 243; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREWellboreFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREWellboreFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreFeature); }
	         resqml2__obj_USCOREWellboreFeature() { resqml2__obj_USCOREWellboreFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREWellboreFeature() { }
	friend resqml2__obj_USCOREWellboreFeature *soap_instantiate_resqml2__obj_USCOREWellboreFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:873 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicSurveyFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicSurveyFeature (246)
/* Type resqml2__AbstractSeismicSurveyFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:AbstractSeismicSurveyFeature complex type: */
class SOAP_CMAC resqml2__AbstractSeismicSurveyFeature : public resqml2__AbstractTechnicalFeature
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicSurveyFeature (246)
	virtual int soap_type(void) const { return 246; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__AbstractSeismicSurveyFeature, default initialized and not managed by a soap context
	virtual resqml2__AbstractSeismicSurveyFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractSeismicSurveyFeature); }
	         resqml2__AbstractSeismicSurveyFeature() { resqml2__AbstractSeismicSurveyFeature::soap_default(NULL); }
	virtual ~resqml2__AbstractSeismicSurveyFeature() { }
	friend resqml2__AbstractSeismicSurveyFeature *soap_instantiate_resqml2__AbstractSeismicSurveyFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:918 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesFeature (261)
/* Type resqml2__obj_USCOREStreamlinesFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_StreamlinesFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREStreamlinesFeature : public resqml2__AbstractTechnicalFeature
{
public:
	enum resqml2__StreamlineFlux Flux;	/* required element of XSD type resqml2:StreamlineFlux */
	std::string *OtherFlux;	/* optional element of XSD type xsd:string */
	resqml2__TimeIndex *TimeIndex;	/* required element of XSD type resqml2:TimeIndex */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesFeature (261)
	virtual int soap_type(void) const { return 261; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREStreamlinesFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREStreamlinesFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStreamlinesFeature); }
	         resqml2__obj_USCOREStreamlinesFeature() { resqml2__obj_USCOREStreamlinesFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREStreamlinesFeature() { }
	friend resqml2__obj_USCOREStreamlinesFeature *soap_instantiate_resqml2__obj_USCOREStreamlinesFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:29522 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_GeodeticCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_GeodeticCRSType (1183)
/* xsd:choice complex type: */
union _gml__union_GeodeticCRSType
{
#define SOAP_UNION_gsoap_resqml2_0_1__gml__union_GeodeticCRSType_ellipsoidalCS	(1)
	gml__EllipsoidalCSPropertyType *ellipsoidalCS;
#define SOAP_UNION_gsoap_resqml2_0_1__gml__union_GeodeticCRSType_cartesianCS	(2)
	gml__CartesianCSPropertyType *cartesianCS;
#define SOAP_UNION_gsoap_resqml2_0_1__gml__union_GeodeticCRSType_sphericalCS	(3)
	gml__SphericalCSPropertyType *sphericalCS;
};
#endif

/* resqml2_0_1ForGsoap.h:1524 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSType (463)
/* Type gml__GeodeticCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:GeodeticCRSType complex type: */
class SOAP_CMAC gml__GeodeticCRSType : public gml__AbstractCRSType
{
public:
	int __union_GeodeticCRSType;	/* union discriminant (of union defined below) */
	union _gml__union_GeodeticCRSType union_GeodeticCRSType;
	gml__GeodeticDatumPropertyType *geodeticDatum;	/* required element of XSD type gml:GeodeticDatumPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSType (463)
	virtual int soap_type(void) const { return 463; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeodeticCRSType, default initialized and not managed by a soap context
	virtual gml__GeodeticCRSType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticCRSType); }
	         gml__GeodeticCRSType() { gml__GeodeticCRSType::soap_default(NULL); }
	virtual ~gml__GeodeticCRSType() { }
	friend gml__GeodeticCRSType *soap_instantiate_gml__GeodeticCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1569 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSType (478)
/* Type gml__EllipsoidalCSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:EllipsoidalCSType complex type: */
class SOAP_CMAC gml__EllipsoidalCSType : public gml__AbstractCoordinateSystemType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSType (478)
	virtual int soap_type(void) const { return 478; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__EllipsoidalCSType, default initialized and not managed by a soap context
	virtual gml__EllipsoidalCSType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidalCSType); }
	         gml__EllipsoidalCSType() { gml__EllipsoidalCSType::soap_default(NULL); }
	virtual ~gml__EllipsoidalCSType() { }
	friend gml__EllipsoidalCSType *soap_instantiate_gml__EllipsoidalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1584 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSType (483)
/* Type gml__CartesianCSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:CartesianCSType complex type: */
class SOAP_CMAC gml__CartesianCSType : public gml__AbstractCoordinateSystemType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSType (483)
	virtual int soap_type(void) const { return 483; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CartesianCSType, default initialized and not managed by a soap context
	virtual gml__CartesianCSType *soap_alloc(void) const { return SOAP_NEW(gml__CartesianCSType); }
	         gml__CartesianCSType() { gml__CartesianCSType::soap_default(NULL); }
	virtual ~gml__CartesianCSType() { }
	friend gml__CartesianCSType *soap_instantiate_gml__CartesianCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1590 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSType (485)
/* Type gml__SphericalCSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:SphericalCSType complex type: */
class SOAP_CMAC gml__SphericalCSType : public gml__AbstractCoordinateSystemType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSType (485)
	virtual int soap_type(void) const { return 485; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__SphericalCSType, default initialized and not managed by a soap context
	virtual gml__SphericalCSType *soap_alloc(void) const { return SOAP_NEW(gml__SphericalCSType); }
	         gml__SphericalCSType() { gml__SphericalCSType::soap_default(NULL); }
	virtual ~gml__SphericalCSType() { }
	friend gml__SphericalCSType *soap_instantiate_gml__SphericalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1596 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumType (487)
/* Type gml__GeodeticDatumType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:GeodeticDatumType complex type: */
class SOAP_CMAC gml__GeodeticDatumType : public gml__AbstractDatumType
{
public:
	gml__PrimeMeridianPropertyType *primeMeridian;	/* required element of XSD type gml:PrimeMeridianPropertyType */
	gml__EllipsoidPropertyType *ellipsoid;	/* required element of XSD type gml:EllipsoidPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumType (487)
	virtual int soap_type(void) const { return 487; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeodeticDatumType, default initialized and not managed by a soap context
	virtual gml__GeodeticDatumType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticDatumType); }
	         gml__GeodeticDatumType() { gml__GeodeticDatumType::soap_default(NULL); }
	virtual ~gml__GeodeticDatumType() { }
	friend gml__GeodeticDatumType *soap_instantiate_gml__GeodeticDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1626 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralDerivedCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralDerivedCRSType (497)
/* Type gml__AbstractGeneralDerivedCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractGeneralDerivedCRSType complex type: */
class SOAP_CMAC gml__AbstractGeneralDerivedCRSType : public gml__AbstractCRSType
{
public:
	gml__GeneralConversionPropertyType *conversion;	/* required element of XSD type gml:GeneralConversionPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralDerivedCRSType (497)
	virtual int soap_type(void) const { return 497; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractGeneralDerivedCRSType, default initialized and not managed by a soap context
	virtual gml__AbstractGeneralDerivedCRSType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGeneralDerivedCRSType); }
	         gml__AbstractGeneralDerivedCRSType() { gml__AbstractGeneralDerivedCRSType::soap_default(NULL); }
	virtual ~gml__AbstractGeneralDerivedCRSType() { }
	friend gml__AbstractGeneralDerivedCRSType *soap_instantiate_gml__AbstractGeneralDerivedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1632 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralConversionType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralConversionType (499)
/* gml:AbstractGeneralConversionType complex type: */
class SOAP_CMAC gml__AbstractGeneralConversionType
{
public:
	gml__StringOrRefType *description;	/* optional element of XSD type gml:StringOrRefType */
	gml__ReferenceType *descriptionReference;	/* optional element of XSD type gml:ReferenceType */
	gml__CodeWithAuthorityType *identifier;	/* required element of XSD type gml:CodeWithAuthorityType */
	std::vector<gml__CodeType *> name;	/* optional element of XSD type gml:CodeType */
	std::string *remarks;	/* optional element of XSD type xsd:string */
	_gml__domainOfValidity *domainOfValidity;	/* optional element of XSD type gml:domainOfValidity */
	std::vector<std::string> scope;	/* required element of XSD type xsd:string */
	std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;	/* optional element of XSD type gml:coordinateOperationAccuracy */
	std::string gml__id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralConversionType (499)
	virtual int soap_type(void) const { return 499; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractGeneralConversionType, default initialized and not managed by a soap context
	virtual gml__AbstractGeneralConversionType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGeneralConversionType); }
	         gml__AbstractGeneralConversionType() { gml__AbstractGeneralConversionType::soap_default(NULL); }
	virtual ~gml__AbstractGeneralConversionType() { }
	friend gml__AbstractGeneralConversionType *soap_instantiate_gml__AbstractGeneralConversionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1644 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCRSType (503)
/* Type gml__VerticalCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:VerticalCRSType complex type: */
class SOAP_CMAC gml__VerticalCRSType : public gml__AbstractCRSType
{
public:
	gml__VerticalCSPropertyType *verticalCS;	/* required element of XSD type gml:VerticalCSPropertyType */
	gml__VerticalDatumPropertyType *verticalDatum;	/* required element of XSD type gml:VerticalDatumPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCRSType (503)
	virtual int soap_type(void) const { return 503; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalCRSType, default initialized and not managed by a soap context
	virtual gml__VerticalCRSType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCRSType); }
	         gml__VerticalCRSType() { gml__VerticalCRSType::soap_default(NULL); }
	virtual ~gml__VerticalCRSType() { }
	friend gml__VerticalCRSType *soap_instantiate_gml__VerticalCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1650 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSType (505)
/* Type gml__VerticalCSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:VerticalCSType complex type: */
class SOAP_CMAC gml__VerticalCSType : public gml__AbstractCoordinateSystemType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSType (505)
	virtual int soap_type(void) const { return 505; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalCSType, default initialized and not managed by a soap context
	virtual gml__VerticalCSType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCSType); }
	         gml__VerticalCSType() { gml__VerticalCSType::soap_default(NULL); }
	virtual ~gml__VerticalCSType() { }
	friend gml__VerticalCSType *soap_instantiate_gml__VerticalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1656 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumType (507)
/* Type gml__VerticalDatumType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:VerticalDatumType complex type: */
class SOAP_CMAC gml__VerticalDatumType : public gml__AbstractDatumType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumType (507)
	virtual int soap_type(void) const { return 507; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalDatumType, default initialized and not managed by a soap context
	virtual gml__VerticalDatumType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalDatumType); }
	         gml__VerticalDatumType() { gml__VerticalDatumType::soap_default(NULL); }
	virtual ~gml__VerticalDatumType() { }
	friend gml__VerticalDatumType *soap_instantiate_gml__VerticalDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:456 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation (107)
/* Type resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_UnstructuredColumnLayerGridRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation : public resqml2__AbstractColumnLayerGridRepresentation
{
public:
	ULONG64 ColumnCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__UnstructuredColumnLayerGridGeometry *Geometry;	/* optional element of XSD type resqml2:UnstructuredColumnLayerGridGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation (107)
	virtual int soap_type(void) const { return 107; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation); }
	         resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation() { resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation() { }
	friend resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation *soap_instantiate_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:462 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREIjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREIjkGridRepresentation (109)
/* Type resqml2__obj_USCOREIjkGridRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_IjkGridRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCOREIjkGridRepresentation : public resqml2__AbstractColumnLayerGridRepresentation
{
public:
	ULONG64 Ni;	/* required element of XSD type xsd:positiveInteger */
	ULONG64 Nj;	/* required element of XSD type xsd:positiveInteger */
	bool *RadialGridIsComplete;	/* optional element of XSD type xsd:boolean */
	resqml2__KGaps *KGaps;	/* optional element of XSD type resqml2:KGaps */
	resqml2__IjkGridGeometry *Geometry;	/* optional element of XSD type resqml2:IjkGridGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREIjkGridRepresentation (109)
	virtual int soap_type(void) const { return 109; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREIjkGridRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREIjkGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREIjkGridRepresentation); }
	         resqml2__obj_USCOREIjkGridRepresentation() { resqml2__obj_USCOREIjkGridRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREIjkGridRepresentation() { }
	friend resqml2__obj_USCOREIjkGridRepresentation *soap_instantiate_resqml2__obj_USCOREIjkGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:543 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation (136)
/* Type resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_TruncatedUnstructuredColumnLayerGridRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation : public resqml2__AbstractTruncatedColumnLayerGridRepresentation
{
public:
	ULONG64 ColumnCount;	/* required element of XSD type xsd:positiveInteger */
	resqml2__UnstructuredColumnLayerGridGeometry *Geometry;	/* required element of XSD type resqml2:UnstructuredColumnLayerGridGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation (136)
	virtual int soap_type(void) const { return 136; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation); }
	         resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation() { resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation() { }
	friend resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation *soap_instantiate_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:555 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedIjkGridRepresentation (140)
/* Type resqml2__obj_USCORETruncatedIjkGridRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_TruncatedIjkGridRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCORETruncatedIjkGridRepresentation : public resqml2__AbstractTruncatedColumnLayerGridRepresentation
{
public:
	ULONG64 Ni;	/* required element of XSD type xsd:positiveInteger */
	ULONG64 Nj;	/* required element of XSD type xsd:positiveInteger */
	resqml2__IjkGridGeometry *Geometry;	/* required element of XSD type resqml2:IjkGridGeometry */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedIjkGridRepresentation (140)
	virtual int soap_type(void) const { return 140; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORETruncatedIjkGridRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORETruncatedIjkGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETruncatedIjkGridRepresentation); }
	         resqml2__obj_USCORETruncatedIjkGridRepresentation() { resqml2__obj_USCORETruncatedIjkGridRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORETruncatedIjkGridRepresentation() { }
	friend resqml2__obj_USCORETruncatedIjkGridRepresentation *soap_instantiate_resqml2__obj_USCORETruncatedIjkGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:654 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumnRankInterpretation (173)
/* Type resqml2__obj_USCOREStratigraphicColumnRankInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_StratigraphicColumnRankInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicColumnRankInterpretation : public resqml2__AbstractStratigraphicOrganizationInterpretation
{
public:
	ULONG64 Index;	/* required element of XSD type xsd:nonNegativeInteger */
	std::vector<resqml2__StratigraphicUnitInterpretationIndex *> StratigraphicUnits;	/* required element of XSD type resqml2:StratigraphicUnitInterpretationIndex */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumnRankInterpretation (173)
	virtual int soap_type(void) const { return 173; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREStratigraphicColumnRankInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREStratigraphicColumnRankInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicColumnRankInterpretation); }
	         resqml2__obj_USCOREStratigraphicColumnRankInterpretation() { resqml2__obj_USCOREStratigraphicColumnRankInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREStratigraphicColumnRankInterpretation() { }
	friend resqml2__obj_USCOREStratigraphicColumnRankInterpretation *soap_instantiate_resqml2__obj_USCOREStratigraphicColumnRankInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:672 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation (179)
/* Type resqml2__obj_USCOREStratigraphicOccurrenceInterpretation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_StratigraphicOccurrenceInterpretation complex type: */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicOccurrenceInterpretation : public resqml2__AbstractStratigraphicOrganizationInterpretation
{
public:
	eml__DataObjectReference *IsOccurrenceOf;	/* optional element of XSD type eml:DataObjectReference */
	std::vector<resqml2__GeologicUnitInterpretationIndex *> GeologicUnitIndex;	/* optional element of XSD type resqml2:GeologicUnitInterpretationIndex */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation (179)
	virtual int soap_type(void) const { return 179; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREStratigraphicOccurrenceInterpretation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREStratigraphicOccurrenceInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicOccurrenceInterpretation); }
	         resqml2__obj_USCOREStratigraphicOccurrenceInterpretation() { resqml2__obj_USCOREStratigraphicOccurrenceInterpretation::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREStratigraphicOccurrenceInterpretation() { }
	friend resqml2__obj_USCOREStratigraphicOccurrenceInterpretation *soap_instantiate_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:675 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFluidBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFluidBoundaryFeature (180)
/* Type resqml2__obj_USCOREFluidBoundaryFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_FluidBoundaryFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREFluidBoundaryFeature : public resqml2__obj_USCOREBoundaryFeature
{
public:
	enum resqml2__FluidContact FluidContact;	/* required element of XSD type resqml2:FluidContact */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFluidBoundaryFeature (180)
	virtual int soap_type(void) const { return 180; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREFluidBoundaryFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREFluidBoundaryFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREFluidBoundaryFeature); }
	         resqml2__obj_USCOREFluidBoundaryFeature() { resqml2__obj_USCOREFluidBoundaryFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREFluidBoundaryFeature() { }
	friend resqml2__obj_USCOREFluidBoundaryFeature *soap_instantiate_resqml2__obj_USCOREFluidBoundaryFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:681 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitFeature (182)
/* Type resqml2__obj_USCORERockFluidUnitFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_RockFluidUnitFeature complex type: */
class SOAP_CMAC resqml2__obj_USCORERockFluidUnitFeature : public resqml2__obj_USCOREGeologicUnitFeature
{
public:
	enum resqml2__Phase Phase;	/* required element of XSD type resqml2:Phase */
	eml__DataObjectReference *FluidBoundaryBottom;	/* required element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *FluidBoundaryTop;	/* required element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitFeature (182)
	virtual int soap_type(void) const { return 182; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORERockFluidUnitFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORERockFluidUnitFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERockFluidUnitFeature); }
	         resqml2__obj_USCORERockFluidUnitFeature() { resqml2__obj_USCORERockFluidUnitFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCORERockFluidUnitFeature() { }
	friend resqml2__obj_USCORERockFluidUnitFeature *soap_instantiate_resqml2__obj_USCORERockFluidUnitFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:693 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitFeature (186)
/* Type resqml2__obj_USCOREStratigraphicUnitFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_StratigraphicUnitFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicUnitFeature : public resqml2__obj_USCOREGeologicUnitFeature
{
public:
	eml__DataObjectReference *ChronostratigraphicBottom;	/* optional element of XSD type eml:DataObjectReference */
	eml__DataObjectReference *ChronostratigraphicTop;	/* optional element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitFeature (186)
	virtual int soap_type(void) const { return 186; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREStratigraphicUnitFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREStratigraphicUnitFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicUnitFeature); }
	         resqml2__obj_USCOREStratigraphicUnitFeature() { resqml2__obj_USCOREStratigraphicUnitFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREStratigraphicUnitFeature() { }
	friend resqml2__obj_USCOREStratigraphicUnitFeature *soap_instantiate_resqml2__obj_USCOREStratigraphicUnitFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:699 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeneticBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeneticBoundaryFeature (188)
/* Type resqml2__obj_USCOREGeneticBoundaryFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GeneticBoundaryFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREGeneticBoundaryFeature : public resqml2__obj_USCOREBoundaryFeature
{
public:
	enum resqml2__GeneticBoundaryKind GeneticBoundaryKind;	/* required element of XSD type resqml2:GeneticBoundaryKind */
	resqml2__Timestamp *AbsoluteAge;	/* optional element of XSD type resqml2:Timestamp */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeneticBoundaryFeature (188)
	virtual int soap_type(void) const { return 188; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGeneticBoundaryFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGeneticBoundaryFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeneticBoundaryFeature); }
	         resqml2__obj_USCOREGeneticBoundaryFeature() { resqml2__obj_USCOREGeneticBoundaryFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGeneticBoundaryFeature() { }
	friend resqml2__obj_USCOREGeneticBoundaryFeature *soap_instantiate_resqml2__obj_USCOREGeneticBoundaryFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:702 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyFeature (189)
/* Type resqml2__obj_USCOREGeobodyFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_GeobodyFeature complex type: */
class SOAP_CMAC resqml2__obj_USCOREGeobodyFeature : public resqml2__obj_USCOREGeologicUnitFeature
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyFeature (189)
	virtual int soap_type(void) const { return 189; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREGeobodyFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREGeobodyFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeobodyFeature); }
	         resqml2__obj_USCOREGeobodyFeature() { resqml2__obj_USCOREGeobodyFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREGeobodyFeature() { }
	friend resqml2__obj_USCOREGeobodyFeature *soap_instantiate_resqml2__obj_USCOREGeobodyFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:708 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETectonicBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETectonicBoundaryFeature (191)
/* Type resqml2__obj_USCORETectonicBoundaryFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_TectonicBoundaryFeature complex type: */
class SOAP_CMAC resqml2__obj_USCORETectonicBoundaryFeature : public resqml2__obj_USCOREBoundaryFeature
{
public:
	enum resqml2__TectonicBoundaryKind TectonicBoundaryKind;	/* required element of XSD type resqml2:TectonicBoundaryKind */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETectonicBoundaryFeature (191)
	virtual int soap_type(void) const { return 191; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORETectonicBoundaryFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORETectonicBoundaryFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETectonicBoundaryFeature); }
	         resqml2__obj_USCORETectonicBoundaryFeature() { resqml2__obj_USCORETectonicBoundaryFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCORETectonicBoundaryFeature() { }
	friend resqml2__obj_USCORETectonicBoundaryFeature *soap_instantiate_resqml2__obj_USCORETectonicBoundaryFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:771 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation (212)
/* Type resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_NonSealedSurfaceFrameworkRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation : public resqml2__AbstractSurfaceFrameworkRepresentation
{
public:
	std::vector<resqml2__AbstractContactRepresentationPart *> NonSealedContactRepresentation;	/* optional element of XSD type resqml2:AbstractContactRepresentationPart */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation (212)
	virtual int soap_type(void) const { return 212; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation); }
	         resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation() { resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation() { }
	friend resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation *soap_instantiate_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:816 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation (227)
/* Type resqml2__obj_USCORESealedSurfaceFrameworkRepresentation is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_SealedSurfaceFrameworkRepresentation complex type: */
class SOAP_CMAC resqml2__obj_USCORESealedSurfaceFrameworkRepresentation : public resqml2__AbstractSurfaceFrameworkRepresentation
{
public:
	std::vector<resqml2__SealedContactRepresentationPart *> SealedContactRepresentation;	/* optional element of XSD type resqml2:SealedContactRepresentationPart */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation (227)
	virtual int soap_type(void) const { return 227; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORESealedSurfaceFrameworkRepresentation, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORESealedSurfaceFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESealedSurfaceFrameworkRepresentation); }
	         resqml2__obj_USCORESealedSurfaceFrameworkRepresentation() { resqml2__obj_USCORESealedSurfaceFrameworkRepresentation::soap_default(NULL); }
	virtual ~resqml2__obj_USCORESealedSurfaceFrameworkRepresentation() { }
	friend resqml2__obj_USCORESealedSurfaceFrameworkRepresentation *soap_instantiate_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:858 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SeismicLatticeSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SeismicLatticeSetFeature (241)
/* Type resqml2__SeismicLatticeSetFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:SeismicLatticeSetFeature complex type: */
class SOAP_CMAC resqml2__SeismicLatticeSetFeature : public resqml2__AbstractSeismicSurveyFeature
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SeismicLatticeSetFeature (241)
	virtual int soap_type(void) const { return 241; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__SeismicLatticeSetFeature, default initialized and not managed by a soap context
	virtual resqml2__SeismicLatticeSetFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__SeismicLatticeSetFeature); }
	         resqml2__SeismicLatticeSetFeature() { resqml2__SeismicLatticeSetFeature::soap_default(NULL); }
	virtual ~resqml2__SeismicLatticeSetFeature() { }
	friend resqml2__SeismicLatticeSetFeature *soap_instantiate_resqml2__SeismicLatticeSetFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:861 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineSetFeature (242)
/* Type resqml2__obj_USCORESeismicLineSetFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_SeismicLineSetFeature complex type: */
class SOAP_CMAC resqml2__obj_USCORESeismicLineSetFeature : public resqml2__AbstractSeismicSurveyFeature
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineSetFeature (242)
	virtual int soap_type(void) const { return 242; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORESeismicLineSetFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORESeismicLineSetFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESeismicLineSetFeature); }
	         resqml2__obj_USCORESeismicLineSetFeature() { resqml2__obj_USCORESeismicLineSetFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCORESeismicLineSetFeature() { }
	friend resqml2__obj_USCORESeismicLineSetFeature *soap_instantiate_resqml2__obj_USCORESeismicLineSetFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:867 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineFeature (244)
/* Type resqml2__obj_USCORESeismicLineFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_SeismicLineFeature complex type: */
class SOAP_CMAC resqml2__obj_USCORESeismicLineFeature : public resqml2__AbstractSeismicSurveyFeature
{
public:
	LONG64 FirstTraceIndex;	/* required element of XSD type xsd:integer */
	ULONG64 TraceCount;	/* required element of XSD type xsd:positiveInteger */
	LONG64 TraceIndexIncrement;	/* required element of XSD type xsd:integer */
	eml__DataObjectReference *IsPartOf;	/* optional element of XSD type eml:DataObjectReference */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineFeature (244)
	virtual int soap_type(void) const { return 244; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORESeismicLineFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORESeismicLineFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESeismicLineFeature); }
	         resqml2__obj_USCORESeismicLineFeature() { resqml2__obj_USCORESeismicLineFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCORESeismicLineFeature() { }
	friend resqml2__obj_USCORESeismicLineFeature *soap_instantiate_resqml2__obj_USCORESeismicLineFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:870 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLatticeFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLatticeFeature (245)
/* Type resqml2__obj_USCORESeismicLatticeFeature is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_SeismicLatticeFeature complex type: */
class SOAP_CMAC resqml2__obj_USCORESeismicLatticeFeature : public resqml2__AbstractSeismicSurveyFeature
{
public:
	ULONG64 CrosslineCount;	/* required element of XSD type xsd:positiveInteger */
	LONG64 CrosslineIndexIncrement;	/* required element of XSD type xsd:integer */
	LONG64 FirstCrosslineIndex;	/* required element of XSD type xsd:integer */
	LONG64 FirstInlineIndex;	/* required element of XSD type xsd:integer */
	ULONG64 InlineCount;	/* required element of XSD type xsd:positiveInteger */
	LONG64 InlineIndexIncrement;	/* required element of XSD type xsd:integer */
	resqml2__SeismicLatticeSetFeature *IsPartOf;	/* optional element of XSD type resqml2:SeismicLatticeSetFeature */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLatticeFeature (245)
	virtual int soap_type(void) const { return 245; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORESeismicLatticeFeature, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORESeismicLatticeFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESeismicLatticeFeature); }
	         resqml2__obj_USCORESeismicLatticeFeature() { resqml2__obj_USCORESeismicLatticeFeature::soap_default(NULL); }
	virtual ~resqml2__obj_USCORESeismicLatticeFeature() { }
	friend resqml2__obj_USCORESeismicLatticeFeature *soap_instantiate_resqml2__obj_USCORESeismicLatticeFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:933 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousPropertySeries (266)
/* Type resqml2__obj_USCOREContinuousPropertySeries is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_ContinuousPropertySeries complex type: */
class SOAP_CMAC resqml2__obj_USCOREContinuousPropertySeries : public resqml2__obj_USCOREContinuousProperty
{
public:
	resqml2__AbstractIntegerArray *RealizationIndices;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__TimeIndices *SeriesTimeIndices;	/* optional element of XSD type resqml2:TimeIndices */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousPropertySeries (266)
	virtual int soap_type(void) const { return 266; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREContinuousPropertySeries, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREContinuousPropertySeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREContinuousPropertySeries); }
	         resqml2__obj_USCOREContinuousPropertySeries() { resqml2__obj_USCOREContinuousPropertySeries::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREContinuousPropertySeries() { }
	friend resqml2__obj_USCOREContinuousPropertySeries *soap_instantiate_resqml2__obj_USCOREContinuousPropertySeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:936 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalPropertySeries (267)
/* Type resqml2__obj_USCORECategoricalPropertySeries is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_CategoricalPropertySeries complex type: */
class SOAP_CMAC resqml2__obj_USCORECategoricalPropertySeries : public resqml2__obj_USCORECategoricalProperty
{
public:
	resqml2__AbstractIntegerArray *RealizationIndices;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__TimeIndices *SeriesTimeIndices;	/* optional element of XSD type resqml2:TimeIndices */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalPropertySeries (267)
	virtual int soap_type(void) const { return 267; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORECategoricalPropertySeries, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORECategoricalPropertySeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORECategoricalPropertySeries); }
	         resqml2__obj_USCORECategoricalPropertySeries() { resqml2__obj_USCORECategoricalPropertySeries::soap_default(NULL); }
	virtual ~resqml2__obj_USCORECategoricalPropertySeries() { }
	friend resqml2__obj_USCORECategoricalPropertySeries *soap_instantiate_resqml2__obj_USCORECategoricalPropertySeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:939 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentPropertySeries (268)
/* Type resqml2__obj_USCORECommentPropertySeries is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_CommentPropertySeries complex type: */
class SOAP_CMAC resqml2__obj_USCORECommentPropertySeries : public resqml2__obj_USCORECommentProperty
{
public:
	resqml2__AbstractIntegerArray *RealizationIndices;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__TimeIndices *SeriesTimeIndices;	/* optional element of XSD type resqml2:TimeIndices */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentPropertySeries (268)
	virtual int soap_type(void) const { return 268; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCORECommentPropertySeries, default initialized and not managed by a soap context
	virtual resqml2__obj_USCORECommentPropertySeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORECommentPropertySeries); }
	         resqml2__obj_USCORECommentPropertySeries() { resqml2__obj_USCORECommentPropertySeries::soap_default(NULL); }
	virtual ~resqml2__obj_USCORECommentPropertySeries() { }
	friend resqml2__obj_USCORECommentPropertySeries *soap_instantiate_resqml2__obj_USCORECommentPropertySeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:942 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscretePropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscretePropertySeries (269)
/* Type resqml2__obj_USCOREDiscretePropertySeries is a recursive data type (in)directly referencing itself through its (base) class members */
/* resqml2:obj_DiscretePropertySeries complex type: */
class SOAP_CMAC resqml2__obj_USCOREDiscretePropertySeries : public resqml2__obj_USCOREDiscreteProperty
{
public:
	resqml2__AbstractIntegerArray *RealizationIndices;	/* optional element of XSD type resqml2:AbstractIntegerArray */
	resqml2__TimeIndices *SeriesTimeIndices;	/* optional element of XSD type resqml2:TimeIndices */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscretePropertySeries (269)
	virtual int soap_type(void) const { return 269; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type resqml2__obj_USCOREDiscretePropertySeries, default initialized and not managed by a soap context
	virtual resqml2__obj_USCOREDiscretePropertySeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREDiscretePropertySeries); }
	         resqml2__obj_USCOREDiscretePropertySeries() { resqml2__obj_USCOREDiscretePropertySeries::soap_default(NULL); }
	virtual ~resqml2__obj_USCOREDiscretePropertySeries() { }
	friend resqml2__obj_USCOREDiscretePropertySeries *soap_instantiate_resqml2__obj_USCOREDiscretePropertySeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:31102 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_ProjectedCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_ProjectedCRSType (1201)
/* xsd:choice complex type: */
union _gml__union_ProjectedCRSType
{
#define SOAP_UNION_gsoap_resqml2_0_1__gml__union_ProjectedCRSType_baseGeodeticCRS	(1)
	gml__GeodeticCRSPropertyType *baseGeodeticCRS;
};
#endif

/* resqml2_0_1ForGsoap.h:1623 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__ProjectedCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__ProjectedCRSType (496)
/* Type gml__ProjectedCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:ProjectedCRSType complex type: */
class SOAP_CMAC gml__ProjectedCRSType : public gml__AbstractGeneralDerivedCRSType
{
public:
	int __union_ProjectedCRSType;	/* union discriminant (of union defined below) */
	union _gml__union_ProjectedCRSType union_ProjectedCRSType;
	gml__CartesianCSPropertyType *cartesianCS;	/* required element of XSD type gml:CartesianCSPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_resqml2_0_1_gml__ProjectedCRSType (496)
	virtual int soap_type(void) const { return 496; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__ProjectedCRSType, default initialized and not managed by a soap context
	virtual gml__ProjectedCRSType *soap_alloc(void) const { return SOAP_NEW(gml__ProjectedCRSType); }
	         gml__ProjectedCRSType() { gml__ProjectedCRSType::soap_default(NULL); }
	virtual ~gml__ProjectedCRSType() { }
	friend gml__ProjectedCRSType *soap_instantiate_gml__ProjectedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:33170 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Header (1356)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 1356; } /* = unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	virtual ~SOAP_ENV__Header() { }
};
#endif
#endif

/* resqml2_0_1ForGsoap.h:33170 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Code (1357)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 1357; } /* = unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	virtual ~SOAP_ENV__Code() { }
};
#endif
#endif

/* resqml2_0_1ForGsoap.h:33170 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Detail (1359)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 1359; } /* = unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	virtual ~SOAP_ENV__Detail() { }
};
#endif
#endif

/* resqml2_0_1ForGsoap.h:33170 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Reason (1362)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 1362; } /* = unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	virtual ~SOAP_ENV__Reason() { }
};
#endif
#endif

/* resqml2_0_1ForGsoap.h:33170 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Fault (1363)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 1363; } /* = unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	virtual ~SOAP_ENV__Fault() { }
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* resqml2_0_1ForGsoap.h:1 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__QName
#define SOAP_TYPE_gsoap_resqml2_0_1__QName (5)
typedef char *_QName;
#endif

/* resqml2_0_1ForGsoap.h:1 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__XML
#define SOAP_TYPE_gsoap_resqml2_0_1__XML (6)
typedef char *_XML;
#endif

/* resqml2_0_1ForGsoap.h:175 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__integer
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__integer (13)
typedef LONG64 xsd__integer;
#endif

/* resqml2_0_1ForGsoap.h:178 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__nonNegativeInteger (16)
typedef ULONG64 xsd__nonNegativeInteger;
#endif

/* resqml2_0_1ForGsoap.h:181 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__positiveInteger
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__positiveInteger (17)
typedef ULONG64 xsd__positiveInteger;
#endif

/* resqml2_0_1ForGsoap.h:184 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__ID
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__ID (19)
typedef std::string xsd__ID;
#endif

/* resqml2_0_1ForGsoap.h:187 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__anyURI
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__anyURI (20)
typedef std::string xsd__anyURI;
#endif

/* resqml2_0_1ForGsoap.h:190 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__date
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__date (21)
typedef std::string xsd__date;
#endif

/* resqml2_0_1ForGsoap.h:1836 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonType (559)
typedef std::string gml__NilReasonType;
#endif

/* resqml2_0_1ForGsoap.h:1840 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonEnumeration
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonEnumeration (560)
typedef std::string gml__NilReasonEnumeration;
#endif

/* resqml2_0_1ForGsoap.h:1843 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__UomIdentifier
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__UomIdentifier (561)
typedef std::string gml__UomIdentifier;
#endif

/* resqml2_0_1ForGsoap.h:1878 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREType (562)
typedef std::string gco__Date_USCOREType;
#endif

/* resqml2_0_1ForGsoap.h:4539 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__UuidString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__UuidString (603)
typedef std::string eml__UuidString;
#endif

/* resqml2_0_1ForGsoap.h:4546 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__Measure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__Measure (605)
typedef double eml__Measure;
#endif

/* resqml2_0_1ForGsoap.h:4554 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__String
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__String (606)
typedef std::string eml__String;
#endif

/* resqml2_0_1ForGsoap.h:4570 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__UomSymbol
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__UomSymbol (607)
typedef std::string gml__UomSymbol;
#endif

/* resqml2_0_1ForGsoap.h:4580 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__UomURI
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__UomURI (608)
typedef xsd__anyURI gml__UomURI;
#endif

/* resqml2_0_1ForGsoap.h:4690 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DescriptionString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DescriptionString (612)
typedef eml__String eml__DescriptionString;
#endif

/* resqml2_0_1ForGsoap.h:4698 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TypeEnum
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TypeEnum (613)
typedef eml__String eml__TypeEnum;
#endif

/* resqml2_0_1ForGsoap.h:4707 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__NameString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__NameString (614)
typedef eml__String eml__NameString;
#endif

/* resqml2_0_1ForGsoap.h:4717 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__UidString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__UidString (615)
typedef eml__String eml__UidString;
#endif

/* resqml2_0_1ForGsoap.h:4726 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MaximumLengthString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MaximumLengthString (616)
typedef eml__String eml__MaximumLengthString;
#endif

/* resqml2_0_1ForGsoap.h:4735 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__UomEnum
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__UomEnum (617)
typedef eml__String eml__UomEnum;
#endif

/* resqml2_0_1ForGsoap.h:5232 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CommentString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CommentString (620)
typedef eml__String eml__CommentString;
#endif

/* resqml2_0_1ForGsoap.h:31120 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Activity
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Activity (1202)
typedef resqml2__obj_USCOREActivity _resqml2__Activity;
#endif

/* resqml2_0_1ForGsoap.h:31123 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ActivityTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ActivityTemplate (1203)
typedef resqml2__obj_USCOREActivityTemplate _resqml2__ActivityTemplate;
#endif

/* resqml2_0_1ForGsoap.h:31126 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalPropertySeries (1204)
typedef resqml2__obj_USCORECategoricalPropertySeries _resqml2__CategoricalPropertySeries;
#endif

/* resqml2_0_1ForGsoap.h:31129 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentPropertySeries (1205)
typedef resqml2__obj_USCORECommentPropertySeries _resqml2__CommentPropertySeries;
#endif

/* resqml2_0_1ForGsoap.h:31132 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousPropertySeries (1206)
typedef resqml2__obj_USCOREContinuousPropertySeries _resqml2__ContinuousPropertySeries;
#endif

/* resqml2_0_1ForGsoap.h:31135 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscretePropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscretePropertySeries (1207)
typedef resqml2__obj_USCOREDiscretePropertySeries _resqml2__DiscretePropertySeries;
#endif

/* resqml2_0_1ForGsoap.h:31138 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesFeature (1208)
typedef resqml2__obj_USCOREStreamlinesFeature _resqml2__StreamlinesFeature;
#endif

/* resqml2_0_1ForGsoap.h:31141 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesRepresentation (1209)
typedef resqml2__obj_USCOREStreamlinesRepresentation _resqml2__StreamlinesRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31144 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalDepth3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalDepth3dCrs (1210)
typedef resqml2__obj_USCORELocalDepth3dCrs _resqml2__LocalDepth3dCrs;
#endif

/* resqml2_0_1ForGsoap.h:31147 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalTime3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalTime3dCrs (1211)
typedef resqml2__obj_USCORELocalTime3dCrs _resqml2__LocalTime3dCrs;
#endif

/* resqml2_0_1ForGsoap.h:31150 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TimeSeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TimeSeries (1212)
typedef resqml2__obj_USCORETimeSeries _resqml2__TimeSeries;
#endif

/* resqml2_0_1ForGsoap.h:31153 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FluidBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FluidBoundaryFeature (1213)
typedef resqml2__obj_USCOREFluidBoundaryFeature _resqml2__FluidBoundaryFeature;
#endif

/* resqml2_0_1ForGsoap.h:31156 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeneticBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeneticBoundaryFeature (1214)
typedef resqml2__obj_USCOREGeneticBoundaryFeature _resqml2__GeneticBoundaryFeature;
#endif

/* resqml2_0_1ForGsoap.h:31159 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyFeature (1215)
typedef resqml2__obj_USCOREGeobodyFeature _resqml2__GeobodyFeature;
#endif

/* resqml2_0_1ForGsoap.h:31162 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GlobalChronostratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GlobalChronostratigraphicColumn (1216)
typedef resqml2__obj_USCOREGlobalChronostratigraphicColumn _resqml2__GlobalChronostratigraphicColumn;
#endif

/* resqml2_0_1ForGsoap.h:31165 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitFeature (1217)
typedef resqml2__obj_USCORERockFluidUnitFeature _resqml2__RockFluidUnitFeature;
#endif

/* resqml2_0_1ForGsoap.h:31168 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitFeature (1218)
typedef resqml2__obj_USCOREStratigraphicUnitFeature _resqml2__StratigraphicUnitFeature;
#endif

/* resqml2_0_1ForGsoap.h:31171 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TectonicBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TectonicBoundaryFeature (1219)
typedef resqml2__obj_USCORETectonicBoundaryFeature _resqml2__TectonicBoundaryFeature;
#endif

/* resqml2_0_1ForGsoap.h:31174 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeature (1220)
typedef resqml2__obj_USCOREBoundaryFeature _resqml2__BoundaryFeature;
#endif

/* resqml2_0_1ForGsoap.h:31177 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitFeature (1221)
typedef resqml2__obj_USCOREGeologicUnitFeature _resqml2__GeologicUnitFeature;
#endif

/* resqml2_0_1ForGsoap.h:31180 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__OrganizationFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__OrganizationFeature (1222)
typedef resqml2__obj_USCOREOrganizationFeature _resqml2__OrganizationFeature;
#endif

/* resqml2_0_1ForGsoap.h:31183 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FrontierFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FrontierFeature (1223)
typedef resqml2__obj_USCOREFrontierFeature _resqml2__FrontierFeature;
#endif

/* resqml2_0_1ForGsoap.h:31186 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLatticeFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLatticeFeature (1224)
typedef resqml2__obj_USCORESeismicLatticeFeature _resqml2__SeismicLatticeFeature;
#endif

/* resqml2_0_1ForGsoap.h:31189 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineFeature (1225)
typedef resqml2__obj_USCORESeismicLineFeature _resqml2__SeismicLineFeature;
#endif

/* resqml2_0_1ForGsoap.h:31192 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineSetFeature (1226)
typedef resqml2__obj_USCORESeismicLineSetFeature _resqml2__SeismicLineSetFeature;
#endif

/* resqml2_0_1ForGsoap.h:31195 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFeature (1227)
typedef resqml2__obj_USCOREWellboreFeature _resqml2__WellboreFeature;
#endif

/* resqml2_0_1ForGsoap.h:31198 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeatureInterpretation (1228)
typedef resqml2__obj_USCOREBoundaryFeatureInterpretation _resqml2__BoundaryFeatureInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31201 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GenericFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GenericFeatureInterpretation (1229)
typedef resqml2__obj_USCOREGenericFeatureInterpretation _resqml2__GenericFeatureInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31204 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitInterpretation (1230)
typedef resqml2__obj_USCOREGeologicUnitInterpretation _resqml2__GeologicUnitInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31207 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumn (1231)
typedef resqml2__obj_USCOREStratigraphicColumn _resqml2__StratigraphicColumn;
#endif

/* resqml2_0_1ForGsoap.h:31210 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumnRankInterpretation (1232)
typedef resqml2__obj_USCOREStratigraphicColumnRankInterpretation _resqml2__StratigraphicColumnRankInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31213 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicOccurrenceInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicOccurrenceInterpretation (1233)
typedef resqml2__obj_USCOREStratigraphicOccurrenceInterpretation _resqml2__StratigraphicOccurrenceInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31216 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StructuralOrganizationInterpretation (1234)
typedef resqml2__obj_USCOREStructuralOrganizationInterpretation _resqml2__StructuralOrganizationInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31219 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreInterpretation (1235)
typedef resqml2__obj_USCOREWellboreInterpretation _resqml2__WellboreInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31222 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__EarthModelInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__EarthModelInterpretation (1236)
typedef resqml2__obj_USCOREEarthModelInterpretation _resqml2__EarthModelInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31225 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FaultInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FaultInterpretation (1237)
typedef resqml2__obj_USCOREFaultInterpretation _resqml2__FaultInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31228 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyBoundaryInterpretation (1238)
typedef resqml2__obj_USCOREGeobodyBoundaryInterpretation _resqml2__GeobodyBoundaryInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31231 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyInterpretation (1239)
typedef resqml2__obj_USCOREGeobodyInterpretation _resqml2__GeobodyInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31234 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitInterpretation (1240)
typedef resqml2__obj_USCORERockFluidUnitInterpretation _resqml2__RockFluidUnitInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31237 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__HorizonInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__HorizonInterpretation (1241)
typedef resqml2__obj_USCOREHorizonInterpretation _resqml2__HorizonInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31240 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidOrganizationInterpretation (1242)
typedef resqml2__obj_USCORERockFluidOrganizationInterpretation _resqml2__RockFluidOrganizationInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31243 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitInterpretation (1243)
typedef resqml2__obj_USCOREStratigraphicUnitInterpretation _resqml2__StratigraphicUnitInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31246 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RedefinedGeometryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RedefinedGeometryRepresentation (1244)
typedef resqml2__obj_USCORERedefinedGeometryRepresentation _resqml2__RedefinedGeometryRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31249 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationIdentitySet
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationIdentitySet (1245)
typedef resqml2__obj_USCORERepresentationIdentitySet _resqml2__RepresentationIdentitySet;
#endif

/* resqml2_0_1ForGsoap.h:31252 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationSetRepresentation (1246)
typedef resqml2__obj_USCORERepresentationSetRepresentation _resqml2__RepresentationSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31255 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SubRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SubRepresentation (1247)
typedef resqml2__obj_USCORESubRepresentation _resqml2__SubRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31258 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GpGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GpGridRepresentation (1248)
typedef resqml2__obj_USCOREGpGridRepresentation _resqml2__GpGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31261 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GridConnectionSetRepresentation (1249)
typedef resqml2__obj_USCOREGridConnectionSetRepresentation _resqml2__GridConnectionSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31264 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__IjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__IjkGridRepresentation (1250)
typedef resqml2__obj_USCOREIjkGridRepresentation _resqml2__IjkGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31267 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalGridSet
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalGridSet (1251)
typedef resqml2__obj_USCORELocalGridSet _resqml2__LocalGridSet;
#endif

/* resqml2_0_1ForGsoap.h:31270 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedIjkGridRepresentation (1252)
typedef resqml2__obj_USCORETruncatedIjkGridRepresentation _resqml2__TruncatedIjkGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31273 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedUnstructuredColumnLayerGridRepresentation (1253)
typedef resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation _resqml2__TruncatedUnstructuredColumnLayerGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31276 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredColumnLayerGridRepresentation (1254)
typedef resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation _resqml2__UnstructuredColumnLayerGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31279 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredGridRepresentation (1255)
typedef resqml2__obj_USCOREUnstructuredGridRepresentation _resqml2__UnstructuredGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31282 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dRepresentation (1256)
typedef resqml2__obj_USCOREGrid2dRepresentation _resqml2__Grid2dRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31285 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dSetRepresentation (1257)
typedef resqml2__obj_USCOREGrid2dSetRepresentation _resqml2__Grid2dSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31288 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__NonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__NonSealedSurfaceFrameworkRepresentation (1258)
typedef resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation _resqml2__NonSealedSurfaceFrameworkRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31291 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PlaneSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PlaneSetRepresentation (1259)
typedef resqml2__obj_USCOREPlaneSetRepresentation _resqml2__PlaneSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31294 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointSetRepresentation (1260)
typedef resqml2__obj_USCOREPointSetRepresentation _resqml2__PointSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31297 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineRepresentation (1261)
typedef resqml2__obj_USCOREPolylineRepresentation _resqml2__PolylineRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31300 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineSetRepresentation (1262)
typedef resqml2__obj_USCOREPolylineSetRepresentation _resqml2__PolylineSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31303 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedSurfaceFrameworkRepresentation (1263)
typedef resqml2__obj_USCORESealedSurfaceFrameworkRepresentation _resqml2__SealedSurfaceFrameworkRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31306 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedVolumeFrameworkRepresentation (1264)
typedef resqml2__obj_USCORESealedVolumeFrameworkRepresentation _resqml2__SealedVolumeFrameworkRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31309 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TriangulatedSetRepresentation (1265)
typedef resqml2__obj_USCORETriangulatedSetRepresentation _resqml2__TriangulatedSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31312 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BlockedWellboreRepresentation (1266)
typedef resqml2__obj_USCOREBlockedWellboreRepresentation _resqml2__BlockedWellboreRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31315 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DeviationSurveyRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DeviationSurveyRepresentation (1267)
typedef resqml2__obj_USCOREDeviationSurveyRepresentation _resqml2__DeviationSurveyRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31318 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__MdDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__MdDatum (1268)
typedef resqml2__obj_USCOREMdDatum _resqml2__MdDatum;
#endif

/* resqml2_0_1ForGsoap.h:31321 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFrameRepresentation (1269)
typedef resqml2__obj_USCOREWellboreFrameRepresentation _resqml2__WellboreFrameRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31324 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreMarkerFrameRepresentation (1270)
typedef resqml2__obj_USCOREWellboreMarkerFrameRepresentation _resqml2__WellboreMarkerFrameRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31327 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreTrajectoryRepresentation (1271)
typedef resqml2__obj_USCOREWellboreTrajectoryRepresentation _resqml2__WellboreTrajectoryRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31330 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalProperty (1272)
typedef resqml2__obj_USCORECategoricalProperty _resqml2__CategoricalProperty;
#endif

/* resqml2_0_1ForGsoap.h:31333 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentProperty (1273)
typedef resqml2__obj_USCORECommentProperty _resqml2__CommentProperty;
#endif

/* resqml2_0_1ForGsoap.h:31336 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousProperty (1274)
typedef resqml2__obj_USCOREContinuousProperty _resqml2__ContinuousProperty;
#endif

/* resqml2_0_1ForGsoap.h:31339 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscreteProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscreteProperty (1275)
typedef resqml2__obj_USCOREDiscreteProperty _resqml2__DiscreteProperty;
#endif

/* resqml2_0_1ForGsoap.h:31342 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DoubleTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DoubleTableLookup (1276)
typedef resqml2__obj_USCOREDoubleTableLookup _resqml2__DoubleTableLookup;
#endif

/* resqml2_0_1ForGsoap.h:31345 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointsProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointsProperty (1277)
typedef resqml2__obj_USCOREPointsProperty _resqml2__PointsProperty;
#endif

/* resqml2_0_1ForGsoap.h:31348 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertyKind (1278)
typedef resqml2__obj_USCOREPropertyKind _resqml2__PropertyKind;
#endif

/* resqml2_0_1ForGsoap.h:31351 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertySet
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertySet (1279)
typedef resqml2__obj_USCOREPropertySet _resqml2__PropertySet;
#endif

/* resqml2_0_1ForGsoap.h:31354 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StringTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StringTableLookup (1280)
typedef resqml2__obj_USCOREStringTableLookup _resqml2__StringTableLookup;
#endif

/* resqml2_0_1ForGsoap.h:31373 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__eml__EpcExternalPartReference
#define SOAP_TYPE_gsoap_resqml2_0_1__eml__EpcExternalPartReference (1281)
typedef eml__obj_USCOREEpcExternalPartReference _eml__EpcExternalPartReference;
#endif

/* resqml2_0_1ForGsoap.h:31379 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractDataObject
#define SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractDataObject (1282)
typedef eml__AbstractObject _eml__AbstractDataObject;
#endif

/* resqml2_0_1ForGsoap.h:31385 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractContextualObject
#define SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractContextualObject (1283)
typedef eml__AbstractObject _eml__AbstractContextualObject;
#endif

/* resqml2_0_1ForGsoap.h:31404 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticCRS (1284)
typedef gml__GeodeticCRSType _gml__GeodeticCRS;
#endif

/* resqml2_0_1ForGsoap.h:31410 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__description
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__description (1285)
typedef gml__StringOrRefType _gml__description;
#endif

/* resqml2_0_1ForGsoap.h:31416 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__descriptionReference
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__descriptionReference (1286)
typedef gml__ReferenceType _gml__descriptionReference;
#endif

/* resqml2_0_1ForGsoap.h:31422 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__identifier
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__identifier (1287)
typedef gml__CodeWithAuthorityType _gml__identifier;
#endif

/* resqml2_0_1ForGsoap.h:31428 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__name
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__name (1288)
typedef gml__CodeType _gml__name;
#endif

/* resqml2_0_1ForGsoap.h:31431 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__remarks
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__remarks (1289)
typedef std::string _gml__remarks;
#endif

/* resqml2_0_1ForGsoap.h:31439 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__Definition
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__Definition (1290)
typedef gml__DefinitionType _gml__Definition;
#endif

/* resqml2_0_1ForGsoap.h:31445 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__scope
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__scope (1291)
typedef std::string _gml__scope;
#endif

/* resqml2_0_1ForGsoap.h:31451 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoidalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoidalCS (1292)
typedef gml__EllipsoidalCSPropertyType _gml__ellipsoidalCS;
#endif

/* resqml2_0_1ForGsoap.h:31457 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__EllipsoidalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__EllipsoidalCS (1293)
typedef gml__EllipsoidalCSType _gml__EllipsoidalCS;
#endif

/* resqml2_0_1ForGsoap.h:31463 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__axis
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__axis (1294)
typedef gml__CoordinateSystemAxisPropertyType _gml__axis;
#endif

/* resqml2_0_1ForGsoap.h:31469 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__CoordinateSystemAxis
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__CoordinateSystemAxis (1295)
typedef gml__CoordinateSystemAxisType _gml__CoordinateSystemAxis;
#endif

/* resqml2_0_1ForGsoap.h:31475 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__axisAbbrev
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__axisAbbrev (1296)
typedef gml__CodeType _gml__axisAbbrev;
#endif

/* resqml2_0_1ForGsoap.h:31483 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__axisDirection
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__axisDirection (1297)
typedef gml__CodeWithAuthorityType _gml__axisDirection;
#endif

/* resqml2_0_1ForGsoap.h:31489 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__minimumValue
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__minimumValue (1298)
typedef double _gml__minimumValue;
#endif

/* resqml2_0_1ForGsoap.h:31495 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__maximumValue
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__maximumValue (1299)
typedef double _gml__maximumValue;
#endif

/* resqml2_0_1ForGsoap.h:31501 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__rangeMeaning
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__rangeMeaning (1300)
typedef gml__CodeWithAuthorityType _gml__rangeMeaning;
#endif

/* resqml2_0_1ForGsoap.h:31507 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__cartesianCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__cartesianCS (1301)
typedef gml__CartesianCSPropertyType _gml__cartesianCS;
#endif

/* resqml2_0_1ForGsoap.h:31513 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__CartesianCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__CartesianCS (1302)
typedef gml__CartesianCSType _gml__CartesianCS;
#endif

/* resqml2_0_1ForGsoap.h:31519 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__sphericalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__sphericalCS (1303)
typedef gml__SphericalCSPropertyType _gml__sphericalCS;
#endif

/* resqml2_0_1ForGsoap.h:31525 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__SphericalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__SphericalCS (1304)
typedef gml__SphericalCSType _gml__SphericalCS;
#endif

/* resqml2_0_1ForGsoap.h:31531 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__geodeticDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__geodeticDatum (1305)
typedef gml__GeodeticDatumPropertyType _gml__geodeticDatum;
#endif

/* resqml2_0_1ForGsoap.h:31537 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticDatum (1306)
typedef gml__GeodeticDatumType _gml__GeodeticDatum;
#endif

/* resqml2_0_1ForGsoap.h:31547 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__anchorDefinition
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__anchorDefinition (1307)
typedef gml__CodeType _gml__anchorDefinition;
#endif

/* resqml2_0_1ForGsoap.h:31553 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__realizationEpoch
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__realizationEpoch (1308)
typedef xsd__date _gml__realizationEpoch;
#endif

/* resqml2_0_1ForGsoap.h:31559 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__primeMeridian
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__primeMeridian (1309)
typedef gml__PrimeMeridianPropertyType _gml__primeMeridian;
#endif

/* resqml2_0_1ForGsoap.h:31565 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__PrimeMeridian
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__PrimeMeridian (1310)
typedef gml__PrimeMeridianType _gml__PrimeMeridian;
#endif

/* resqml2_0_1ForGsoap.h:31571 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__greenwichLongitude
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__greenwichLongitude (1311)
typedef gml__AngleType _gml__greenwichLongitude;
#endif

/* resqml2_0_1ForGsoap.h:31577 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoid
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoid (1312)
typedef gml__EllipsoidPropertyType _gml__ellipsoid;
#endif

/* resqml2_0_1ForGsoap.h:31583 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__Ellipsoid
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__Ellipsoid (1313)
typedef gml__EllipsoidType _gml__Ellipsoid;
#endif

/* resqml2_0_1ForGsoap.h:31589 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__semiMajorAxis
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__semiMajorAxis (1314)
typedef gml__MeasureType _gml__semiMajorAxis;
#endif

/* resqml2_0_1ForGsoap.h:31595 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__ProjectedCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__ProjectedCRS (1315)
typedef gml__ProjectedCRSType _gml__ProjectedCRS;
#endif

/* resqml2_0_1ForGsoap.h:31601 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__conversion
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__conversion (1316)
typedef gml__GeneralConversionPropertyType _gml__conversion;
#endif

/* resqml2_0_1ForGsoap.h:31607 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__operationVersion
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__operationVersion (1317)
typedef std::string _gml__operationVersion;
#endif

/* resqml2_0_1ForGsoap.h:31613 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__sourceCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__sourceCRS (1318)
typedef gml__CRSPropertyType _gml__sourceCRS;
#endif

/* resqml2_0_1ForGsoap.h:31619 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__targetCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__targetCRS (1319)
typedef gml__CRSPropertyType _gml__targetCRS;
#endif

/* resqml2_0_1ForGsoap.h:31625 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__baseGeodeticCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__baseGeodeticCRS (1320)
typedef gml__GeodeticCRSPropertyType _gml__baseGeodeticCRS;
#endif

/* resqml2_0_1ForGsoap.h:31631 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCRS (1321)
typedef gml__VerticalCRSType _gml__VerticalCRS;
#endif

/* resqml2_0_1ForGsoap.h:31637 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalCS (1322)
typedef gml__VerticalCSPropertyType _gml__verticalCS;
#endif

/* resqml2_0_1ForGsoap.h:31643 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCS (1323)
typedef gml__VerticalCSType _gml__VerticalCS;
#endif

/* resqml2_0_1ForGsoap.h:31649 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalDatum (1324)
typedef gml__VerticalDatumPropertyType _gml__verticalDatum;
#endif

/* resqml2_0_1ForGsoap.h:31655 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalDatum (1325)
typedef gml__VerticalDatumType _gml__VerticalDatum;
#endif

/* resqml2_0_1ForGsoap.h:31669 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__id
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__id (1326)
typedef xsd__ID _gml__id;
#endif

/* resqml2_0_1ForGsoap.h:31688 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__href
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__href (1327)
typedef xsd__anyURI _xlink__href;
#endif

/* resqml2_0_1ForGsoap.h:31691 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__role
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__role (1328)
typedef xsd__anyURI _xlink__role;
#endif

/* resqml2_0_1ForGsoap.h:31694 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__arcrole
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__arcrole (1329)
typedef xsd__anyURI _xlink__arcrole;
#endif

/* resqml2_0_1ForGsoap.h:31697 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__title
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__title (1330)
typedef std::string _xlink__title;
#endif

/* resqml2_0_1ForGsoap.h:31708 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREExtent
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREExtent (1331)
typedef gmd__EX_USCOREExtent_USCOREType _gmd__EX_USCOREExtent;
#endif

/* resqml2_0_1ForGsoap.h:31711 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCORETemporalExtent
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCORETemporalExtent (1332)
typedef gmd__EX_USCORETemporalExtent_USCOREType _gmd__EX_USCORETemporalExtent;
#endif

/* resqml2_0_1ForGsoap.h:31714 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREVerticalExtent
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREVerticalExtent (1333)
typedef gmd__EX_USCOREVerticalExtent_USCOREType _gmd__EX_USCOREVerticalExtent;
#endif

/* resqml2_0_1ForGsoap.h:31717 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__MD_USCOREIdentifier
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__MD_USCOREIdentifier (1334)
typedef gmd__MD_USCOREIdentifier_USCOREType _gmd__MD_USCOREIdentifier;
#endif

/* resqml2_0_1ForGsoap.h:31720 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORECitation
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORECitation (1335)
typedef gmd__CI_USCORECitation_USCOREType _gmd__CI_USCORECitation;
#endif

/* resqml2_0_1ForGsoap.h:31723 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDate
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDate (1336)
typedef gmd__CI_USCOREDate_USCOREType _gmd__CI_USCOREDate;
#endif

/* resqml2_0_1ForGsoap.h:31726 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDateTypeCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDateTypeCode (1337)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREDateTypeCode;
#endif

/* resqml2_0_1ForGsoap.h:31729 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREResponsibleParty
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREResponsibleParty (1338)
typedef gmd__CI_USCOREResponsibleParty_USCOREType _gmd__CI_USCOREResponsibleParty;
#endif

/* resqml2_0_1ForGsoap.h:31732 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREContact
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREContact (1339)
typedef gmd__CI_USCOREContact_USCOREType _gmd__CI_USCOREContact;
#endif

/* resqml2_0_1ForGsoap.h:31735 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORETelephone
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORETelephone (1340)
typedef gmd__CI_USCORETelephone_USCOREType _gmd__CI_USCORETelephone;
#endif

/* resqml2_0_1ForGsoap.h:31738 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREAddress
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREAddress (1341)
typedef gmd__CI_USCOREAddress_USCOREType _gmd__CI_USCOREAddress;
#endif

/* resqml2_0_1ForGsoap.h:31741 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnlineResource
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnlineResource (1342)
typedef gmd__CI_USCOREOnlineResource_USCOREType _gmd__CI_USCOREOnlineResource;
#endif

/* resqml2_0_1ForGsoap.h:31744 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__URL
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__URL (1343)
typedef xsd__anyURI _gmd__URL;
#endif

/* resqml2_0_1ForGsoap.h:31747 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnLineFunctionCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnLineFunctionCode (1344)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREOnLineFunctionCode;
#endif

/* resqml2_0_1ForGsoap.h:31750 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORERoleCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORERoleCode (1345)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCORERoleCode;
#endif

/* resqml2_0_1ForGsoap.h:31753 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREPresentationFormCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREPresentationFormCode (1346)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREPresentationFormCode;
#endif

/* resqml2_0_1ForGsoap.h:31756 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORESeries
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORESeries (1347)
typedef gmd__CI_USCORESeries_USCOREType _gmd__CI_USCORESeries;
#endif

/* resqml2_0_1ForGsoap.h:31759 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__DQ_USCOREEvaluationMethodTypeCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__DQ_USCOREEvaluationMethodTypeCode (1348)
typedef gco__CodeListValue_USCOREType _gmd__DQ_USCOREEvaluationMethodTypeCode;
#endif

/* resqml2_0_1ForGsoap.h:31794 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__CharacterString
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__CharacterString (1349)
typedef std::string _gco__CharacterString;
#endif

/* resqml2_0_1ForGsoap.h:31797 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__Boolean
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__Boolean (1350)
typedef bool _gco__Boolean;
#endif

/* resqml2_0_1ForGsoap.h:31800 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__Real
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__Real (1351)
typedef double _gco__Real;
#endif

/* resqml2_0_1ForGsoap.h:31803 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__Date
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__Date (1352)
typedef gco__Date_USCOREType _gco__Date;
#endif

/* resqml2_0_1ForGsoap.h:31806 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__DateTime
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__DateTime (1353)
typedef time_t _gco__DateTime;
#endif

/* resqml2_0_1ForGsoap.h:31817 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__nilReason
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__nilReason (1354)
typedef gml__NilReasonType _gco__nilReason;
#endif

/* resqml2_0_1ForGsoap.h:31847 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__ptm__standardEnergisticsPropertyTypeSet
#define SOAP_TYPE_gsoap_resqml2_0_1__ptm__standardEnergisticsPropertyTypeSet (1355)
typedef ptm__standardEnergisticsPropertyTypeSet _ptm__standardEnergisticsPropertyTypeSet;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace gsoap_resqml2_0_1


#endif

/* End of gsoap_resqml2_0_1Stub.h */
