/* gsoap_resqml2_0_1Stub.h
   Generated by gSOAP 2.8.32 for resqml2_0_1ForGsoap.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool is licensed for commercial use, no resale/redistribution.
--------------------------------------------------------------------------------
Product and source code licensed by Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_resqml2	"http://www.energistics.org/energyml/data/resqmlv2"
#define SOAP_NAMESPACE_OF_eml	"http://www.energistics.org/energyml/data/commonv2"
#define SOAP_NAMESPACE_OF_gml	"http://www.opengis.net/gml/3.2"
#define SOAP_NAMESPACE_OF_xlink	"http://www.w3.org/1999/xlink"
#define SOAP_NAMESPACE_OF_gmd	"http://www.isotc211.org/2005/gmd"
#define SOAP_NAMESPACE_OF_gts	"http://www.isotc211.org/2005/gts"
#define SOAP_NAMESPACE_OF_gco	"http://www.isotc211.org/2005/gco"
#define SOAP_NAMESPACE_OF_gsr	"http://www.isotc211.org/2005/gsr"
#define SOAP_NAMESPACE_OF_ptm	"http://www.f2i-consulting.com/PropertyTypeMapping"

#ifndef gsoap_resqml2_0_1Stub_H
#define gsoap_resqml2_0_1Stub_H
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20832
# error "GSOAP VERSION 20832 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace gsoap_resqml2_0_1 {

/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* resqml2_0_1ForGsoap.h:1913 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSetKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSetKind (563)
/* resqml2:TimeSetKind */
enum resqml2__TimeSetKind {
	resqml2__TimeSetKind__single_x0020time = 0,
	resqml2__TimeSetKind__equivalent_x0020times = 1,
	resqml2__TimeSetKind__not_x0020a_x0020time_x0020set = 2
};
#endif

/* resqml2_0_1ForGsoap.h:1935 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Facet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Facet (564)
/* resqml2:Facet */
enum resqml2__Facet {
	resqml2__Facet__conditions = 0,
	resqml2__Facet__direction = 1,
	resqml2__Facet__netgross = 2,
	resqml2__Facet__qualifier = 3,
	resqml2__Facet__statistics = 4,
	resqml2__Facet__what = 5
};
#endif

/* resqml2_0_1ForGsoap.h:1966 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlUom
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlUom (565)
/* resqml2:ResqmlUom */
enum resqml2__ResqmlUom {
	resqml2__ResqmlUom__A = 'A',
	resqml2__ResqmlUom__a = 'a',
	resqml2__ResqmlUom__b = 'b',
	resqml2__ResqmlUom__B = 'B',
	resqml2__ResqmlUom__C = 'C',
	resqml2__ResqmlUom__d = 'd',
	resqml2__ResqmlUom__D = 'D',
	resqml2__ResqmlUom__F = 'F',
	resqml2__ResqmlUom__g = 'g',
	resqml2__ResqmlUom__H = 'H',
	resqml2__ResqmlUom__h = 'h',
	resqml2__ResqmlUom__J = 'J',
	resqml2__ResqmlUom__K = 'K',
	resqml2__ResqmlUom__L = 'L',
	resqml2__ResqmlUom__m = 'm',
	resqml2__ResqmlUom__N = 'N',
	resqml2__ResqmlUom__O = 'O',
	resqml2__ResqmlUom__P = 'P',
	resqml2__ResqmlUom__S = 'S',
	resqml2__ResqmlUom__s = 's',
	resqml2__ResqmlUom__t = 't',
	resqml2__ResqmlUom__T = 'T',
	resqml2__ResqmlUom__V = 'V',
	resqml2__ResqmlUom__W = 'W',
	resqml2__ResqmlUom___x0025 = 'u',
	resqml2__ResqmlUom___x0025_x005barea_x005d = 'v',
	resqml2__ResqmlUom___x0025_x005bmass_x005d = 'w',
	resqml2__ResqmlUom___x0025_x005bmolar_x005d = 'x',
	resqml2__ResqmlUom___x0025_x005bvol_x005d = 'y',
	resqml2__ResqmlUom___x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 'z',
	resqml2__ResqmlUom___x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 123,
	resqml2__ResqmlUom___x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 124,
	resqml2__ResqmlUom__0_x002e001_x0020bbl_x002fft3 = 125,
	resqml2__ResqmlUom__0_x002e001_x0020bbl_x002fm3 = 126,
	resqml2__ResqmlUom__0_x002e001_x0020d_x002fft3 = 127,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 128,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 129,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 130,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 131,
	resqml2__ResqmlUom__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 132,
	resqml2__ResqmlUom__0_x002e001_x0020h_x002fft = 133,
	resqml2__ResqmlUom__0_x002e001_x0020kPa2_x002fcP = 134,
	resqml2__ResqmlUom__0_x002e001_x0020lbm_x002fbbl = 135,
	resqml2__ResqmlUom__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 136,
	resqml2__ResqmlUom__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 137,
	resqml2__ResqmlUom__0_x002e001_x0020psi_x002fft = 138,
	resqml2__ResqmlUom__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 139,
	resqml2__ResqmlUom__0_x002e001_x0020seca = 140,
	resqml2__ResqmlUom__0_x002e01_x0020bbl_x002fbbl = 141,
	resqml2__ResqmlUom__0_x002e01_x0020dega_x002fft = 142,
	resqml2__ResqmlUom__0_x002e01_x0020degF_x002fft = 143,
	resqml2__ResqmlUom__0_x002e01_x0020dm3_x002fkm = 144,
	resqml2__ResqmlUom__0_x002e01_x0020ft_x002fft = 145,
	resqml2__ResqmlUom__0_x002e01_x0020grain_x002fft3 = 146,
	resqml2__ResqmlUom__0_x002e01_x0020L_x002fkg = 147,
	resqml2__ResqmlUom__0_x002e01_x0020L_x002fkm = 148,
	resqml2__ResqmlUom__0_x002e01_x0020lbf_x002fft = 149,
	resqml2__ResqmlUom__0_x002e01_x0020lbf_x002fft2 = 150,
	resqml2__ResqmlUom__0_x002e01_x0020lbm_x002fft2 = 151,
	resqml2__ResqmlUom__0_x002e01_x0020psi_x002fft = 152,
	resqml2__ResqmlUom__0_x002e1_x0020ft = 153,
	resqml2__ResqmlUom__0_x002e1_x0020ft_x005bUS_x005d = 154,
	resqml2__ResqmlUom__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 155,
	resqml2__ResqmlUom__0_x002e1_x0020in = 156,
	resqml2__ResqmlUom__0_x002e1_x0020L_x002fbbl = 157,
	resqml2__ResqmlUom__0_x002e1_x0020lbm_x002fbbl = 158,
	resqml2__ResqmlUom__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 159,
	resqml2__ResqmlUom__0_x002e1_x0020yd = 160,
	resqml2__ResqmlUom__1_x002f_x0028kg_x002es_x0029 = 161,
	resqml2__ResqmlUom__1_x002f16_x0020in = 162,
	resqml2__ResqmlUom__1_x002f2_x0020ft = 163,
	resqml2__ResqmlUom__1_x002f2_x0020ms = 164,
	resqml2__ResqmlUom__1_x002f30_x0020cm3_x002fmin = 165,
	resqml2__ResqmlUom__1_x002f30_x0020dega_x002fft = 166,
	resqml2__ResqmlUom__1_x002f30_x0020dega_x002fm = 167,
	resqml2__ResqmlUom__1_x002f30_x0020lbf_x002fm = 168,
	resqml2__ResqmlUom__1_x002f30_x0020m_x002fm = 169,
	resqml2__ResqmlUom__1_x002f30_x0020N_x002fm = 170,
	resqml2__ResqmlUom__1_x002f32_x0020in = 171,
	resqml2__ResqmlUom__1_x002f64_x0020in = 172,
	resqml2__ResqmlUom__1_x002fa = 173,
	resqml2__ResqmlUom__1_x002fangstrom = 174,
	resqml2__ResqmlUom__1_x002fbar = 175,
	resqml2__ResqmlUom__1_x002fbbl = 176,
	resqml2__ResqmlUom__1_x002fcm = 177,
	resqml2__ResqmlUom__1_x002fd = 178,
	resqml2__ResqmlUom__1_x002fdegC = 179,
	resqml2__ResqmlUom__1_x002fdegF = 180,
	resqml2__ResqmlUom__1_x002fdegR = 181,
	resqml2__ResqmlUom__1_x002fft = 182,
	resqml2__ResqmlUom__1_x002fft2 = 183,
	resqml2__ResqmlUom__1_x002fft3 = 184,
	resqml2__ResqmlUom__1_x002fg = 185,
	resqml2__ResqmlUom__1_x002fgal_x005bUK_x005d = 186,
	resqml2__ResqmlUom__1_x002fgal_x005bUS_x005d = 187,
	resqml2__ResqmlUom__1_x002fH = 188,
	resqml2__ResqmlUom__1_x002fh = 189,
	resqml2__ResqmlUom__1_x002fin = 190,
	resqml2__ResqmlUom__1_x002fK = 191,
	resqml2__ResqmlUom__1_x002fkg = 192,
	resqml2__ResqmlUom__1_x002fkm2 = 193,
	resqml2__ResqmlUom__1_x002fkPa = 194,
	resqml2__ResqmlUom__1_x002fL = 195,
	resqml2__ResqmlUom__1_x002flbf = 196,
	resqml2__ResqmlUom__1_x002flbm = 197,
	resqml2__ResqmlUom__1_x002fm = 198,
	resqml2__ResqmlUom__1_x002fm2 = 199,
	resqml2__ResqmlUom__1_x002fm3 = 200,
	resqml2__ResqmlUom__1_x002fmi = 201,
	resqml2__ResqmlUom__1_x002fmi2 = 202,
	resqml2__ResqmlUom__1_x002fmin = 203,
	resqml2__ResqmlUom__1_x002fmm = 204,
	resqml2__ResqmlUom__1_x002fms = 205,
	resqml2__ResqmlUom__1_x002fN = 206,
	resqml2__ResqmlUom__1_x002fnm = 207,
	resqml2__ResqmlUom__1_x002fPa = 208,
	resqml2__ResqmlUom__1_x002fpPa = 209,
	resqml2__ResqmlUom__1_x002fpsi = 210,
	resqml2__ResqmlUom__1_x002fs = 211,
	resqml2__ResqmlUom__1_x002fupsi = 212,
	resqml2__ResqmlUom__1_x002fus = 213,
	resqml2__ResqmlUom__1_x002fuV = 214,
	resqml2__ResqmlUom__1_x002fV = 215,
	resqml2__ResqmlUom__1_x002fwk = 216,
	resqml2__ResqmlUom__1_x002fyd = 217,
	resqml2__ResqmlUom__10_x0020ft = 218,
	resqml2__ResqmlUom__10_x0020in = 219,
	resqml2__ResqmlUom__10_x0020km = 220,
	resqml2__ResqmlUom__10_x0020kN = 221,
	resqml2__ResqmlUom__10_x0020Mg_x002fm3 = 222,
	resqml2__ResqmlUom__100_x0020ft = 223,
	resqml2__ResqmlUom__100_x0020ka_x005bt_x005d = 224,
	resqml2__ResqmlUom__100_x0020km = 225,
	resqml2__ResqmlUom__1000_x0020bbl = 226,
	resqml2__ResqmlUom__1000_x0020bbl_x002eft_x002fd = 227,
	resqml2__ResqmlUom__1000_x0020bbl_x002fd = 228,
	resqml2__ResqmlUom__1000_x0020ft = 229,
	resqml2__ResqmlUom__1000_x0020ft_x002fh = 230,
	resqml2__ResqmlUom__1000_x0020ft_x002fs = 231,
	resqml2__ResqmlUom__1000_x0020ft3 = 232,
	resqml2__ResqmlUom__1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 233,
	resqml2__ResqmlUom__1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 234,
	resqml2__ResqmlUom__1000_x0020ft3_x002fbbl = 235,
	resqml2__ResqmlUom__1000_x0020ft3_x002fd = 236,
	resqml2__ResqmlUom__1000_x0020gal_x005bUK_x005d = 237,
	resqml2__ResqmlUom__1000_x0020gal_x005bUS_x005d = 238,
	resqml2__ResqmlUom__1000_x0020lbf_x002eft = 239,
	resqml2__ResqmlUom__1000_x0020m3 = 240,
	resqml2__ResqmlUom__1000_x0020m3_x002f_x0028d_x002em_x0029 = 241,
	resqml2__ResqmlUom__1000_x0020m3_x002f_x0028h_x002em_x0029 = 242,
	resqml2__ResqmlUom__1000_x0020m3_x002fd = 243,
	resqml2__ResqmlUom__1000_x0020m3_x002fh = 244,
	resqml2__ResqmlUom__1000_x0020m3_x002fm3 = 245,
	resqml2__ResqmlUom__1000_x0020m4_x002fd = 246,
	resqml2__ResqmlUom__1E_6_x0020acre_x002eft_x002fbbl = 247,
	resqml2__ResqmlUom__1E_6_x0020bbl_x002fft3 = 248,
	resqml2__ResqmlUom__1E_6_x0020bbl_x002fm3 = 249,
	resqml2__ResqmlUom__1E_6_x0020gal_x005bUS_x005d = 250,
	resqml2__ResqmlUom__1E_6_x0020m3_x002f_x0028m3_x002edegC_x0029 = 251,
	resqml2__ResqmlUom__1E_6_x0020m3_x002f_x0028m3_x002edegF_x0029 = 252,
	resqml2__ResqmlUom__1E_9_x00201_x002fft = 253,
	resqml2__ResqmlUom__1E12_x0020ft3 = 254,
	resqml2__ResqmlUom__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 255,
	resqml2__ResqmlUom__1E6_x0020bbl = 256,
	resqml2__ResqmlUom__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 257,
	resqml2__ResqmlUom__1E6_x0020bbl_x002facre = 258,
	resqml2__ResqmlUom__1E6_x0020bbl_x002fd = 259,
	resqml2__ResqmlUom__1E6_x0020Btu_x005bIT_x005d = 260,
	resqml2__ResqmlUom__1E6_x0020Btu_x005bIT_x005d_x002fh = 261,
	resqml2__ResqmlUom__1E6_x0020ft3 = 262,
	resqml2__ResqmlUom__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 263,
	resqml2__ResqmlUom__1E6_x0020ft3_x002fbbl = 264,
	resqml2__ResqmlUom__1E6_x0020ft3_x002fd = 265,
	resqml2__ResqmlUom__1E6_x0020lbm_x002fa = 266,
	resqml2__ResqmlUom__1E6_x0020m3 = 267,
	resqml2__ResqmlUom__1E6_x0020m3_x002fd = 268,
	resqml2__ResqmlUom__1E9_x0020bbl = 269,
	resqml2__ResqmlUom__1E9_x0020ft3 = 270,
	resqml2__ResqmlUom__30_x0020ft = 271,
	resqml2__ResqmlUom__30_x0020m = 272,
	resqml2__ResqmlUom__A_x002eh = 273,
	resqml2__ResqmlUom__A_x002em2 = 274,
	resqml2__ResqmlUom__A_x002es = 275,
	resqml2__ResqmlUom__A_x002es_x002fkg = 276,
	resqml2__ResqmlUom__A_x002es_x002fm3 = 277,
	resqml2__ResqmlUom__A_x002fcm2 = 278,
	resqml2__ResqmlUom__A_x002fft2 = 279,
	resqml2__ResqmlUom__A_x002fm = 280,
	resqml2__ResqmlUom__A_x002fm2 = 281,
	resqml2__ResqmlUom__A_x002fmm = 282,
	resqml2__ResqmlUom__A_x002fmm2 = 283,
	resqml2__ResqmlUom__a_x005bt_x005d = 284,
	resqml2__ResqmlUom__acre = 285,
	resqml2__ResqmlUom__acre_x002eft = 286,
	resqml2__ResqmlUom__ag = 287,
	resqml2__ResqmlUom__aJ = 288,
	resqml2__ResqmlUom__angstrom = 289,
	resqml2__ResqmlUom__at = 290,
	resqml2__ResqmlUom__atm = 291,
	resqml2__ResqmlUom__atm_x002fft = 292,
	resqml2__ResqmlUom__atm_x002fh = 293,
	resqml2__ResqmlUom__atm_x002fhm = 294,
	resqml2__ResqmlUom__atm_x002fm = 295,
	resqml2__ResqmlUom__B_x002eW = 296,
	resqml2__ResqmlUom__b_x002fcm3 = 297,
	resqml2__ResqmlUom__B_x002fm = 298,
	resqml2__ResqmlUom__B_x002fO = 299,
	resqml2__ResqmlUom__bar = 300,
	resqml2__ResqmlUom__bar_x002fh = 301,
	resqml2__ResqmlUom__bar_x002fkm = 302,
	resqml2__ResqmlUom__bar_x002fm = 303,
	resqml2__ResqmlUom__bar2 = 304,
	resqml2__ResqmlUom__bar2_x002fcP = 305,
	resqml2__ResqmlUom__bbl = 306,
	resqml2__ResqmlUom__bbl_x002f_x0028acre_x002eft_x0029 = 307,
	resqml2__ResqmlUom__bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 308,
	resqml2__ResqmlUom__bbl_x002f_x0028d_x002eft_x0029 = 309,
	resqml2__ResqmlUom__bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 310,
	resqml2__ResqmlUom__bbl_x002f_x0028kPa_x002ed_x0029 = 311,
	resqml2__ResqmlUom__bbl_x002f_x0028psi_x002ed_x0029 = 312,
	resqml2__ResqmlUom__bbl_x002facre = 313,
	resqml2__ResqmlUom__bbl_x002fbbl = 314,
	resqml2__ResqmlUom__bbl_x002fd = 315,
	resqml2__ResqmlUom__bbl_x002fd2 = 316,
	resqml2__ResqmlUom__bbl_x002fft = 317,
	resqml2__ResqmlUom__bbl_x002fft3 = 318,
	resqml2__ResqmlUom__bbl_x002fh = 319,
	resqml2__ResqmlUom__bbl_x002fh2 = 320,
	resqml2__ResqmlUom__bbl_x002fin = 321,
	resqml2__ResqmlUom__bbl_x002fm3 = 322,
	resqml2__ResqmlUom__bbl_x002fmi = 323,
	resqml2__ResqmlUom__bbl_x002fmin = 324,
	resqml2__ResqmlUom__bbl_x002fpsi = 325,
	resqml2__ResqmlUom__bbl_x002fton_x005bUK_x005d = 326,
	resqml2__ResqmlUom__bbl_x002fton_x005bUS_x005d = 327,
	resqml2__ResqmlUom__Bd = 328,
	resqml2__ResqmlUom__bit = 329,
	resqml2__ResqmlUom__bit_x002fs = 330,
	resqml2__ResqmlUom__Bq = 331,
	resqml2__ResqmlUom__Bq_x002fkg = 332,
	resqml2__ResqmlUom__Btu_x005bIT_x005d = 333,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edegF_x0029 = 334,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edegF_x0029 = 335,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 336,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegF_x0029 = 337,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edegR_x0029 = 338,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 339,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edegF_x0029 = 340,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 341,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 342,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edegF_x0029 = 343,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edegR_x0029 = 344,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028lbmol_x002edegF_x0029 = 345,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 346,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edegF_x0029 = 347,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 348,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edegF_x0029 = 349,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fbbl = 350,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fft3 = 351,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 352,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 353,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fh = 354,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002flbm = 355,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002flbmol = 356,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fmin = 357,
	resqml2__ResqmlUom__Btu_x005bIT_x005d_x002fs = 358,
	resqml2__ResqmlUom__Btu_x005bth_x005d = 359,
	resqml2__ResqmlUom__Btu_x005bUK_x005d = 360,
	resqml2__ResqmlUom__byte = 361,
	resqml2__ResqmlUom__byte_x002fs = 362,
	resqml2__ResqmlUom__C_x002em = 363,
	resqml2__ResqmlUom__C_x002fcm2 = 364,
	resqml2__ResqmlUom__C_x002fcm3 = 365,
	resqml2__ResqmlUom__C_x002fg = 366,
	resqml2__ResqmlUom__C_x002fkg = 367,
	resqml2__ResqmlUom__C_x002fm2 = 368,
	resqml2__ResqmlUom__C_x002fm3 = 369,
	resqml2__ResqmlUom__C_x002fmm2 = 370,
	resqml2__ResqmlUom__C_x002fmm3 = 371,
	resqml2__ResqmlUom__ca = 372,
	resqml2__ResqmlUom__cA = 373,
	resqml2__ResqmlUom__cal_x005bIT_x005d = 374,
	resqml2__ResqmlUom__cal_x005bth_x005d = 375,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028g_x002eK_x0029 = 376,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edegC_x0029 = 377,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 378,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edegC_x0029 = 379,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 380,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028mol_x002edegC_x0029 = 381,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edegC_x0029 = 382,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edegC_x0029 = 383,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 384,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fcm3 = 385,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fg = 386,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fh = 387,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fkg = 388,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002flbm = 389,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fmL = 390,
	resqml2__ResqmlUom__cal_x005bth_x005d_x002fmm3 = 391,
	resqml2__ResqmlUom__cC = 392,
	resqml2__ResqmlUom__ccal_x005bth_x005d = 393,
	resqml2__ResqmlUom__ccgr = 394,
	resqml2__ResqmlUom__cd = 395,
	resqml2__ResqmlUom__cd_x002fm2 = 396,
	resqml2__ResqmlUom__cEuc = 397,
	resqml2__ResqmlUom__ceV = 398,
	resqml2__ResqmlUom__cF = 399,
	resqml2__ResqmlUom__cg = 400,
	resqml2__ResqmlUom__cgauss = 401,
	resqml2__ResqmlUom__cgr = 402,
	resqml2__ResqmlUom__cGy = 403,
	resqml2__ResqmlUom__cH = 404,
	resqml2__ResqmlUom__chain = 405,
	resqml2__ResqmlUom__chain_x005bBnA_x005d = 406,
	resqml2__ResqmlUom__chain_x005bBnB_x005d = 407,
	resqml2__ResqmlUom__chain_x005bCla_x005d = 408,
	resqml2__ResqmlUom__chain_x005bInd37_x005d = 409,
	resqml2__ResqmlUom__chain_x005bSe_x005d = 410,
	resqml2__ResqmlUom__chain_x005bSeT_x005d = 411,
	resqml2__ResqmlUom__chain_x005bUS_x005d = 412,
	resqml2__ResqmlUom__cHz = 413,
	resqml2__ResqmlUom__Ci = 414,
	resqml2__ResqmlUom__cJ = 415,
	resqml2__ResqmlUom__cm = 416,
	resqml2__ResqmlUom__cm_x002fa = 417,
	resqml2__ResqmlUom__cm_x002fs = 418,
	resqml2__ResqmlUom__cm_x002fs2 = 419,
	resqml2__ResqmlUom__cm2 = 420,
	resqml2__ResqmlUom__cm2_x002fg = 421,
	resqml2__ResqmlUom__cm2_x002fs = 422,
	resqml2__ResqmlUom__cm3 = 423,
	resqml2__ResqmlUom__cm3_x002fcm3 = 424,
	resqml2__ResqmlUom__cm3_x002fg = 425,
	resqml2__ResqmlUom__cm3_x002fh = 426,
	resqml2__ResqmlUom__cm3_x002fL = 427,
	resqml2__ResqmlUom__cm3_x002fm3 = 428,
	resqml2__ResqmlUom__cm3_x002fmin = 429,
	resqml2__ResqmlUom__cm3_x002fs = 430,
	resqml2__ResqmlUom__cm4 = 431,
	resqml2__ResqmlUom__cmH2O_x005b4degC_x005d = 432,
	resqml2__ResqmlUom__cN = 433,
	resqml2__ResqmlUom__cohm = 434,
	resqml2__ResqmlUom__cP = 435,
	resqml2__ResqmlUom__cPa = 436,
	resqml2__ResqmlUom__crd = 437,
	resqml2__ResqmlUom__cS = 438,
	resqml2__ResqmlUom__cs = 439,
	resqml2__ResqmlUom__cSt = 440,
	resqml2__ResqmlUom__ct = 441,
	resqml2__ResqmlUom__cT = 442,
	resqml2__ResqmlUom__cu = 443,
	resqml2__ResqmlUom__cV = 444,
	resqml2__ResqmlUom__cW = 445,
	resqml2__ResqmlUom__cWb = 446,
	resqml2__ResqmlUom__cwt_x005bUK_x005d = 447,
	resqml2__ResqmlUom__cwt_x005bUS_x005d = 448,
	resqml2__ResqmlUom__D_x002eft = 449,
	resqml2__ResqmlUom__D_x002em = 450,
	resqml2__ResqmlUom__D_x002f_x0028Pa_x002es_x0029 = 451,
	resqml2__ResqmlUom__d_x002fbbl = 452,
	resqml2__ResqmlUom__D_x002fcP = 453,
	resqml2__ResqmlUom__d_x002fft3 = 454,
	resqml2__ResqmlUom__d_x002fm3 = 455,
	resqml2__ResqmlUom__D_x005bAPI_x005d = 456,
	resqml2__ResqmlUom__dA = 457,
	resqml2__ResqmlUom__dam = 458,
	resqml2__ResqmlUom__daN = 459,
	resqml2__ResqmlUom__daN_x002em = 460,
	resqml2__ResqmlUom__dAPI = 461,
	resqml2__ResqmlUom__dB = 462,
	resqml2__ResqmlUom__dB_x002eMW = 463,
	resqml2__ResqmlUom__dB_x002emW = 464,
	resqml2__ResqmlUom__dB_x002eW = 465,
	resqml2__ResqmlUom__dB_x002fft = 466,
	resqml2__ResqmlUom__dB_x002fkm = 467,
	resqml2__ResqmlUom__dB_x002fm = 468,
	resqml2__ResqmlUom__dB_x002fO = 469,
	resqml2__ResqmlUom__dC = 470,
	resqml2__ResqmlUom__dcal_x005bth_x005d = 471,
	resqml2__ResqmlUom__dega = 472,
	resqml2__ResqmlUom__dega_x002fft = 473,
	resqml2__ResqmlUom__dega_x002fh = 474,
	resqml2__ResqmlUom__dega_x002fm = 475,
	resqml2__ResqmlUom__dega_x002fmin = 476,
	resqml2__ResqmlUom__dega_x002fs = 477,
	resqml2__ResqmlUom__degC = 478,
	resqml2__ResqmlUom__degC_x002em2_x002eh_x002fkcal_x005bth_x005d = 479,
	resqml2__ResqmlUom__degC_x002fft = 480,
	resqml2__ResqmlUom__degC_x002fh = 481,
	resqml2__ResqmlUom__degC_x002fhm = 482,
	resqml2__ResqmlUom__degC_x002fkm = 483,
	resqml2__ResqmlUom__degC_x002fkPa = 484,
	resqml2__ResqmlUom__degC_x002fm = 485,
	resqml2__ResqmlUom__degC_x002fmin = 486,
	resqml2__ResqmlUom__degC_x002fs = 487,
	resqml2__ResqmlUom__degF = 488,
	resqml2__ResqmlUom__degF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 489,
	resqml2__ResqmlUom__degF_x002fft = 490,
	resqml2__ResqmlUom__degF_x002fh = 491,
	resqml2__ResqmlUom__degF_x002fm = 492,
	resqml2__ResqmlUom__degF_x002fmin = 493,
	resqml2__ResqmlUom__degF_x002fpsi = 494,
	resqml2__ResqmlUom__degF_x002fs = 495,
	resqml2__ResqmlUom__degR = 496,
	resqml2__ResqmlUom__dEuc = 497,
	resqml2__ResqmlUom__deV = 498,
	resqml2__ResqmlUom__dF = 499,
	resqml2__ResqmlUom__dgauss = 500,
	resqml2__ResqmlUom__dGy = 501,
	resqml2__ResqmlUom__dH = 502,
	resqml2__ResqmlUom__dHz = 503,
	resqml2__ResqmlUom__dJ = 504,
	resqml2__ResqmlUom__dm = 505,
	resqml2__ResqmlUom__dm_x002fs = 506,
	resqml2__ResqmlUom__dm3 = 507,
	resqml2__ResqmlUom__dm3_x002f_x0028kW_x002eh_x0029 = 508,
	resqml2__ResqmlUom__dm3_x002fkg = 509,
	resqml2__ResqmlUom__dm3_x002fkmol = 510,
	resqml2__ResqmlUom__dm3_x002fm = 511,
	resqml2__ResqmlUom__dm3_x002fm3 = 512,
	resqml2__ResqmlUom__dm3_x002fMJ = 513,
	resqml2__ResqmlUom__dm3_x002fs = 514,
	resqml2__ResqmlUom__dm3_x002fs2 = 515,
	resqml2__ResqmlUom__dm3_x002ft = 516,
	resqml2__ResqmlUom__dN = 517,
	resqml2__ResqmlUom__dN_x002em = 518,
	resqml2__ResqmlUom__dohm = 519,
	resqml2__ResqmlUom__dP = 520,
	resqml2__ResqmlUom__dPa = 521,
	resqml2__ResqmlUom__drd = 522,
	resqml2__ResqmlUom__ds = 523,
	resqml2__ResqmlUom__dS = 524,
	resqml2__ResqmlUom__dT = 525,
	resqml2__ResqmlUom__dV = 526,
	resqml2__ResqmlUom__dW = 527,
	resqml2__ResqmlUom__dWb = 528,
	resqml2__ResqmlUom__dyne = 529,
	resqml2__ResqmlUom__dyne_x002ecm2 = 530,
	resqml2__ResqmlUom__dyne_x002es_x002fcm2 = 531,
	resqml2__ResqmlUom__dyne_x002fcm = 532,
	resqml2__ResqmlUom__dyne_x002fcm2 = 533,
	resqml2__ResqmlUom__EA = 534,
	resqml2__ResqmlUom__Ea_x005bt_x005d = 535,
	resqml2__ResqmlUom__EC = 536,
	resqml2__ResqmlUom__Ecal_x005bth_x005d = 537,
	resqml2__ResqmlUom__EEuc = 538,
	resqml2__ResqmlUom__EeV = 539,
	resqml2__ResqmlUom__EF = 540,
	resqml2__ResqmlUom__Eg = 541,
	resqml2__ResqmlUom__Egauss = 542,
	resqml2__ResqmlUom__EGy = 543,
	resqml2__ResqmlUom__EH = 544,
	resqml2__ResqmlUom__EHz = 545,
	resqml2__ResqmlUom__EJ = 546,
	resqml2__ResqmlUom__EJ_x002fa = 547,
	resqml2__ResqmlUom__Em = 548,
	resqml2__ResqmlUom__EN = 549,
	resqml2__ResqmlUom__Eohm = 550,
	resqml2__ResqmlUom__EP = 551,
	resqml2__ResqmlUom__EPa = 552,
	resqml2__ResqmlUom__Erd = 553,
	resqml2__ResqmlUom__erg = 554,
	resqml2__ResqmlUom__erg_x002fa = 555,
	resqml2__ResqmlUom__erg_x002fcm2 = 556,
	resqml2__ResqmlUom__erg_x002fcm3 = 557,
	resqml2__ResqmlUom__erg_x002fg = 558,
	resqml2__ResqmlUom__erg_x002fkg = 559,
	resqml2__ResqmlUom__erg_x002fm3 = 560,
	resqml2__ResqmlUom__ES = 561,
	resqml2__ResqmlUom__ET = 562,
	resqml2__ResqmlUom__Euc = 563,
	resqml2__ResqmlUom__eV = 564,
	resqml2__ResqmlUom__EW = 565,
	resqml2__ResqmlUom__EWb = 566,
	resqml2__ResqmlUom__F_x002fm = 567,
	resqml2__ResqmlUom__fa = 568,
	resqml2__ResqmlUom__fA = 569,
	resqml2__ResqmlUom__fathom = 570,
	resqml2__ResqmlUom__fC = 571,
	resqml2__ResqmlUom__fcal_x005bth_x005d = 572,
	resqml2__ResqmlUom__fEuc = 573,
	resqml2__ResqmlUom__feV = 574,
	resqml2__ResqmlUom__fF = 575,
	resqml2__ResqmlUom__fg = 576,
	resqml2__ResqmlUom__fgauss = 577,
	resqml2__ResqmlUom__fGy = 578,
	resqml2__ResqmlUom__fH = 579,
	resqml2__ResqmlUom__fHz = 580,
	resqml2__ResqmlUom__fJ = 581,
	resqml2__ResqmlUom__floz_x005bUK_x005d = 582,
	resqml2__ResqmlUom__floz_x005bUS_x005d = 583,
	resqml2__ResqmlUom__fm = 584,
	resqml2__ResqmlUom__fN = 585,
	resqml2__ResqmlUom__fohm = 586,
	resqml2__ResqmlUom__footcandle = 587,
	resqml2__ResqmlUom__footcandle_x002es = 588,
	resqml2__ResqmlUom__fP = 589,
	resqml2__ResqmlUom__fPa = 590,
	resqml2__ResqmlUom__frd = 591,
	resqml2__ResqmlUom__fS = 592,
	resqml2__ResqmlUom__ft = 593,
	resqml2__ResqmlUom__fT = 594,
	resqml2__ResqmlUom__ft_x002fbbl = 595,
	resqml2__ResqmlUom__ft_x002fd = 596,
	resqml2__ResqmlUom__ft_x002fdegF = 597,
	resqml2__ResqmlUom__ft_x002fft = 598,
	resqml2__ResqmlUom__ft_x002fft3 = 599,
	resqml2__ResqmlUom__ft_x002fgal_x005bUS_x005d = 600,
	resqml2__ResqmlUom__ft_x002fh = 601,
	resqml2__ResqmlUom__ft_x002fin = 602,
	resqml2__ResqmlUom__ft_x002flbm = 603,
	resqml2__ResqmlUom__ft_x002fm = 604,
	resqml2__ResqmlUom__ft_x002fmi = 605,
	resqml2__ResqmlUom__ft_x002fmin = 606,
	resqml2__ResqmlUom__ft_x002fms = 607,
	resqml2__ResqmlUom__ft_x002fpsi = 608,
	resqml2__ResqmlUom__ft_x002fs = 609,
	resqml2__ResqmlUom__ft_x002fs2 = 610,
	resqml2__ResqmlUom__ft_x002fus = 611,
	resqml2__ResqmlUom__ft_x005bBnA_x005d = 612,
	resqml2__ResqmlUom__ft_x005bBnB_x005d = 613,
	resqml2__ResqmlUom__ft_x005bBr36_x005d = 614,
	resqml2__ResqmlUom__ft_x005bBr65_x005d = 615,
	resqml2__ResqmlUom__ft_x005bCla_x005d = 616,
	resqml2__ResqmlUom__ft_x005bGC_x005d = 617,
	resqml2__ResqmlUom__ft_x005bInd_x005d = 618,
	resqml2__ResqmlUom__ft_x005bInd37_x005d = 619,
	resqml2__ResqmlUom__ft_x005bInd62_x005d = 620,
	resqml2__ResqmlUom__ft_x005bInd75_x005d = 621,
	resqml2__ResqmlUom__ft_x005bSe_x005d = 622,
	resqml2__ResqmlUom__ft_x005bSeT_x005d = 623,
	resqml2__ResqmlUom__ft_x005bUS_x005d = 624,
	resqml2__ResqmlUom__ft2 = 625,
	resqml2__ResqmlUom__ft2_x002fh = 626,
	resqml2__ResqmlUom__ft2_x002fin3 = 627,
	resqml2__ResqmlUom__ft2_x002flbm = 628,
	resqml2__ResqmlUom__ft2_x002fs = 629,
	resqml2__ResqmlUom__ft3 = 630,
	resqml2__ResqmlUom__ft3_x002f_x0028d_x002eft_x0029 = 631,
	resqml2__ResqmlUom__ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 632,
	resqml2__ResqmlUom__ft3_x002f_x0028min_x002eft2_x0029 = 633,
	resqml2__ResqmlUom__ft3_x002f_x0028s_x002eft2_x0029 = 634,
	resqml2__ResqmlUom__ft3_x002fbbl = 635,
	resqml2__ResqmlUom__ft3_x002fd = 636,
	resqml2__ResqmlUom__ft3_x002fd2 = 637,
	resqml2__ResqmlUom__ft3_x002fft = 638,
	resqml2__ResqmlUom__ft3_x002fft2 = 639,
	resqml2__ResqmlUom__ft3_x002fft3 = 640,
	resqml2__ResqmlUom__ft3_x002fh = 641,
	resqml2__ResqmlUom__ft3_x002fh2 = 642,
	resqml2__ResqmlUom__ft3_x002fkg = 643,
	resqml2__ResqmlUom__ft3_x002flbm = 644,
	resqml2__ResqmlUom__ft3_x002flbmol = 645,
	resqml2__ResqmlUom__ft3_x002fmin = 646,
	resqml2__ResqmlUom__ft3_x002fmin2 = 647,
	resqml2__ResqmlUom__ft3_x002frad = 648,
	resqml2__ResqmlUom__ft3_x002fs = 649,
	resqml2__ResqmlUom__ft3_x002fs2 = 650,
	resqml2__ResqmlUom__ft3_x002fsack_x005b94lbm_x005d = 651,
	resqml2__ResqmlUom__fur_x005bUS_x005d = 652,
	resqml2__ResqmlUom__fV = 653,
	resqml2__ResqmlUom__fW = 654,
	resqml2__ResqmlUom__fWb = 655,
	resqml2__ResqmlUom__g_x002eft_x002f_x0028cm3_x002es_x0029 = 656,
	resqml2__ResqmlUom__g_x002em_x002f_x0028cm3_x002es_x0029 = 657,
	resqml2__ResqmlUom__g_x002fcm3 = 658,
	resqml2__ResqmlUom__g_x002fcm4 = 659,
	resqml2__ResqmlUom__g_x002fdm3 = 660,
	resqml2__ResqmlUom__g_x002fgal_x005bUK_x005d = 661,
	resqml2__ResqmlUom__g_x002fgal_x005bUS_x005d = 662,
	resqml2__ResqmlUom__g_x002fkg = 663,
	resqml2__ResqmlUom__g_x002fL = 664,
	resqml2__ResqmlUom__g_x002fm3 = 665,
	resqml2__ResqmlUom__g_x002fmol = 666,
	resqml2__ResqmlUom__g_x002fs = 667,
	resqml2__ResqmlUom__g_x002ft = 668,
	resqml2__ResqmlUom__GA = 669,
	resqml2__ResqmlUom__Ga_x005bt_x005d = 670,
	resqml2__ResqmlUom__Gal = 671,
	resqml2__ResqmlUom__gal_x005bUK_x005d = 672,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 673,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 674,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 675,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 676,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 677,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 678,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fd = 679,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fft3 = 680,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fh = 681,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fh2 = 682,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002flbm = 683,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fmi = 684,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fmin = 685,
	resqml2__ResqmlUom__gal_x005bUK_x005d_x002fmin2 = 686,
	resqml2__ResqmlUom__gal_x005bUS_x005d = 687,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 688,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 689,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 690,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 691,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 692,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 693,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fbbl = 694,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fd = 695,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fft = 696,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fft3 = 697,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fh = 698,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fh2 = 699,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002flbm = 700,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fmi = 701,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fmin = 702,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fmin2 = 703,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 704,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fton_x005bUK_x005d = 705,
	resqml2__ResqmlUom__gal_x005bUS_x005d_x002fton_x005bUS_x005d = 706,
	resqml2__ResqmlUom__gAPI = 707,
	resqml2__ResqmlUom__gauss = 708,
	resqml2__ResqmlUom__gauss_x002fcm = 709,
	resqml2__ResqmlUom__GBq = 710,
	resqml2__ResqmlUom__GC = 711,
	resqml2__ResqmlUom__Gcal_x005bth_x005d = 712,
	resqml2__ResqmlUom__GEuc = 713,
	resqml2__ResqmlUom__GeV = 714,
	resqml2__ResqmlUom__gf = 715,
	resqml2__ResqmlUom__GF = 716,
	resqml2__ResqmlUom__Gg = 717,
	resqml2__ResqmlUom__Ggauss = 718,
	resqml2__ResqmlUom__GGy = 719,
	resqml2__ResqmlUom__GH = 720,
	resqml2__ResqmlUom__GHz = 721,
	resqml2__ResqmlUom__GJ = 722,
	resqml2__ResqmlUom__Gm = 723,
	resqml2__ResqmlUom__gn = 724,
	resqml2__ResqmlUom__GN = 725,
	resqml2__ResqmlUom__Gohm = 726,
	resqml2__ResqmlUom__gon = 727,
	resqml2__ResqmlUom__GP = 728,
	resqml2__ResqmlUom__GPa = 729,
	resqml2__ResqmlUom__GPa_x002fcm = 730,
	resqml2__ResqmlUom__GPa2 = 731,
	resqml2__ResqmlUom__grain = 732,
	resqml2__ResqmlUom__grain_x002fft3 = 733,
	resqml2__ResqmlUom__grain_x002fgal_x005bUS_x005d = 734,
	resqml2__ResqmlUom__Grd = 735,
	resqml2__ResqmlUom__GS = 736,
	resqml2__ResqmlUom__GT = 737,
	resqml2__ResqmlUom__GV = 738,
	resqml2__ResqmlUom__GW = 739,
	resqml2__ResqmlUom__GW_x002eh = 740,
	resqml2__ResqmlUom__GWb = 741,
	resqml2__ResqmlUom__Gy = 742,
	resqml2__ResqmlUom__h_x002fft3 = 743,
	resqml2__ResqmlUom__h_x002fkm = 744,
	resqml2__ResqmlUom__H_x002fm = 745,
	resqml2__ResqmlUom__h_x002fm3 = 746,
	resqml2__ResqmlUom__ha = 747,
	resqml2__ResqmlUom__ha_x002em = 748,
	resqml2__ResqmlUom__hbar = 749,
	resqml2__ResqmlUom__hg = 750,
	resqml2__ResqmlUom__hL = 751,
	resqml2__ResqmlUom__hm = 752,
	resqml2__ResqmlUom__hN = 753,
	resqml2__ResqmlUom__hp = 754,
	resqml2__ResqmlUom__hp_x002eh = 755,
	resqml2__ResqmlUom__hp_x002eh_x002fbbl = 756,
	resqml2__ResqmlUom__hp_x002eh_x002flbm = 757,
	resqml2__ResqmlUom__hp_x002fft3 = 758,
	resqml2__ResqmlUom__hp_x002fin2 = 759,
	resqml2__ResqmlUom__hp_x005belec_x005d = 760,
	resqml2__ResqmlUom__hp_x005bhyd_x005d = 761,
	resqml2__ResqmlUom__hp_x005bhyd_x005d_x002fin2 = 762,
	resqml2__ResqmlUom__hp_x005bmetric_x005d = 763,
	resqml2__ResqmlUom__hp_x005bmetric_x005d_x002eh = 764,
	resqml2__ResqmlUom__hs = 765,
	resqml2__ResqmlUom__Hz = 766,
	resqml2__ResqmlUom__in = 767,
	resqml2__ResqmlUom__in_x002f_x0028in_x002edegF_x0029 = 768,
	resqml2__ResqmlUom__in_x002fa = 769,
	resqml2__ResqmlUom__in_x002fmin = 770,
	resqml2__ResqmlUom__in_x002fs = 771,
	resqml2__ResqmlUom__in_x002fs2 = 772,
	resqml2__ResqmlUom__in_x005bUS_x005d = 773,
	resqml2__ResqmlUom__in2 = 774,
	resqml2__ResqmlUom__in2_x002fft2 = 775,
	resqml2__ResqmlUom__in2_x002fin2 = 776,
	resqml2__ResqmlUom__in2_x002fs = 777,
	resqml2__ResqmlUom__in3 = 778,
	resqml2__ResqmlUom__in3_x002fft = 779,
	resqml2__ResqmlUom__in4 = 780,
	resqml2__ResqmlUom__inH2O_x005b39degF_x005d = 781,
	resqml2__ResqmlUom__inH2O_x005b60degF_x005d = 782,
	resqml2__ResqmlUom__inHg_x005b32degF_x005d = 783,
	resqml2__ResqmlUom__inHg_x005b60degF_x005d = 784,
	resqml2__ResqmlUom__J_x002em_x002f_x0028s_x002em2_x002eK_x0029 = 785,
	resqml2__ResqmlUom__J_x002em_x002fm2 = 786,
	resqml2__ResqmlUom__J_x002f_x0028g_x002eK_x0029 = 787,
	resqml2__ResqmlUom__J_x002f_x0028kg_x002eK_x0029 = 788,
	resqml2__ResqmlUom__J_x002f_x0028mol_x002eK_x0029 = 789,
	resqml2__ResqmlUom__J_x002f_x0028s_x002em2_x002edegC_x0029 = 790,
	resqml2__ResqmlUom__J_x002fcm2 = 791,
	resqml2__ResqmlUom__J_x002fdm3 = 792,
	resqml2__ResqmlUom__J_x002fg = 793,
	resqml2__ResqmlUom__J_x002fK = 794,
	resqml2__ResqmlUom__J_x002fkg = 795,
	resqml2__ResqmlUom__J_x002fm = 796,
	resqml2__ResqmlUom__J_x002fm2 = 797,
	resqml2__ResqmlUom__J_x002fm3 = 798,
	resqml2__ResqmlUom__J_x002fmol = 799,
	resqml2__ResqmlUom__J_x002fs = 800,
	resqml2__ResqmlUom__K_x002em2_x002fkW = 801,
	resqml2__ResqmlUom__K_x002em2_x002fW = 802,
	resqml2__ResqmlUom__K_x002fkm = 803,
	resqml2__ResqmlUom__K_x002fm = 804,
	resqml2__ResqmlUom__K_x002fPa = 805,
	resqml2__ResqmlUom__K_x002fs = 806,
	resqml2__ResqmlUom__K_x002fW = 807,
	resqml2__ResqmlUom__kA = 808,
	resqml2__ResqmlUom__ka_x005bt_x005d = 809,
	resqml2__ResqmlUom__kC = 810,
	resqml2__ResqmlUom__kcal_x005bth_x005d = 811,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002em_x002fcm2 = 812,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002f_x0028h_x002em_x002edegC_x0029 = 813,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edegC_x0029 = 814,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002f_x0028kg_x002edegC_x0029 = 815,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fcm3 = 816,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fg = 817,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fh = 818,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fkg = 819,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fm3 = 820,
	resqml2__ResqmlUom__kcal_x005bth_x005d_x002fmol = 821,
	resqml2__ResqmlUom__kcd = 822,
	resqml2__ResqmlUom__kdyne = 823,
	resqml2__ResqmlUom__kEuc = 824,
	resqml2__ResqmlUom__keV = 825,
	resqml2__ResqmlUom__kF = 826,
	resqml2__ResqmlUom__kg = 827,
	resqml2__ResqmlUom__kg_x002em = 828,
	resqml2__ResqmlUom__kg_x002em_x002fcm2 = 829,
	resqml2__ResqmlUom__kg_x002em_x002fs = 830,
	resqml2__ResqmlUom__kg_x002em2 = 831,
	resqml2__ResqmlUom__kg_x002f_x0028kW_x002eh_x0029 = 832,
	resqml2__ResqmlUom__kg_x002f_x0028m_x002es_x0029 = 833,
	resqml2__ResqmlUom__kg_x002f_x0028m2_x002es_x0029 = 834,
	resqml2__ResqmlUom__kg_x002fd = 835,
	resqml2__ResqmlUom__kg_x002fdm3 = 836,
	resqml2__ResqmlUom__kg_x002fdm4 = 837,
	resqml2__ResqmlUom__kg_x002fh = 838,
	resqml2__ResqmlUom__kg_x002fJ = 839,
	resqml2__ResqmlUom__kg_x002fkg = 840,
	resqml2__ResqmlUom__kg_x002fL = 841,
	resqml2__ResqmlUom__kg_x002fm = 842,
	resqml2__ResqmlUom__kg_x002fm2 = 843,
	resqml2__ResqmlUom__kg_x002fm3 = 844,
	resqml2__ResqmlUom__kg_x002fm4 = 845,
	resqml2__ResqmlUom__kg_x002fmin = 846,
	resqml2__ResqmlUom__kg_x002fMJ = 847,
	resqml2__ResqmlUom__kg_x002fmol = 848,
	resqml2__ResqmlUom__kg_x002fs = 849,
	resqml2__ResqmlUom__kg_x002fsack_x005b94lbm_x005d = 850,
	resqml2__ResqmlUom__kg_x002ft = 851,
	resqml2__ResqmlUom__kgauss = 852,
	resqml2__ResqmlUom__kgf = 853,
	resqml2__ResqmlUom__kgf_x002em = 854,
	resqml2__ResqmlUom__kgf_x002em_x002fcm2 = 855,
	resqml2__ResqmlUom__kgf_x002em_x002fm = 856,
	resqml2__ResqmlUom__kgf_x002em2 = 857,
	resqml2__ResqmlUom__kgf_x002es_x002fm2 = 858,
	resqml2__ResqmlUom__kgf_x002fcm = 859,
	resqml2__ResqmlUom__kgf_x002fcm2 = 860,
	resqml2__ResqmlUom__kgf_x002fkgf = 861,
	resqml2__ResqmlUom__kgf_x002fm2 = 862,
	resqml2__ResqmlUom__kgf_x002fmm2 = 863,
	resqml2__ResqmlUom__kGy = 864,
	resqml2__ResqmlUom__kH = 865,
	resqml2__ResqmlUom__kHz = 866,
	resqml2__ResqmlUom__Kibyte = 867,
	resqml2__ResqmlUom__kJ = 868,
	resqml2__ResqmlUom__kJ_x002em_x002f_x0028h_x002em2_x002eK_x0029 = 869,
	resqml2__ResqmlUom__kJ_x002f_x0028h_x002em2_x002eK_x0029 = 870,
	resqml2__ResqmlUom__kJ_x002f_x0028kg_x002eK_x0029 = 871,
	resqml2__ResqmlUom__kJ_x002f_x0028kmol_x002eK_x0029 = 872,
	resqml2__ResqmlUom__kJ_x002fdm3 = 873,
	resqml2__ResqmlUom__kJ_x002fkg = 874,
	resqml2__ResqmlUom__kJ_x002fkmol = 875,
	resqml2__ResqmlUom__kJ_x002fm3 = 876,
	resqml2__ResqmlUom__klbf = 877,
	resqml2__ResqmlUom__klbm = 878,
	resqml2__ResqmlUom__klbm_x002fin = 879,
	resqml2__ResqmlUom__klx = 880,
	resqml2__ResqmlUom__km = 881,
	resqml2__ResqmlUom__km_x002fcm = 882,
	resqml2__ResqmlUom__km_x002fdm3 = 883,
	resqml2__ResqmlUom__km_x002fh = 884,
	resqml2__ResqmlUom__km_x002fL = 885,
	resqml2__ResqmlUom__km_x002fs = 886,
	resqml2__ResqmlUom__km2 = 887,
	resqml2__ResqmlUom__km3 = 888,
	resqml2__ResqmlUom__kmol = 889,
	resqml2__ResqmlUom__kmol_x002fh = 890,
	resqml2__ResqmlUom__kmol_x002fm3 = 891,
	resqml2__ResqmlUom__kmol_x002fs = 892,
	resqml2__ResqmlUom__kN = 893,
	resqml2__ResqmlUom__kN_x002em = 894,
	resqml2__ResqmlUom__kN_x002em2 = 895,
	resqml2__ResqmlUom__kN_x002fm = 896,
	resqml2__ResqmlUom__kN_x002fm2 = 897,
	resqml2__ResqmlUom__knot = 898,
	resqml2__ResqmlUom__kohm = 899,
	resqml2__ResqmlUom__kohm_x002em = 900,
	resqml2__ResqmlUom__kP = 901,
	resqml2__ResqmlUom__kPa = 902,
	resqml2__ResqmlUom__kPa_x002es_x002fm = 903,
	resqml2__ResqmlUom__kPa_x002fh = 904,
	resqml2__ResqmlUom__kPa_x002fhm = 905,
	resqml2__ResqmlUom__kPa_x002fm = 906,
	resqml2__ResqmlUom__kPa_x002fmin = 907,
	resqml2__ResqmlUom__kPa2 = 908,
	resqml2__ResqmlUom__kPa2_x002fcP = 909,
	resqml2__ResqmlUom__kpsi = 910,
	resqml2__ResqmlUom__kpsi2 = 911,
	resqml2__ResqmlUom__krad = 912,
	resqml2__ResqmlUom__krd = 913,
	resqml2__ResqmlUom__kS = 914,
	resqml2__ResqmlUom__kS_x002fm = 915,
	resqml2__ResqmlUom__kT = 916,
	resqml2__ResqmlUom__kV = 917,
	resqml2__ResqmlUom__kW = 918,
	resqml2__ResqmlUom__kW_x002eh = 919,
	resqml2__ResqmlUom__kW_x002eh_x002f_x0028kg_x002edegC_x0029 = 920,
	resqml2__ResqmlUom__kW_x002eh_x002fdm3 = 921,
	resqml2__ResqmlUom__kW_x002eh_x002fkg = 922,
	resqml2__ResqmlUom__kW_x002eh_x002fm3 = 923,
	resqml2__ResqmlUom__kW_x002f_x0028m2_x002eK_x0029 = 924,
	resqml2__ResqmlUom__kW_x002f_x0028m3_x002eK_x0029 = 925,
	resqml2__ResqmlUom__kW_x002fcm2 = 926,
	resqml2__ResqmlUom__kW_x002fm2 = 927,
	resqml2__ResqmlUom__kW_x002fm3 = 928,
	resqml2__ResqmlUom__kWb = 929,
	resqml2__ResqmlUom__L_x002f_x0028bar_x002emin_x0029 = 930,
	resqml2__ResqmlUom__L_x002fh = 931,
	resqml2__ResqmlUom__L_x002fkg = 932,
	resqml2__ResqmlUom__L_x002fkmol = 933,
	resqml2__ResqmlUom__L_x002fm = 934,
	resqml2__ResqmlUom__L_x002fm3 = 935,
	resqml2__ResqmlUom__L_x002fmin = 936,
	resqml2__ResqmlUom__L_x002fmol = 937,
	resqml2__ResqmlUom__L_x002fs = 938,
	resqml2__ResqmlUom__L_x002fs2 = 939,
	resqml2__ResqmlUom__L_x002ft = 940,
	resqml2__ResqmlUom__L_x002fton_x005bUK_x005d = 941,
	resqml2__ResqmlUom__lbf = 942,
	resqml2__ResqmlUom__lbf_x002eft = 943,
	resqml2__ResqmlUom__lbf_x002eft_x002fbbl = 944,
	resqml2__ResqmlUom__lbf_x002eft_x002fgal_x005bUS_x005d = 945,
	resqml2__ResqmlUom__lbf_x002eft_x002fin = 946,
	resqml2__ResqmlUom__lbf_x002eft_x002fin2 = 947,
	resqml2__ResqmlUom__lbf_x002eft_x002flbm = 948,
	resqml2__ResqmlUom__lbf_x002eft_x002fmin = 949,
	resqml2__ResqmlUom__lbf_x002eft_x002fs = 950,
	resqml2__ResqmlUom__lbf_x002ein = 951,
	resqml2__ResqmlUom__lbf_x002ein_x002fin = 952,
	resqml2__ResqmlUom__lbf_x002ein2 = 953,
	resqml2__ResqmlUom__lbf_x002es_x002fft2 = 954,
	resqml2__ResqmlUom__lbf_x002es_x002fin2 = 955,
	resqml2__ResqmlUom__lbf_x002fft = 956,
	resqml2__ResqmlUom__lbf_x002fft2 = 957,
	resqml2__ResqmlUom__lbf_x002fft3 = 958,
	resqml2__ResqmlUom__lbf_x002fgal_x005bUS_x005d = 959,
	resqml2__ResqmlUom__lbf_x002fin = 960,
	resqml2__ResqmlUom__lbf_x002flbf = 961,
	resqml2__ResqmlUom__lbm = 962,
	resqml2__ResqmlUom__lbm_x002eft = 963,
	resqml2__ResqmlUom__lbm_x002eft_x002fs = 964,
	resqml2__ResqmlUom__lbm_x002eft2 = 965,
	resqml2__ResqmlUom__lbm_x002eft2_x002fs2 = 966,
	resqml2__ResqmlUom__lbm_x002f_x0028ft_x002eh_x0029 = 967,
	resqml2__ResqmlUom__lbm_x002f_x0028ft_x002es_x0029 = 968,
	resqml2__ResqmlUom__lbm_x002f_x0028ft2_x002eh_x0029 = 969,
	resqml2__ResqmlUom__lbm_x002f_x0028ft2_x002es_x0029 = 970,
	resqml2__ResqmlUom__lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 971,
	resqml2__ResqmlUom__lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 972,
	resqml2__ResqmlUom__lbm_x002f_x0028hp_x002eh_x0029 = 973,
	resqml2__ResqmlUom__lbm_x002fbbl = 974,
	resqml2__ResqmlUom__lbm_x002fd = 975,
	resqml2__ResqmlUom__lbm_x002fft = 976,
	resqml2__ResqmlUom__lbm_x002fft2 = 977,
	resqml2__ResqmlUom__lbm_x002fft3 = 978,
	resqml2__ResqmlUom__lbm_x002fft4 = 979,
	resqml2__ResqmlUom__lbm_x002fgal_x005bUK_x005d = 980,
	resqml2__ResqmlUom__lbm_x002fgal_x005bUS_x005d = 981,
	resqml2__ResqmlUom__lbm_x002fh = 982,
	resqml2__ResqmlUom__lbm_x002fin3 = 983,
	resqml2__ResqmlUom__lbm_x002flbmol = 984,
	resqml2__ResqmlUom__lbm_x002fmin = 985,
	resqml2__ResqmlUom__lbm_x002fs = 986,
	resqml2__ResqmlUom__lbmol = 987,
	resqml2__ResqmlUom__lbmol_x002f_x0028h_x002eft2_x0029 = 988,
	resqml2__ResqmlUom__lbmol_x002f_x0028s_x002eft2_x0029 = 989,
	resqml2__ResqmlUom__lbmol_x002fft3 = 990,
	resqml2__ResqmlUom__lbmol_x002fgal_x005bUK_x005d = 991,
	resqml2__ResqmlUom__lbmol_x002fgal_x005bUS_x005d = 992,
	resqml2__ResqmlUom__lbmol_x002fh = 993,
	resqml2__ResqmlUom__lbmol_x002fs = 994,
	resqml2__ResqmlUom__link = 995,
	resqml2__ResqmlUom__link_x005bBnA_x005d = 996,
	resqml2__ResqmlUom__link_x005bBnB_x005d = 997,
	resqml2__ResqmlUom__link_x005bCla_x005d = 998,
	resqml2__ResqmlUom__link_x005bSe_x005d = 999,
	resqml2__ResqmlUom__link_x005bSeT_x005d = 1000,
	resqml2__ResqmlUom__link_x005bUS_x005d = 1001,
	resqml2__ResqmlUom__lm = 1002,
	resqml2__ResqmlUom__lm_x002es = 1003,
	resqml2__ResqmlUom__lm_x002fm2 = 1004,
	resqml2__ResqmlUom__lm_x002fW = 1005,
	resqml2__ResqmlUom__lx = 1006,
	resqml2__ResqmlUom__lx_x002es = 1007,
	resqml2__ResqmlUom__m_x002f_x0028m_x002eK_x0029 = 1008,
	resqml2__ResqmlUom__m_x002fcm = 1009,
	resqml2__ResqmlUom__m_x002fd = 1010,
	resqml2__ResqmlUom__m_x002fh = 1011,
	resqml2__ResqmlUom__m_x002fK = 1012,
	resqml2__ResqmlUom__m_x002fkg = 1013,
	resqml2__ResqmlUom__m_x002fkm = 1014,
	resqml2__ResqmlUom__m_x002fkPa = 1015,
	resqml2__ResqmlUom__m_x002fm = 1016,
	resqml2__ResqmlUom__m_x002fm3 = 1017,
	resqml2__ResqmlUom__m_x002fmin = 1018,
	resqml2__ResqmlUom__m_x002fms = 1019,
	resqml2__ResqmlUom__m_x002fPa = 1020,
	resqml2__ResqmlUom__m_x002fs = 1021,
	resqml2__ResqmlUom__m_x002fs2 = 1022,
	resqml2__ResqmlUom__m_x005bGer_x005d = 1023,
	resqml2__ResqmlUom__m2 = 1024,
	resqml2__ResqmlUom__m2_x002f_x0028kPa_x002ed_x0029 = 1025,
	resqml2__ResqmlUom__m2_x002f_x0028Pa_x002es_x0029 = 1026,
	resqml2__ResqmlUom__m2_x002fcm3 = 1027,
	resqml2__ResqmlUom__m2_x002fd = 1028,
	resqml2__ResqmlUom__m2_x002fg = 1029,
	resqml2__ResqmlUom__m2_x002fh = 1030,
	resqml2__ResqmlUom__m2_x002fkg = 1031,
	resqml2__ResqmlUom__m2_x002fm2 = 1032,
	resqml2__ResqmlUom__m2_x002fm3 = 1033,
	resqml2__ResqmlUom__m2_x002fmol = 1034,
	resqml2__ResqmlUom__m2_x002fs = 1035,
	resqml2__ResqmlUom__m3 = 1036,
	resqml2__ResqmlUom__m3_x002f_x0028bar_x002ed_x0029 = 1037,
	resqml2__ResqmlUom__m3_x002f_x0028bar_x002eh_x0029 = 1038,
	resqml2__ResqmlUom__m3_x002f_x0028bar_x002emin_x0029 = 1039,
	resqml2__ResqmlUom__m3_x002f_x0028d_x002em_x0029 = 1040,
	resqml2__ResqmlUom__m3_x002f_x0028h_x002em_x0029 = 1041,
	resqml2__ResqmlUom__m3_x002f_x0028ha_x002em_x0029 = 1042,
	resqml2__ResqmlUom__m3_x002f_x0028kPa_x002ed_x0029 = 1043,
	resqml2__ResqmlUom__m3_x002f_x0028kPa_x002eh_x0029 = 1044,
	resqml2__ResqmlUom__m3_x002f_x0028kW_x002eh_x0029 = 1045,
	resqml2__ResqmlUom__m3_x002f_x0028m3_x002eK_x0029 = 1046,
	resqml2__ResqmlUom__m3_x002f_x0028Pa_x002es_x0029 = 1047,
	resqml2__ResqmlUom__m3_x002f_x0028psi_x002ed_x0029 = 1048,
	resqml2__ResqmlUom__m3_x002f_x0028s_x002eft_x0029 = 1049,
	resqml2__ResqmlUom__m3_x002f_x0028s_x002em_x0029 = 1050,
	resqml2__ResqmlUom__m3_x002f_x0028s_x002em2_x0029 = 1051,
	resqml2__ResqmlUom__m3_x002f_x0028s_x002em3_x0029 = 1052,
	resqml2__ResqmlUom__m3_x002fbbl = 1053,
	resqml2__ResqmlUom__m3_x002fd = 1054,
	resqml2__ResqmlUom__m3_x002fd2 = 1055,
	resqml2__ResqmlUom__m3_x002fg = 1056,
	resqml2__ResqmlUom__m3_x002fh = 1057,
	resqml2__ResqmlUom__m3_x002fJ = 1058,
	resqml2__ResqmlUom__m3_x002fkg = 1059,
	resqml2__ResqmlUom__m3_x002fkm = 1060,
	resqml2__ResqmlUom__m3_x002fkmol = 1061,
	resqml2__ResqmlUom__m3_x002fkPa = 1062,
	resqml2__ResqmlUom__m3_x002fm = 1063,
	resqml2__ResqmlUom__m3_x002fm2 = 1064,
	resqml2__ResqmlUom__m3_x002fm3 = 1065,
	resqml2__ResqmlUom__m3_x002fmin = 1066,
	resqml2__ResqmlUom__m3_x002fmol = 1067,
	resqml2__ResqmlUom__m3_x002fPa = 1068,
	resqml2__ResqmlUom__m3_x002frad = 1069,
	resqml2__ResqmlUom__m3_x002frev = 1070,
	resqml2__ResqmlUom__m3_x002fs = 1071,
	resqml2__ResqmlUom__m3_x002fs2 = 1072,
	resqml2__ResqmlUom__m3_x002ft = 1073,
	resqml2__ResqmlUom__m3_x002fton_x005bUK_x005d = 1074,
	resqml2__ResqmlUom__m3_x002fton_x005bUS_x005d = 1075,
	resqml2__ResqmlUom__m4 = 1076,
	resqml2__ResqmlUom__m4_x002fs = 1077,
	resqml2__ResqmlUom__mA = 1078,
	resqml2__ResqmlUom__MA = 1079,
	resqml2__ResqmlUom__mA_x002fcm2 = 1080,
	resqml2__ResqmlUom__mA_x002fft2 = 1081,
	resqml2__ResqmlUom__Ma_x005bt_x005d = 1082,
	resqml2__ResqmlUom__mbar = 1083,
	resqml2__ResqmlUom__MBq = 1084,
	resqml2__ResqmlUom__mC = 1085,
	resqml2__ResqmlUom__MC = 1086,
	resqml2__ResqmlUom__mC_x002fm2 = 1087,
	resqml2__ResqmlUom__Mcal_x005bth_x005d = 1088,
	resqml2__ResqmlUom__mcal_x005bth_x005d = 1089,
	resqml2__ResqmlUom__mCi = 1090,
	resqml2__ResqmlUom__mD = 1091,
	resqml2__ResqmlUom__mD_x002eft = 1092,
	resqml2__ResqmlUom__mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 1093,
	resqml2__ResqmlUom__mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 1094,
	resqml2__ResqmlUom__mD_x002em = 1095,
	resqml2__ResqmlUom__mD_x002f_x0028Pa_x002es_x0029 = 1096,
	resqml2__ResqmlUom__mD_x002fcP = 1097,
	resqml2__ResqmlUom__MEuc = 1098,
	resqml2__ResqmlUom__mEuc = 1099,
	resqml2__ResqmlUom__meV = 1100,
	resqml2__ResqmlUom__MeV = 1101,
	resqml2__ResqmlUom__mF = 1102,
	resqml2__ResqmlUom__MF = 1103,
	resqml2__ResqmlUom__Mg = 1104,
	resqml2__ResqmlUom__mg = 1105,
	resqml2__ResqmlUom__Mg_x002fa = 1106,
	resqml2__ResqmlUom__Mg_x002fd = 1107,
	resqml2__ResqmlUom__mg_x002fdm3 = 1108,
	resqml2__ResqmlUom__mg_x002fg = 1109,
	resqml2__ResqmlUom__mg_x002fgal_x005bUS_x005d = 1110,
	resqml2__ResqmlUom__Mg_x002fh = 1111,
	resqml2__ResqmlUom__Mg_x002fin = 1112,
	resqml2__ResqmlUom__mg_x002fJ = 1113,
	resqml2__ResqmlUom__mg_x002fkg = 1114,
	resqml2__ResqmlUom__mg_x002fL = 1115,
	resqml2__ResqmlUom__Mg_x002fm2 = 1116,
	resqml2__ResqmlUom__Mg_x002fm3 = 1117,
	resqml2__ResqmlUom__mg_x002fm3 = 1118,
	resqml2__ResqmlUom__Mg_x002fmin = 1119,
	resqml2__ResqmlUom__mGal = 1120,
	resqml2__ResqmlUom__Mgauss = 1121,
	resqml2__ResqmlUom__mgauss = 1122,
	resqml2__ResqmlUom__Mgf = 1123,
	resqml2__ResqmlUom__mgn = 1124,
	resqml2__ResqmlUom__MGy = 1125,
	resqml2__ResqmlUom__mGy = 1126,
	resqml2__ResqmlUom__MH = 1127,
	resqml2__ResqmlUom__mH = 1128,
	resqml2__ResqmlUom__mHz = 1129,
	resqml2__ResqmlUom__MHz = 1130,
	resqml2__ResqmlUom__mi = 1131,
	resqml2__ResqmlUom__mi_x002fgal_x005bUK_x005d = 1132,
	resqml2__ResqmlUom__mi_x002fgal_x005bUS_x005d = 1133,
	resqml2__ResqmlUom__mi_x002fh = 1134,
	resqml2__ResqmlUom__mi_x002fin = 1135,
	resqml2__ResqmlUom__mi_x005bnaut_x005d = 1136,
	resqml2__ResqmlUom__mi_x005bnautUK_x005d = 1137,
	resqml2__ResqmlUom__mi_x005bUS_x005d = 1138,
	resqml2__ResqmlUom__mi_x005bUS_x005d2 = 1139,
	resqml2__ResqmlUom__mi2 = 1140,
	resqml2__ResqmlUom__mi3 = 1141,
	resqml2__ResqmlUom__Mibyte = 1142,
	resqml2__ResqmlUom__mil = 1143,
	resqml2__ResqmlUom__mil_x002fa = 1144,
	resqml2__ResqmlUom__mila = 1145,
	resqml2__ResqmlUom__min_ = 1146,
	resqml2__ResqmlUom__min_x002fft = 1147,
	resqml2__ResqmlUom__min_x002fm = 1148,
	resqml2__ResqmlUom__mina = 1149,
	resqml2__ResqmlUom__mJ = 1150,
	resqml2__ResqmlUom__MJ = 1151,
	resqml2__ResqmlUom__MJ_x002fa = 1152,
	resqml2__ResqmlUom__mJ_x002fcm2 = 1153,
	resqml2__ResqmlUom__MJ_x002fkg = 1154,
	resqml2__ResqmlUom__MJ_x002fkmol = 1155,
	resqml2__ResqmlUom__MJ_x002fm = 1156,
	resqml2__ResqmlUom__mJ_x002fm2 = 1157,
	resqml2__ResqmlUom__MJ_x002fm3 = 1158,
	resqml2__ResqmlUom__mL = 1159,
	resqml2__ResqmlUom__mL_x002fgal_x005bUK_x005d = 1160,
	resqml2__ResqmlUom__mL_x002fgal_x005bUS_x005d = 1161,
	resqml2__ResqmlUom__mL_x002fmL = 1162,
	resqml2__ResqmlUom__Mm = 1163,
	resqml2__ResqmlUom__mm = 1164,
	resqml2__ResqmlUom__mm_x002f_x0028mm_x002eK_x0029 = 1165,
	resqml2__ResqmlUom__mm_x002fa = 1166,
	resqml2__ResqmlUom__mm_x002fs = 1167,
	resqml2__ResqmlUom__mm2 = 1168,
	resqml2__ResqmlUom__mm2_x002fmm2 = 1169,
	resqml2__ResqmlUom__mm2_x002fs = 1170,
	resqml2__ResqmlUom__mm3 = 1171,
	resqml2__ResqmlUom__mm3_x002fJ = 1172,
	resqml2__ResqmlUom__mmHg_x005b0degC_x005d = 1173,
	resqml2__ResqmlUom__mmol = 1174,
	resqml2__ResqmlUom__mN = 1175,
	resqml2__ResqmlUom__MN = 1176,
	resqml2__ResqmlUom__mN_x002em2 = 1177,
	resqml2__ResqmlUom__mN_x002fkm = 1178,
	resqml2__ResqmlUom__mN_x002fm = 1179,
	resqml2__ResqmlUom__mohm = 1180,
	resqml2__ResqmlUom__Mohm = 1181,
	resqml2__ResqmlUom__mol = 1182,
	resqml2__ResqmlUom__mol_x002em2_x002f_x0028mol_x002es_x0029 = 1183,
	resqml2__ResqmlUom__mol_x002f_x0028s_x002em2_x0029 = 1184,
	resqml2__ResqmlUom__mol_x002fm2 = 1185,
	resqml2__ResqmlUom__mol_x002fm3 = 1186,
	resqml2__ResqmlUom__mol_x002fmol = 1187,
	resqml2__ResqmlUom__mol_x002fs = 1188,
	resqml2__ResqmlUom__mP = 1189,
	resqml2__ResqmlUom__MP = 1190,
	resqml2__ResqmlUom__MPa = 1191,
	resqml2__ResqmlUom__mPa = 1192,
	resqml2__ResqmlUom__mPa_x002es = 1193,
	resqml2__ResqmlUom__MPa_x002es_x002fm = 1194,
	resqml2__ResqmlUom__MPa_x002fh = 1195,
	resqml2__ResqmlUom__MPa_x002fm = 1196,
	resqml2__ResqmlUom__Mpsi = 1197,
	resqml2__ResqmlUom__mrad = 1198,
	resqml2__ResqmlUom__Mrad = 1199,
	resqml2__ResqmlUom__Mrd = 1200,
	resqml2__ResqmlUom__mrd = 1201,
	resqml2__ResqmlUom__mrem = 1202,
	resqml2__ResqmlUom__mrem_x002fh = 1203,
	resqml2__ResqmlUom__MS = 1204,
	resqml2__ResqmlUom__mS = 1205,
	resqml2__ResqmlUom__ms = 1206,
	resqml2__ResqmlUom__ms_x002fcm = 1207,
	resqml2__ResqmlUom__mS_x002fcm = 1208,
	resqml2__ResqmlUom__ms_x002fft = 1209,
	resqml2__ResqmlUom__ms_x002fin = 1210,
	resqml2__ResqmlUom__mS_x002fm = 1211,
	resqml2__ResqmlUom__ms_x002fm = 1212,
	resqml2__ResqmlUom__ms_x002fs = 1213,
	resqml2__ResqmlUom__mSv = 1214,
	resqml2__ResqmlUom__mSv_x002fh = 1215,
	resqml2__ResqmlUom__mT = 1216,
	resqml2__ResqmlUom__mT_x002fdm = 1217,
	resqml2__ResqmlUom__MV = 1218,
	resqml2__ResqmlUom__mV = 1219,
	resqml2__ResqmlUom__mV_x002fft = 1220,
	resqml2__ResqmlUom__mV_x002fm = 1221,
	resqml2__ResqmlUom__MW = 1222,
	resqml2__ResqmlUom__mW = 1223,
	resqml2__ResqmlUom__MW_x002eh = 1224,
	resqml2__ResqmlUom__MW_x002eh_x002fkg = 1225,
	resqml2__ResqmlUom__MW_x002eh_x002fm3 = 1226,
	resqml2__ResqmlUom__mW_x002fm2 = 1227,
	resqml2__ResqmlUom__mWb = 1228,
	resqml2__ResqmlUom__MWb = 1229,
	resqml2__ResqmlUom__N_x002em = 1230,
	resqml2__ResqmlUom__N_x002em_x002fm = 1231,
	resqml2__ResqmlUom__N_x002em2 = 1232,
	resqml2__ResqmlUom__N_x002es_x002fm2 = 1233,
	resqml2__ResqmlUom__N_x002fm = 1234,
	resqml2__ResqmlUom__N_x002fm2 = 1235,
	resqml2__ResqmlUom__N_x002fm3 = 1236,
	resqml2__ResqmlUom__N_x002fmm2 = 1237,
	resqml2__ResqmlUom__N_x002fN = 1238,
	resqml2__ResqmlUom__nA = 1239,
	resqml2__ResqmlUom__na = 1240,
	resqml2__ResqmlUom__nAPI = 1241,
	resqml2__ResqmlUom__nC = 1242,
	resqml2__ResqmlUom__ncal_x005bth_x005d = 1243,
	resqml2__ResqmlUom__nCi = 1244,
	resqml2__ResqmlUom__nEuc = 1245,
	resqml2__ResqmlUom__neV = 1246,
	resqml2__ResqmlUom__nF = 1247,
	resqml2__ResqmlUom__ng = 1248,
	resqml2__ResqmlUom__ng_x002fg = 1249,
	resqml2__ResqmlUom__ng_x002fmg = 1250,
	resqml2__ResqmlUom__ngauss = 1251,
	resqml2__ResqmlUom__nGy = 1252,
	resqml2__ResqmlUom__nH = 1253,
	resqml2__ResqmlUom__nHz = 1254,
	resqml2__ResqmlUom__nJ = 1255,
	resqml2__ResqmlUom__nm = 1256,
	resqml2__ResqmlUom__nm_x002fs = 1257,
	resqml2__ResqmlUom__nN = 1258,
	resqml2__ResqmlUom__nohm = 1259,
	resqml2__ResqmlUom__nohm_x002emil2_x002fft = 1260,
	resqml2__ResqmlUom__nohm_x002emm2_x002fm = 1261,
	resqml2__ResqmlUom__nP = 1262,
	resqml2__ResqmlUom__nPa = 1263,
	resqml2__ResqmlUom__nrd = 1264,
	resqml2__ResqmlUom__nS = 1265,
	resqml2__ResqmlUom__ns = 1266,
	resqml2__ResqmlUom__ns_x002fft = 1267,
	resqml2__ResqmlUom__ns_x002fm = 1268,
	resqml2__ResqmlUom__nT = 1269,
	resqml2__ResqmlUom__nV = 1270,
	resqml2__ResqmlUom__nW = 1271,
	resqml2__ResqmlUom__nWb = 1272,
	resqml2__ResqmlUom__Oe = 1273,
	resqml2__ResqmlUom__ohm = 1274,
	resqml2__ResqmlUom__ohm_x002ecm = 1275,
	resqml2__ResqmlUom__ohm_x002em = 1276,
	resqml2__ResqmlUom__ohm_x002em2_x002fm = 1277,
	resqml2__ResqmlUom__ohm_x002fm = 1278,
	resqml2__ResqmlUom__ozf = 1279,
	resqml2__ResqmlUom__ozm = 1280,
	resqml2__ResqmlUom__ozm_x005btroy_x005d = 1281,
	resqml2__ResqmlUom__pA = 1282,
	resqml2__ResqmlUom__Pa = 1283,
	resqml2__ResqmlUom__Pa_x002es = 1284,
	resqml2__ResqmlUom__Pa_x002es_x002em3_x002fkg = 1285,
	resqml2__ResqmlUom__Pa_x002es_x002fm3 = 1286,
	resqml2__ResqmlUom__Pa_x002es2_x002fm3 = 1287,
	resqml2__ResqmlUom__Pa_x002fh = 1288,
	resqml2__ResqmlUom__Pa_x002fm = 1289,
	resqml2__ResqmlUom__Pa_x002fm3 = 1290,
	resqml2__ResqmlUom__Pa_x002fs = 1291,
	resqml2__ResqmlUom__Pa2 = 1292,
	resqml2__ResqmlUom__Pa2_x002f_x0028Pa_x002es_x0029 = 1293,
	resqml2__ResqmlUom__pC = 1294,
	resqml2__ResqmlUom__pcal_x005bth_x005d = 1295,
	resqml2__ResqmlUom__pCi = 1296,
	resqml2__ResqmlUom__pCi_x002fg = 1297,
	resqml2__ResqmlUom__pdl = 1298,
	resqml2__ResqmlUom__pdl_x002ecm2 = 1299,
	resqml2__ResqmlUom__pdl_x002eft = 1300,
	resqml2__ResqmlUom__pdl_x002fcm = 1301,
	resqml2__ResqmlUom__pEuc = 1302,
	resqml2__ResqmlUom__peV = 1303,
	resqml2__ResqmlUom__pF = 1304,
	resqml2__ResqmlUom__pg = 1305,
	resqml2__ResqmlUom__pgauss = 1306,
	resqml2__ResqmlUom__pGy = 1307,
	resqml2__ResqmlUom__pHz = 1308,
	resqml2__ResqmlUom__pJ = 1309,
	resqml2__ResqmlUom__pm = 1310,
	resqml2__ResqmlUom__pN = 1311,
	resqml2__ResqmlUom__pohm = 1312,
	resqml2__ResqmlUom__pP = 1313,
	resqml2__ResqmlUom__pPa = 1314,
	resqml2__ResqmlUom__ppk = 1315,
	resqml2__ResqmlUom__ppm = 1316,
	resqml2__ResqmlUom__ppm_x005bmass_x005d = 1317,
	resqml2__ResqmlUom__ppm_x005bvol_x005d = 1318,
	resqml2__ResqmlUom__ppm_x005bvol_x005d_x002fdegC = 1319,
	resqml2__ResqmlUom__ppm_x005bvol_x005d_x002fdegF = 1320,
	resqml2__ResqmlUom__prd = 1321,
	resqml2__ResqmlUom__ps = 1322,
	resqml2__ResqmlUom__pS = 1323,
	resqml2__ResqmlUom__psi = 1324,
	resqml2__ResqmlUom__psi_x002ed_x002fbbl = 1325,
	resqml2__ResqmlUom__psi_x002es = 1326,
	resqml2__ResqmlUom__psi_x002fft = 1327,
	resqml2__ResqmlUom__psi_x002fh = 1328,
	resqml2__ResqmlUom__psi_x002fm = 1329,
	resqml2__ResqmlUom__psi_x002fmin = 1330,
	resqml2__ResqmlUom__psi2 = 1331,
	resqml2__ResqmlUom__psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1332,
	resqml2__ResqmlUom__psi2_x002fcP = 1333,
	resqml2__ResqmlUom__pT = 1334,
	resqml2__ResqmlUom__pt_x005bUK_x005d = 1335,
	resqml2__ResqmlUom__pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 1336,
	resqml2__ResqmlUom__pt_x005bUS_x005d = 1337,
	resqml2__ResqmlUom__pV = 1338,
	resqml2__ResqmlUom__pW = 1339,
	resqml2__ResqmlUom__pWb = 1340,
	resqml2__ResqmlUom__qt_x005bUK_x005d = 1341,
	resqml2__ResqmlUom__qt_x005bUS_x005d = 1342,
	resqml2__ResqmlUom__quad = 1343,
	resqml2__ResqmlUom__quad_x002fa = 1344,
	resqml2__ResqmlUom__rad = 1345,
	resqml2__ResqmlUom__rad_x002fft = 1346,
	resqml2__ResqmlUom__rad_x002fft3 = 1347,
	resqml2__ResqmlUom__rad_x002fm = 1348,
	resqml2__ResqmlUom__rad_x002fm3 = 1349,
	resqml2__ResqmlUom__rad_x002fs = 1350,
	resqml2__ResqmlUom__rad_x002fs2 = 1351,
	resqml2__ResqmlUom__rd = 1352,
	resqml2__ResqmlUom__rem = 1353,
	resqml2__ResqmlUom__rem_x002fh = 1354,
	resqml2__ResqmlUom__rev = 1355,
	resqml2__ResqmlUom__rev_x002fft = 1356,
	resqml2__ResqmlUom__rev_x002fm = 1357,
	resqml2__ResqmlUom__rev_x002fs = 1358,
	resqml2__ResqmlUom__rod_x005bUS_x005d = 1359,
	resqml2__ResqmlUom__rpm = 1360,
	resqml2__ResqmlUom__rpm_x002fs = 1361,
	resqml2__ResqmlUom__s_x002fcm = 1362,
	resqml2__ResqmlUom__s_x002fft = 1363,
	resqml2__ResqmlUom__s_x002fft3 = 1364,
	resqml2__ResqmlUom__s_x002fin = 1365,
	resqml2__ResqmlUom__s_x002fkg = 1366,
	resqml2__ResqmlUom__s_x002fL = 1367,
	resqml2__ResqmlUom__S_x002fm = 1368,
	resqml2__ResqmlUom__s_x002fm = 1369,
	resqml2__ResqmlUom__s_x002fm3 = 1370,
	resqml2__ResqmlUom__s_x002fqt_x005bUK_x005d = 1371,
	resqml2__ResqmlUom__s_x002fqt_x005bUS_x005d = 1372,
	resqml2__ResqmlUom__s_x002fs = 1373,
	resqml2__ResqmlUom__sack_x005b94lbm_x005d = 1374,
	resqml2__ResqmlUom__seca = 1375,
	resqml2__ResqmlUom__section = 1376,
	resqml2__ResqmlUom__sr = 1377,
	resqml2__ResqmlUom__St = 1378,
	resqml2__ResqmlUom__Sv = 1379,
	resqml2__ResqmlUom__Sv_x002fh = 1380,
	resqml2__ResqmlUom__Sv_x002fs = 1381,
	resqml2__ResqmlUom__t_x002fa = 1382,
	resqml2__ResqmlUom__t_x002fd = 1383,
	resqml2__ResqmlUom__t_x002fh = 1384,
	resqml2__ResqmlUom__T_x002fm = 1385,
	resqml2__ResqmlUom__t_x002fm3 = 1386,
	resqml2__ResqmlUom__t_x002fmin = 1387,
	resqml2__ResqmlUom__TA = 1388,
	resqml2__ResqmlUom__Ta_x005bt_x005d = 1389,
	resqml2__ResqmlUom__TBq = 1390,
	resqml2__ResqmlUom__TC = 1391,
	resqml2__ResqmlUom__Tcal_x005bth_x005d = 1392,
	resqml2__ResqmlUom__TD_x005bAPI_x005d = 1393,
	resqml2__ResqmlUom__TD_x005bAPI_x005d_x002em = 1394,
	resqml2__ResqmlUom__TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 1395,
	resqml2__ResqmlUom__TEuc = 1396,
	resqml2__ResqmlUom__TeV = 1397,
	resqml2__ResqmlUom__TF = 1398,
	resqml2__ResqmlUom__Tg = 1399,
	resqml2__ResqmlUom__Tgauss = 1400,
	resqml2__ResqmlUom__TGy = 1401,
	resqml2__ResqmlUom__TH = 1402,
	resqml2__ResqmlUom__therm_x005bEC_x005d = 1403,
	resqml2__ResqmlUom__therm_x005bUK_x005d = 1404,
	resqml2__ResqmlUom__therm_x005bUS_x005d = 1405,
	resqml2__ResqmlUom__THz = 1406,
	resqml2__ResqmlUom__TJ = 1407,
	resqml2__ResqmlUom__TJ_x002fa = 1408,
	resqml2__ResqmlUom__Tm = 1409,
	resqml2__ResqmlUom__TN = 1410,
	resqml2__ResqmlUom__Tohm = 1411,
	resqml2__ResqmlUom__ton_x005bUK_x005d = 1412,
	resqml2__ResqmlUom__ton_x005bUK_x005d_x002fa = 1413,
	resqml2__ResqmlUom__ton_x005bUK_x005d_x002fd = 1414,
	resqml2__ResqmlUom__ton_x005bUK_x005d_x002fh = 1415,
	resqml2__ResqmlUom__ton_x005bUK_x005d_x002fmin = 1416,
	resqml2__ResqmlUom__ton_x005bUS_x005d = 1417,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fa = 1418,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fd = 1419,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fft2 = 1420,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fh = 1421,
	resqml2__ResqmlUom__ton_x005bUS_x005d_x002fmin = 1422,
	resqml2__ResqmlUom__tonf_x005bUK_x005d = 1423,
	resqml2__ResqmlUom__tonf_x005bUK_x005d_x002eft2 = 1424,
	resqml2__ResqmlUom__tonf_x005bUK_x005d_x002fft = 1425,
	resqml2__ResqmlUom__tonf_x005bUK_x005d_x002fft2 = 1426,
	resqml2__ResqmlUom__tonf_x005bUS_x005d = 1427,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002eft = 1428,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002eft2 = 1429,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002emi = 1430,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002emi_x002fbbl = 1431,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002emi_x002fft = 1432,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002fft = 1433,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002fft2 = 1434,
	resqml2__ResqmlUom__tonf_x005bUS_x005d_x002fin2 = 1435,
	resqml2__ResqmlUom__tonRefrig = 1436,
	resqml2__ResqmlUom__torr = 1437,
	resqml2__ResqmlUom__TP = 1438,
	resqml2__ResqmlUom__TPa = 1439,
	resqml2__ResqmlUom__Trd = 1440,
	resqml2__ResqmlUom__TS = 1441,
	resqml2__ResqmlUom__TT = 1442,
	resqml2__ResqmlUom__TV = 1443,
	resqml2__ResqmlUom__TW = 1444,
	resqml2__ResqmlUom__TW_x002eh = 1445,
	resqml2__ResqmlUom__TWb = 1446,
	resqml2__ResqmlUom__uA = 1447,
	resqml2__ResqmlUom__uA_x002fcm2 = 1448,
	resqml2__ResqmlUom__uA_x002fin2 = 1449,
	resqml2__ResqmlUom__ubar = 1450,
	resqml2__ResqmlUom__uC = 1451,
	resqml2__ResqmlUom__ucal_x005bth_x005d = 1452,
	resqml2__ResqmlUom__ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 1453,
	resqml2__ResqmlUom__ucal_x005bth_x005d_x002fs = 1454,
	resqml2__ResqmlUom__uCi = 1455,
	resqml2__ResqmlUom__uEuc = 1456,
	resqml2__ResqmlUom__ueV = 1457,
	resqml2__ResqmlUom__uF = 1458,
	resqml2__ResqmlUom__uF_x002fm = 1459,
	resqml2__ResqmlUom__ug = 1460,
	resqml2__ResqmlUom__ug_x002fcm3 = 1461,
	resqml2__ResqmlUom__ug_x002fg = 1462,
	resqml2__ResqmlUom__ug_x002fmg = 1463,
	resqml2__ResqmlUom__ugauss = 1464,
	resqml2__ResqmlUom__uGy = 1465,
	resqml2__ResqmlUom__uH = 1466,
	resqml2__ResqmlUom__uH_x002fm = 1467,
	resqml2__ResqmlUom__uHz = 1468,
	resqml2__ResqmlUom__uJ = 1469,
	resqml2__ResqmlUom__um = 1470,
	resqml2__ResqmlUom__um_x002fs = 1471,
	resqml2__ResqmlUom__um2 = 1472,
	resqml2__ResqmlUom__um2_x002em = 1473,
	resqml2__ResqmlUom__umHg_x005b0degC_x005d = 1474,
	resqml2__ResqmlUom__umol = 1475,
	resqml2__ResqmlUom__uN = 1476,
	resqml2__ResqmlUom__uohm = 1477,
	resqml2__ResqmlUom__uohm_x002fft = 1478,
	resqml2__ResqmlUom__uohm_x002fm = 1479,
	resqml2__ResqmlUom__uP = 1480,
	resqml2__ResqmlUom__uPa = 1481,
	resqml2__ResqmlUom__upsi = 1482,
	resqml2__ResqmlUom__urad = 1483,
	resqml2__ResqmlUom__urd = 1484,
	resqml2__ResqmlUom__us = 1485,
	resqml2__ResqmlUom__uS = 1486,
	resqml2__ResqmlUom__us_x002fft = 1487,
	resqml2__ResqmlUom__us_x002fin = 1488,
	resqml2__ResqmlUom__us_x002fm = 1489,
	resqml2__ResqmlUom__uT = 1490,
	resqml2__ResqmlUom__uV = 1491,
	resqml2__ResqmlUom__uV_x002fft = 1492,
	resqml2__ResqmlUom__uV_x002fm = 1493,
	resqml2__ResqmlUom__uW = 1494,
	resqml2__ResqmlUom__uW_x002fm3 = 1495,
	resqml2__ResqmlUom__uWb = 1496,
	resqml2__ResqmlUom__V_x002fB = 1497,
	resqml2__ResqmlUom__V_x002fdB = 1498,
	resqml2__ResqmlUom__V_x002fm = 1499,
	resqml2__ResqmlUom__W_x002em2_x002eK_x002f_x0028J_x002eK_x0029 = 1500,
	resqml2__ResqmlUom__W_x002f_x0028m_x002eK_x0029 = 1501,
	resqml2__ResqmlUom__W_x002f_x0028m2_x002eK_x0029 = 1502,
	resqml2__ResqmlUom__W_x002f_x0028m2_x002esr_x0029 = 1503,
	resqml2__ResqmlUom__W_x002f_x0028m3_x002eK_x0029 = 1504,
	resqml2__ResqmlUom__W_x002fcm2 = 1505,
	resqml2__ResqmlUom__W_x002fK = 1506,
	resqml2__ResqmlUom__W_x002fkW = 1507,
	resqml2__ResqmlUom__W_x002fm2 = 1508,
	resqml2__ResqmlUom__W_x002fm3 = 1509,
	resqml2__ResqmlUom__W_x002fmm2 = 1510,
	resqml2__ResqmlUom__W_x002fsr = 1511,
	resqml2__ResqmlUom__W_x002fW = 1512,
	resqml2__ResqmlUom__Wb = 1513,
	resqml2__ResqmlUom__Wb_x002em = 1514,
	resqml2__ResqmlUom__Wb_x002fm = 1515,
	resqml2__ResqmlUom__Wb_x002fmm = 1516,
	resqml2__ResqmlUom__wk = 1517,
	resqml2__ResqmlUom__yd = 1518,
	resqml2__ResqmlUom__yd_x005bBnA_x005d = 1519,
	resqml2__ResqmlUom__yd_x005bBnB_x005d = 1520,
	resqml2__ResqmlUom__yd_x005bCla_x005d = 1521,
	resqml2__ResqmlUom__yd_x005bInd_x005d = 1522,
	resqml2__ResqmlUom__yd_x005bInd37_x005d = 1523,
	resqml2__ResqmlUom__yd_x005bInd62_x005d = 1524,
	resqml2__ResqmlUom__yd_x005bInd75_x005d = 1525,
	resqml2__ResqmlUom__yd_x005bSe_x005d = 1526,
	resqml2__ResqmlUom__yd_x005bSeT_x005d = 1527,
	resqml2__ResqmlUom__yd_x005bUS_x005d = 1528,
	resqml2__ResqmlUom__yd2 = 1529,
	resqml2__ResqmlUom__yd3 = 1530
};
#endif

/* resqml2_0_1ForGsoap.h:3414 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IdentityKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IdentityKind (566)
/* resqml2:IdentityKind */
enum resqml2__IdentityKind {
	resqml2__IdentityKind__colocation = 0,
	resqml2__IdentityKind__previous_x0020colocation = 1,
	resqml2__IdentityKind__equivalence = 2,
	resqml2__IdentityKind__previous_x0020equivalence = 3
};
#endif

/* resqml2_0_1ForGsoap.h:3445 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IndexableElements (567)
/* resqml2:IndexableElements */
enum resqml2__IndexableElements {
	resqml2__IndexableElements__cells = 0,
	resqml2__IndexableElements__column_x0020edges = 1,
	resqml2__IndexableElements__columns = 2,
	resqml2__IndexableElements__contacts = 3,
	resqml2__IndexableElements__coordinate_x0020lines = 4,
	resqml2__IndexableElements__edges = 5,
	resqml2__IndexableElements__edges_x0020per_x0020column = 6,
	resqml2__IndexableElements__enumerated_x0020elements = 7,
	resqml2__IndexableElements__faces = 8,
	resqml2__IndexableElements__faces_x0020per_x0020cell = 9,
	resqml2__IndexableElements__interval_x0020edges = 10,
	resqml2__IndexableElements__intervals = 11,
	resqml2__IndexableElements__I0 = 12,
	resqml2__IndexableElements__I0_x0020edges = 13,
	resqml2__IndexableElements__J0 = 14,
	resqml2__IndexableElements__J0_x0020edges = 15,
	resqml2__IndexableElements__layers = 16,
	resqml2__IndexableElements__nodes = 17,
	resqml2__IndexableElements__nodes_x0020per_x0020cell = 18,
	resqml2__IndexableElements__nodes_x0020per_x0020edge = 19,
	resqml2__IndexableElements__nodes_x0020per_x0020face = 20,
	resqml2__IndexableElements__patches = 21,
	resqml2__IndexableElements__pillars = 22,
	resqml2__IndexableElements__regions = 23,
	resqml2__IndexableElements__representation = 24,
	resqml2__IndexableElements__subnodes = 25,
	resqml2__IndexableElements__triangles = 26
};
#endif

/* resqml2_0_1ForGsoap.h:3500 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerIndexableElements (568)
/* resqml2:UnstructuredColumnLayerIndexableElements */
enum resqml2__UnstructuredColumnLayerIndexableElements {
	resqml2__UnstructuredColumnLayerIndexableElements__cells = 0,
	resqml2__UnstructuredColumnLayerIndexableElements__column_x0020edges = 1,
	resqml2__UnstructuredColumnLayerIndexableElements__columns = 2,
	resqml2__UnstructuredColumnLayerIndexableElements__coordinate_x0020lines = 3,
	resqml2__UnstructuredColumnLayerIndexableElements__edges = 4,
	resqml2__UnstructuredColumnLayerIndexableElements__edges_x0020per_x0020column = 5,
	resqml2__UnstructuredColumnLayerIndexableElements__faces = 6,
	resqml2__UnstructuredColumnLayerIndexableElements__faces_x0020per_x0020cell = 7,
	resqml2__UnstructuredColumnLayerIndexableElements__hinge_x0020node_x0020faces = 8,
	resqml2__UnstructuredColumnLayerIndexableElements__interval_x0020edges = 9,
	resqml2__UnstructuredColumnLayerIndexableElements__intervals = 10,
	resqml2__UnstructuredColumnLayerIndexableElements__layers = 11,
	resqml2__UnstructuredColumnLayerIndexableElements__nodes = 12,
	resqml2__UnstructuredColumnLayerIndexableElements__nodes_x0020per_x0020cell = 13,
	resqml2__UnstructuredColumnLayerIndexableElements__nodes_x0020per_x0020edge = 14,
	resqml2__UnstructuredColumnLayerIndexableElements__nodes_x0020per_x0020face = 15,
	resqml2__UnstructuredColumnLayerIndexableElements__pillars = 16,
	resqml2__UnstructuredColumnLayerIndexableElements__subnodes = 17
};
#endif

/* resqml2_0_1ForGsoap.h:3583 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeNodeObject
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeNodeObject (569)
/* resqml2:SubnodeNodeObject */
enum resqml2__SubnodeNodeObject {
	resqml2__SubnodeNodeObject__cell = 0,
	resqml2__SubnodeNodeObject__face = 1,
	resqml2__SubnodeNodeObject__edge = 2
};
#endif

/* resqml2_0_1ForGsoap.h:3608 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnShape (570)
/* resqml2:ColumnShape */
enum resqml2__ColumnShape {
	resqml2__ColumnShape__triangular = 0,
	resqml2__ColumnShape__quadrilateral = 1,
	resqml2__ColumnShape__polygonal = 2
};
#endif

/* resqml2_0_1ForGsoap.h:3630 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KDirection
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KDirection (571)
/* resqml2:KDirection */
enum resqml2__KDirection {
	resqml2__KDirection__down = 0,
	resqml2__KDirection__up = 1,
	resqml2__KDirection__not_x0020monotonic = 2
};
#endif

/* resqml2_0_1ForGsoap.h:3652 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkIndexableElements (572)
/* resqml2:IjkIndexableElements */
enum resqml2__IjkIndexableElements {
	resqml2__IjkIndexableElements__cells = 0,
	resqml2__IjkIndexableElements__column_x0020edges = 1,
	resqml2__IjkIndexableElements__columns = 2,
	resqml2__IjkIndexableElements__coordinate_x0020lines = 3,
	resqml2__IjkIndexableElements__edges = 4,
	resqml2__IjkIndexableElements__edges_x0020per_x0020column = 5,
	resqml2__IjkIndexableElements__faces = 6,
	resqml2__IjkIndexableElements__faces_x0020per_x0020cell = 7,
	resqml2__IjkIndexableElements__hinge_x0020node_x0020faces = 8,
	resqml2__IjkIndexableElements__interval_x0020edges = 9,
	resqml2__IjkIndexableElements__intervals = 10,
	resqml2__IjkIndexableElements__I0 = 11,
	resqml2__IjkIndexableElements__I0_x0020edges = 12,
	resqml2__IjkIndexableElements__J0 = 13,
	resqml2__IjkIndexableElements__J0_x0020edges = 14,
	resqml2__IjkIndexableElements__layers = 15,
	resqml2__IjkIndexableElements__nodes = 16,
	resqml2__IjkIndexableElements__nodes_x0020per_x0020cell = 17,
	resqml2__IjkIndexableElements__nodes_x0020per_x0020edge = 18,
	resqml2__IjkIndexableElements__nodes_x0020per_x0020face = 19,
	resqml2__IjkIndexableElements__pillars = 20,
	resqml2__IjkIndexableElements__radial_x0020origin_x0020polyline = 21,
	resqml2__IjkIndexableElements__subnodes = 22
};
#endif

/* resqml2_0_1ForGsoap.h:3754 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GridGeometryAttachment
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GridGeometryAttachment (573)
/* resqml2:GridGeometryAttachment */
enum resqml2__GridGeometryAttachment {
	resqml2__GridGeometryAttachment__cells = 0,
	resqml2__GridGeometryAttachment__edges = 1,
	resqml2__GridGeometryAttachment__faces = 2,
	resqml2__GridGeometryAttachment__hinge_x0020node_x0020faces = 3,
	resqml2__GridGeometryAttachment__nodes = 4,
	resqml2__GridGeometryAttachment__radial_x0020origin_x0020polyline = 5,
	resqml2__GridGeometryAttachment__subnodes = 6
};
#endif

/* resqml2_0_1ForGsoap.h:3798 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellShape (574)
/* resqml2:CellShape */
enum resqml2__CellShape {
	resqml2__CellShape__tetrahedral = 0,
	resqml2__CellShape__pyramidal = 1,
	resqml2__CellShape__prism = 2,
	resqml2__CellShape__hexahedral = 3,
	resqml2__CellShape__polyhedral = 4
};
#endif

/* resqml2_0_1ForGsoap.h:3828 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredCellIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredCellIndexableElements (575)
/* resqml2:UnstructuredCellIndexableElements */
enum resqml2__UnstructuredCellIndexableElements {
	resqml2__UnstructuredCellIndexableElements__cells = 0,
	resqml2__UnstructuredCellIndexableElements__edges = 1,
	resqml2__UnstructuredCellIndexableElements__faces = 2,
	resqml2__UnstructuredCellIndexableElements__faces_x0020per_x0020cell = 3,
	resqml2__UnstructuredCellIndexableElements__hinge_x0020node_x0020faces = 4,
	resqml2__UnstructuredCellIndexableElements__nodes = 5,
	resqml2__UnstructuredCellIndexableElements__nodes_x0020per_x0020cell = 6,
	resqml2__UnstructuredCellIndexableElements__nodes_x0020per_x0020edge = 7,
	resqml2__UnstructuredCellIndexableElements__nodes_x0020per_x0020face = 8,
	resqml2__UnstructuredCellIndexableElements__subnodes = 9
};
#endif

/* resqml2_0_1ForGsoap.h:3881 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PillarShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PillarShape (576)
/* resqml2:PillarShape */
enum resqml2__PillarShape {
	resqml2__PillarShape__vertical = 0,
	resqml2__PillarShape__straight = 1,
	resqml2__PillarShape__curved = 2
};
#endif

/* resqml2_0_1ForGsoap.h:3903 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThrowKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThrowKind (577)
/* resqml2:ThrowKind */
enum resqml2__ThrowKind {
	resqml2__ThrowKind__reverse = 0,
	resqml2__ThrowKind__normal = 1,
	resqml2__ThrowKind__thrust = 2,
	resqml2__ThrowKind__strike_x0020and_x0020slip = 3,
	resqml2__ThrowKind__scissor = 4,
	resqml2__ThrowKind__variable = 5
};
#endif

/* resqml2_0_1ForGsoap.h:3919 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SequenceStratigraphySurface
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SequenceStratigraphySurface (578)
/* resqml2:SequenceStratigraphySurface */
enum resqml2__SequenceStratigraphySurface {
	resqml2__SequenceStratigraphySurface__flooding = 0,
	resqml2__SequenceStratigraphySurface__ravinement = 1,
	resqml2__SequenceStratigraphySurface__maximum_x0020flooding = 2,
	resqml2__SequenceStratigraphySurface__transgressive = 3
};
#endif

/* resqml2_0_1ForGsoap.h:3933 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRelationship
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRelationship (579)
/* resqml2:ContactRelationship */
enum resqml2__ContactRelationship {
	resqml2__ContactRelationship__frontier_x0020feature_x0020to_x0020frontier_x0020feature = 0,
	resqml2__ContactRelationship__genetic_x0020boundary_x0020to_x0020frontier_x0020feature = 1,
	resqml2__ContactRelationship__genetic_x0020boundary_x0020to_x0020genetic_x0020boundary = 2,
	resqml2__ContactRelationship__genetic_x0020boundary_x0020to_x0020tectonic_x0020boundary = 3,
	resqml2__ContactRelationship__stratigraphic_x0020unit_x0020to_x0020frontier_x0020feature = 4,
	resqml2__ContactRelationship__stratigraphic_x0020unit_x0020to_x0020stratigraphic_x0020unit = 5,
	resqml2__ContactRelationship__tectonic_x0020boundary_x0020to_x0020frontier_x0020feature = 6,
	resqml2__ContactRelationship__tectonic_x0020boundary_x0020to_x0020genetic_x0020boundary = 7,
	resqml2__ContactRelationship__tectonic_x0020boundary_x0020to_x0020tectonic_x0020boundary = 8
};
#endif

/* resqml2_0_1ForGsoap.h:3979 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DepositionMode
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DepositionMode (580)
/* resqml2:DepositionMode */
enum resqml2__DepositionMode {
	resqml2__DepositionMode__proportional_x0020between_x0020top_x0020and_x0020bottom = 0,
	resqml2__DepositionMode__parallel_x0020to_x0020bottom = 1,
	resqml2__DepositionMode__parallel_x0020to_x0020top = 2,
	resqml2__DepositionMode__parallel_x0020to_x0020another_x0020boundary = 3
};
#endif

/* resqml2_0_1ForGsoap.h:3990 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitComposition
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitComposition (581)
/* resqml2:GeologicUnitComposition */
enum resqml2__GeologicUnitComposition {
	resqml2__GeologicUnitComposition__intrusive_x0020clay_x0020 = 0,
	resqml2__GeologicUnitComposition__organic = 1,
	resqml2__GeologicUnitComposition__intrusive_x0020mud_x0020 = 2,
	resqml2__GeologicUnitComposition__evaporite_x0020salt = 3,
	resqml2__GeologicUnitComposition__evaporite_x0020non_x0020salt = 4,
	resqml2__GeologicUnitComposition__sedimentary_x0020siliclastic = 5,
	resqml2__GeologicUnitComposition__carbonate = 6,
	resqml2__GeologicUnitComposition__magmatic_x0020intrusive_x0020granitoid = 7,
	resqml2__GeologicUnitComposition__magmatic_x0020intrusive_x0020pyroclastic = 8,
	resqml2__GeologicUnitComposition__magmatic_x0020extrusive_x0020lava_x0020flow = 9,
	resqml2__GeologicUnitComposition__other_x0020chemichal_x0020rock = 10,
	resqml2__GeologicUnitComposition__sedimentary_x0020turbidite = 11
};
#endif

/* resqml2_0_1ForGsoap.h:4012 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Domain
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Domain (582)
/* resqml2:Domain */
enum resqml2__Domain {
	resqml2__Domain__depth = 0,
	resqml2__Domain__time = 1,
	resqml2__Domain__mixed = 2
};
#endif

/* resqml2_0_1ForGsoap.h:4031 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BoundaryRelation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BoundaryRelation (583)
/* resqml2:BoundaryRelation */
enum resqml2__BoundaryRelation {
	resqml2__BoundaryRelation__conformable = 0,
	resqml2__BoundaryRelation__unconformable_x0020below_x0020and_x0020above = 1,
	resqml2__BoundaryRelation__unconformable_x0020above = 2,
	resqml2__BoundaryRelation__unconformable_x0020below = 3
};
#endif

/* resqml2_0_1ForGsoap.h:4052 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactMode
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactMode (584)
/* resqml2:ContactMode */
enum resqml2__ContactMode {
	resqml2__ContactMode__baselap = 0,
	resqml2__ContactMode__erosion = 1,
	resqml2__ContactMode__extended = 2,
	resqml2__ContactMode__proportional = 3
};
#endif

/* resqml2_0_1ForGsoap.h:4066 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrderingCriteria
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrderingCriteria (585)
/* resqml2:OrderingCriteria */
enum resqml2__OrderingCriteria {
	resqml2__OrderingCriteria__age = 0,
	resqml2__OrderingCriteria__apparent_x0020depth = 1,
	resqml2__OrderingCriteria__measured_x0020depth = 2
};
#endif

/* resqml2_0_1ForGsoap.h:4088 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Geobody3dShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Geobody3dShape (586)
/* resqml2:Geobody3dShape */
enum resqml2__Geobody3dShape {
	resqml2__Geobody3dShape__dyke = 0,
	resqml2__Geobody3dShape__silt = 1,
	resqml2__Geobody3dShape__dome = 2,
	resqml2__Geobody3dShape__sheeth = 3,
	resqml2__Geobody3dShape__diapir = 4,
	resqml2__Geobody3dShape__batholith = 5,
	resqml2__Geobody3dShape__channel = 6,
	resqml2__Geobody3dShape__delta = 7,
	resqml2__Geobody3dShape__dune = 8,
	resqml2__Geobody3dShape__fan = 9,
	resqml2__Geobody3dShape__reef = 10,
	resqml2__Geobody3dShape__wedge = 11
};
#endif

/* resqml2_0_1ForGsoap.h:4110 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactVerb
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactVerb (587)
/* resqml2:ContactVerb */
enum resqml2__ContactVerb {
	resqml2__ContactVerb__splits = 0,
	resqml2__ContactVerb__interrupts = 1,
	resqml2__ContactVerb__contains = 2,
	resqml2__ContactVerb__conforms = 3,
	resqml2__ContactVerb__erodes = 4,
	resqml2__ContactVerb__stops_x0020at = 5,
	resqml2__ContactVerb__crosses = 6,
	resqml2__ContactVerb__includes = 7
};
#endif

/* resqml2_0_1ForGsoap.h:4153 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactSide
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactSide (588)
/* resqml2:ContactSide */
enum resqml2__ContactSide {
	resqml2__ContactSide__footwall = 0,
	resqml2__ContactSide__hanging_x0020wall = 1,
	resqml2__ContactSide__north = 2,
	resqml2__ContactSide__south = 3,
	resqml2__ContactSide__east = 4,
	resqml2__ContactSide__west = 5,
	resqml2__ContactSide__younger = 6,
	resqml2__ContactSide__older = 7,
	resqml2__ContactSide__both = 8
};
#endif

/* resqml2_0_1ForGsoap.h:4199 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitMaterialImplacement
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitMaterialImplacement (589)
/* resqml2:GeologicUnitMaterialImplacement */
enum resqml2__GeologicUnitMaterialImplacement {
	resqml2__GeologicUnitMaterialImplacement__autochtonous = 0,
	resqml2__GeologicUnitMaterialImplacement__allochtonous = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4212 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Phase
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Phase (590)
/* resqml2:Phase */
enum resqml2__Phase {
	resqml2__Phase__aquifer = 0,
	resqml2__Phase__gas_x0020cap = 1,
	resqml2__Phase__oil_x0020column = 2,
	resqml2__Phase__seal = 3
};
#endif

/* resqml2_0_1ForGsoap.h:4238 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeneticBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeneticBoundaryKind (591)
/* resqml2:GeneticBoundaryKind */
enum resqml2__GeneticBoundaryKind {
	resqml2__GeneticBoundaryKind__geobody_x0020boundary = 0,
	resqml2__GeneticBoundaryKind__horizon = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4256 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidContact
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidContact (592)
/* resqml2:FluidContact */
enum resqml2__FluidContact {
	resqml2__FluidContact__free_x0020water_x0020contact = 0,
	resqml2__FluidContact__gas_x0020oil_x0020contact = 1,
	resqml2__FluidContact__gas_x0020water_x0020contact = 2,
	resqml2__FluidContact__seal = 3,
	resqml2__FluidContact__water_x0020oil_x0020contact = 4
};
#endif

/* resqml2_0_1ForGsoap.h:4286 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TectonicBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TectonicBoundaryKind (593)
/* resqml2:TectonicBoundaryKind */
enum resqml2__TectonicBoundaryKind {
	resqml2__TectonicBoundaryKind__fault = 0,
	resqml2__TectonicBoundaryKind__fracture = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4304 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicBoundaryKind (594)
/* resqml2:GeologicBoundaryKind */
enum resqml2__GeologicBoundaryKind {
	resqml2__GeologicBoundaryKind__fault = 0,
	resqml2__GeologicBoundaryKind__geobody = 1,
	resqml2__GeologicBoundaryKind__horizon = 2
};
#endif

/* resqml2_0_1ForGsoap.h:4317 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreFrameIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreFrameIndexableElements (595)
/* resqml2:WellboreFrameIndexableElements */
enum resqml2__WellboreFrameIndexableElements {
	resqml2__WellboreFrameIndexableElements__intervals = 0,
	resqml2__WellboreFrameIndexableElements__nodes = 1,
	resqml2__WellboreFrameIndexableElements__cells = 2
};
#endif

/* resqml2_0_1ForGsoap.h:4339 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdDomain
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdDomain (596)
/* resqml2:MdDomain */
enum resqml2__MdDomain {
	resqml2__MdDomain__driller = 0,
	resqml2__MdDomain__logger = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4358 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdReference (597)
/* resqml2:MdReference */
enum resqml2__MdReference {
	resqml2__MdReference__ground_x0020level = 0,
	resqml2__MdReference__kelly_x0020bushing = 1,
	resqml2__MdReference__mean_x0020sea_x0020level = 2,
	resqml2__MdReference__derrick_x0020floor = 3,
	resqml2__MdReference__casing_x0020flange = 4,
	resqml2__MdReference__arbitrary_x0020point = 5,
	resqml2__MdReference__crown_x0020valve = 6,
	resqml2__MdReference__rotary_x0020bushing = 7,
	resqml2__MdReference__rotary_x0020table = 8,
	resqml2__MdReference__sea_x0020floor = 9,
	resqml2__MdReference__lowest_x0020astronomical_x0020tide = 10,
	resqml2__MdReference__mean_x0020higher_x0020high_x0020water = 11,
	resqml2__MdReference__mean_x0020high_x0020water = 12,
	resqml2__MdReference__mean_x0020lower_x0020low_x0020water = 13,
	resqml2__MdReference__mean_x0020low_x0020water = 14,
	resqml2__MdReference__mean_x0020tide_x0020level = 15,
	resqml2__MdReference__kickoff_x0020point = 16
};
#endif

/* resqml2_0_1ForGsoap.h:4415 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidMarker
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidMarker (598)
/* resqml2:FluidMarker */
enum resqml2__FluidMarker {
	resqml2__FluidMarker__gas_x0020down_x0020to = 0,
	resqml2__FluidMarker__gas_x0020up_x0020to = 1,
	resqml2__FluidMarker__oil_x0020down_x0020to = 2,
	resqml2__FluidMarker__oil_x0020up_x0020to = 3,
	resqml2__FluidMarker__water_x0020down_x0020to = 4,
	resqml2__FluidMarker__water_x0020up_x0020to = 5
};
#endif

/* resqml2_0_1ForGsoap.h:4431 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SurfaceRole
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SurfaceRole (599)
/* resqml2:SurfaceRole */
enum resqml2__SurfaceRole {
	resqml2__SurfaceRole__map = 0,
	resqml2__SurfaceRole__pick = 1
};
#endif

/* resqml2_0_1ForGsoap.h:4449 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LineRole
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LineRole (600)
/* resqml2:LineRole */
enum resqml2__LineRole {
	resqml2__LineRole__fault_x0020center_x0020line = 0,
	resqml2__LineRole__pick = 1,
	resqml2__LineRole__inner_x0020ring = 2,
	resqml2__LineRole__outer_x0020ring = 3,
	resqml2__LineRole__trajectory = 4,
	resqml2__LineRole__interpretation_x0020line = 5,
	resqml2__LineRole__contact = 6,
	resqml2__LineRole__depositional_x0020line = 7,
	resqml2__LineRole__erosion_x0020line = 8,
	resqml2__LineRole__contouring = 9,
	resqml2__LineRole__pillar = 10
};
#endif

/* resqml2_0_1ForGsoap.h:4498 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterKind (601)
/* resqml2:ParameterKind */
enum resqml2__ParameterKind {
	resqml2__ParameterKind__dataObject = 0,
	resqml2__ParameterKind__floatingPoint = 1,
	resqml2__ParameterKind__integer = 2,
	resqml2__ParameterKind__string = 3,
	resqml2__ParameterKind__timestamp = 4,
	resqml2__ParameterKind__subActivity = 5
};
#endif

/* resqml2_0_1ForGsoap.h:4514 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineFlux
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineFlux (602)
/* resqml2:StreamlineFlux */
enum resqml2__StreamlineFlux {
	resqml2__StreamlineFlux__oil = 0,
	resqml2__StreamlineFlux__gas = 1,
	resqml2__StreamlineFlux__water = 2,
	resqml2__StreamlineFlux__total = 3,
	resqml2__StreamlineFlux__other = 4
};
#endif

/* resqml2_0_1ForGsoap.h:4596 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AggregationType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AggregationType (609)
/* gml:AggregationType */
enum gml__AggregationType {
	gml__AggregationType__set = 0,
	gml__AggregationType__bag = 1,
	gml__AggregationType__sequence = 2,
	gml__AggregationType__array = 3,
	gml__AggregationType__record = 4,
	gml__AggregationType__table = 5
};
#endif

/* resqml2_0_1ForGsoap.h:4623 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__show
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__show (610)
/* xlink:show */
enum _xlink__show {
	_xlink__show__new_ = 0,
	_xlink__show__replace = 1,
	_xlink__show__embed = 2,
	_xlink__show__other = 3,
	_xlink__show__none = 4
};
#endif

/* resqml2_0_1ForGsoap.h:4639 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__actuate
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__actuate (611)
/* xlink:actuate */
enum _xlink__actuate {
	_xlink__actuate__onLoad = 0,
	_xlink__actuate__onRequest = 1,
	_xlink__actuate__other = 2,
	_xlink__actuate__none = 3
};
#endif

/* resqml2_0_1ForGsoap.h:4810 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlPropertyKind (618)
/* resqml2:ResqmlPropertyKind */
enum resqml2__ResqmlPropertyKind {
	resqml2__ResqmlPropertyKind__absorbed_x0020dose = 0,
	resqml2__ResqmlPropertyKind__acceleration_x0020linear = 1,
	resqml2__ResqmlPropertyKind__activity_x0020_x0028of_x0020radioactivity_x0029 = 2,
	resqml2__ResqmlPropertyKind__amount_x0020of_x0020substance = 3,
	resqml2__ResqmlPropertyKind__amplitude = 4,
	resqml2__ResqmlPropertyKind__angle_x0020per_x0020length = 5,
	resqml2__ResqmlPropertyKind__angle_x0020per_x0020time = 6,
	resqml2__ResqmlPropertyKind__angle_x0020per_x0020volume = 7,
	resqml2__ResqmlPropertyKind__angular_x0020acceleration = 8,
	resqml2__ResqmlPropertyKind__area = 9,
	resqml2__ResqmlPropertyKind__area_x0020per_x0020area = 10,
	resqml2__ResqmlPropertyKind__area_x0020per_x0020volume = 11,
	resqml2__ResqmlPropertyKind__attenuation = 12,
	resqml2__ResqmlPropertyKind__attenuation_x0020per_x0020length = 13,
	resqml2__ResqmlPropertyKind__azimuth = 14,
	resqml2__ResqmlPropertyKind__bubble_x0020point_x0020pressure = 15,
	resqml2__ResqmlPropertyKind__bulk_x0020modulus = 16,
	resqml2__ResqmlPropertyKind__capacitance = 17,
	resqml2__ResqmlPropertyKind__categorical = 18,
	resqml2__ResqmlPropertyKind__cell_x0020length = 19,
	resqml2__ResqmlPropertyKind__charge_x0020density = 20,
	resqml2__ResqmlPropertyKind__chemical_x0020potential = 21,
	resqml2__ResqmlPropertyKind__code = 22,
	resqml2__ResqmlPropertyKind__compressibility = 23,
	resqml2__ResqmlPropertyKind__concentration_x0020of_x0020B = 24,
	resqml2__ResqmlPropertyKind__conductivity = 25,
	resqml2__ResqmlPropertyKind__continuous = 26,
	resqml2__ResqmlPropertyKind__cross_x0020section_x0020absorption = 27,
	resqml2__ResqmlPropertyKind__current_x0020density = 28,
	resqml2__ResqmlPropertyKind__Darcy_x0020flow_x0020coefficient = 29,
	resqml2__ResqmlPropertyKind__data_x0020transmission_x0020speed = 30,
	resqml2__ResqmlPropertyKind__delta_x0020temperature = 31,
	resqml2__ResqmlPropertyKind__density = 32,
	resqml2__ResqmlPropertyKind__depth = 33,
	resqml2__ResqmlPropertyKind__diffusion_x0020coefficient = 34,
	resqml2__ResqmlPropertyKind__digital_x0020storage = 35,
	resqml2__ResqmlPropertyKind__dimensionless = 36,
	resqml2__ResqmlPropertyKind__dip = 37,
	resqml2__ResqmlPropertyKind__discrete = 38,
	resqml2__ResqmlPropertyKind__dose_x0020equivalent = 39,
	resqml2__ResqmlPropertyKind__dose_x0020equivalent_x0020rate = 40,
	resqml2__ResqmlPropertyKind__dynamic_x0020viscosity = 41,
	resqml2__ResqmlPropertyKind__electric_x0020charge = 42,
	resqml2__ResqmlPropertyKind__electric_x0020conductance = 43,
	resqml2__ResqmlPropertyKind__electric_x0020current = 44,
	resqml2__ResqmlPropertyKind__electric_x0020dipole_x0020moment = 45,
	resqml2__ResqmlPropertyKind__electric_x0020field_x0020strength = 46,
	resqml2__ResqmlPropertyKind__electric_x0020polarization = 47,
	resqml2__ResqmlPropertyKind__electric_x0020potential = 48,
	resqml2__ResqmlPropertyKind__electrical_x0020resistivity = 49,
	resqml2__ResqmlPropertyKind__electrochemical_x0020equivalent = 50,
	resqml2__ResqmlPropertyKind__electromagnetic_x0020moment = 51,
	resqml2__ResqmlPropertyKind__energy_x0020length_x0020per_x0020area = 52,
	resqml2__ResqmlPropertyKind__energy_x0020length_x0020per_x0020time_x0020area_x0020temperature = 53,
	resqml2__ResqmlPropertyKind__energy_x0020per_x0020area = 54,
	resqml2__ResqmlPropertyKind__energy_x0020per_x0020length = 55,
	resqml2__ResqmlPropertyKind__equivalent_x0020per_x0020mass = 56,
	resqml2__ResqmlPropertyKind__equivalent_x0020per_x0020volume = 57,
	resqml2__ResqmlPropertyKind__exposure_x0020_x0028radioactivity_x0029 = 58,
	resqml2__ResqmlPropertyKind__fluid_x0020volume = 59,
	resqml2__ResqmlPropertyKind__force = 60,
	resqml2__ResqmlPropertyKind__force_x0020area = 61,
	resqml2__ResqmlPropertyKind__force_x0020length_x0020per_x0020length = 62,
	resqml2__ResqmlPropertyKind__force_x0020per_x0020force = 63,
	resqml2__ResqmlPropertyKind__force_x0020per_x0020length = 64,
	resqml2__ResqmlPropertyKind__force_x0020per_x0020volume = 'A',
	resqml2__ResqmlPropertyKind__formation_x0020volume_x0020factor = 'B',
	resqml2__ResqmlPropertyKind__frequency = 'C',
	resqml2__ResqmlPropertyKind__frequency_x0020interval = 'D',
	resqml2__ResqmlPropertyKind__gamma_x0020ray_x0020API_x0020unit = 'E',
	resqml2__ResqmlPropertyKind__heat_x0020capacity = 'F',
	resqml2__ResqmlPropertyKind__heat_x0020flow_x0020rate = 'G',
	resqml2__ResqmlPropertyKind__heat_x0020transfer_x0020coefficient = 'H',
	resqml2__ResqmlPropertyKind__illuminance = 'I',
	resqml2__ResqmlPropertyKind__index = 'J',
	resqml2__ResqmlPropertyKind__irradiance = 'K',
	resqml2__ResqmlPropertyKind__isothermal_x0020compressibility = 'L',
	resqml2__ResqmlPropertyKind__kinematic_x0020viscosity = 'M',
	resqml2__ResqmlPropertyKind__Lambda_x0020Rho = 'N',
	resqml2__ResqmlPropertyKind__Lame_x0020constant = 'O',
	resqml2__ResqmlPropertyKind__length = 'P',
	resqml2__ResqmlPropertyKind__length_x0020per_x0020length = 'Q',
	resqml2__ResqmlPropertyKind__length_x0020per_x0020temperature = 'R',
	resqml2__ResqmlPropertyKind__length_x0020per_x0020volume = 'S',
	resqml2__ResqmlPropertyKind__level_x0020of_x0020power_x0020intensity = 'T',
	resqml2__ResqmlPropertyKind__light_x0020exposure = 'U',
	resqml2__ResqmlPropertyKind__linear_x0020thermal_x0020expansion = 'V',
	resqml2__ResqmlPropertyKind__luminance = 'W',
	resqml2__ResqmlPropertyKind__luminous_x0020efficacy = 'X',
	resqml2__ResqmlPropertyKind__luminous_x0020flux = 'Y',
	resqml2__ResqmlPropertyKind__luminous_x0020intensity = 'Z',
	resqml2__ResqmlPropertyKind__magnetic_x0020dipole_x0020moment = 91,
	resqml2__ResqmlPropertyKind__magnetic_x0020field_x0020strength = 92,
	resqml2__ResqmlPropertyKind__magnetic_x0020flux = 93,
	resqml2__ResqmlPropertyKind__magnetic_x0020induction = 94,
	resqml2__ResqmlPropertyKind__magnetic_x0020permeability = 95,
	resqml2__ResqmlPropertyKind__magnetic_x0020vector_x0020potential = 96,
	resqml2__ResqmlPropertyKind__mass = 'a',
	resqml2__ResqmlPropertyKind__mass_x0020attenuation_x0020coefficient = 'b',
	resqml2__ResqmlPropertyKind__mass_x0020concentration = 'c',
	resqml2__ResqmlPropertyKind__mass_x0020flow_x0020rate = 'd',
	resqml2__ResqmlPropertyKind__mass_x0020length = 'e',
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020energy = 'f',
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020length = 'g',
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020time_x0020per_x0020area = 'h',
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020time_x0020per_x0020length = 'i',
	resqml2__ResqmlPropertyKind__mass_x0020per_x0020volume_x0020per_x0020length = 'j',
	resqml2__ResqmlPropertyKind__mobility = 'k',
	resqml2__ResqmlPropertyKind__modulus_x0020of_x0020compression = 'l',
	resqml2__ResqmlPropertyKind__molar_x0020concentration = 'm',
	resqml2__ResqmlPropertyKind__molar_x0020heat_x0020capacity = 'n',
	resqml2__ResqmlPropertyKind__molar_x0020volume = 'o',
	resqml2__ResqmlPropertyKind__mole_x0020per_x0020area = 'p',
	resqml2__ResqmlPropertyKind__mole_x0020per_x0020time = 'q',
	resqml2__ResqmlPropertyKind__mole_x0020per_x0020time_x0020per_x0020area = 'r',
	resqml2__ResqmlPropertyKind__moment_x0020of_x0020force = 's',
	resqml2__ResqmlPropertyKind__moment_x0020of_x0020inertia = 't',
	resqml2__ResqmlPropertyKind__moment_x0020of_x0020section = 'u',
	resqml2__ResqmlPropertyKind__momentum = 'v',
	resqml2__ResqmlPropertyKind__Mu_x0020Rho = 'w',
	resqml2__ResqmlPropertyKind__net_x0020to_x0020gross_x0020ratio = 'x',
	resqml2__ResqmlPropertyKind__neutron_x0020API_x0020unit = 'y',
	resqml2__ResqmlPropertyKind__nonDarcy_x0020flow_x0020coefficient = 'z',
	resqml2__ResqmlPropertyKind__operations_x0020per_x0020time = 123,
	resqml2__ResqmlPropertyKind__parachor = 124,
	resqml2__ResqmlPropertyKind__per_x0020area = 125,
	resqml2__ResqmlPropertyKind__per_x0020electric_x0020potential = 126,
	resqml2__ResqmlPropertyKind__per_x0020force = 127,
	resqml2__ResqmlPropertyKind__per_x0020length = 128,
	resqml2__ResqmlPropertyKind__per_x0020mass = 129,
	resqml2__ResqmlPropertyKind__per_x0020volume = 130,
	resqml2__ResqmlPropertyKind__permeability_x0020length = 131,
	resqml2__ResqmlPropertyKind__permeability_x0020rock = 132,
	resqml2__ResqmlPropertyKind__permeability_x0020thickness = 133,
	resqml2__ResqmlPropertyKind__permeance = 134,
	resqml2__ResqmlPropertyKind__permittivity = 135,
	resqml2__ResqmlPropertyKind__pH = 136,
	resqml2__ResqmlPropertyKind__plane_x0020angle = 137,
	resqml2__ResqmlPropertyKind__Poisson_x0020ratio = 138,
	resqml2__ResqmlPropertyKind__pore_x0020volume = 139,
	resqml2__ResqmlPropertyKind__porosity = 140,
	resqml2__ResqmlPropertyKind__potential_x0020difference_x0020per_x0020power_x0020drop = 141,
	resqml2__ResqmlPropertyKind__power = 142,
	resqml2__ResqmlPropertyKind__power_x0020per_x0020volume = 143,
	resqml2__ResqmlPropertyKind__pressure = 144,
	resqml2__ResqmlPropertyKind__pressure_x0020per_x0020time = 145,
	resqml2__ResqmlPropertyKind__pressure_x0020squared = 146,
	resqml2__ResqmlPropertyKind__pressure_x0020squared_x0020per_x0020force_x0020time_x0020per_x0020area = 147,
	resqml2__ResqmlPropertyKind__pressure_x0020time_x0020per_x0020volume = 148,
	resqml2__ResqmlPropertyKind__productivity_x0020index = 149,
	resqml2__ResqmlPropertyKind__property_x0020multiplier = 150,
	resqml2__ResqmlPropertyKind__quantity = 151,
	resqml2__ResqmlPropertyKind__quantity_x0020of_x0020light = 152,
	resqml2__ResqmlPropertyKind__radiance = 153,
	resqml2__ResqmlPropertyKind__radiant_x0020intensity = 154,
	resqml2__ResqmlPropertyKind__relative_x0020permeability = 155,
	resqml2__ResqmlPropertyKind__relative_x0020power = 156,
	resqml2__ResqmlPropertyKind__relative_x0020time = 157,
	resqml2__ResqmlPropertyKind__reluctance = 158,
	resqml2__ResqmlPropertyKind__resistance = 159,
	resqml2__ResqmlPropertyKind__resistivity_x0020per_x0020length = 160,
	resqml2__ResqmlPropertyKind__RESQML_x0020root_x0020property = 161,
	resqml2__ResqmlPropertyKind__Rock_x0020Impedance = 162,
	resqml2__ResqmlPropertyKind__rock_x0020permeability = 163,
	resqml2__ResqmlPropertyKind__rock_x0020volume = 164,
	resqml2__ResqmlPropertyKind__saturation = 165,
	resqml2__ResqmlPropertyKind__second_x0020moment_x0020of_x0020area = 166,
	resqml2__ResqmlPropertyKind__shear_x0020modulus = 167,
	resqml2__ResqmlPropertyKind__solid_x0020angle = 168,
	resqml2__ResqmlPropertyKind__solution_x0020gas_oil_x0020ratio = 169,
	resqml2__ResqmlPropertyKind__specific_x0020activity_x0020_x0028of_x0020radioactivity_x0029 = 170,
	resqml2__ResqmlPropertyKind__specific_x0020energy = 171,
	resqml2__ResqmlPropertyKind__specific_x0020heat_x0020capacity = 172,
	resqml2__ResqmlPropertyKind__specific_x0020productivity_x0020index = 173,
	resqml2__ResqmlPropertyKind__specific_x0020volume = 174,
	resqml2__ResqmlPropertyKind__surface_x0020density = 175,
	resqml2__ResqmlPropertyKind__temperature_x0020per_x0020length = 176,
	resqml2__ResqmlPropertyKind__temperature_x0020per_x0020time = 177,
	resqml2__ResqmlPropertyKind__thermal_x0020conductance = 178,
	resqml2__ResqmlPropertyKind__thermal_x0020conductivity = 179,
	resqml2__ResqmlPropertyKind__thermal_x0020diffusivity = 180,
	resqml2__ResqmlPropertyKind__thermal_x0020insulance = 181,
	resqml2__ResqmlPropertyKind__thermal_x0020resistance = 182,
	resqml2__ResqmlPropertyKind__thermodynamic_x0020temperature = 183,
	resqml2__ResqmlPropertyKind__thickness = 184,
	resqml2__ResqmlPropertyKind__time = 185,
	resqml2__ResqmlPropertyKind__time_x0020per_x0020length = 186,
	resqml2__ResqmlPropertyKind__time_x0020per_x0020volume = 187,
	resqml2__ResqmlPropertyKind__transmissibility = 188,
	resqml2__ResqmlPropertyKind__unit_x0020productivity_x0020index = 189,
	resqml2__ResqmlPropertyKind__unitless = 190,
	resqml2__ResqmlPropertyKind__vapor_x0020oil_gas_x0020ratio = 191,
	resqml2__ResqmlPropertyKind__velocity = 192,
	resqml2__ResqmlPropertyKind__volume = 193,
	resqml2__ResqmlPropertyKind__volume_x0020flow_x0020rate = 194,
	resqml2__ResqmlPropertyKind__volume_x0020length_x0020per_x0020time = 195,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020area = 196,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020length = 197,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020time_x0020per_x0020area = 198,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020time_x0020per_x0020length = 199,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020time_x0020per_x0020time = 200,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020time_x0020per_x0020volume = 201,
	resqml2__ResqmlPropertyKind__volume_x0020per_x0020volume = 202,
	resqml2__ResqmlPropertyKind__volumetric_x0020heat_x0020transfer_x0020coefficient = 203,
	resqml2__ResqmlPropertyKind__volumetric_x0020thermal_x0020expansion = 204,
	resqml2__ResqmlPropertyKind__work = 205,
	resqml2__ResqmlPropertyKind__Young_x0020modulus = 206
};
#endif

/* resqml2_0_1ForGsoap.h:5210 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrganizationKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrganizationKind (619)
/* resqml2:OrganizationKind */
enum resqml2__OrganizationKind {
	resqml2__OrganizationKind__earth_x0020model = 0,
	resqml2__OrganizationKind__fluid = 1,
	resqml2__OrganizationKind__stratigraphic = 2,
	resqml2__OrganizationKind__structural = 3
};
#endif

/* resqml2_0_1ForGsoap.h:5251 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AxisOrder2d
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AxisOrder2d (621)
/* eml:AxisOrder2d */
enum eml__AxisOrder2d {
	eml__AxisOrder2d__easting_x0020northing = 0,
	eml__AxisOrder2d__northing_x0020easting = 1,
	eml__AxisOrder2d__westing_x0020southing = 2,
	eml__AxisOrder2d__southing_x0020westing = 3,
	eml__AxisOrder2d__northing_x0020westing = 4,
	eml__AxisOrder2d__westing_x0020northing = 5
};
#endif

/* resqml2_0_1ForGsoap.h:5282 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalDirection
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalDirection (622)
/* eml:VerticalDirection */
enum eml__VerticalDirection {
	eml__VerticalDirection__up = 0,
	eml__VerticalDirection__down = 1
};
#endif

/* resqml2_0_1ForGsoap.h:5297 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioUom (623)
/* eml:LogarithmicPowerRatioUom */
enum eml__LogarithmicPowerRatioUom {
	eml__LogarithmicPowerRatioUom__B = 'B',
	eml__LogarithmicPowerRatioUom__dB = 'C'
};
#endif

/* resqml2_0_1ForGsoap.h:5312 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeUom (624)
/* eml:AmountOfSubstancePerTimeUom */
enum eml__AmountOfSubstancePerTimeUom {
	eml__AmountOfSubstancePerTimeUom__kmol_x002fh = 0,
	eml__AmountOfSubstancePerTimeUom__kmol_x002fs = 1,
	eml__AmountOfSubstancePerTimeUom__lbmol_x002fh = 2,
	eml__AmountOfSubstancePerTimeUom__lbmol_x002fs = 3,
	eml__AmountOfSubstancePerTimeUom__mol_x002fs = 4
};
#endif

/* resqml2_0_1ForGsoap.h:5339 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityUom (625)
/* eml:ElectricConductivityUom */
enum eml__ElectricConductivityUom {
	eml__ElectricConductivityUom__kS_x002fm = 0,
	eml__ElectricConductivityUom__mS_x002fcm = 1,
	eml__ElectricConductivityUom__mS_x002fm = 2,
	eml__ElectricConductivityUom__S_x002fm = 3
};
#endif

/* resqml2_0_1ForGsoap.h:5362 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationUom (626)
/* eml:VolumePerRotationUom */
enum eml__VolumePerRotationUom {
	eml__VolumePerRotationUom__ft3_x002frad = 0,
	eml__VolumePerRotationUom__m3_x002frad = 1,
	eml__VolumePerRotationUom__m3_x002frev = 2
};
#endif

/* resqml2_0_1ForGsoap.h:5381 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaUom (627)
/* eml:VolumePerTimePerAreaUom */
enum eml__VolumePerTimePerAreaUom {
	eml__VolumePerTimePerAreaUom__ft3_x002f_x0028min_x002eft2_x0029 = 0,
	eml__VolumePerTimePerAreaUom__ft3_x002f_x0028s_x002eft2_x0029 = 1,
	eml__VolumePerTimePerAreaUom__gal_x005bUK_x005d_x002f_x0028h_x002eft2_x0029 = 2,
	eml__VolumePerTimePerAreaUom__gal_x005bUK_x005d_x002f_x0028h_x002ein2_x0029 = 3,
	eml__VolumePerTimePerAreaUom__gal_x005bUK_x005d_x002f_x0028min_x002eft2_x0029 = 4,
	eml__VolumePerTimePerAreaUom__gal_x005bUS_x005d_x002f_x0028h_x002eft2_x0029 = 5,
	eml__VolumePerTimePerAreaUom__gal_x005bUS_x005d_x002f_x0028h_x002ein2_x0029 = 6,
	eml__VolumePerTimePerAreaUom__gal_x005bUS_x005d_x002f_x0028min_x002eft2_x0029 = 7,
	eml__VolumePerTimePerAreaUom__m3_x002f_x0028s_x002em2_x0029 = 8
};
#endif

/* resqml2_0_1ForGsoap.h:5424 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityUom (628)
/* eml:MobilityUom */
enum eml__MobilityUom {
	eml__MobilityUom__D_x002f_x0028Pa_x002es_x0029 = 0,
	eml__MobilityUom__D_x002fcP = 1,
	eml__MobilityUom__mD_x002eft2_x002f_x0028lbf_x002es_x0029 = 2,
	eml__MobilityUom__mD_x002ein2_x002f_x0028lbf_x002es_x0029 = 3,
	eml__MobilityUom__mD_x002f_x0028Pa_x002es_x0029 = 4,
	eml__MobilityUom__mD_x002fcP = 5,
	eml__MobilityUom__TD_x005bAPI_x005d_x002f_x0028Pa_x002es_x0029 = 6
};
#endif

/* resqml2_0_1ForGsoap.h:5459 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientUom (629)
/* eml:HeatTransferCoefficientUom */
enum eml__HeatTransferCoefficientUom {
	eml__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	eml__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x002edeltaR_x0029 = 1,
	eml__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 2,
	eml__HeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x002edeltaF_x0029 = 3,
	eml__HeatTransferCoefficientUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x002edeltaC_x0029 = 4,
	eml__HeatTransferCoefficientUom__cal_x005bth_x005d_x002f_x0028s_x002ecm2_x002edeltaC_x0029 = 5,
	eml__HeatTransferCoefficientUom__J_x002f_x0028s_x002em2_x002edeltaC_x0029 = 6,
	eml__HeatTransferCoefficientUom__kcal_x005bth_x005d_x002f_x0028h_x002em2_x002edeltaC_x0029 = 7,
	eml__HeatTransferCoefficientUom__kJ_x002f_x0028h_x002em2_x002edeltaK_x0029 = 8,
	eml__HeatTransferCoefficientUom__kW_x002f_x0028m2_x002edeltaK_x0029 = 9,
	eml__HeatTransferCoefficientUom__W_x002f_x0028m2_x002edeltaK_x0029 = 10
};
#endif

/* resqml2_0_1ForGsoap.h:5510 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyUom (630)
/* eml:MassPerEnergyUom */
enum eml__MassPerEnergyUom {
	eml__MassPerEnergyUom__kg_x002f_x0028kW_x002eh_x0029 = 0,
	eml__MassPerEnergyUom__kg_x002fJ = 1,
	eml__MassPerEnergyUom__kg_x002fMJ = 2,
	eml__MassPerEnergyUom__lbm_x002f_x0028hp_x002eh_x0029 = 3,
	eml__MassPerEnergyUom__mg_x002fJ = 4
};
#endif

/* resqml2_0_1ForGsoap.h:5537 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaUom (631)
/* eml:MomentOfInertiaUom */
enum eml__MomentOfInertiaUom {
	eml__MomentOfInertiaUom__kg_x002em2 = 0,
	eml__MomentOfInertiaUom__lbm_x002eft2 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:5552 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceUom (632)
/* eml:CapacitanceUom */
enum eml__CapacitanceUom {
	eml__CapacitanceUom__F = 'F',
	eml__CapacitanceUom__cF = 'G',
	eml__CapacitanceUom__dF = 'H',
	eml__CapacitanceUom__EF = 'I',
	eml__CapacitanceUom__fF = 'J',
	eml__CapacitanceUom__GF = 'K',
	eml__CapacitanceUom__kF = 'L',
	eml__CapacitanceUom__mF = 'M',
	eml__CapacitanceUom__MF = 'N',
	eml__CapacitanceUom__nF = 'O',
	eml__CapacitanceUom__pF = 'P',
	eml__CapacitanceUom__TF = 'Q',
	eml__CapacitanceUom__uF = 'R'
};
#endif

/* resqml2_0_1ForGsoap.h:5611 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthUom (633)
/* eml:MagneticFluxDensityPerLengthUom */
enum eml__MagneticFluxDensityPerLengthUom {
	eml__MagneticFluxDensityPerLengthUom__gauss_x002fcm = 0,
	eml__MagneticFluxDensityPerLengthUom__mT_x002fdm = 1,
	eml__MagneticFluxDensityPerLengthUom__T_x002fm = 2
};
#endif

/* resqml2_0_1ForGsoap.h:5630 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeUom (634)
/* eml:LengthPerVolumeUom */
enum eml__LengthPerVolumeUom {
	eml__LengthPerVolumeUom__ft_x002fbbl = 0,
	eml__LengthPerVolumeUom__ft_x002fft3 = 1,
	eml__LengthPerVolumeUom__ft_x002fgal_x005bUS_x005d = 2,
	eml__LengthPerVolumeUom__km_x002fdm3 = 3,
	eml__LengthPerVolumeUom__km_x002fL = 4,
	eml__LengthPerVolumeUom__m_x002fm3 = 5,
	eml__LengthPerVolumeUom__mi_x002fgal_x005bUK_x005d = 6,
	eml__LengthPerVolumeUom__mi_x002fgal_x005bUS_x005d = 7
};
#endif

/* resqml2_0_1ForGsoap.h:5669 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeUom (635)
/* eml:MassPerTimeUom */
enum eml__MassPerTimeUom {
	eml__MassPerTimeUom__1E6_x0020lbm_x002fa = 0,
	eml__MassPerTimeUom__g_x002fs = 1,
	eml__MassPerTimeUom__kg_x002fd = 2,
	eml__MassPerTimeUom__kg_x002fh = 3,
	eml__MassPerTimeUom__kg_x002fmin = 4,
	eml__MassPerTimeUom__kg_x002fs = 5,
	eml__MassPerTimeUom__lbm_x002fd = 6,
	eml__MassPerTimeUom__lbm_x002fh = 7,
	eml__MassPerTimeUom__lbm_x002fmin = 8,
	eml__MassPerTimeUom__lbm_x002fs = 9,
	eml__MassPerTimeUom__Mg_x002fa = 10,
	eml__MassPerTimeUom__Mg_x002fd = 11,
	eml__MassPerTimeUom__Mg_x002fh = 12,
	eml__MassPerTimeUom__Mg_x002fmin = 13,
	eml__MassPerTimeUom__t_x002fa = 14,
	eml__MassPerTimeUom__t_x002fd = 15,
	eml__MassPerTimeUom__t_x002fh = 16,
	eml__MassPerTimeUom__t_x002fmin = 17,
	eml__MassPerTimeUom__ton_x005bUK_x005d_x002fa = 18,
	eml__MassPerTimeUom__ton_x005bUK_x005d_x002fd = 19,
	eml__MassPerTimeUom__ton_x005bUK_x005d_x002fh = 20,
	eml__MassPerTimeUom__ton_x005bUK_x005d_x002fmin = 21,
	eml__MassPerTimeUom__ton_x005bUS_x005d_x002fa = 22,
	eml__MassPerTimeUom__ton_x005bUS_x005d_x002fd = 23,
	eml__MassPerTimeUom__ton_x005bUS_x005d_x002fh = 24,
	eml__MassPerTimeUom__ton_x005bUS_x005d_x002fmin = 25
};
#endif

/* resqml2_0_1ForGsoap.h:5780 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightUom (636)
/* eml:MolecularWeightUom */
enum eml__MolecularWeightUom {
	eml__MolecularWeightUom__g_x002fmol = 0,
	eml__MolecularWeightUom__kg_x002fmol = 1,
	eml__MolecularWeightUom__lbm_x002flbmol = 2
};
#endif

/* resqml2_0_1ForGsoap.h:5799 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxUom (637)
/* eml:MagneticFluxUom */
enum eml__MagneticFluxUom {
	eml__MagneticFluxUom__cWb = 0,
	eml__MagneticFluxUom__dWb = 1,
	eml__MagneticFluxUom__EWb = 2,
	eml__MagneticFluxUom__fWb = 3,
	eml__MagneticFluxUom__GWb = 4,
	eml__MagneticFluxUom__kWb = 5,
	eml__MagneticFluxUom__MWb = 6,
	eml__MagneticFluxUom__mWb = 7,
	eml__MagneticFluxUom__nWb = 8,
	eml__MagneticFluxUom__pWb = 9,
	eml__MagneticFluxUom__TWb = 10,
	eml__MagneticFluxUom__uWb = 11,
	eml__MagneticFluxUom__Wb = 12
};
#endif

/* resqml2_0_1ForGsoap.h:5858 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeUom (638)
/* eml:VolumeUom */
enum eml__VolumeUom {
	eml__VolumeUom__L = 'L',
	eml__VolumeUom__1000_x0020bbl = 'M',
	eml__VolumeUom__1000_x0020ft3 = 'N',
	eml__VolumeUom__1000_x0020gal_x005bUK_x005d = 'O',
	eml__VolumeUom__1000_x0020gal_x005bUS_x005d = 'P',
	eml__VolumeUom__1000_x0020m3 = 'Q',
	eml__VolumeUom__1E_6_x0020gal_x005bUS_x005d = 'R',
	eml__VolumeUom__1E12_x0020ft3 = 'S',
	eml__VolumeUom__1E6_x0020bbl = 'T',
	eml__VolumeUom__1E6_x0020ft3 = 'U',
	eml__VolumeUom__1E6_x0020m3 = 'V',
	eml__VolumeUom__1E9_x0020bbl = 'W',
	eml__VolumeUom__1E9_x0020ft3 = 'X',
	eml__VolumeUom__acre_x002eft = 'Y',
	eml__VolumeUom__bbl = 'Z',
	eml__VolumeUom__cm3 = 91,
	eml__VolumeUom__dm3 = 92,
	eml__VolumeUom__floz_x005bUK_x005d = 93,
	eml__VolumeUom__floz_x005bUS_x005d = 94,
	eml__VolumeUom__ft3 = 95,
	eml__VolumeUom__gal_x005bUK_x005d = 96,
	eml__VolumeUom__gal_x005bUS_x005d = 'a',
	eml__VolumeUom__ha_x002em = 'b',
	eml__VolumeUom__hL = 'c',
	eml__VolumeUom__in3 = 'd',
	eml__VolumeUom__km3 = 'e',
	eml__VolumeUom__m3 = 'f',
	eml__VolumeUom__mi3 = 'g',
	eml__VolumeUom__mL = 'h',
	eml__VolumeUom__mm3 = 'i',
	eml__VolumeUom__pt_x005bUK_x005d = 'j',
	eml__VolumeUom__pt_x005bUS_x005d = 'k',
	eml__VolumeUom__qt_x005bUK_x005d = 'l',
	eml__VolumeUom__qt_x005bUS_x005d = 'm',
	eml__VolumeUom__um2_x002em = 'n',
	eml__VolumeUom__yd3 = 'o'
};
#endif

/* resqml2_0_1ForGsoap.h:6009 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceUom (639)
/* eml:ThermalConductanceUom */
enum eml__ThermalConductanceUom {
	eml__ThermalConductanceUom__W_x002fdeltaK = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6020 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightUom (640)
/* eml:QuantityOfLightUom */
enum eml__QuantityOfLightUom {
	eml__QuantityOfLightUom__lm_x002es = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6031 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeUom (641)
/* eml:LengthPerTimeUom */
enum eml__LengthPerTimeUom {
	eml__LengthPerTimeUom__1000_x0020ft_x002fh = 0,
	eml__LengthPerTimeUom__1000_x0020ft_x002fs = 1,
	eml__LengthPerTimeUom__cm_x002fa = 2,
	eml__LengthPerTimeUom__cm_x002fs = 3,
	eml__LengthPerTimeUom__dm_x002fs = 4,
	eml__LengthPerTimeUom__ft_x002fd = 5,
	eml__LengthPerTimeUom__ft_x002fh = 6,
	eml__LengthPerTimeUom__ft_x002fmin = 7,
	eml__LengthPerTimeUom__ft_x002fms = 8,
	eml__LengthPerTimeUom__ft_x002fs = 9,
	eml__LengthPerTimeUom__ft_x002fus = 10,
	eml__LengthPerTimeUom__in_x002fa = 11,
	eml__LengthPerTimeUom__in_x002fmin = 12,
	eml__LengthPerTimeUom__in_x002fs = 13,
	eml__LengthPerTimeUom__km_x002fh = 14,
	eml__LengthPerTimeUom__km_x002fs = 15,
	eml__LengthPerTimeUom__knot = 16,
	eml__LengthPerTimeUom__m_x002fd = 17,
	eml__LengthPerTimeUom__m_x002fh = 18,
	eml__LengthPerTimeUom__m_x002fmin = 19,
	eml__LengthPerTimeUom__m_x002fms = 20,
	eml__LengthPerTimeUom__m_x002fs = 21,
	eml__LengthPerTimeUom__mi_x002fh = 22,
	eml__LengthPerTimeUom__mil_x002fa = 23,
	eml__LengthPerTimeUom__mm_x002fa = 24,
	eml__LengthPerTimeUom__mm_x002fs = 25,
	eml__LengthPerTimeUom__nm_x002fs = 26,
	eml__LengthPerTimeUom__um_x002fs = 27
};
#endif

/* resqml2_0_1ForGsoap.h:6150 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthUom (642)
/* eml:ForceLengthPerLengthUom */
enum eml__ForceLengthPerLengthUom {
	eml__ForceLengthPerLengthUom__kgf_x002em_x002fm = 0,
	eml__ForceLengthPerLengthUom__lbf_x002eft_x002fin = 1,
	eml__ForceLengthPerLengthUom__lbf_x002ein_x002fin = 2,
	eml__ForceLengthPerLengthUom__N_x002em_x002fm = 3,
	eml__ForceLengthPerLengthUom__tonf_x005bUS_x005d_x002emi_x002fft = 4
};
#endif

/* resqml2_0_1ForGsoap.h:6177 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleUom (643)
/* eml:SolidAngleUom */
enum eml__SolidAngleUom {
	eml__SolidAngleUom__sr = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6188 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeUom (644)
/* eml:VolumePerTimePerVolumeUom */
enum eml__VolumePerTimePerVolumeUom {
	eml__VolumePerTimePerVolumeUom__bbl_x002f_x0028d_x002eacre_x002eft_x0029 = 0,
	eml__VolumePerTimePerVolumeUom__m3_x002f_x0028s_x002em3_x0029 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:6203 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceUom (645)
/* eml:MomentOfForceUom */
enum eml__MomentOfForceUom {
	eml__MomentOfForceUom__J = 'J',
	eml__MomentOfForceUom__1000_x0020lbf_x002eft = 'K',
	eml__MomentOfForceUom__daN_x002em = 'L',
	eml__MomentOfForceUom__dN_x002em = 'M',
	eml__MomentOfForceUom__kgf_x002em = 'N',
	eml__MomentOfForceUom__kN_x002em = 'O',
	eml__MomentOfForceUom__lbf_x002eft = 'P',
	eml__MomentOfForceUom__lbf_x002ein = 'Q',
	eml__MomentOfForceUom__lbm_x002eft2_x002fs2 = 'R',
	eml__MomentOfForceUom__N_x002em = 'S',
	eml__MomentOfForceUom__pdl_x002eft = 'T',
	eml__MomentOfForceUom__tonf_x005bUS_x005d_x002eft = 'U',
	eml__MomentOfForceUom__tonf_x005bUS_x005d_x002emi = 'V'
};
#endif

/* resqml2_0_1ForGsoap.h:6262 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeUom (646)
/* eml:MassPerVolumeUom */
enum eml__MassPerVolumeUom {
	eml__MassPerVolumeUom__0_x002e001_x0020lbm_x002fbbl = 0,
	eml__MassPerVolumeUom__0_x002e001_x0020lbm_x002fgal_x005bUK_x005d = 1,
	eml__MassPerVolumeUom__0_x002e001_x0020lbm_x002fgal_x005bUS_x005d = 2,
	eml__MassPerVolumeUom__0_x002e01_x0020grain_x002fft3 = 3,
	eml__MassPerVolumeUom__0_x002e1_x0020lbm_x002fbbl = 4,
	eml__MassPerVolumeUom__10_x0020Mg_x002fm3 = 5,
	eml__MassPerVolumeUom__g_x002fcm3 = 6,
	eml__MassPerVolumeUom__g_x002fdm3 = 7,
	eml__MassPerVolumeUom__g_x002fgal_x005bUK_x005d = 8,
	eml__MassPerVolumeUom__g_x002fgal_x005bUS_x005d = 9,
	eml__MassPerVolumeUom__g_x002fL = 10,
	eml__MassPerVolumeUom__g_x002fm3 = 11,
	eml__MassPerVolumeUom__grain_x002fft3 = 12,
	eml__MassPerVolumeUom__grain_x002fgal_x005bUS_x005d = 13,
	eml__MassPerVolumeUom__kg_x002fdm3 = 14,
	eml__MassPerVolumeUom__kg_x002fL = 15,
	eml__MassPerVolumeUom__kg_x002fm3 = 16,
	eml__MassPerVolumeUom__lbm_x002fbbl = 17,
	eml__MassPerVolumeUom__lbm_x002fft3 = 18,
	eml__MassPerVolumeUom__lbm_x002fgal_x005bUK_x005d = 19,
	eml__MassPerVolumeUom__lbm_x002fgal_x005bUS_x005d = 20,
	eml__MassPerVolumeUom__lbm_x002fin3 = 21,
	eml__MassPerVolumeUom__mg_x002fdm3 = 22,
	eml__MassPerVolumeUom__mg_x002fgal_x005bUS_x005d = 23,
	eml__MassPerVolumeUom__mg_x002fL = 24,
	eml__MassPerVolumeUom__mg_x002fm3 = 25,
	eml__MassPerVolumeUom__Mg_x002fm3 = 26,
	eml__MassPerVolumeUom__t_x002fm3 = 27,
	eml__MassPerVolumeUom__ug_x002fcm3 = 28
};
#endif

/* resqml2_0_1ForGsoap.h:6385 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeUom (647)
/* eml:MolarVolumeUom */
enum eml__MolarVolumeUom {
	eml__MolarVolumeUom__dm3_x002fkmol = 0,
	eml__MolarVolumeUom__ft3_x002flbmol = 1,
	eml__MolarVolumeUom__L_x002fkmol = 2,
	eml__MolarVolumeUom__L_x002fmol = 3,
	eml__MolarVolumeUom__m3_x002fkmol = 4,
	eml__MolarVolumeUom__m3_x002fmol = 5
};
#endif

/* resqml2_0_1ForGsoap.h:6416 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceUom (648)
/* eml:AmountOfSubstanceUom */
enum eml__AmountOfSubstanceUom {
	eml__AmountOfSubstanceUom__kmol = 0,
	eml__AmountOfSubstanceUom__lbmol = 1,
	eml__AmountOfSubstanceUom__mmol = 2,
	eml__AmountOfSubstanceUom__mol = 3,
	eml__AmountOfSubstanceUom__umol = 4
};
#endif

/* resqml2_0_1ForGsoap.h:6443 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentUom (649)
/* eml:DipoleMomentUom */
enum eml__DipoleMomentUom {
	eml__DipoleMomentUom__C_x002em = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6454 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronUom (650)
/* eml:APINeutronUom */
enum eml__APINeutronUom {
	eml__APINeutronUom__nAPI = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6465 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeUom (651)
/* eml:ReciprocalTimeUom */
enum eml__ReciprocalTimeUom {
	eml__ReciprocalTimeUom__1_x002fa = 0,
	eml__ReciprocalTimeUom__1_x002fd = 1,
	eml__ReciprocalTimeUom__1_x002fh = 2,
	eml__ReciprocalTimeUom__1_x002fmin = 3,
	eml__ReciprocalTimeUom__1_x002fms = 4,
	eml__ReciprocalTimeUom__1_x002fs = 5,
	eml__ReciprocalTimeUom__1_x002fus = 6,
	eml__ReciprocalTimeUom__1_x002fwk = 7
};
#endif

/* resqml2_0_1ForGsoap.h:6504 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureUom (652)
/* eml:TemperatureIntervalPerPressureUom */
enum eml__TemperatureIntervalPerPressureUom {
	eml__TemperatureIntervalPerPressureUom__deltaC_x002fkPa = 0,
	eml__TemperatureIntervalPerPressureUom__deltaF_x002fpsi = 1,
	eml__TemperatureIntervalPerPressureUom__deltaK_x002fPa = 2
};
#endif

/* resqml2_0_1ForGsoap.h:6523 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthUom (653)
/* eml:LengthPerLengthUom */
enum eml__LengthPerLengthUom {
	eml__LengthPerLengthUom___x0025 = 0,
	eml__LengthPerLengthUom__0_x002e01_x0020ft_x002fft = 1,
	eml__LengthPerLengthUom__1_x002f30_x0020m_x002fm = 2,
	eml__LengthPerLengthUom__Euc = 3,
	eml__LengthPerLengthUom__ft_x002fft = 4,
	eml__LengthPerLengthUom__ft_x002fin = 5,
	eml__LengthPerLengthUom__ft_x002fm = 6,
	eml__LengthPerLengthUom__ft_x002fmi = 7,
	eml__LengthPerLengthUom__km_x002fcm = 8,
	eml__LengthPerLengthUom__m_x002fcm = 9,
	eml__LengthPerLengthUom__m_x002fkm = 10,
	eml__LengthPerLengthUom__m_x002fm = 11,
	eml__LengthPerLengthUom__mi_x002fin = 12
};
#endif

/* resqml2_0_1ForGsoap.h:6582 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaUom (654)
/* eml:AreaUom */
enum eml__AreaUom {
	eml__AreaUom__b = 'b',
	eml__AreaUom__acre = 'c',
	eml__AreaUom__cm2 = 'd',
	eml__AreaUom__ft2 = 'e',
	eml__AreaUom__ha = 'f',
	eml__AreaUom__in2 = 'g',
	eml__AreaUom__km2 = 'h',
	eml__AreaUom__m2 = 'i',
	eml__AreaUom__mi_x005bUS_x005d2 = 'j',
	eml__AreaUom__mi2 = 'k',
	eml__AreaUom__mm2 = 'l',
	eml__AreaUom__section = 'm',
	eml__AreaUom__um2 = 'n',
	eml__AreaUom__yd2 = 'o'
};
#endif

/* resqml2_0_1ForGsoap.h:6645 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayUom (655)
/* eml:APIGammaRayUom */
enum eml__APIGammaRayUom {
	eml__APIGammaRayUom__gAPI = 0
};
#endif

/* resqml2_0_1ForGsoap.h:6656 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionUom (656)
/* eml:VolumetricThermalExpansionUom */
enum eml__VolumetricThermalExpansionUom {
	eml__VolumetricThermalExpansionUom__1_x002fdeltaC = 0,
	eml__VolumetricThermalExpansionUom__1_x002fdeltaF = 1,
	eml__VolumetricThermalExpansionUom__1_x002fdeltaK = 2,
	eml__VolumetricThermalExpansionUom__1_x002fdeltaR = 3,
	eml__VolumetricThermalExpansionUom__1E_6_x0020m3_x002f_x0028m3_x002edeltaC_x0029 = 4,
	eml__VolumetricThermalExpansionUom__1E_6_x0020m3_x002f_x0028m3_x002edeltaF_x0029 = 5,
	eml__VolumetricThermalExpansionUom__m3_x002f_x0028m3_x002edeltaK_x0029 = 6,
	eml__VolumetricThermalExpansionUom__ppm_x005bvol_x005d_x002fdeltaC = 7,
	eml__VolumetricThermalExpansionUom__ppm_x005bvol_x005d_x002fdeltaF = 8
};
#endif

/* resqml2_0_1ForGsoap.h:6699 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityUom (657)
/* eml:ElectricCurrentDensityUom */
enum eml__ElectricCurrentDensityUom {
	eml__ElectricCurrentDensityUom__A_x002fcm2 = 0,
	eml__ElectricCurrentDensityUom__A_x002fft2 = 1,
	eml__ElectricCurrentDensityUom__A_x002fm2 = 2,
	eml__ElectricCurrentDensityUom__A_x002fmm2 = 3,
	eml__ElectricCurrentDensityUom__mA_x002fcm2 = 4,
	eml__ElectricCurrentDensityUom__mA_x002fft2 = 5,
	eml__ElectricCurrentDensityUom__uA_x002fcm2 = 6,
	eml__ElectricCurrentDensityUom__uA_x002fin2 = 7
};
#endif

/* resqml2_0_1ForGsoap.h:6738 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceUom (658)
/* eml:ForceUom */
enum eml__ForceUom {
	eml__ForceUom__N = 'N',
	eml__ForceUom__10_x0020kN = 'O',
	eml__ForceUom__cN = 'P',
	eml__ForceUom__daN = 'Q',
	eml__ForceUom__dN = 'R',
	eml__ForceUom__dyne = 'S',
	eml__ForceUom__EN = 'T',
	eml__ForceUom__fN = 'U',
	eml__ForceUom__gf = 'V',
	eml__ForceUom__GN = 'W',
	eml__ForceUom__hN = 'X',
	eml__ForceUom__kdyne = 'Y',
	eml__ForceUom__kgf = 'Z',
	eml__ForceUom__klbf = 91,
	eml__ForceUom__kN = 92,
	eml__ForceUom__lbf = 93,
	eml__ForceUom__Mgf = 94,
	eml__ForceUom__mN = 95,
	eml__ForceUom__MN = 96,
	eml__ForceUom__nN = 'a',
	eml__ForceUom__ozf = 'b',
	eml__ForceUom__pdl = 'c',
	eml__ForceUom__pN = 'd',
	eml__ForceUom__TN = 'e',
	eml__ForceUom__tonf_x005bUK_x005d = 'f',
	eml__ForceUom__tonf_x005bUS_x005d = 'g',
	eml__ForceUom__uN = 'h'
};
#endif

/* resqml2_0_1ForGsoap.h:6853 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaUom (659)
/* eml:VolumePerAreaUom */
enum eml__VolumePerAreaUom {
	eml__VolumePerAreaUom__1E6_x0020bbl_x002facre = 0,
	eml__VolumePerAreaUom__bbl_x002facre = 1,
	eml__VolumePerAreaUom__ft3_x002fft2 = 2,
	eml__VolumePerAreaUom__m3_x002fm2 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:6876 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceUom (660)
/* eml:ReciprocalElectricPotentialDifferenceUom */
enum eml__ReciprocalElectricPotentialDifferenceUom {
	eml__ReciprocalElectricPotentialDifferenceUom__1_x002fuV = 0,
	eml__ReciprocalElectricPotentialDifferenceUom__1_x002fV = 1
};
#endif

/* resqml2_0_1ForGsoap.h:6891 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthUom (661)
/* eml:TimePerLengthUom */
enum eml__TimePerLengthUom {
	eml__TimePerLengthUom__0_x002e001_x0020h_x002fft = 0,
	eml__TimePerLengthUom__h_x002fkm = 1,
	eml__TimePerLengthUom__min_x002fft = 2,
	eml__TimePerLengthUom__min_x002fm = 3,
	eml__TimePerLengthUom__ms_x002fcm = 4,
	eml__TimePerLengthUom__ms_x002fft = 5,
	eml__TimePerLengthUom__ms_x002fin = 6,
	eml__TimePerLengthUom__ms_x002fm = 7,
	eml__TimePerLengthUom__ns_x002fft = 8,
	eml__TimePerLengthUom__ns_x002fm = 9,
	eml__TimePerLengthUom__s_x002fcm = 10,
	eml__TimePerLengthUom__s_x002fft = 11,
	eml__TimePerLengthUom__s_x002fin = 12,
	eml__TimePerLengthUom__s_x002fm = 13,
	eml__TimePerLengthUom__us_x002fft = 14,
	eml__TimePerLengthUom__us_x002fin = 15,
	eml__TimePerLengthUom__us_x002fm = 16
};
#endif

/* resqml2_0_1ForGsoap.h:6966 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureUom (662)
/* eml:VolumePerPressureUom */
enum eml__VolumePerPressureUom {
	eml__VolumePerPressureUom__bbl_x002fpsi = 0,
	eml__VolumePerPressureUom__m3_x002fkPa = 1,
	eml__VolumePerPressureUom__m3_x002fPa = 2
};
#endif

/* resqml2_0_1ForGsoap.h:6985 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaUom (663)
/* eml:ElectricChargePerAreaUom */
enum eml__ElectricChargePerAreaUom {
	eml__ElectricChargePerAreaUom__C_x002fcm2 = 0,
	eml__ElectricChargePerAreaUom__C_x002fm2 = 1,
	eml__ElectricChargePerAreaUom__C_x002fmm2 = 2,
	eml__ElectricChargePerAreaUom__mC_x002fm2 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7008 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthUom (664)
/* eml:MassPerTimePerLengthUom */
enum eml__MassPerTimePerLengthUom {
	eml__MassPerTimePerLengthUom__kg_x002f_x0028m_x002es_x0029 = 0,
	eml__MassPerTimePerLengthUom__lbm_x002f_x0028ft_x002eh_x0029 = 1,
	eml__MassPerTimePerLengthUom__lbm_x002f_x0028ft_x002es_x0029 = 2,
	eml__MassPerTimePerLengthUom__Pa_x002es = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7031 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityUom (665)
/* eml:MagneticFluxDensityUom */
enum eml__MagneticFluxDensityUom {
	eml__MagneticFluxDensityUom__T = 'T',
	eml__MagneticFluxDensityUom__cgauss = 'U',
	eml__MagneticFluxDensityUom__cT = 'V',
	eml__MagneticFluxDensityUom__dgauss = 'W',
	eml__MagneticFluxDensityUom__dT = 'X',
	eml__MagneticFluxDensityUom__Egauss = 'Y',
	eml__MagneticFluxDensityUom__ET = 'Z',
	eml__MagneticFluxDensityUom__fgauss = 91,
	eml__MagneticFluxDensityUom__fT = 92,
	eml__MagneticFluxDensityUom__gauss = 93,
	eml__MagneticFluxDensityUom__Ggauss = 94,
	eml__MagneticFluxDensityUom__GT = 95,
	eml__MagneticFluxDensityUom__kgauss = 96,
	eml__MagneticFluxDensityUom__kT = 'a',
	eml__MagneticFluxDensityUom__mgauss = 'b',
	eml__MagneticFluxDensityUom__Mgauss = 'c',
	eml__MagneticFluxDensityUom__mT = 'd',
	eml__MagneticFluxDensityUom__ngauss = 'e',
	eml__MagneticFluxDensityUom__nT = 'f',
	eml__MagneticFluxDensityUom__pgauss = 'g',
	eml__MagneticFluxDensityUom__pT = 'h',
	eml__MagneticFluxDensityUom__Tgauss = 'i',
	eml__MagneticFluxDensityUom__TT = 'j',
	eml__MagneticFluxDensityUom__ugauss = 'k',
	eml__MagneticFluxDensityUom__uT = 'l'
};
#endif

/* resqml2_0_1ForGsoap.h:7138 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleUom (666)
/* eml:PlaneAngleUom */
enum eml__PlaneAngleUom {
	eml__PlaneAngleUom__0_x002e001_x0020seca = 0,
	eml__PlaneAngleUom__ccgr = 1,
	eml__PlaneAngleUom__cgr = 2,
	eml__PlaneAngleUom__dega = 3,
	eml__PlaneAngleUom__gon = 4,
	eml__PlaneAngleUom__krad = 5,
	eml__PlaneAngleUom__mila = 6,
	eml__PlaneAngleUom__mina = 7,
	eml__PlaneAngleUom__Mrad = 8,
	eml__PlaneAngleUom__mrad = 9,
	eml__PlaneAngleUom__rad = 10,
	eml__PlaneAngleUom__rev = 11,
	eml__PlaneAngleUom__seca = 12,
	eml__PlaneAngleUom__urad = 13
};
#endif

/* resqml2_0_1ForGsoap.h:7201 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeUom (667)
/* eml:SignalingEventPerTimeUom */
enum eml__SignalingEventPerTimeUom {
	eml__SignalingEventPerTimeUom__Bd = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7212 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthUom (668)
/* eml:EnergyPerLengthUom */
enum eml__EnergyPerLengthUom {
	eml__EnergyPerLengthUom__J_x002fm = 0,
	eml__EnergyPerLengthUom__MJ_x002fm = 1
};
#endif

/* resqml2_0_1ForGsoap.h:7227 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentUom (669)
/* eml:ElectricCurrentUom */
enum eml__ElectricCurrentUom {
	eml__ElectricCurrentUom__A = 'A',
	eml__ElectricCurrentUom__cA = 'B',
	eml__ElectricCurrentUom__dA = 'C',
	eml__ElectricCurrentUom__EA = 'D',
	eml__ElectricCurrentUom__fA = 'E',
	eml__ElectricCurrentUom__GA = 'F',
	eml__ElectricCurrentUom__kA = 'G',
	eml__ElectricCurrentUom__mA = 'H',
	eml__ElectricCurrentUom__MA = 'I',
	eml__ElectricCurrentUom__nA = 'J',
	eml__ElectricCurrentUom__pA = 'K',
	eml__ElectricCurrentUom__TA = 'L',
	eml__ElectricCurrentUom__uA = 'M'
};
#endif

/* resqml2_0_1ForGsoap.h:7286 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredUom (670)
/* eml:PressureSquaredUom */
enum eml__PressureSquaredUom {
	eml__PressureSquaredUom__bar2 = 0,
	eml__PressureSquaredUom__GPa2 = 1,
	eml__PressureSquaredUom__kPa2 = 2,
	eml__PressureSquaredUom__kpsi2 = 3,
	eml__PressureSquaredUom__Pa2 = 4,
	eml__PressureSquaredUom__psi2 = 5
};
#endif

/* resqml2_0_1ForGsoap.h:7317 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationUom (671)
/* eml:AngularAccelerationUom */
enum eml__AngularAccelerationUom {
	eml__AngularAccelerationUom__rad_x002fs2 = 0,
	eml__AngularAccelerationUom__rpm_x002fs = 1
};
#endif

/* resqml2_0_1ForGsoap.h:7332 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeUom (672)
/* eml:ReciprocalMassTimeUom */
enum eml__ReciprocalMassTimeUom {
	eml__ReciprocalMassTimeUom__1_x002f_x0028kg_x002es_x0029 = 0,
	eml__ReciprocalMassTimeUom__Bq_x002fkg = 1,
	eml__ReciprocalMassTimeUom__pCi_x002fg = 2
};
#endif

/* resqml2_0_1ForGsoap.h:7351 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityUom (673)
/* eml:ThermalDiffusivityUom */
enum eml__ThermalDiffusivityUom {
	eml__ThermalDiffusivityUom__cm2_x002fs = 0,
	eml__ThermalDiffusivityUom__ft2_x002fh = 1,
	eml__ThermalDiffusivityUom__ft2_x002fs = 2,
	eml__ThermalDiffusivityUom__in2_x002fs = 3,
	eml__ThermalDiffusivityUom__m2_x002fh = 4,
	eml__ThermalDiffusivityUom__m2_x002fs = 5,
	eml__ThermalDiffusivityUom__mm2_x002fs = 6
};
#endif

/* resqml2_0_1ForGsoap.h:7386 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthUom (674)
/* eml:VolumePerTimeLengthUom */
enum eml__VolumePerTimeLengthUom {
	eml__VolumePerTimeLengthUom__1000_x0020bbl_x002eft_x002fd = 0,
	eml__VolumePerTimeLengthUom__1000_x0020m4_x002fd = 1,
	eml__VolumePerTimeLengthUom__m4_x002fs = 2
};
#endif

/* resqml2_0_1ForGsoap.h:7405 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockUom (675)
/* eml:PermeabilityRockUom */
enum eml__PermeabilityRockUom {
	eml__PermeabilityRockUom__D = 'D',
	eml__PermeabilityRockUom__D_x005bAPI_x005d = 'E',
	eml__PermeabilityRockUom__mD = 'F',
	eml__PermeabilityRockUom__TD_x005bAPI_x005d = 'G'
};
#endif

/* resqml2_0_1ForGsoap.h:7428 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaUom (676)
/* eml:SecondMomentOfAreaUom */
enum eml__SecondMomentOfAreaUom {
	eml__SecondMomentOfAreaUom__cm4 = 0,
	eml__SecondMomentOfAreaUom__in4 = 1,
	eml__SecondMomentOfAreaUom__m4 = 2
};
#endif

/* resqml2_0_1ForGsoap.h:7447 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaUom (677)
/* eml:ForceAreaUom */
enum eml__ForceAreaUom {
	eml__ForceAreaUom__dyne_x002ecm2 = 0,
	eml__ForceAreaUom__kgf_x002em2 = 1,
	eml__ForceAreaUom__kN_x002em2 = 2,
	eml__ForceAreaUom__lbf_x002ein2 = 3,
	eml__ForceAreaUom__mN_x002em2 = 4,
	eml__ForceAreaUom__N_x002em2 = 5,
	eml__ForceAreaUom__pdl_x002ecm2 = 6,
	eml__ForceAreaUom__tonf_x005bUK_x005d_x002eft2 = 7,
	eml__ForceAreaUom__tonf_x005bUS_x005d_x002eft2 = 8
};
#endif

/* resqml2_0_1ForGsoap.h:7490 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthUom (678)
/* eml:ElectricFieldStrengthUom */
enum eml__ElectricFieldStrengthUom {
	eml__ElectricFieldStrengthUom__mV_x002fft = 0,
	eml__ElectricFieldStrengthUom__mV_x002fm = 1,
	eml__ElectricFieldStrengthUom__uV_x002fft = 2,
	eml__ElectricFieldStrengthUom__uV_x002fm = 3,
	eml__ElectricFieldStrengthUom__V_x002fm = 4
};
#endif

/* resqml2_0_1ForGsoap.h:7517 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaUom (679)
/* eml:AmountOfSubstancePerAreaUom */
enum eml__AmountOfSubstancePerAreaUom {
	eml__AmountOfSubstancePerAreaUom__mol_x002fm2 = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7528 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeUom (680)
/* eml:TimeUom */
enum eml__TimeUom {
	eml__TimeUom__a = 'a',
	eml__TimeUom__d = 'd',
	eml__TimeUom__h = 'h',
	eml__TimeUom__s = 's',
	eml__TimeUom__1_x002f2_x0020ms = 't',
	eml__TimeUom__100_x0020ka_x005bt_x005d = 'u',
	eml__TimeUom__a_x005bt_x005d = 'v',
	eml__TimeUom__ca = 'w',
	eml__TimeUom__cs = 'x',
	eml__TimeUom__ds = 'y',
	eml__TimeUom__Ea_x005bt_x005d = 'z',
	eml__TimeUom__fa = 123,
	eml__TimeUom__Ga_x005bt_x005d = 124,
	eml__TimeUom__hs = 125,
	eml__TimeUom__ka_x005bt_x005d = 126,
	eml__TimeUom__Ma_x005bt_x005d = 127,
	eml__TimeUom__min_ = 128,
	eml__TimeUom__ms = 129,
	eml__TimeUom__na = 130,
	eml__TimeUom__ns = 131,
	eml__TimeUom__ps = 132,
	eml__TimeUom__Ta_x005bt_x005d = 133,
	eml__TimeUom__us = 134,
	eml__TimeUom__wk = 135
};
#endif

/* resqml2_0_1ForGsoap.h:7631 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityUom (681)
/* eml:ThermalConductivityUom */
enum eml__ThermalConductivityUom {
	eml__ThermalConductivityUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft_x002edeltaF_x0029 = 0,
	eml__ThermalConductivityUom__cal_x005bth_x005d_x002f_x0028h_x002ecm_x002edeltaC_x0029 = 1,
	eml__ThermalConductivityUom__cal_x005bth_x005d_x002f_x0028s_x002ecm_x002edeltaC_x0029 = 2,
	eml__ThermalConductivityUom__kcal_x005bth_x005d_x002f_x0028h_x002em_x002edeltaC_x0029 = 3,
	eml__ThermalConductivityUom__W_x002f_x0028m_x002edeltaK_x0029 = 4
};
#endif

/* resqml2_0_1ForGsoap.h:7658 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceUom (682)
/* eml:AreaPerAmountOfSubstanceUom */
enum eml__AreaPerAmountOfSubstanceUom {
	eml__AreaPerAmountOfSubstanceUom__m2_x002fmol = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7669 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthUom (683)
/* eml:LogarithmicPowerRatioPerLengthUom */
enum eml__LogarithmicPowerRatioPerLengthUom {
	eml__LogarithmicPowerRatioPerLengthUom__B_x002fm = 0,
	eml__LogarithmicPowerRatioPerLengthUom__dB_x002fft = 1,
	eml__LogarithmicPowerRatioPerLengthUom__dB_x002fkm = 2,
	eml__LogarithmicPowerRatioPerLengthUom__dB_x002fm = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7692 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthUom (684)
/* eml:ReciprocalLengthUom */
enum eml__ReciprocalLengthUom {
	eml__ReciprocalLengthUom__1_x002fangstrom = 0,
	eml__ReciprocalLengthUom__1_x002fcm = 1,
	eml__ReciprocalLengthUom__1_x002fft = 2,
	eml__ReciprocalLengthUom__1_x002fin = 3,
	eml__ReciprocalLengthUom__1_x002fm = 4,
	eml__ReciprocalLengthUom__1_x002fmi = 5,
	eml__ReciprocalLengthUom__1_x002fmm = 6,
	eml__ReciprocalLengthUom__1_x002fnm = 7,
	eml__ReciprocalLengthUom__1_x002fyd = 8,
	eml__ReciprocalLengthUom__1E_9_x00201_x002fft = 9
};
#endif

/* resqml2_0_1ForGsoap.h:7739 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceUom (685)
/* eml:LuminanceUom */
enum eml__LuminanceUom {
	eml__LuminanceUom__cd_x002fm2 = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7750 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeUom (686)
/* eml:VolumePerTimePerTimeUom */
enum eml__VolumePerTimePerTimeUom {
	eml__VolumePerTimePerTimeUom__bbl_x002fd2 = 0,
	eml__VolumePerTimePerTimeUom__bbl_x002fh2 = 1,
	eml__VolumePerTimePerTimeUom__dm3_x002fs2 = 2,
	eml__VolumePerTimePerTimeUom__ft3_x002fd2 = 3,
	eml__VolumePerTimePerTimeUom__ft3_x002fh2 = 4,
	eml__VolumePerTimePerTimeUom__ft3_x002fmin2 = 5,
	eml__VolumePerTimePerTimeUom__ft3_x002fs2 = 6,
	eml__VolumePerTimePerTimeUom__gal_x005bUK_x005d_x002fh2 = 7,
	eml__VolumePerTimePerTimeUom__gal_x005bUK_x005d_x002fmin2 = 8,
	eml__VolumePerTimePerTimeUom__gal_x005bUS_x005d_x002fh2 = 9,
	eml__VolumePerTimePerTimeUom__gal_x005bUS_x005d_x002fmin2 = 10,
	eml__VolumePerTimePerTimeUom__L_x002fs2 = 11,
	eml__VolumePerTimePerTimeUom__m3_x002fd2 = 12,
	eml__VolumePerTimePerTimeUom__m3_x002fs2 = 13
};
#endif

/* resqml2_0_1ForGsoap.h:7813 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityUom (687)
/* eml:MolarHeatCapacityUom */
enum eml__MolarHeatCapacityUom {
	eml__MolarHeatCapacityUom__Btu_x005bIT_x005d_x002f_x0028lbmol_x002edeltaF_x0029 = 0,
	eml__MolarHeatCapacityUom__cal_x005bth_x005d_x002f_x0028mol_x002edeltaC_x0029 = 1,
	eml__MolarHeatCapacityUom__J_x002f_x0028mol_x002edeltaK_x0029 = 2,
	eml__MolarHeatCapacityUom__kJ_x002f_x0028kmol_x002edeltaK_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7836 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateUom (688)
/* eml:VolumeFlowRatePerVolumeFlowRateUom */
enum eml__VolumeFlowRatePerVolumeFlowRateUom {
	eml__VolumeFlowRatePerVolumeFlowRateUom___x0025 = 0,
	eml__VolumeFlowRatePerVolumeFlowRateUom___x0028bbl_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 1,
	eml__VolumeFlowRatePerVolumeFlowRateUom___x0028m3_x002fd_x0029_x002f_x0028m3_x002fd_x0029 = 2,
	eml__VolumeFlowRatePerVolumeFlowRateUom___x0028m3_x002fs_x0029_x002f_x0028m3_x002fs_x0029 = 3,
	eml__VolumeFlowRatePerVolumeFlowRateUom__1E6_x0020_x0028ft3_x002fd_x0029_x002f_x0028bbl_x002fd_x0029 = 4,
	eml__VolumeFlowRatePerVolumeFlowRateUom__Euc = 5
};
#endif

/* resqml2_0_1ForGsoap.h:7867 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalUom (689)
/* eml:FrequencyIntervalUom */
enum eml__FrequencyIntervalUom {
	eml__FrequencyIntervalUom__O = 'O'
};
#endif

/* resqml2_0_1ForGsoap.h:7878 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalUom (690)
/* eml:TemperatureIntervalUom */
enum eml__TemperatureIntervalUom {
	eml__TemperatureIntervalUom__deltaC = 0,
	eml__TemperatureIntervalUom__deltaF = 1,
	eml__TemperatureIntervalUom__deltaK = 2,
	eml__TemperatureIntervalUom__deltaR = 3
};
#endif

/* resqml2_0_1ForGsoap.h:7901 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityUom (691)
/* eml:RadiantIntensityUom */
enum eml__RadiantIntensityUom {
	eml__RadiantIntensityUom__W_x002fsr = 0
};
#endif

/* resqml2_0_1ForGsoap.h:7912 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthUom (692)
/* eml:PermeabilityLengthUom */
enum eml__PermeabilityLengthUom {
	eml__PermeabilityLengthUom__D_x002eft = 0,
	eml__PermeabilityLengthUom__D_x002em = 1,
	eml__PermeabilityLengthUom__mD_x002eft = 2,
	eml__PermeabilityLengthUom__mD_x002em = 3,
	eml__PermeabilityLengthUom__TD_x005bAPI_x005d_x002em = 4
};
#endif

/* resqml2_0_1ForGsoap.h:7939 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedUom (693)
/* eml:DataTransferSpeedUom */
enum eml__DataTransferSpeedUom {
	eml__DataTransferSpeedUom__bit_x002fs = 0,
	eml__DataTransferSpeedUom__byte_x002fs = 1
};
#endif

/* resqml2_0_1ForGsoap.h:7954 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceUom (694)
/* eml:InductanceUom */
enum eml__InductanceUom {
	eml__InductanceUom__H = 'H',
	eml__InductanceUom__cH = 'I',
	eml__InductanceUom__dH = 'J',
	eml__InductanceUom__EH = 'K',
	eml__InductanceUom__fH = 'L',
	eml__InductanceUom__GH = 'M',
	eml__InductanceUom__kH = 'N',
	eml__InductanceUom__MH = 'O',
	eml__InductanceUom__mH = 'P',
	eml__InductanceUom__nH = 'Q',
	eml__InductanceUom__TH = 'R',
	eml__InductanceUom__uH = 'S'
};
#endif

/* resqml2_0_1ForGsoap.h:8009 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityUom (695)
/* eml:KinematicViscosityUom */
enum eml__KinematicViscosityUom {
	eml__KinematicViscosityUom__cm2_x002fs = 0,
	eml__KinematicViscosityUom__cSt = 1,
	eml__KinematicViscosityUom__ft2_x002fh = 2,
	eml__KinematicViscosityUom__ft2_x002fs = 3,
	eml__KinematicViscosityUom__in2_x002fs = 4,
	eml__KinematicViscosityUom__m2_x002fh = 5,
	eml__KinematicViscosityUom__m2_x002fs = 6,
	eml__KinematicViscosityUom__mm2_x002fs = 7,
	eml__KinematicViscosityUom__Pa_x002es_x002em3_x002fkg = 8,
	eml__KinematicViscosityUom__St = 9
};
#endif

/* resqml2_0_1ForGsoap.h:8056 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthUom (696)
/* eml:VolumePerTimePerPressureLengthUom */
enum eml__VolumePerTimePerPressureLengthUom {
	eml__VolumePerTimePerPressureLengthUom__bbl_x002f_x0028ft_x002epsi_x002ed_x0029 = 0,
	eml__VolumePerTimePerPressureLengthUom__ft3_x002f_x0028ft_x002epsi_x002ed_x0029 = 1,
	eml__VolumePerTimePerPressureLengthUom__m2_x002f_x0028kPa_x002ed_x0029 = 2,
	eml__VolumePerTimePerPressureLengthUom__m2_x002f_x0028Pa_x002es_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:8079 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceUom (697)
/* eml:ReciprocalForceUom */
enum eml__ReciprocalForceUom {
	eml__ReciprocalForceUom__1_x002flbf = 0,
	eml__ReciprocalForceUom__1_x002fN = 1
};
#endif

/* resqml2_0_1ForGsoap.h:8094 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaUom (698)
/* eml:ReciprocalAreaUom */
enum eml__ReciprocalAreaUom {
	eml__ReciprocalAreaUom__1_x002fft2 = 0,
	eml__ReciprocalAreaUom__1_x002fkm2 = 1,
	eml__ReciprocalAreaUom__1_x002fm2 = 2,
	eml__ReciprocalAreaUom__1_x002fmi2 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:8117 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeUom (699)
/* eml:PressurePerTimeUom */
enum eml__PressurePerTimeUom {
	eml__PressurePerTimeUom__atm_x002fh = 0,
	eml__PressurePerTimeUom__bar_x002fh = 1,
	eml__PressurePerTimeUom__kPa_x002fh = 2,
	eml__PressurePerTimeUom__kPa_x002fmin = 3,
	eml__PressurePerTimeUom__MPa_x002fh = 4,
	eml__PressurePerTimeUom__Pa_x002fh = 5,
	eml__PressurePerTimeUom__Pa_x002fs = 6,
	eml__PressurePerTimeUom__psi_x002fh = 7,
	eml__PressurePerTimeUom__psi_x002fmin = 8
};
#endif

/* resqml2_0_1ForGsoap.h:8160 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeUom (700)
/* eml:ElectricChargeUom */
enum eml__ElectricChargeUom {
	eml__ElectricChargeUom__C = 'C',
	eml__ElectricChargeUom__A_x002eh = 'D',
	eml__ElectricChargeUom__A_x002es = 'E',
	eml__ElectricChargeUom__cC = 'F',
	eml__ElectricChargeUom__dC = 'G',
	eml__ElectricChargeUom__EC = 'H',
	eml__ElectricChargeUom__fC = 'I',
	eml__ElectricChargeUom__GC = 'J',
	eml__ElectricChargeUom__kC = 'K',
	eml__ElectricChargeUom__MC = 'L',
	eml__ElectricChargeUom__mC = 'M',
	eml__ElectricChargeUom__nC = 'N',
	eml__ElectricChargeUom__pC = 'O',
	eml__ElectricChargeUom__TC = 'P',
	eml__ElectricChargeUom__uC = 'Q'
};
#endif

/* resqml2_0_1ForGsoap.h:8227 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyUom (701)
/* eml:LuminousEfficacyUom */
enum eml__LuminousEfficacyUom {
	eml__LuminousEfficacyUom__lm_x002fW = 0
};
#endif

/* resqml2_0_1ForGsoap.h:8238 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerUom (702)
/* eml:PowerUom */
enum eml__PowerUom {
	eml__PowerUom__W = 'W',
	eml__PowerUom__cW = 'X',
	eml__PowerUom__dW = 'Y',
	eml__PowerUom__EW = 'Z',
	eml__PowerUom__fW = 91,
	eml__PowerUom__GW = 92,
	eml__PowerUom__hp = 93,
	eml__PowerUom__hp_x005belec_x005d = 94,
	eml__PowerUom__hp_x005bhyd_x005d = 95,
	eml__PowerUom__hp_x005bmetric_x005d = 96,
	eml__PowerUom__kW = 'a',
	eml__PowerUom__MW = 'b',
	eml__PowerUom__mW = 'c',
	eml__PowerUom__nW = 'd',
	eml__PowerUom__pW = 'e',
	eml__PowerUom__tonRefrig = 'f',
	eml__PowerUom__TW = 'g',
	eml__PowerUom__uW = 'h'
};
#endif

/* resqml2_0_1ForGsoap.h:8317 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeUom (703)
/* eml:PressurePerVolumeUom */
enum eml__PressurePerVolumeUom {
	eml__PressurePerVolumeUom__Pa_x002fm3 = 0,
	eml__PressurePerVolumeUom__psi2_x002ed_x002f_x0028cP_x002eft3_x0029 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:8332 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityUom (704)
/* eml:ActivityOfRadioactivityUom */
enum eml__ActivityOfRadioactivityUom {
	eml__ActivityOfRadioactivityUom__Bq = 0,
	eml__ActivityOfRadioactivityUom__Ci = 1,
	eml__ActivityOfRadioactivityUom__GBq = 2,
	eml__ActivityOfRadioactivityUom__MBq = 3,
	eml__ActivityOfRadioactivityUom__mCi = 4,
	eml__ActivityOfRadioactivityUom__nCi = 5,
	eml__ActivityOfRadioactivityUom__pCi = 6,
	eml__ActivityOfRadioactivityUom__TBq = 7,
	eml__ActivityOfRadioactivityUom__uCi = 8
};
#endif

/* resqml2_0_1ForGsoap.h:8375 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceUom (705)
/* eml:ElectricPotentialDifferenceUom */
enum eml__ElectricPotentialDifferenceUom {
	eml__ElectricPotentialDifferenceUom__V = 'V',
	eml__ElectricPotentialDifferenceUom__cV = 'W',
	eml__ElectricPotentialDifferenceUom__dV = 'X',
	eml__ElectricPotentialDifferenceUom__fV = 'Y',
	eml__ElectricPotentialDifferenceUom__GV = 'Z',
	eml__ElectricPotentialDifferenceUom__kV = 91,
	eml__ElectricPotentialDifferenceUom__mV = 92,
	eml__ElectricPotentialDifferenceUom__MV = 93,
	eml__ElectricPotentialDifferenceUom__nV = 94,
	eml__ElectricPotentialDifferenceUom__pV = 95,
	eml__ElectricPotentialDifferenceUom__TV = 96,
	eml__ElectricPotentialDifferenceUom__uV = 'a'
};
#endif

/* resqml2_0_1ForGsoap.h:8430 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureUom (706)
/* eml:LengthPerPressureUom */
enum eml__LengthPerPressureUom {
	eml__LengthPerPressureUom__ft_x002fpsi = 0,
	eml__LengthPerPressureUom__m_x002fkPa = 1,
	eml__LengthPerPressureUom__m_x002fPa = 2
};
#endif

/* resqml2_0_1ForGsoap.h:8449 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialUom (707)
/* eml:MagneticVectorPotentialUom */
enum eml__MagneticVectorPotentialUom {
	eml__MagneticVectorPotentialUom__Wb_x002fm = 0,
	eml__MagneticVectorPotentialUom__Wb_x002fmm = 1
};
#endif

/* resqml2_0_1ForGsoap.h:8464 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthUom (708)
/* eml:MagneticFieldStrengthUom */
enum eml__MagneticFieldStrengthUom {
	eml__MagneticFieldStrengthUom__A_x002fm = 0,
	eml__MagneticFieldStrengthUom__A_x002fmm = 1,
	eml__MagneticFieldStrengthUom__Oe = 2
};
#endif

/* resqml2_0_1ForGsoap.h:8483 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeUom (709)
/* eml:VolumePerTimeUom */
enum eml__VolumePerTimeUom {
	eml__VolumePerTimeUom__1_x002f30_x0020cm3_x002fmin = 0,
	eml__VolumePerTimeUom__1000_x0020bbl_x002fd = 1,
	eml__VolumePerTimeUom__1000_x0020ft3_x002fd = 2,
	eml__VolumePerTimeUom__1000_x0020m3_x002fd = 3,
	eml__VolumePerTimeUom__1000_x0020m3_x002fh = 4,
	eml__VolumePerTimeUom__1E6_x0020bbl_x002fd = 5,
	eml__VolumePerTimeUom__1E6_x0020ft3_x002fd = 6,
	eml__VolumePerTimeUom__1E6_x0020m3_x002fd = 7,
	eml__VolumePerTimeUom__bbl_x002fd = 8,
	eml__VolumePerTimeUom__bbl_x002fh = 9,
	eml__VolumePerTimeUom__bbl_x002fmin = 10,
	eml__VolumePerTimeUom__cm3_x002fh = 11,
	eml__VolumePerTimeUom__cm3_x002fmin = 12,
	eml__VolumePerTimeUom__cm3_x002fs = 13,
	eml__VolumePerTimeUom__dm3_x002fs = 14,
	eml__VolumePerTimeUom__ft3_x002fd = 15,
	eml__VolumePerTimeUom__ft3_x002fh = 16,
	eml__VolumePerTimeUom__ft3_x002fmin = 17,
	eml__VolumePerTimeUom__ft3_x002fs = 18,
	eml__VolumePerTimeUom__gal_x005bUK_x005d_x002fd = 19,
	eml__VolumePerTimeUom__gal_x005bUK_x005d_x002fh = 20,
	eml__VolumePerTimeUom__gal_x005bUK_x005d_x002fmin = 21,
	eml__VolumePerTimeUom__gal_x005bUS_x005d_x002fd = 22,
	eml__VolumePerTimeUom__gal_x005bUS_x005d_x002fh = 23,
	eml__VolumePerTimeUom__gal_x005bUS_x005d_x002fmin = 24,
	eml__VolumePerTimeUom__L_x002fh = 25,
	eml__VolumePerTimeUom__L_x002fmin = 26,
	eml__VolumePerTimeUom__L_x002fs = 27,
	eml__VolumePerTimeUom__m3_x002fd = 28,
	eml__VolumePerTimeUom__m3_x002fh = 29,
	eml__VolumePerTimeUom__m3_x002fmin = 30,
	eml__VolumePerTimeUom__m3_x002fs = 31
};
#endif

/* resqml2_0_1ForGsoap.h:8618 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthUom (710)
/* eml:LengthUom */
enum eml__LengthUom {
	eml__LengthUom__m = 'm',
	eml__LengthUom__0_x002e1_x0020ft = 'n',
	eml__LengthUom__0_x002e1_x0020ft_x005bUS_x005d = 'o',
	eml__LengthUom__0_x002e1_x0020in = 'p',
	eml__LengthUom__0_x002e1_x0020yd = 'q',
	eml__LengthUom__1_x002f16_x0020in = 'r',
	eml__LengthUom__1_x002f2_x0020ft = 's',
	eml__LengthUom__1_x002f32_x0020in = 't',
	eml__LengthUom__1_x002f64_x0020in = 'u',
	eml__LengthUom__10_x0020ft = 'v',
	eml__LengthUom__10_x0020in = 'w',
	eml__LengthUom__10_x0020km = 'x',
	eml__LengthUom__100_x0020ft = 'y',
	eml__LengthUom__100_x0020km = 'z',
	eml__LengthUom__1000_x0020ft = 123,
	eml__LengthUom__30_x0020ft = 124,
	eml__LengthUom__30_x0020m = 125,
	eml__LengthUom__angstrom = 126,
	eml__LengthUom__chain = 127,
	eml__LengthUom__chain_x005bBnA_x005d = 128,
	eml__LengthUom__chain_x005bBnB_x005d = 129,
	eml__LengthUom__chain_x005bCla_x005d = 130,
	eml__LengthUom__chain_x005bInd37_x005d = 131,
	eml__LengthUom__chain_x005bSe_x005d = 132,
	eml__LengthUom__chain_x005bSeT_x005d = 133,
	eml__LengthUom__chain_x005bUS_x005d = 134,
	eml__LengthUom__cm = 135,
	eml__LengthUom__dam = 136,
	eml__LengthUom__dm = 137,
	eml__LengthUom__Em = 138,
	eml__LengthUom__fathom = 139,
	eml__LengthUom__fm = 140,
	eml__LengthUom__ft = 141,
	eml__LengthUom__ft_x005bBnA_x005d = 142,
	eml__LengthUom__ft_x005bBnB_x005d = 143,
	eml__LengthUom__ft_x005bBr36_x005d = 144,
	eml__LengthUom__ft_x005bBr65_x005d = 145,
	eml__LengthUom__ft_x005bCla_x005d = 146,
	eml__LengthUom__ft_x005bGC_x005d = 147,
	eml__LengthUom__ft_x005bInd_x005d = 148,
	eml__LengthUom__ft_x005bInd37_x005d = 149,
	eml__LengthUom__ft_x005bInd62_x005d = 150,
	eml__LengthUom__ft_x005bInd75_x005d = 151,
	eml__LengthUom__ft_x005bSe_x005d = 152,
	eml__LengthUom__ft_x005bSeT_x005d = 153,
	eml__LengthUom__ft_x005bUS_x005d = 154,
	eml__LengthUom__fur_x005bUS_x005d = 155,
	eml__LengthUom__Gm = 156,
	eml__LengthUom__hm = 157,
	eml__LengthUom__in = 158,
	eml__LengthUom__in_x005bUS_x005d = 159,
	eml__LengthUom__km = 160,
	eml__LengthUom__link = 161,
	eml__LengthUom__link_x005bBnA_x005d = 162,
	eml__LengthUom__link_x005bBnB_x005d = 163,
	eml__LengthUom__link_x005bCla_x005d = 164,
	eml__LengthUom__link_x005bSe_x005d = 165,
	eml__LengthUom__link_x005bSeT_x005d = 166,
	eml__LengthUom__link_x005bUS_x005d = 167,
	eml__LengthUom__m_x005bGer_x005d = 168,
	eml__LengthUom__mi = 169,
	eml__LengthUom__mi_x005bnaut_x005d = 170,
	eml__LengthUom__mi_x005bnautUK_x005d = 171,
	eml__LengthUom__mi_x005bUS_x005d = 172,
	eml__LengthUom__mil = 173,
	eml__LengthUom__Mm = 174,
	eml__LengthUom__mm = 175,
	eml__LengthUom__nm = 176,
	eml__LengthUom__pm = 177,
	eml__LengthUom__rod_x005bUS_x005d = 178,
	eml__LengthUom__Tm = 179,
	eml__LengthUom__um = 180,
	eml__LengthUom__yd = 181,
	eml__LengthUom__yd_x005bBnA_x005d = 182,
	eml__LengthUom__yd_x005bBnB_x005d = 183,
	eml__LengthUom__yd_x005bCla_x005d = 184,
	eml__LengthUom__yd_x005bInd_x005d = 185,
	eml__LengthUom__yd_x005bInd37_x005d = 186,
	eml__LengthUom__yd_x005bInd62_x005d = 187,
	eml__LengthUom__yd_x005bInd75_x005d = 188,
	eml__LengthUom__yd_x005bSe_x005d = 189,
	eml__LengthUom__yd_x005bSeT_x005d = 190,
	eml__LengthUom__yd_x005bUS_x005d = 191
};
#endif

/* resqml2_0_1ForGsoap.h:8957 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassUom (711)
/* eml:AreaPerMassUom */
enum eml__AreaPerMassUom {
	eml__AreaPerMassUom__cm2_x002fg = 0,
	eml__AreaPerMassUom__ft2_x002flbm = 1,
	eml__AreaPerMassUom__m2_x002fg = 2,
	eml__AreaPerMassUom__m2_x002fkg = 3
};
#endif

/* resqml2_0_1ForGsoap.h:8980 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceUom (712)
/* eml:ThermalResistanceUom */
enum eml__ThermalResistanceUom {
	eml__ThermalResistanceUom__deltaK_x002fW = 0
};
#endif

/* resqml2_0_1ForGsoap.h:8991 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceUom (713)
/* eml:ForcePerForceUom */
enum eml__ForcePerForceUom {
	eml__ForcePerForceUom___x0025 = 0,
	eml__ForcePerForceUom__Euc = 1,
	eml__ForcePerForceUom__kgf_x002fkgf = 2,
	eml__ForcePerForceUom__lbf_x002flbf = 3,
	eml__ForcePerForceUom__N_x002fN = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9018 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassUom (714)
/* eml:MassUom */
enum eml__MassUom {
	eml__MassUom__g = 'g',
	eml__MassUom__t = 't',
	eml__MassUom__ag = 'u',
	eml__MassUom__cg = 'v',
	eml__MassUom__ct = 'w',
	eml__MassUom__cwt_x005bUK_x005d = 'x',
	eml__MassUom__cwt_x005bUS_x005d = 'y',
	eml__MassUom__Eg = 'z',
	eml__MassUom__fg = 123,
	eml__MassUom__Gg = 124,
	eml__MassUom__grain = 125,
	eml__MassUom__hg = 126,
	eml__MassUom__kg = 127,
	eml__MassUom__klbm = 128,
	eml__MassUom__lbm = 129,
	eml__MassUom__mg = 130,
	eml__MassUom__Mg = 131,
	eml__MassUom__ng = 132,
	eml__MassUom__ozm = 133,
	eml__MassUom__ozm_x005btroy_x005d = 134,
	eml__MassUom__pg = 135,
	eml__MassUom__sack_x005b94lbm_x005d = 136,
	eml__MassUom__Tg = 137,
	eml__MassUom__ton_x005bUK_x005d = 138,
	eml__MassUom__ton_x005bUS_x005d = 139,
	eml__MassUom__ug = 140
};
#endif

/* resqml2_0_1ForGsoap.h:9129 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityUom (715)
/* eml:SpecificHeatCapacityUom */
enum eml__SpecificHeatCapacityUom {
	eml__SpecificHeatCapacityUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaF_x0029 = 0,
	eml__SpecificHeatCapacityUom__Btu_x005bIT_x005d_x002f_x0028lbm_x002edeltaR_x0029 = 1,
	eml__SpecificHeatCapacityUom__cal_x005bth_x005d_x002f_x0028g_x002edeltaK_x0029 = 2,
	eml__SpecificHeatCapacityUom__J_x002f_x0028g_x002edeltaK_x0029 = 3,
	eml__SpecificHeatCapacityUom__J_x002f_x0028kg_x002edeltaK_x0029 = 4,
	eml__SpecificHeatCapacityUom__kcal_x005bth_x005d_x002f_x0028kg_x002edeltaC_x0029 = 5,
	eml__SpecificHeatCapacityUom__kJ_x002f_x0028kg_x002edeltaK_x0029 = 6,
	eml__SpecificHeatCapacityUom__kW_x002eh_x002f_x0028kg_x002edeltaC_x0029 = 7
};
#endif

/* resqml2_0_1ForGsoap.h:9168 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassUom (716)
/* eml:LengthPerMassUom */
enum eml__LengthPerMassUom {
	eml__LengthPerMassUom__ft_x002flbm = 0,
	eml__LengthPerMassUom__m_x002fkg = 1
};
#endif

/* resqml2_0_1ForGsoap.h:9183 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaUom (717)
/* eml:AmountOfSubstancePerTimePerAreaUom */
enum eml__AmountOfSubstancePerTimePerAreaUom {
	eml__AmountOfSubstancePerTimePerAreaUom__lbmol_x002f_x0028h_x002eft2_x0029 = 0,
	eml__AmountOfSubstancePerTimePerAreaUom__lbmol_x002f_x0028s_x002eft2_x0029 = 1,
	eml__AmountOfSubstancePerTimePerAreaUom__mol_x002f_x0028s_x002em2_x0029 = 2
};
#endif

/* resqml2_0_1ForGsoap.h:9202 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureUom (718)
/* eml:ThermodynamicTemperatureUom */
enum eml__ThermodynamicTemperatureUom {
	eml__ThermodynamicTemperatureUom__K = 'K',
	eml__ThermodynamicTemperatureUom__degC = 'L',
	eml__ThermodynamicTemperatureUom__degF = 'M',
	eml__ThermodynamicTemperatureUom__degR = 'N'
};
#endif

/* resqml2_0_1ForGsoap.h:9225 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionUom (719)
/* eml:LinearThermalExpansionUom */
enum eml__LinearThermalExpansionUom {
	eml__LinearThermalExpansionUom__1_x002fdeltaK = 0,
	eml__LinearThermalExpansionUom__in_x002f_x0028in_x002edeltaF_x0029 = 1,
	eml__LinearThermalExpansionUom__m_x002f_x0028m_x002edeltaK_x0029 = 2,
	eml__LinearThermalExpansionUom__mm_x002f_x0028mm_x002edeltaK_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:9248 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthUom (720)
/* eml:MassPerLengthUom */
enum eml__MassPerLengthUom {
	eml__MassPerLengthUom__kg_x002em_x002fcm2 = 0,
	eml__MassPerLengthUom__kg_x002fm = 1,
	eml__MassPerLengthUom__klbm_x002fin = 2,
	eml__MassPerLengthUom__lbm_x002fft = 3,
	eml__MassPerLengthUom__Mg_x002fin = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9275 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityUom (721)
/* eml:ElectricalResistivityUom */
enum eml__ElectricalResistivityUom {
	eml__ElectricalResistivityUom__kohm_x002em = 0,
	eml__ElectricalResistivityUom__nohm_x002emil2_x002fft = 1,
	eml__ElectricalResistivityUom__nohm_x002emm2_x002fm = 2,
	eml__ElectricalResistivityUom__ohm_x002ecm = 3,
	eml__ElectricalResistivityUom__ohm_x002em = 4,
	eml__ElectricalResistivityUom__ohm_x002em2_x002fm = 5
};
#endif

/* resqml2_0_1ForGsoap.h:9306 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassUom (722)
/* eml:MassPerMassUom */
enum eml__MassPerMassUom {
	eml__MassPerMassUom___x0025 = 0,
	eml__MassPerMassUom___x0025_x005bmass_x005d = 1,
	eml__MassPerMassUom__Euc = 2,
	eml__MassPerMassUom__g_x002fkg = 3,
	eml__MassPerMassUom__g_x002ft = 4,
	eml__MassPerMassUom__kg_x002fkg = 5,
	eml__MassPerMassUom__kg_x002fsack_x005b94lbm_x005d = 6,
	eml__MassPerMassUom__kg_x002ft = 7,
	eml__MassPerMassUom__mg_x002fg = 8,
	eml__MassPerMassUom__mg_x002fkg = 9,
	eml__MassPerMassUom__ng_x002fg = 10,
	eml__MassPerMassUom__ng_x002fmg = 11,
	eml__MassPerMassUom__ppk = 12,
	eml__MassPerMassUom__ppm = 13,
	eml__MassPerMassUom__ppm_x005bmass_x005d = 14,
	eml__MassPerMassUom__ug_x002fg = 15,
	eml__MassPerMassUom__ug_x002fmg = 16
};
#endif

/* resqml2_0_1ForGsoap.h:9381 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaUom (723)
/* eml:PressureSquaredPerForceTimePerAreaUom */
enum eml__PressureSquaredPerForceTimePerAreaUom {
	eml__PressureSquaredPerForceTimePerAreaUom__0_x002e001_x0020kPa2_x002fcP = 0,
	eml__PressureSquaredPerForceTimePerAreaUom__bar2_x002fcP = 1,
	eml__PressureSquaredPerForceTimePerAreaUom__kPa2_x002fcP = 2,
	eml__PressureSquaredPerForceTimePerAreaUom__Pa2_x002f_x0028Pa_x002es_x0029 = 3,
	eml__PressureSquaredPerForceTimePerAreaUom__psi2_x002fcP = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9408 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxUom (724)
/* eml:LuminousFluxUom */
enum eml__LuminousFluxUom {
	eml__LuminousFluxUom__lm = 0
};
#endif

/* resqml2_0_1ForGsoap.h:9419 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureUom (725)
/* eml:VolumePerTimePerPressureUom */
enum eml__VolumePerTimePerPressureUom {
	eml__VolumePerTimePerPressureUom__1000_x0020ft3_x002f_x0028psi_x002ed_x0029 = 0,
	eml__VolumePerTimePerPressureUom__bbl_x002f_x0028kPa_x002ed_x0029 = 1,
	eml__VolumePerTimePerPressureUom__bbl_x002f_x0028psi_x002ed_x0029 = 2,
	eml__VolumePerTimePerPressureUom__L_x002f_x0028bar_x002emin_x0029 = 3,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028bar_x002ed_x0029 = 4,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028bar_x002eh_x0029 = 5,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028bar_x002emin_x0029 = 6,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028kPa_x002ed_x0029 = 7,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028kPa_x002eh_x0029 = 8,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028Pa_x002es_x0029 = 9,
	eml__VolumePerTimePerPressureUom__m3_x002f_x0028psi_x002ed_x0029 = 10
};
#endif

/* resqml2_0_1ForGsoap.h:9470 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeUom (726)
/* eml:AmountOfSubstancePerVolumeUom */
enum eml__AmountOfSubstancePerVolumeUom {
	eml__AmountOfSubstancePerVolumeUom__kmol_x002fm3 = 0,
	eml__AmountOfSubstancePerVolumeUom__lbmol_x002fft3 = 1,
	eml__AmountOfSubstancePerVolumeUom__lbmol_x002fgal_x005bUK_x005d = 2,
	eml__AmountOfSubstancePerVolumeUom__lbmol_x002fgal_x005bUS_x005d = 3,
	eml__AmountOfSubstancePerVolumeUom__mol_x002fm3 = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9497 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassUom (727)
/* eml:EnergyPerMassUom */
enum eml__EnergyPerMassUom {
	eml__EnergyPerMassUom__Btu_x005bIT_x005d_x002flbm = 0,
	eml__EnergyPerMassUom__cal_x005bth_x005d_x002fg = 1,
	eml__EnergyPerMassUom__cal_x005bth_x005d_x002fkg = 2,
	eml__EnergyPerMassUom__cal_x005bth_x005d_x002flbm = 3,
	eml__EnergyPerMassUom__erg_x002fg = 4,
	eml__EnergyPerMassUom__erg_x002fkg = 5,
	eml__EnergyPerMassUom__hp_x002eh_x002flbm = 6,
	eml__EnergyPerMassUom__J_x002fg = 7,
	eml__EnergyPerMassUom__J_x002fkg = 8,
	eml__EnergyPerMassUom__kcal_x005bth_x005d_x002fg = 9,
	eml__EnergyPerMassUom__kcal_x005bth_x005d_x002fkg = 10,
	eml__EnergyPerMassUom__kJ_x002fkg = 11,
	eml__EnergyPerMassUom__kW_x002eh_x002fkg = 12,
	eml__EnergyPerMassUom__lbf_x002eft_x002flbm = 13,
	eml__EnergyPerMassUom__MJ_x002fkg = 14,
	eml__EnergyPerMassUom__MW_x002eh_x002fkg = 15
};
#endif

/* resqml2_0_1ForGsoap.h:9568 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityUom (728)
/* eml:PermittivityUom */
enum eml__PermittivityUom {
	eml__PermittivityUom__F_x002fm = 0,
	eml__PermittivityUom__uF_x002fm = 1
};
#endif

/* resqml2_0_1ForGsoap.h:9583 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentUom (729)
/* eml:ElectromagneticMomentUom */
enum eml__ElectromagneticMomentUom {
	eml__ElectromagneticMomentUom__A_x002em2 = 0
};
#endif

/* resqml2_0_1ForGsoap.h:9594 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceUom (730)
/* eml:ThermalInsulanceUom */
enum eml__ThermalInsulanceUom {
	eml__ThermalInsulanceUom__deltaC_x002em2_x002eh_x002fkcal_x005bth_x005d = 0,
	eml__ThermalInsulanceUom__deltaF_x002eft2_x002eh_x002fBtu_x005bIT_x005d = 1,
	eml__ThermalInsulanceUom__deltaK_x002em2_x002fkW = 2,
	eml__ThermalInsulanceUom__deltaK_x002em2_x002fW = 3
};
#endif

/* resqml2_0_1ForGsoap.h:9617 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaUom (731)
/* eml:PowerPerAreaUom */
enum eml__PowerPerAreaUom {
	eml__PowerPerAreaUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft2_x0029 = 0,
	eml__PowerPerAreaUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft2_x0029 = 1,
	eml__PowerPerAreaUom__cal_x005bth_x005d_x002f_x0028h_x002ecm2_x0029 = 2,
	eml__PowerPerAreaUom__hp_x002fin2 = 3,
	eml__PowerPerAreaUom__hp_x005bhyd_x005d_x002fin2 = 4,
	eml__PowerPerAreaUom__kW_x002fcm2 = 5,
	eml__PowerPerAreaUom__kW_x002fm2 = 6,
	eml__PowerPerAreaUom__mW_x002fm2 = 7,
	eml__PowerPerAreaUom__ucal_x005bth_x005d_x002f_x0028s_x002ecm2_x0029 = 8,
	eml__PowerPerAreaUom__W_x002fcm2 = 9,
	eml__PowerPerAreaUom__W_x002fm2 = 10,
	eml__PowerPerAreaUom__W_x002fmm2 = 11
};
#endif

/* resqml2_0_1ForGsoap.h:9672 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaUom (732)
/* eml:MassPerAreaUom */
enum eml__MassPerAreaUom {
	eml__MassPerAreaUom__0_x002e01_x0020lbm_x002fft2 = 0,
	eml__MassPerAreaUom__kg_x002fm2 = 1,
	eml__MassPerAreaUom__lbm_x002fft2 = 2,
	eml__MassPerAreaUom__Mg_x002fm2 = 3,
	eml__MassPerAreaUom__ton_x005bUS_x005d_x002fft2 = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9699 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceUom (733)
/* eml:IlluminanceUom */
enum eml__IlluminanceUom {
	eml__IlluminanceUom__footcandle = 0,
	eml__IlluminanceUom__klx = 1,
	eml__IlluminanceUom__lm_x002fm2 = 2,
	eml__IlluminanceUom__lx = 3
};
#endif

/* resqml2_0_1ForGsoap.h:9722 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeUom (734)
/* eml:AreaPerVolumeUom */
enum eml__AreaPerVolumeUom {
	eml__AreaPerVolumeUom__1_x002fm = 0,
	eml__AreaPerVolumeUom__b_x002fcm3 = 1,
	eml__AreaPerVolumeUom__cu = 2,
	eml__AreaPerVolumeUom__ft2_x002fin3 = 3,
	eml__AreaPerVolumeUom__m2_x002fcm3 = 4,
	eml__AreaPerVolumeUom__m2_x002fm3 = 5
};
#endif

/* resqml2_0_1ForGsoap.h:9753 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeUom (735)
/* eml:TemperatureIntervalPerTimeUom */
enum eml__TemperatureIntervalPerTimeUom {
	eml__TemperatureIntervalPerTimeUom__deltaC_x002fh = 0,
	eml__TemperatureIntervalPerTimeUom__deltaC_x002fmin = 1,
	eml__TemperatureIntervalPerTimeUom__deltaC_x002fs = 2,
	eml__TemperatureIntervalPerTimeUom__deltaF_x002fh = 3,
	eml__TemperatureIntervalPerTimeUom__deltaF_x002fmin = 4,
	eml__TemperatureIntervalPerTimeUom__deltaF_x002fs = 5,
	eml__TemperatureIntervalPerTimeUom__deltaK_x002fs = 6
};
#endif

/* resqml2_0_1ForGsoap.h:9788 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceUom (736)
/* eml:AmountOfSubstancePerAmountOfSubstanceUom */
enum eml__AmountOfSubstancePerAmountOfSubstanceUom {
	eml__AmountOfSubstancePerAmountOfSubstanceUom___x0025 = 0,
	eml__AmountOfSubstancePerAmountOfSubstanceUom___x0025_x005bmolar_x005d = 1,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__Euc = 2,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__mol_x002fmol = 3,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__nEuc = 4,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__ppk = 5,
	eml__AmountOfSubstancePerAmountOfSubstanceUom__ppm = 6
};
#endif

/* resqml2_0_1ForGsoap.h:9823 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceUom (737)
/* eml:RadianceUom */
enum eml__RadianceUom {
	eml__RadianceUom__W_x002f_x0028m2_x002esr_x0029 = 0
};
#endif

/* resqml2_0_1ForGsoap.h:9834 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateUom (738)
/* eml:HeatFlowRateUom */
enum eml__HeatFlowRateUom {
	eml__HeatFlowRateUom__W = 'W',
	eml__HeatFlowRateUom__1E6_x0020Btu_x005bIT_x005d_x002fh = 'X',
	eml__HeatFlowRateUom__Btu_x005bIT_x005d_x002fh = 'Y',
	eml__HeatFlowRateUom__Btu_x005bIT_x005d_x002fmin = 'Z',
	eml__HeatFlowRateUom__Btu_x005bIT_x005d_x002fs = 91,
	eml__HeatFlowRateUom__cal_x005bth_x005d_x002fh = 92,
	eml__HeatFlowRateUom__EJ_x002fa = 93,
	eml__HeatFlowRateUom__erg_x002fa = 94,
	eml__HeatFlowRateUom__GW = 95,
	eml__HeatFlowRateUom__J_x002fs = 96,
	eml__HeatFlowRateUom__kcal_x005bth_x005d_x002fh = 'a',
	eml__HeatFlowRateUom__kW = 'b',
	eml__HeatFlowRateUom__lbf_x002eft_x002fmin = 'c',
	eml__HeatFlowRateUom__lbf_x002eft_x002fs = 'd',
	eml__HeatFlowRateUom__MJ_x002fa = 'e',
	eml__HeatFlowRateUom__MW = 'f',
	eml__HeatFlowRateUom__mW = 'g',
	eml__HeatFlowRateUom__nW = 'h',
	eml__HeatFlowRateUom__quad_x002fa = 'i',
	eml__HeatFlowRateUom__TJ_x002fa = 'j',
	eml__HeatFlowRateUom__TW = 'k',
	eml__HeatFlowRateUom__ucal_x005bth_x005d_x002fs = 'l',
	eml__HeatFlowRateUom__uW = 'm'
};
#endif

/* resqml2_0_1ForGsoap.h:9933 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentUom (739)
/* eml:DoseEquivalentUom */
enum eml__DoseEquivalentUom {
	eml__DoseEquivalentUom__mrem = 0,
	eml__DoseEquivalentUom__mSv = 1,
	eml__DoseEquivalentUom__rem = 2,
	eml__DoseEquivalentUom__Sv = 3
};
#endif

/* resqml2_0_1ForGsoap.h:9956 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerUom (740)
/* eml:PowerPerPowerUom */
enum eml__PowerPerPowerUom {
	eml__PowerPerPowerUom___x0025 = 0,
	eml__PowerPerPowerUom__Btu_x005bIT_x005d_x002f_x0028hp_x002eh_x0029 = 1,
	eml__PowerPerPowerUom__Euc = 2,
	eml__PowerPerPowerUom__W_x002fkW = 3,
	eml__PowerPerPowerUom__W_x002fW = 4
};
#endif

/* resqml2_0_1ForGsoap.h:9983 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassUom (741)
/* eml:ElectricChargePerMassUom */
enum eml__ElectricChargePerMassUom {
	eml__ElectricChargePerMassUom__A_x002es_x002fkg = 0,
	eml__ElectricChargePerMassUom__C_x002fg = 1,
	eml__ElectricChargePerMassUom__C_x002fkg = 2
};
#endif

/* resqml2_0_1ForGsoap.h:10002 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthUom (742)
/* eml:MassPerVolumePerLengthUom */
enum eml__MassPerVolumePerLengthUom {
	eml__MassPerVolumePerLengthUom__g_x002fcm4 = 0,
	eml__MassPerVolumePerLengthUom__kg_x002fdm4 = 1,
	eml__MassPerVolumePerLengthUom__kg_x002fm4 = 2,
	eml__MassPerVolumePerLengthUom__lbm_x002f_x0028gal_x005bUK_x005d_x002eft_x0029 = 3,
	eml__MassPerVolumePerLengthUom__lbm_x002f_x0028gal_x005bUS_x005d_x002eft_x0029 = 4,
	eml__MassPerVolumePerLengthUom__lbm_x002fft4 = 5,
	eml__MassPerVolumePerLengthUom__Pa_x002es2_x002fm3 = 6
};
#endif

/* resqml2_0_1ForGsoap.h:10037 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthUom (743)
/* eml:MassLengthUom */
enum eml__MassLengthUom {
	eml__MassLengthUom__kg_x002em = 0,
	eml__MassLengthUom__lbm_x002eft = 1
};
#endif

/* resqml2_0_1ForGsoap.h:10052 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeUom (744)
/* eml:ForcePerVolumeUom */
enum eml__ForcePerVolumeUom {
	eml__ForcePerVolumeUom__0_x002e001_x0020psi_x002fft = 0,
	eml__ForcePerVolumeUom__0_x002e01_x0020psi_x002fft = 1,
	eml__ForcePerVolumeUom__atm_x002fft = 2,
	eml__ForcePerVolumeUom__atm_x002fhm = 3,
	eml__ForcePerVolumeUom__atm_x002fm = 4,
	eml__ForcePerVolumeUom__bar_x002fkm = 5,
	eml__ForcePerVolumeUom__bar_x002fm = 6,
	eml__ForcePerVolumeUom__GPa_x002fcm = 7,
	eml__ForcePerVolumeUom__kPa_x002fhm = 8,
	eml__ForcePerVolumeUom__kPa_x002fm = 9,
	eml__ForcePerVolumeUom__lbf_x002fft3 = 10,
	eml__ForcePerVolumeUom__lbf_x002fgal_x005bUS_x005d = 11,
	eml__ForcePerVolumeUom__MPa_x002fm = 12,
	eml__ForcePerVolumeUom__N_x002fm3 = 13,
	eml__ForcePerVolumeUom__Pa_x002fm = 14,
	eml__ForcePerVolumeUom__psi_x002fft = 15,
	eml__ForcePerVolumeUom__psi_x002fm = 16
};
#endif

/* resqml2_0_1ForGsoap.h:10127 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeUom (745)
/* eml:ElectricChargePerVolumeUom */
enum eml__ElectricChargePerVolumeUom {
	eml__ElectricChargePerVolumeUom__A_x002es_x002fm3 = 0,
	eml__ElectricChargePerVolumeUom__C_x002fcm3 = 1,
	eml__ElectricChargePerVolumeUom__C_x002fm3 = 2,
	eml__ElectricChargePerVolumeUom__C_x002fmm3 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:10150 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityUom (746)
/* eml:APIGravityUom */
enum eml__APIGravityUom {
	eml__APIGravityUom__dAPI = 0
};
#endif

/* resqml2_0_1ForGsoap.h:10161 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceUom (747)
/* eml:ReluctanceUom */
enum eml__ReluctanceUom {
	eml__ReluctanceUom__1_x002fH = 0
};
#endif

/* resqml2_0_1ForGsoap.h:10172 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureUom (748)
/* eml:LengthPerTemperatureUom */
enum eml__LengthPerTemperatureUom {
	eml__LengthPerTemperatureUom__ft_x002fdeltaF = 0,
	eml__LengthPerTemperatureUom__m_x002fdeltaK = 1
};
#endif

/* resqml2_0_1ForGsoap.h:10187 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthUom (749)
/* eml:VolumePerTimePerLengthUom */
enum eml__VolumePerTimePerLengthUom {
	eml__VolumePerTimePerLengthUom__1000_x0020ft3_x002f_x0028d_x002eft_x0029 = 0,
	eml__VolumePerTimePerLengthUom__1000_x0020m3_x002f_x0028d_x002em_x0029 = 1,
	eml__VolumePerTimePerLengthUom__1000_x0020m3_x002f_x0028h_x002em_x0029 = 2,
	eml__VolumePerTimePerLengthUom__bbl_x002f_x0028d_x002eft_x0029 = 3,
	eml__VolumePerTimePerLengthUom__ft3_x002f_x0028d_x002eft_x0029 = 4,
	eml__VolumePerTimePerLengthUom__gal_x005bUK_x005d_x002f_x0028h_x002eft_x0029 = 5,
	eml__VolumePerTimePerLengthUom__gal_x005bUK_x005d_x002f_x0028h_x002ein_x0029 = 6,
	eml__VolumePerTimePerLengthUom__gal_x005bUK_x005d_x002f_x0028min_x002eft_x0029 = 7,
	eml__VolumePerTimePerLengthUom__gal_x005bUS_x005d_x002f_x0028h_x002eft_x0029 = 8,
	eml__VolumePerTimePerLengthUom__gal_x005bUS_x005d_x002f_x0028h_x002ein_x0029 = 9,
	eml__VolumePerTimePerLengthUom__gal_x005bUS_x005d_x002f_x0028min_x002eft_x0029 = 10,
	eml__VolumePerTimePerLengthUom__m3_x002f_x0028d_x002em_x0029 = 11,
	eml__VolumePerTimePerLengthUom__m3_x002f_x0028h_x002em_x0029 = 12,
	eml__VolumePerTimePerLengthUom__m3_x002f_x0028s_x002eft_x0029 = 13,
	eml__VolumePerTimePerLengthUom__m3_x002f_x0028s_x002em_x0029 = 14
};
#endif

/* resqml2_0_1ForGsoap.h:10254 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationUom (750)
/* eml:LinearAccelerationUom */
enum eml__LinearAccelerationUom {
	eml__LinearAccelerationUom__cm_x002fs2 = 0,
	eml__LinearAccelerationUom__ft_x002fs2 = 1,
	eml__LinearAccelerationUom__Gal = 2,
	eml__LinearAccelerationUom__gn = 3,
	eml__LinearAccelerationUom__in_x002fs2 = 4,
	eml__LinearAccelerationUom__m_x002fs2 = 5,
	eml__LinearAccelerationUom__mGal = 6,
	eml__LinearAccelerationUom__mgn = 7
};
#endif

/* resqml2_0_1ForGsoap.h:10293 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessUom (751)
/* eml:DimensionlessUom */
enum eml__DimensionlessUom {
	eml__DimensionlessUom___x0025 = 0,
	eml__DimensionlessUom__cEuc = 1,
	eml__DimensionlessUom__dEuc = 2,
	eml__DimensionlessUom__EEuc = 3,
	eml__DimensionlessUom__Euc = 4,
	eml__DimensionlessUom__fEuc = 5,
	eml__DimensionlessUom__GEuc = 6,
	eml__DimensionlessUom__kEuc = 7,
	eml__DimensionlessUom__MEuc = 8,
	eml__DimensionlessUom__mEuc = 9,
	eml__DimensionlessUom__nEuc = 10,
	eml__DimensionlessUom__pEuc = 11,
	eml__DimensionlessUom__ppk = 12,
	eml__DimensionlessUom__ppm = 13,
	eml__DimensionlessUom__TEuc = 14,
	eml__DimensionlessUom__uEuc = 15
};
#endif

/* resqml2_0_1ForGsoap.h:10364 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyUom (752)
/* eml:EnergyUom */
enum eml__EnergyUom {
	eml__EnergyUom__J = 'J',
	eml__EnergyUom__1E6_x0020Btu_x005bIT_x005d = 'K',
	eml__EnergyUom__aJ = 'L',
	eml__EnergyUom__Btu_x005bIT_x005d = 'M',
	eml__EnergyUom__Btu_x005bth_x005d = 'N',
	eml__EnergyUom__Btu_x005bUK_x005d = 'O',
	eml__EnergyUom__cal_x005bIT_x005d = 'P',
	eml__EnergyUom__cal_x005bth_x005d = 'Q',
	eml__EnergyUom__ccal_x005bth_x005d = 'R',
	eml__EnergyUom__ceV = 'S',
	eml__EnergyUom__cJ = 'T',
	eml__EnergyUom__dcal_x005bth_x005d = 'U',
	eml__EnergyUom__deV = 'V',
	eml__EnergyUom__dJ = 'W',
	eml__EnergyUom__Ecal_x005bth_x005d = 'X',
	eml__EnergyUom__EeV = 'Y',
	eml__EnergyUom__EJ = 'Z',
	eml__EnergyUom__erg = 91,
	eml__EnergyUom__eV = 92,
	eml__EnergyUom__fcal_x005bth_x005d = 93,
	eml__EnergyUom__feV = 94,
	eml__EnergyUom__fJ = 95,
	eml__EnergyUom__Gcal_x005bth_x005d = 96,
	eml__EnergyUom__GeV = 'a',
	eml__EnergyUom__GJ = 'b',
	eml__EnergyUom__GW_x002eh = 'c',
	eml__EnergyUom__hp_x002eh = 'd',
	eml__EnergyUom__hp_x005bmetric_x005d_x002eh = 'e',
	eml__EnergyUom__kcal_x005bth_x005d = 'f',
	eml__EnergyUom__keV = 'g',
	eml__EnergyUom__kJ = 'h',
	eml__EnergyUom__kW_x002eh = 'i',
	eml__EnergyUom__Mcal_x005bth_x005d = 'j',
	eml__EnergyUom__mcal_x005bth_x005d = 'k',
	eml__EnergyUom__meV = 'l',
	eml__EnergyUom__MeV = 'm',
	eml__EnergyUom__MJ = 'n',
	eml__EnergyUom__mJ = 'o',
	eml__EnergyUom__MW_x002eh = 'p',
	eml__EnergyUom__ncal_x005bth_x005d = 'q',
	eml__EnergyUom__neV = 'r',
	eml__EnergyUom__nJ = 's',
	eml__EnergyUom__pcal_x005bth_x005d = 't',
	eml__EnergyUom__peV = 'u',
	eml__EnergyUom__pJ = 'v',
	eml__EnergyUom__quad = 'w',
	eml__EnergyUom__Tcal_x005bth_x005d = 'x',
	eml__EnergyUom__TeV = 'y',
	eml__EnergyUom__therm_x005bEC_x005d = 'z',
	eml__EnergyUom__therm_x005bUK_x005d = 123,
	eml__EnergyUom__therm_x005bUS_x005d = 124,
	eml__EnergyUom__TJ = 125,
	eml__EnergyUom__TW_x002eh = 126,
	eml__EnergyUom__ucal_x005bth_x005d = 127,
	eml__EnergyUom__ueV = 128,
	eml__EnergyUom__uJ = 129
};
#endif

/* resqml2_0_1ForGsoap.h:10595 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthUom (753)
/* eml:AnglePerLengthUom */
enum eml__AnglePerLengthUom {
	eml__AnglePerLengthUom__0_x002e01_x0020dega_x002fft = 0,
	eml__AnglePerLengthUom__1_x002f30_x0020dega_x002fft = 1,
	eml__AnglePerLengthUom__1_x002f30_x0020dega_x002fm = 2,
	eml__AnglePerLengthUom__dega_x002fft = 3,
	eml__AnglePerLengthUom__dega_x002fm = 4,
	eml__AnglePerLengthUom__rad_x002fft = 5,
	eml__AnglePerLengthUom__rad_x002fm = 6,
	eml__AnglePerLengthUom__rev_x002fft = 7,
	eml__AnglePerLengthUom__rev_x002fm = 8
};
#endif

/* resqml2_0_1ForGsoap.h:10641 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCoordinateUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCoordinateUom (754)
/* eml:VerticalCoordinateUom */
enum eml__VerticalCoordinateUom {
	eml__VerticalCoordinateUom__m = 'm',
	eml__VerticalCoordinateUom__ft = 'n',
	eml__VerticalCoordinateUom__ftUS = 'o',
	eml__VerticalCoordinateUom__ftBr_x002865_x0029 = 'p'
};
#endif

/* resqml2_0_1ForGsoap.h:10664 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthUom (755)
/* eml:VolumePerLengthUom */
enum eml__VolumePerLengthUom {
	eml__VolumePerLengthUom__0_x002e01_x0020dm3_x002fkm = 0,
	eml__VolumePerLengthUom__0_x002e01_x0020L_x002fkm = 1,
	eml__VolumePerLengthUom__bbl_x002fft = 2,
	eml__VolumePerLengthUom__bbl_x002fin = 3,
	eml__VolumePerLengthUom__bbl_x002fmi = 4,
	eml__VolumePerLengthUom__dm3_x002fm = 5,
	eml__VolumePerLengthUom__ft3_x002fft = 6,
	eml__VolumePerLengthUom__gal_x005bUK_x005d_x002fmi = 7,
	eml__VolumePerLengthUom__gal_x005bUS_x005d_x002fft = 8,
	eml__VolumePerLengthUom__gal_x005bUS_x005d_x002fmi = 9,
	eml__VolumePerLengthUom__in3_x002fft = 10,
	eml__VolumePerLengthUom__L_x002fm = 11,
	eml__VolumePerLengthUom__m3_x002fkm = 12,
	eml__VolumePerLengthUom__m3_x002fm = 13
};
#endif

/* resqml2_0_1ForGsoap.h:10727 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeUom (756)
/* eml:EnergyPerVolumeUom */
enum eml__EnergyPerVolumeUom {
	eml__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fbbl = 0,
	eml__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fft3 = 1,
	eml__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fgal_x005bUK_x005d = 2,
	eml__EnergyPerVolumeUom__Btu_x005bIT_x005d_x002fgal_x005bUS_x005d = 3,
	eml__EnergyPerVolumeUom__cal_x005bth_x005d_x002fcm3 = 4,
	eml__EnergyPerVolumeUom__cal_x005bth_x005d_x002fmL = 5,
	eml__EnergyPerVolumeUom__cal_x005bth_x005d_x002fmm3 = 6,
	eml__EnergyPerVolumeUom__erg_x002fcm3 = 7,
	eml__EnergyPerVolumeUom__erg_x002fm3 = 8,
	eml__EnergyPerVolumeUom__hp_x002eh_x002fbbl = 9,
	eml__EnergyPerVolumeUom__J_x002fdm3 = 10,
	eml__EnergyPerVolumeUom__J_x002fm3 = 11,
	eml__EnergyPerVolumeUom__kcal_x005bth_x005d_x002fcm3 = 12,
	eml__EnergyPerVolumeUom__kcal_x005bth_x005d_x002fm3 = 13,
	eml__EnergyPerVolumeUom__kJ_x002fdm3 = 14,
	eml__EnergyPerVolumeUom__kJ_x002fm3 = 15,
	eml__EnergyPerVolumeUom__kW_x002eh_x002fdm3 = 16,
	eml__EnergyPerVolumeUom__kW_x002eh_x002fm3 = 17,
	eml__EnergyPerVolumeUom__lbf_x002eft_x002fbbl = 18,
	eml__EnergyPerVolumeUom__lbf_x002eft_x002fgal_x005bUS_x005d = 19,
	eml__EnergyPerVolumeUom__MJ_x002fm3 = 20,
	eml__EnergyPerVolumeUom__MW_x002eh_x002fm3 = 21,
	eml__EnergyPerVolumeUom__tonf_x005bUS_x005d_x002emi_x002fbbl = 22
};
#endif

/* resqml2_0_1ForGsoap.h:10826 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityUom (757)
/* eml:MagneticPermeabilityUom */
enum eml__MagneticPermeabilityUom {
	eml__MagneticPermeabilityUom__H_x002fm = 0,
	eml__MagneticPermeabilityUom__uH_x002fm = 1
};
#endif

/* resqml2_0_1ForGsoap.h:10841 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassUom (758)
/* eml:ReciprocalMassUom */
enum eml__ReciprocalMassUom {
	eml__ReciprocalMassUom__1_x002fg = 0,
	eml__ReciprocalMassUom__1_x002fkg = 1,
	eml__ReciprocalMassUom__1_x002flbm = 2
};
#endif

/* resqml2_0_1ForGsoap.h:10860 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityUom (759)
/* eml:DynamicViscosityUom */
enum eml__DynamicViscosityUom {
	eml__DynamicViscosityUom__P = 'P',
	eml__DynamicViscosityUom__cP = 'Q',
	eml__DynamicViscosityUom__dP = 'R',
	eml__DynamicViscosityUom__dyne_x002es_x002fcm2 = 'S',
	eml__DynamicViscosityUom__EP = 'T',
	eml__DynamicViscosityUom__fP = 'U',
	eml__DynamicViscosityUom__GP = 'V',
	eml__DynamicViscosityUom__kgf_x002es_x002fm2 = 'W',
	eml__DynamicViscosityUom__kP = 'X',
	eml__DynamicViscosityUom__lbf_x002es_x002fft2 = 'Y',
	eml__DynamicViscosityUom__lbf_x002es_x002fin2 = 'Z',
	eml__DynamicViscosityUom__mP = 91,
	eml__DynamicViscosityUom__MP = 92,
	eml__DynamicViscosityUom__mPa_x002es = 93,
	eml__DynamicViscosityUom__N_x002es_x002fm2 = 94,
	eml__DynamicViscosityUom__nP = 95,
	eml__DynamicViscosityUom__Pa_x002es = 96,
	eml__DynamicViscosityUom__pP = 'a',
	eml__DynamicViscosityUom__psi_x002es = 'b',
	eml__DynamicViscosityUom__TP = 'c',
	eml__DynamicViscosityUom__uP = 'd'
};
#endif

/* resqml2_0_1ForGsoap.h:10951 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropUom (760)
/* eml:PotentialDifferencePerPowerDropUom */
enum eml__PotentialDifferencePerPowerDropUom {
	eml__PotentialDifferencePerPowerDropUom__V_x002fB = 0,
	eml__PotentialDifferencePerPowerDropUom__V_x002fdB = 1
};
#endif

/* resqml2_0_1ForGsoap.h:10966 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeUom (761)
/* eml:AreaPerTimeUom */
enum eml__AreaPerTimeUom {
	eml__AreaPerTimeUom__cm2_x002fs = 0,
	eml__AreaPerTimeUom__ft2_x002fh = 1,
	eml__AreaPerTimeUom__ft2_x002fs = 2,
	eml__AreaPerTimeUom__in2_x002fs = 3,
	eml__AreaPerTimeUom__m2_x002fd = 4,
	eml__AreaPerTimeUom__m2_x002fh = 5,
	eml__AreaPerTimeUom__m2_x002fs = 6,
	eml__AreaPerTimeUom__mm2_x002fs = 7
};
#endif

/* resqml2_0_1ForGsoap.h:11005 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityUom (762)
/* eml:HeatCapacityUom */
enum eml__HeatCapacityUom {
	eml__HeatCapacityUom__J_x002fdeltaK = 0
};
#endif

/* resqml2_0_1ForGsoap.h:11016 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyUom (763)
/* eml:MolarEnergyUom */
enum eml__MolarEnergyUom {
	eml__MolarEnergyUom__Btu_x005bIT_x005d_x002flbmol = 0,
	eml__MolarEnergyUom__J_x002fmol = 1,
	eml__MolarEnergyUom__kcal_x005bth_x005d_x002fmol = 2,
	eml__MolarEnergyUom__kJ_x002fkmol = 3,
	eml__MolarEnergyUom__MJ_x002fkmol = 4
};
#endif

/* resqml2_0_1ForGsoap.h:11043 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceUom (764)
/* eml:ElectricConductanceUom */
enum eml__ElectricConductanceUom {
	eml__ElectricConductanceUom__S = 'S',
	eml__ElectricConductanceUom__cS = 'T',
	eml__ElectricConductanceUom__dS = 'U',
	eml__ElectricConductanceUom__ES = 'V',
	eml__ElectricConductanceUom__fS = 'W',
	eml__ElectricConductanceUom__GS = 'X',
	eml__ElectricConductanceUom__kS = 'Y',
	eml__ElectricConductanceUom__mS = 'Z',
	eml__ElectricConductanceUom__MS = 91,
	eml__ElectricConductanceUom__nS = 92,
	eml__ElectricConductanceUom__pS = 93,
	eml__ElectricConductanceUom__TS = 94,
	eml__ElectricConductanceUom__uS = 95
};
#endif

/* resqml2_0_1ForGsoap.h:11102 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumUom (765)
/* eml:MomentumUom */
enum eml__MomentumUom {
	eml__MomentumUom__kg_x002em_x002fs = 0,
	eml__MomentumUom__lbm_x002eft_x002fs = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11117 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaUom (766)
/* eml:MassPerTimePerAreaUom */
enum eml__MassPerTimePerAreaUom {
	eml__MassPerTimePerAreaUom__g_x002eft_x002f_x0028cm3_x002es_x0029 = 0,
	eml__MassPerTimePerAreaUom__g_x002em_x002f_x0028cm3_x002es_x0029 = 1,
	eml__MassPerTimePerAreaUom__kg_x002f_x0028m2_x002es_x0029 = 2,
	eml__MassPerTimePerAreaUom__kPa_x002es_x002fm = 3,
	eml__MassPerTimePerAreaUom__lbm_x002f_x0028ft2_x002eh_x0029 = 4,
	eml__MassPerTimePerAreaUom__lbm_x002f_x0028ft2_x002es_x0029 = 5,
	eml__MassPerTimePerAreaUom__MPa_x002es_x002fm = 6
};
#endif

/* resqml2_0_1ForGsoap.h:11152 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeUom (767)
/* eml:PowerPerVolumeUom */
enum eml__PowerPerVolumeUom {
	eml__PowerPerVolumeUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x0029 = 0,
	eml__PowerPerVolumeUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x0029 = 1,
	eml__PowerPerVolumeUom__cal_x005bth_x005d_x002f_x0028h_x002ecm3_x0029 = 2,
	eml__PowerPerVolumeUom__cal_x005bth_x005d_x002f_x0028s_x002ecm3_x0029 = 3,
	eml__PowerPerVolumeUom__hp_x002fft3 = 4,
	eml__PowerPerVolumeUom__kW_x002fm3 = 5,
	eml__PowerPerVolumeUom__uW_x002fm3 = 6,
	eml__PowerPerVolumeUom__W_x002fm3 = 7
};
#endif

/* resqml2_0_1ForGsoap.h:11191 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyUom (768)
/* eml:FrequencyUom */
enum eml__FrequencyUom {
	eml__FrequencyUom__cHz = 0,
	eml__FrequencyUom__dHz = 1,
	eml__FrequencyUom__EHz = 2,
	eml__FrequencyUom__fHz = 3,
	eml__FrequencyUom__GHz = 4,
	eml__FrequencyUom__Hz = 5,
	eml__FrequencyUom__kHz = 6,
	eml__FrequencyUom__mHz = 7,
	eml__FrequencyUom__MHz = 8,
	eml__FrequencyUom__nHz = 9,
	eml__FrequencyUom__pHz = 10,
	eml__FrequencyUom__THz = 11,
	eml__FrequencyUom__uHz = 12
};
#endif

/* resqml2_0_1ForGsoap.h:11250 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityUom (769)
/* eml:LuminousIntensityUom */
enum eml__LuminousIntensityUom {
	eml__LuminousIntensityUom__cd = 0,
	eml__LuminousIntensityUom__kcd = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11265 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseUom (770)
/* eml:AbsorbedDoseUom */
enum eml__AbsorbedDoseUom {
	eml__AbsorbedDoseUom__cGy = 0,
	eml__AbsorbedDoseUom__crd = 1,
	eml__AbsorbedDoseUom__dGy = 2,
	eml__AbsorbedDoseUom__drd = 3,
	eml__AbsorbedDoseUom__EGy = 4,
	eml__AbsorbedDoseUom__Erd = 5,
	eml__AbsorbedDoseUom__fGy = 6,
	eml__AbsorbedDoseUom__frd = 7,
	eml__AbsorbedDoseUom__GGy = 8,
	eml__AbsorbedDoseUom__Grd = 9,
	eml__AbsorbedDoseUom__Gy = 10,
	eml__AbsorbedDoseUom__kGy = 11,
	eml__AbsorbedDoseUom__krd = 12,
	eml__AbsorbedDoseUom__mGy = 13,
	eml__AbsorbedDoseUom__MGy = 14,
	eml__AbsorbedDoseUom__Mrd = 15,
	eml__AbsorbedDoseUom__mrd = 16,
	eml__AbsorbedDoseUom__nGy = 17,
	eml__AbsorbedDoseUom__nrd = 18,
	eml__AbsorbedDoseUom__pGy = 19,
	eml__AbsorbedDoseUom__prd = 20,
	eml__AbsorbedDoseUom__rd = 21,
	eml__AbsorbedDoseUom__TGy = 22,
	eml__AbsorbedDoseUom__Trd = 23,
	eml__AbsorbedDoseUom__uGy = 24,
	eml__AbsorbedDoseUom__urd = 25
};
#endif

/* resqml2_0_1ForGsoap.h:11376 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassUom (771)
/* eml:TimePerMassUom */
enum eml__TimePerMassUom {
	eml__TimePerMassUom__s_x002fkg = 0
};
#endif

/* resqml2_0_1ForGsoap.h:11387 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientUom (772)
/* eml:VolumetricHeatTransferCoefficientUom */
enum eml__VolumetricHeatTransferCoefficientUom {
	eml__VolumetricHeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028h_x002eft3_x002edeltaF_x0029 = 0,
	eml__VolumetricHeatTransferCoefficientUom__Btu_x005bIT_x005d_x002f_x0028s_x002eft3_x002edeltaF_x0029 = 1,
	eml__VolumetricHeatTransferCoefficientUom__kW_x002f_x0028m3_x002edeltaK_x0029 = 2,
	eml__VolumetricHeatTransferCoefficientUom__W_x002f_x0028m3_x002edeltaK_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:11410 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerUom (773)
/* eml:NormalizedPowerUom */
enum eml__NormalizedPowerUom {
	eml__NormalizedPowerUom__B_x002eW = 0,
	eml__NormalizedPowerUom__dB_x002eMW = 1,
	eml__NormalizedPowerUom__dB_x002emW = 2,
	eml__NormalizedPowerUom__dB_x002eW = 3
};
#endif

/* resqml2_0_1ForGsoap.h:11433 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureUom (774)
/* eml:EnergyLengthPerTimeAreaTemperatureUom */
enum eml__EnergyLengthPerTimeAreaTemperatureUom {
	eml__EnergyLengthPerTimeAreaTemperatureUom__Btu_x005bIT_x005d_x002ein_x002f_x0028h_x002eft2_x002edeltaF_x0029 = 0,
	eml__EnergyLengthPerTimeAreaTemperatureUom__J_x002em_x002f_x0028s_x002em2_x002edeltaK_x0029 = 1,
	eml__EnergyLengthPerTimeAreaTemperatureUom__kJ_x002em_x002f_x0028h_x002em2_x002edeltaK_x0029 = 2,
	eml__EnergyLengthPerTimeAreaTemperatureUom__W_x002f_x0028m_x002edeltaK_x0029 = 3
};
#endif

/* resqml2_0_1ForGsoap.h:11456 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeUom (775)
/* eml:PressureTimePerVolumeUom */
enum eml__PressureTimePerVolumeUom {
	eml__PressureTimePerVolumeUom__Pa_x002es_x002fm3 = 0,
	eml__PressureTimePerVolumeUom__psi_x002ed_x002fbbl = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11471 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeUom (776)
/* eml:VolumePerVolumeUom */
enum eml__VolumePerVolumeUom {
	eml__VolumePerVolumeUom___x0025 = 0,
	eml__VolumePerVolumeUom___x0025_x005bvol_x005d = 1,
	eml__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fft3 = 2,
	eml__VolumePerVolumeUom__0_x002e001_x0020bbl_x002fm3 = 3,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fbbl = 4,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUK_x005d_x002fgal_x005bUK_x005d = 5,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fbbl = 6,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fft3 = 7,
	eml__VolumePerVolumeUom__0_x002e001_x0020gal_x005bUS_x005d_x002fgal_x005bUS_x005d = 8,
	eml__VolumePerVolumeUom__0_x002e001_x0020pt_x005bUK_x005d_x002fbbl = 9,
	eml__VolumePerVolumeUom__0_x002e01_x0020bbl_x002fbbl = 10,
	eml__VolumePerVolumeUom__0_x002e1_x0020gal_x005bUS_x005d_x002fbbl = 11,
	eml__VolumePerVolumeUom__0_x002e1_x0020L_x002fbbl = 12,
	eml__VolumePerVolumeUom__0_x002e1_x0020pt_x005bUS_x005d_x002fbbl = 13,
	eml__VolumePerVolumeUom__1000_x0020ft3_x002fbbl = 14,
	eml__VolumePerVolumeUom__1000_x0020m3_x002fm3 = 15,
	eml__VolumePerVolumeUom__1E_6_x0020acre_x002eft_x002fbbl = 16,
	eml__VolumePerVolumeUom__1E_6_x0020bbl_x002fft3 = 17,
	eml__VolumePerVolumeUom__1E_6_x0020bbl_x002fm3 = 18,
	eml__VolumePerVolumeUom__1E6_x0020bbl_x002f_x0028acre_x002eft_x0029 = 19,
	eml__VolumePerVolumeUom__1E6_x0020ft3_x002f_x0028acre_x002eft_x0029 = 20,
	eml__VolumePerVolumeUom__1E6_x0020ft3_x002fbbl = 21,
	eml__VolumePerVolumeUom__bbl_x002f_x0028acre_x002eft_x0029 = 22,
	eml__VolumePerVolumeUom__bbl_x002fbbl = 23,
	eml__VolumePerVolumeUom__bbl_x002fft3 = 24,
	eml__VolumePerVolumeUom__bbl_x002fm3 = 25,
	eml__VolumePerVolumeUom__cEuc = 26,
	eml__VolumePerVolumeUom__cm3_x002fcm3 = 27,
	eml__VolumePerVolumeUom__cm3_x002fL = 28,
	eml__VolumePerVolumeUom__cm3_x002fm3 = 29,
	eml__VolumePerVolumeUom__dm3_x002fm3 = 30,
	eml__VolumePerVolumeUom__Euc = 31,
	eml__VolumePerVolumeUom__ft3_x002fbbl = 32,
	eml__VolumePerVolumeUom__ft3_x002fft3 = 33,
	eml__VolumePerVolumeUom__gal_x005bUK_x005d_x002fft3 = 34,
	eml__VolumePerVolumeUom__gal_x005bUS_x005d_x002fbbl = 35,
	eml__VolumePerVolumeUom__gal_x005bUS_x005d_x002fft3 = 36,
	eml__VolumePerVolumeUom__L_x002fm3 = 37,
	eml__VolumePerVolumeUom__m3_x002f_x0028ha_x002em_x0029 = 38,
	eml__VolumePerVolumeUom__m3_x002fbbl = 39,
	eml__VolumePerVolumeUom__m3_x002fm3 = 40,
	eml__VolumePerVolumeUom__mL_x002fgal_x005bUK_x005d = 41,
	eml__VolumePerVolumeUom__mL_x002fgal_x005bUS_x005d = 42,
	eml__VolumePerVolumeUom__mL_x002fmL = 43,
	eml__VolumePerVolumeUom__ppk = 44,
	eml__VolumePerVolumeUom__ppm = 45,
	eml__VolumePerVolumeUom__ppm_x005bvol_x005d = 46
};
#endif

/* resqml2_0_1ForGsoap.h:11666 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeUom (777)
/* eml:AnglePerVolumeUom */
enum eml__AnglePerVolumeUom {
	eml__AnglePerVolumeUom__rad_x002fft3 = 0,
	eml__AnglePerVolumeUom__rad_x002fm3 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11681 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientUom (778)
/* eml:DiffusionCoefficientUom */
enum eml__DiffusionCoefficientUom {
	eml__DiffusionCoefficientUom__m2_x002fs = 0
};
#endif

/* resqml2_0_1ForGsoap.h:11692 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeUom (779)
/* eml:TimePerTimeUom */
enum eml__TimePerTimeUom {
	eml__TimePerTimeUom___x0025 = 0,
	eml__TimePerTimeUom__Euc = 1,
	eml__TimePerTimeUom__ms_x002fs = 2,
	eml__TimePerTimeUom__s_x002fs = 3
};
#endif

/* resqml2_0_1ForGsoap.h:11715 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeUom (780)
/* eml:EnergyPerMassPerTimeUom */
enum eml__EnergyPerMassPerTimeUom {
	eml__EnergyPerMassPerTimeUom__mrem_x002fh = 0,
	eml__EnergyPerMassPerTimeUom__mSv_x002fh = 1,
	eml__EnergyPerMassPerTimeUom__rem_x002fh = 2,
	eml__EnergyPerMassPerTimeUom__Sv_x002fh = 3,
	eml__EnergyPerMassPerTimeUom__Sv_x002fs = 4
};
#endif

/* resqml2_0_1ForGsoap.h:11742 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassUom (781)
/* eml:VolumePerMassUom */
enum eml__VolumePerMassUom {
	eml__VolumePerMassUom__0_x002e01_x0020L_x002fkg = 0,
	eml__VolumePerMassUom__bbl_x002fton_x005bUK_x005d = 1,
	eml__VolumePerMassUom__bbl_x002fton_x005bUS_x005d = 2,
	eml__VolumePerMassUom__cm3_x002fg = 3,
	eml__VolumePerMassUom__dm3_x002fkg = 4,
	eml__VolumePerMassUom__dm3_x002ft = 5,
	eml__VolumePerMassUom__ft3_x002fkg = 6,
	eml__VolumePerMassUom__ft3_x002flbm = 7,
	eml__VolumePerMassUom__ft3_x002fsack_x005b94lbm_x005d = 8,
	eml__VolumePerMassUom__gal_x005bUK_x005d_x002flbm = 9,
	eml__VolumePerMassUom__gal_x005bUS_x005d_x002flbm = 10,
	eml__VolumePerMassUom__gal_x005bUS_x005d_x002fsack_x005b94lbm_x005d = 11,
	eml__VolumePerMassUom__gal_x005bUS_x005d_x002fton_x005bUK_x005d = 12,
	eml__VolumePerMassUom__gal_x005bUS_x005d_x002fton_x005bUS_x005d = 13,
	eml__VolumePerMassUom__L_x002fkg = 14,
	eml__VolumePerMassUom__L_x002ft = 15,
	eml__VolumePerMassUom__L_x002fton_x005bUK_x005d = 16,
	eml__VolumePerMassUom__m3_x002fg = 17,
	eml__VolumePerMassUom__m3_x002fkg = 18,
	eml__VolumePerMassUom__m3_x002ft = 19,
	eml__VolumePerMassUom__m3_x002fton_x005bUK_x005d = 20,
	eml__VolumePerMassUom__m3_x002fton_x005bUS_x005d = 21
};
#endif

/* resqml2_0_1ForGsoap.h:11837 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthUom (782)
/* eml:TemperatureIntervalPerLengthUom */
enum eml__TemperatureIntervalPerLengthUom {
	eml__TemperatureIntervalPerLengthUom__0_x002e01_x0020deltaF_x002fft = 0,
	eml__TemperatureIntervalPerLengthUom__deltaC_x002fft = 1,
	eml__TemperatureIntervalPerLengthUom__deltaC_x002fhm = 2,
	eml__TemperatureIntervalPerLengthUom__deltaC_x002fkm = 3,
	eml__TemperatureIntervalPerLengthUom__deltaC_x002fm = 4,
	eml__TemperatureIntervalPerLengthUom__deltaF_x002fft = 5,
	eml__TemperatureIntervalPerLengthUom__deltaF_x002fm = 6,
	eml__TemperatureIntervalPerLengthUom__deltaK_x002fkm = 7,
	eml__TemperatureIntervalPerLengthUom__deltaK_x002fm = 8
};
#endif

/* resqml2_0_1ForGsoap.h:11880 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalUom (783)
/* eml:AttenuationPerFrequencyIntervalUom */
enum eml__AttenuationPerFrequencyIntervalUom {
	eml__AttenuationPerFrequencyIntervalUom__B_x002fO = 0,
	eml__AttenuationPerFrequencyIntervalUom__dB_x002fO = 1
};
#endif

/* resqml2_0_1ForGsoap.h:11895 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityUom (784)
/* eml:IsothermalCompressibilityUom */
enum eml__IsothermalCompressibilityUom {
	eml__IsothermalCompressibilityUom__dm3_x002f_x0028kW_x002eh_x0029 = 0,
	eml__IsothermalCompressibilityUom__dm3_x002fMJ = 1,
	eml__IsothermalCompressibilityUom__m3_x002f_x0028kW_x002eh_x0029 = 2,
	eml__IsothermalCompressibilityUom__m3_x002fJ = 3,
	eml__IsothermalCompressibilityUom__mm3_x002fJ = 4,
	eml__IsothermalCompressibilityUom__pt_x005bUK_x005d_x002f_x0028hp_x002eh_x0029 = 5
};
#endif

/* resqml2_0_1ForGsoap.h:11926 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceUom (785)
/* eml:ElectricResistanceUom */
enum eml__ElectricResistanceUom {
	eml__ElectricResistanceUom__cohm = 0,
	eml__ElectricResistanceUom__dohm = 1,
	eml__ElectricResistanceUom__Eohm = 2,
	eml__ElectricResistanceUom__fohm = 3,
	eml__ElectricResistanceUom__Gohm = 4,
	eml__ElectricResistanceUom__kohm = 5,
	eml__ElectricResistanceUom__Mohm = 6,
	eml__ElectricResistanceUom__mohm = 7,
	eml__ElectricResistanceUom__nohm = 8,
	eml__ElectricResistanceUom__ohm = 9,
	eml__ElectricResistanceUom__pohm = 10,
	eml__ElectricResistanceUom__Tohm = 11,
	eml__ElectricResistanceUom__uohm = 12
};
#endif

/* resqml2_0_1ForGsoap.h:11985 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeUom (786)
/* eml:ReciprocalVolumeUom */
enum eml__ReciprocalVolumeUom {
	eml__ReciprocalVolumeUom__1_x002fbbl = 0,
	eml__ReciprocalVolumeUom__1_x002fft3 = 1,
	eml__ReciprocalVolumeUom__1_x002fgal_x005bUK_x005d = 2,
	eml__ReciprocalVolumeUom__1_x002fgal_x005bUS_x005d = 3,
	eml__ReciprocalVolumeUom__1_x002fL = 4,
	eml__ReciprocalVolumeUom__1_x002fm3 = 5
};
#endif

/* resqml2_0_1ForGsoap.h:12016 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureUom (787)
/* eml:PressureUom */
enum eml__PressureUom {
	eml__PressureUom__0_x002e01_x0020lbf_x002fft2 = 0,
	eml__PressureUom__at = 1,
	eml__PressureUom__atm = 2,
	eml__PressureUom__bar = 3,
	eml__PressureUom__cmH2O_x005b4degC_x005d = 4,
	eml__PressureUom__cPa = 5,
	eml__PressureUom__dPa = 6,
	eml__PressureUom__dyne_x002fcm2 = 7,
	eml__PressureUom__EPa = 8,
	eml__PressureUom__fPa = 9,
	eml__PressureUom__GPa = 10,
	eml__PressureUom__hbar = 11,
	eml__PressureUom__inH2O_x005b39degF_x005d = 12,
	eml__PressureUom__inH2O_x005b60degF_x005d = 13,
	eml__PressureUom__inHg_x005b32degF_x005d = 14,
	eml__PressureUom__inHg_x005b60degF_x005d = 15,
	eml__PressureUom__kgf_x002fcm2 = 16,
	eml__PressureUom__kgf_x002fm2 = 17,
	eml__PressureUom__kgf_x002fmm2 = 18,
	eml__PressureUom__kN_x002fm2 = 19,
	eml__PressureUom__kPa = 20,
	eml__PressureUom__kpsi = 21,
	eml__PressureUom__lbf_x002fft2 = 22,
	eml__PressureUom__mbar = 23,
	eml__PressureUom__mmHg_x005b0degC_x005d = 24,
	eml__PressureUom__mPa = 25,
	eml__PressureUom__MPa = 26,
	eml__PressureUom__Mpsi = 27,
	eml__PressureUom__N_x002fm2 = 28,
	eml__PressureUom__N_x002fmm2 = 29,
	eml__PressureUom__nPa = 30,
	eml__PressureUom__Pa = 31,
	eml__PressureUom__pPa = 32,
	eml__PressureUom__psi = 33,
	eml__PressureUom__tonf_x005bUK_x005d_x002fft2 = 34,
	eml__PressureUom__tonf_x005bUS_x005d_x002fft2 = 35,
	eml__PressureUom__tonf_x005bUS_x005d_x002fin2 = 36,
	eml__PressureUom__torr = 37,
	eml__PressureUom__TPa = 38,
	eml__PressureUom__ubar = 39,
	eml__PressureUom__umHg_x005b0degC_x005d = 40,
	eml__PressureUom__uPa = 41,
	eml__PressureUom__upsi = 42
};
#endif

/* resqml2_0_1ForGsoap.h:12195 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaUom (788)
/* eml:AreaPerAreaUom */
enum eml__AreaPerAreaUom {
	eml__AreaPerAreaUom___x0025 = 0,
	eml__AreaPerAreaUom___x0025_x005barea_x005d = 1,
	eml__AreaPerAreaUom__cEuc = 2,
	eml__AreaPerAreaUom__Euc = 3,
	eml__AreaPerAreaUom__in2_x002fft2 = 4,
	eml__AreaPerAreaUom__in2_x002fin2 = 5,
	eml__AreaPerAreaUom__m2_x002fm2 = 6,
	eml__AreaPerAreaUom__mm2_x002fmm2 = 7
};
#endif

/* resqml2_0_1ForGsoap.h:12234 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityUom (789)
/* eml:AngularVelocityUom */
enum eml__AngularVelocityUom {
	eml__AngularVelocityUom__dega_x002fh = 0,
	eml__AngularVelocityUom__dega_x002fmin = 1,
	eml__AngularVelocityUom__dega_x002fs = 2,
	eml__AngularVelocityUom__rad_x002fs = 3,
	eml__AngularVelocityUom__rev_x002fs = 4,
	eml__AngularVelocityUom__rpm = 5
};
#endif

/* resqml2_0_1ForGsoap.h:12265 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeUom (790)
/* eml:TimePerVolumeUom */
enum eml__TimePerVolumeUom {
	eml__TimePerVolumeUom__0_x002e001_x0020d_x002fft3 = 0,
	eml__TimePerVolumeUom__d_x002fbbl = 1,
	eml__TimePerVolumeUom__d_x002fft3 = 2,
	eml__TimePerVolumeUom__d_x002fm3 = 3,
	eml__TimePerVolumeUom__h_x002fft3 = 4,
	eml__TimePerVolumeUom__h_x002fm3 = 5,
	eml__TimePerVolumeUom__s_x002fft3 = 6,
	eml__TimePerVolumeUom__s_x002fL = 7,
	eml__TimePerVolumeUom__s_x002fm3 = 8,
	eml__TimePerVolumeUom__s_x002fqt_x005bUK_x005d = 9,
	eml__TimePerVolumeUom__s_x002fqt_x005bUS_x005d = 10
};
#endif

/* resqml2_0_1ForGsoap.h:12316 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaUom (791)
/* eml:EnergyLengthPerAreaUom */
enum eml__EnergyLengthPerAreaUom {
	eml__EnergyLengthPerAreaUom__J_x002em_x002fm2 = 0,
	eml__EnergyLengthPerAreaUom__kcal_x005bth_x005d_x002em_x002fcm2 = 1
};
#endif

/* resqml2_0_1ForGsoap.h:12331 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthUom (792)
/* eml:ElectricResistancePerLengthUom */
enum eml__ElectricResistancePerLengthUom {
	eml__ElectricResistancePerLengthUom__ohm_x002fm = 0,
	eml__ElectricResistancePerLengthUom__uohm_x002fft = 1,
	eml__ElectricResistancePerLengthUom__uohm_x002fm = 2
};
#endif

/* resqml2_0_1ForGsoap.h:12350 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthUom (793)
/* eml:ForcePerLengthUom */
enum eml__ForcePerLengthUom {
	eml__ForcePerLengthUom__0_x002e01_x0020lbf_x002fft = 0,
	eml__ForcePerLengthUom__1_x002f30_x0020lbf_x002fm = 1,
	eml__ForcePerLengthUom__1_x002f30_x0020N_x002fm = 2,
	eml__ForcePerLengthUom__dyne_x002fcm = 3,
	eml__ForcePerLengthUom__kgf_x002fcm = 4,
	eml__ForcePerLengthUom__kN_x002fm = 5,
	eml__ForcePerLengthUom__lbf_x002fft = 6,
	eml__ForcePerLengthUom__lbf_x002fin = 7,
	eml__ForcePerLengthUom__mN_x002fkm = 8,
	eml__ForcePerLengthUom__mN_x002fm = 9,
	eml__ForcePerLengthUom__N_x002fm = 10,
	eml__ForcePerLengthUom__pdl_x002fcm = 11,
	eml__ForcePerLengthUom__tonf_x005bUK_x005d_x002fft = 12,
	eml__ForcePerLengthUom__tonf_x005bUS_x005d_x002fft = 13
};
#endif

/* resqml2_0_1ForGsoap.h:12413 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureUom (794)
/* eml:ReciprocalPressureUom */
enum eml__ReciprocalPressureUom {
	eml__ReciprocalPressureUom__1_x002fbar = 0,
	eml__ReciprocalPressureUom__1_x002fkPa = 1,
	eml__ReciprocalPressureUom__1_x002fPa = 2,
	eml__ReciprocalPressureUom__1_x002fpPa = 3,
	eml__ReciprocalPressureUom__1_x002fpsi = 4,
	eml__ReciprocalPressureUom__1_x002fupsi = 5
};
#endif

/* resqml2_0_1ForGsoap.h:12444 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureUom (795)
/* eml:LightExposureUom */
enum eml__LightExposureUom {
	eml__LightExposureUom__footcandle_x002es = 0,
	eml__LightExposureUom__lx_x002es = 1
};
#endif

/* resqml2_0_1ForGsoap.h:12459 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaUom (796)
/* eml:EnergyPerAreaUom */
enum eml__EnergyPerAreaUom {
	eml__EnergyPerAreaUom__erg_x002fcm2 = 0,
	eml__EnergyPerAreaUom__J_x002fcm2 = 1,
	eml__EnergyPerAreaUom__J_x002fm2 = 2,
	eml__EnergyPerAreaUom__kgf_x002em_x002fcm2 = 3,
	eml__EnergyPerAreaUom__lbf_x002eft_x002fin2 = 4,
	eml__EnergyPerAreaUom__mJ_x002fcm2 = 5,
	eml__EnergyPerAreaUom__mJ_x002fm2 = 6,
	eml__EnergyPerAreaUom__N_x002fm = 7
};
#endif

/* resqml2_0_1ForGsoap.h:12498 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentUom (797)
/* eml:MagneticDipoleMomentUom */
enum eml__MagneticDipoleMomentUom {
	eml__MagneticDipoleMomentUom__Wb_x002em = 0
};
#endif

/* resqml2_0_1ForGsoap.h:12509 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageUom (798)
/* eml:DigitalStorageUom */
enum eml__DigitalStorageUom {
	eml__DigitalStorageUom__bit = 0,
	eml__DigitalStorageUom__byte = 1,
	eml__DigitalStorageUom__Kibyte = 2,
	eml__DigitalStorageUom__Mibyte = 3
};
#endif

/* resqml2_0_1ForGsoap.h:20006 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__RelatedTimeType_relativePosition (1029)
/* gml:RelatedTimeType-relativePosition */
enum _gml__RelatedTimeType_relativePosition {
	_gml__RelatedTimeType_relativePosition__Before = 0,
	_gml__RelatedTimeType_relativePosition__After = 1,
	_gml__RelatedTimeType_relativePosition__Begins = 2,
	_gml__RelatedTimeType_relativePosition__Ends = 3,
	_gml__RelatedTimeType_relativePosition__During = 4,
	_gml__RelatedTimeType_relativePosition__Equals = 5,
	_gml__RelatedTimeType_relativePosition__Contains = 6,
	_gml__RelatedTimeType_relativePosition__Overlaps = 7,
	_gml__RelatedTimeType_relativePosition__Meets = 8,
	_gml__RelatedTimeType_relativePosition__OverlappedBy = 9,
	_gml__RelatedTimeType_relativePosition__MetBy = 10,
	_gml__RelatedTimeType_relativePosition__BegunBy = 11,
	_gml__RelatedTimeType_relativePosition__EndedBy = 12
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class resqml2__PropertyKindFacet;	/* resqml2_0_1ForGsoap.h:226 */
class resqml2__StringLookup;	/* resqml2_0_1ForGsoap.h:235 */
class resqml2__PatchOfPoints;	/* resqml2_0_1ForGsoap.h:250 */
class resqml2__AbstractPropertyKind;	/* resqml2_0_1ForGsoap.h:280 */
class resqml2__PatchOfValues;	/* resqml2_0_1ForGsoap.h:283 */
class resqml2__AbstractValueArray;	/* resqml2_0_1ForGsoap.h:286 */
class resqml2__PropertyValuesPatch;	/* resqml2_0_1ForGsoap.h:307 */
class resqml2__DoubleLookup;	/* resqml2_0_1ForGsoap.h:319 */
class resqml2__Point3dOffset;	/* resqml2_0_1ForGsoap.h:325 */
class resqml2__AbstractPoint3dArray;	/* resqml2_0_1ForGsoap.h:349 */
class resqml2__AbstractGeometry;	/* resqml2_0_1ForGsoap.h:352 */
class resqml2__ThreePoint3d;	/* resqml2_0_1ForGsoap.h:358 */
class resqml2__AbstractParametricLineArray;	/* resqml2_0_1ForGsoap.h:370 */
class resqml2__ParametricLineIntersections;	/* resqml2_0_1ForGsoap.h:373 */
class resqml2__AbstractSeismicCoordinates;	/* resqml2_0_1ForGsoap.h:391 */
class resqml2__Patch;	/* resqml2_0_1ForGsoap.h:400 */
class resqml2__ElementIndices;	/* resqml2_0_1ForGsoap.h:403 */
class resqml2__RepresentationIdentity;	/* resqml2_0_1ForGsoap.h:415 */
class resqml2__ElementIdentity;	/* resqml2_0_1ForGsoap.h:421 */
class resqml2__PatchOfGeometry;	/* resqml2_0_1ForGsoap.h:427 */
class resqml2__AdditionalGridTopology;	/* resqml2_0_1ForGsoap.h:436 */
class resqml2__CellStratigraphicUnits;	/* resqml2_0_1ForGsoap.h:451 */
class resqml2__SubnodeTopology;	/* resqml2_0_1ForGsoap.h:460 */
class resqml2__SplitFaces;	/* resqml2_0_1ForGsoap.h:463 */
class __resqml2__IjGaps_sequence;	/* resqml2_0_1ForGsoap.h:13484 */
class resqml2__IjGaps;	/* resqml2_0_1ForGsoap.h:469 */
class resqml2__GpGridColumnLayerGrid;	/* resqml2_0_1ForGsoap.h:484 */
class resqml2__ColumnLayerSplitCoordinateLines;	/* resqml2_0_1ForGsoap.h:487 */
class __resqml2__KGaps_sequence;	/* resqml2_0_1ForGsoap.h:13603 */
class resqml2__KGaps;	/* resqml2_0_1ForGsoap.h:493 */
class resqml2__UnstructuredColumnEdges;	/* resqml2_0_1ForGsoap.h:502 */
class resqml2__AdditionalGridPoints;	/* resqml2_0_1ForGsoap.h:505 */
class resqml2__IjSplitColumnEdges;	/* resqml2_0_1ForGsoap.h:508 */
class resqml2__IntervalStratigraphicUnits;	/* resqml2_0_1ForGsoap.h:517 */
class resqml2__Regrid;	/* resqml2_0_1ForGsoap.h:520 */
class resqml2__Activation;	/* resqml2_0_1ForGsoap.h:523 */
class resqml2__ConnectionInterpretations;	/* resqml2_0_1ForGsoap.h:532 */
class resqml2__SplitEdges;	/* resqml2_0_1ForGsoap.h:538 */
class resqml2__CellFluidPhaseUnits;	/* resqml2_0_1ForGsoap.h:541 */
class resqml2__NodesPerCell;	/* resqml2_0_1ForGsoap.h:544 */
class resqml2__Edges;	/* resqml2_0_1ForGsoap.h:550 */
class resqml2__UnstructuredGridHingeNodeFaces;	/* resqml2_0_1ForGsoap.h:574 */
class __resqml2__CellOverlap_sequence;	/* resqml2_0_1ForGsoap.h:14014 */
class resqml2__CellOverlap;	/* resqml2_0_1ForGsoap.h:577 */
class resqml2__ColumnLayerSplitColumnEdges;	/* resqml2_0_1ForGsoap.h:580 */
class __resqml2__OverlapVolume_sequence;	/* resqml2_0_1ForGsoap.h:14089 */
class resqml2__OverlapVolume;	/* resqml2_0_1ForGsoap.h:586 */
class resqml2__Intervals;	/* resqml2_0_1ForGsoap.h:589 */
class resqml2__AbstractParentWindow;	/* resqml2_0_1ForGsoap.h:595 */
class resqml2__TimeInterval;	/* resqml2_0_1ForGsoap.h:604 */
class resqml2__StratigraphicUnitInterpretationIndex;	/* resqml2_0_1ForGsoap.h:613 */
class resqml2__GeologicUnitInterpretationIndex;	/* resqml2_0_1ForGsoap.h:628 */
class resqml2__HorizonInterpretationIndex;	/* resqml2_0_1ForGsoap.h:640 */
class resqml2__AbstractContactInterpretationPart;	/* resqml2_0_1ForGsoap.h:655 */
class resqml2__FaultThrow;	/* resqml2_0_1ForGsoap.h:661 */
class resqml2__RockFluidUnitInterpretationIndex;	/* resqml2_0_1ForGsoap.h:670 */
class resqml2__ChronostratigraphicRank;	/* resqml2_0_1ForGsoap.h:697 */
class resqml2__Point3d;	/* resqml2_0_1ForGsoap.h:724 */
class resqml2__TimeSeriesParentage;	/* resqml2_0_1ForGsoap.h:727 */
class resqml2__TimeIndex;	/* resqml2_0_1ForGsoap.h:733 */
class resqml2__Timestamp;	/* resqml2_0_1ForGsoap.h:736 */
class resqml2__ResqmlJaggedArray;	/* resqml2_0_1ForGsoap.h:742 */
class resqml2__NameValuePair;	/* resqml2_0_1ForGsoap.h:745 */
class resqml2__WellboreTrajectoryParentIntersection;	/* resqml2_0_1ForGsoap.h:760 */
class resqml2__AbstractContactRepresentationPart;	/* resqml2_0_1ForGsoap.h:799 */
class resqml2__VolumeRegion;	/* resqml2_0_1ForGsoap.h:814 */
class resqml2__VolumeShell;	/* resqml2_0_1ForGsoap.h:817 */
class resqml2__PatchBoundaries;	/* resqml2_0_1ForGsoap.h:838 */
class resqml2__OrientedMacroFace;	/* resqml2_0_1ForGsoap.h:853 */
class resqml2__ContactIdentity;	/* resqml2_0_1ForGsoap.h:856 */
class resqml2__WitsmlWellboreReference;	/* resqml2_0_1ForGsoap.h:886 */
class resqml2__ParameterTemplate;	/* resqml2_0_1ForGsoap.h:901 */
class resqml2__AbstractParameterKey;	/* resqml2_0_1ForGsoap.h:913 */
class resqml2__AbstractActivityParameter;	/* resqml2_0_1ForGsoap.h:919 */
class resqml2__StreamlineWellbores;	/* resqml2_0_1ForGsoap.h:934 */
class resqml2__IntervalGridCells;	/* resqml2_0_1ForGsoap.h:937 */
class resqml2__TimeIndices;	/* resqml2_0_1ForGsoap.h:940 */
class eml__CustomData;	/* resqml2_0_1ForGsoap.h:958 */
class eml__Citation;	/* resqml2_0_1ForGsoap.h:961 */
class eml__AbstractObject;	/* resqml2_0_1ForGsoap.h:964 */
class eml__ObjectAlias;	/* resqml2_0_1ForGsoap.h:967 */
class eml__AbstractVerticalCrs;	/* resqml2_0_1ForGsoap.h:985 */
class eml__AbstractProjectedCrs;	/* resqml2_0_1ForGsoap.h:988 */
class eml__Hdf5Dataset;	/* resqml2_0_1ForGsoap.h:1000 */
class eml__DataObjectReference;	/* resqml2_0_1ForGsoap.h:1006 */
class gml__AbstractGMLType;	/* resqml2_0_1ForGsoap.h:1549 */
class gml__ReferenceType;	/* resqml2_0_1ForGsoap.h:1555 */
union _gml__union_TimePrimitivePropertyType;	/* resqml2_0_1ForGsoap.h:15518 */
class __gml__TimePrimitivePropertyType_sequence;	/* resqml2_0_1ForGsoap.h:15507 */
class gml__TimePrimitivePropertyType;	/* resqml2_0_1ForGsoap.h:1573 */
class __gml__EllipsoidalCSPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:15578 */
class gml__EllipsoidalCSPropertyType;	/* resqml2_0_1ForGsoap.h:1576 */
class __gml__CoordinateSystemAxisPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:15639 */
class gml__CoordinateSystemAxisPropertyType;	/* resqml2_0_1ForGsoap.h:1585 */
class __gml__CartesianCSPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:15700 */
class gml__CartesianCSPropertyType;	/* resqml2_0_1ForGsoap.h:1591 */
class __gml__SphericalCSPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:15761 */
class gml__SphericalCSPropertyType;	/* resqml2_0_1ForGsoap.h:1597 */
class __gml__GeodeticDatumPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:15822 */
class gml__GeodeticDatumPropertyType;	/* resqml2_0_1ForGsoap.h:1603 */
class __gml__PrimeMeridianPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:15883 */
class gml__PrimeMeridianPropertyType;	/* resqml2_0_1ForGsoap.h:1612 */
class __gml__EllipsoidPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:15944 */
class gml__EllipsoidPropertyType;	/* resqml2_0_1ForGsoap.h:1624 */
union _gml__union_GeneralConversionPropertyType;	/* resqml2_0_1ForGsoap.h:16017 */
class __gml__GeneralConversionPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16005 */
class gml__GeneralConversionPropertyType;	/* resqml2_0_1ForGsoap.h:1639 */
union _gml__union_CRSPropertyType;	/* resqml2_0_1ForGsoap.h:16084 */
class __gml__CRSPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16073 */
class gml__CRSPropertyType;	/* resqml2_0_1ForGsoap.h:1648 */
class __gml__GeodeticCRSPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16140 */
class gml__GeodeticCRSPropertyType;	/* resqml2_0_1ForGsoap.h:1651 */
class __gml__VerticalCSPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16198 */
class gml__VerticalCSPropertyType;	/* resqml2_0_1ForGsoap.h:1657 */
class __gml__VerticalDatumPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16259 */
class gml__VerticalDatumPropertyType;	/* resqml2_0_1ForGsoap.h:1663 */
class __gml__domainOfValidity_sequence;	/* resqml2_0_1ForGsoap.h:16321 */
class _gml__domainOfValidity;	/* resqml2_0_1ForGsoap.h:1669 */
class _gml__secondDefiningParameter;	/* resqml2_0_1ForGsoap.h:1672 */
union _gml__union_SecondDefiningParameter;	/* resqml2_0_1ForGsoap.h:16413 */
class _gml__SecondDefiningParameter;	/* resqml2_0_1ForGsoap.h:1675 */
union _gml__union_coordinateOperationAccuracy;	/* resqml2_0_1ForGsoap.h:16446 */
class __gml__coordinateOperationAccuracy_sequence;	/* resqml2_0_1ForGsoap.h:16438 */
class _gml__coordinateOperationAccuracy;	/* resqml2_0_1ForGsoap.h:1678 */
union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:16523 */
class __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16515 */
class gmd__EX_USCOREGeographicExtent_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1684 */
class __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16578 */
class gmd__EX_USCORETemporalExtent_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1690 */
class __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16635 */
class gmd__EX_USCOREVerticalExtent_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1696 */
class __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16692 */
class gmd__MD_USCOREIdentifier_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1708 */
class __gmd__CI_USCORECitation_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16749 */
class gmd__CI_USCORECitation_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1714 */
class __gmd__CI_USCOREDate_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16806 */
class gmd__CI_USCOREDate_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1720 */
class __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16863 */
class gmd__CI_USCOREDateTypeCode_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1726 */
class __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16890 */
class gmd__CI_USCOREResponsibleParty_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1729 */
class __gmd__CI_USCOREContact_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:16947 */
class gmd__CI_USCOREContact_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1735 */
class __gmd__CI_USCORETelephone_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17004 */
class gmd__CI_USCORETelephone_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1741 */
class __gmd__CI_USCOREAddress_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17061 */
class gmd__CI_USCOREAddress_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1747 */
class __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17118 */
class gmd__CI_USCOREOnlineResource_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1753 */
class __gmd__URL_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17175 */
class gmd__URL_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1759 */
class __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17202 */
class gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1762 */
class __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17229 */
class gmd__CI_USCORERoleCode_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1765 */
class __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17256 */
class gmd__CI_USCOREPresentationFormCode_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1768 */
class __gmd__CI_USCORESeries_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17283 */
class gmd__CI_USCORESeries_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1771 */
class __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17340 */
class gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1777 */
union _gmd__union_DQ_USCOREResult_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:17375 */
class __gmd__DQ_USCOREResult_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17367 */
class gmd__DQ_USCOREResult_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1780 */
union _gts__union_TM_USCOREPrimitive_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:17449 */
class __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17438 */
class gts__TM_USCOREPrimitive_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1786 */
class gco__AbstractObject_USCOREType;	/* resqml2_0_1ForGsoap.h:1789 */
union _gco__union_CharacterString_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:17565 */
class __gco__CharacterString_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17536 */
class gco__CharacterString_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1792 */
class __gco__Boolean_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17590 */
class gco__Boolean_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1795 */
class __gco__Real_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17617 */
class gco__Real_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1798 */
union _gco__union_Date_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:17652 */
class gco__Date_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1801 */
class __gco__DateTime_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17675 */
class gco__DateTime_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1807 */
union _gsr__union_SC_USCORECRS_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:17721 */
class __gsr__SC_USCORECRS_USCOREPropertyType_sequence;	/* resqml2_0_1ForGsoap.h:17710 */
class gsr__SC_USCORECRS_USCOREPropertyType;	/* resqml2_0_1ForGsoap.h:1810 */
class ptm__standardEnergisticsPropertyTypeSet;	/* resqml2_0_1ForGsoap.h:1813 */
class ptm__standardEnergisticsPropertyType;	/* resqml2_0_1ForGsoap.h:1816 */
class ptm__equivalentPropertyType;	/* resqml2_0_1ForGsoap.h:1819 */
class resqml2__AbstractDoubleArray;	/* resqml2_0_1ForGsoap.h:262 */
class resqml2__StringHdf5Array;	/* resqml2_0_1ForGsoap.h:274 */
class resqml2__AbstractIntegerArray;	/* resqml2_0_1ForGsoap.h:301 */
class resqml2__AbstractBooleanArray;	/* resqml2_0_1ForGsoap.h:304 */
class resqml2__StandardPropertyKind;	/* resqml2_0_1ForGsoap.h:310 */
class resqml2__LocalPropertyKind;	/* resqml2_0_1ForGsoap.h:316 */
class resqml2__Point2dHdf5Array;	/* resqml2_0_1ForGsoap.h:328 */
class resqml2__ParametricLineFromRepresentationLatticeArray;	/* resqml2_0_1ForGsoap.h:334 */
class resqml2__Point3dLatticeArray;	/* resqml2_0_1ForGsoap.h:337 */
class resqml2__Point3dZValueArray;	/* resqml2_0_1ForGsoap.h:340 */
class resqml2__PointGeometry;	/* resqml2_0_1ForGsoap.h:346 */
class resqml2__Point3dHdf5Array;	/* resqml2_0_1ForGsoap.h:355 */
class resqml2__ParametricLineArray;	/* resqml2_0_1ForGsoap.h:364 */
class resqml2__Point3dParametricArray;	/* resqml2_0_1ForGsoap.h:367 */
class resqml2__AbstractPlaneGeometry;	/* resqml2_0_1ForGsoap.h:379 */
class resqml2__AbstractParametricLineGeometry;	/* resqml2_0_1ForGsoap.h:382 */
class resqml2__Point3dFromRepresentationLatticeArray;	/* resqml2_0_1ForGsoap.h:385 */
class resqml2__Seismic3dCoordinates;	/* resqml2_0_1ForGsoap.h:388 */
class resqml2__Seismic2dCoordinates;	/* resqml2_0_1ForGsoap.h:394 */
class resqml2__Patch1d;	/* resqml2_0_1ForGsoap.h:397 */
class resqml2__SplitNodePatch;	/* resqml2_0_1ForGsoap.h:442 */
class resqml2__IjkParentWindow;	/* resqml2_0_1ForGsoap.h:445 */
class resqml2__ColumnLayerParentWindow;	/* resqml2_0_1ForGsoap.h:475 */
class resqml2__UnstructuredSubnodeTopology;	/* resqml2_0_1ForGsoap.h:478 */
class resqml2__GpGridUnstructuredColumnLayerGridPatch;	/* resqml2_0_1ForGsoap.h:481 */
class resqml2__SubnodePatch;	/* resqml2_0_1ForGsoap.h:496 */
class resqml2__ColumnLayerSubnodeTopology;	/* resqml2_0_1ForGsoap.h:499 */
class resqml2__TruncationCellPatch;	/* resqml2_0_1ForGsoap.h:511 */
class resqml2__GpGridUnstructuredGridPatch;	/* resqml2_0_1ForGsoap.h:514 */
class resqml2__CellParentWindow;	/* resqml2_0_1ForGsoap.h:556 */
class resqml2__GpGridIjkGridPatch;	/* resqml2_0_1ForGsoap.h:562 */
class resqml2__BinaryContactInterpretationPart;	/* resqml2_0_1ForGsoap.h:610 */
class resqml2__ContactElementReference;	/* resqml2_0_1ForGsoap.h:616 */
class resqml2__MultipleContactInterpretationPart;	/* resqml2_0_1ForGsoap.h:637 */
class resqml2__NonSealedContactRepresentationPart;	/* resqml2_0_1ForGsoap.h:787 */
class resqml2__SealedContactRepresentationPart;	/* resqml2_0_1ForGsoap.h:790 */
class resqml2__Grid2dPatch;	/* resqml2_0_1ForGsoap.h:844 */
class resqml2__PolylineSetPatch;	/* resqml2_0_1ForGsoap.h:850 */
class resqml2__ContactRepresentationReference;	/* resqml2_0_1ForGsoap.h:859 */
class resqml2__DataObjectParameter;	/* resqml2_0_1ForGsoap.h:889 */
class resqml2__ObjectParameterKey;	/* resqml2_0_1ForGsoap.h:892 */
class resqml2__StringParameter;	/* resqml2_0_1ForGsoap.h:898 */
class resqml2__IntegerQuantityParameter;	/* resqml2_0_1ForGsoap.h:904 */
class resqml2__TimeIndexParameterKey;	/* resqml2_0_1ForGsoap.h:907 */
class resqml2__FloatingPointQuantityParameter;	/* resqml2_0_1ForGsoap.h:910 */
class resqml2__TimeIndexParameter;	/* resqml2_0_1ForGsoap.h:916 */
class resqml2__StreamlinePolylineSetPatch;	/* resqml2_0_1ForGsoap.h:925 */
class eml__AbstractCitedDataObject;	/* resqml2_0_1ForGsoap.h:955 */
class eml__VerticalCrsEpsgCode;	/* resqml2_0_1ForGsoap.h:970 */
class eml__GmlVerticalCrsDefinition;	/* resqml2_0_1ForGsoap.h:973 */
class eml__VerticalUnknownCrs;	/* resqml2_0_1ForGsoap.h:976 */
class eml__ProjectedCrsEpsgCode;	/* resqml2_0_1ForGsoap.h:991 */
class eml__GmlProjectedCrsDefinition;	/* resqml2_0_1ForGsoap.h:994 */
class eml__ProjectedUnknownCrs;	/* resqml2_0_1ForGsoap.h:997 */
class gml__DefinitionBaseType;	/* resqml2_0_1ForGsoap.h:1546 */
class gml__StringOrRefType;	/* resqml2_0_1ForGsoap.h:1552 */
class gml__CodeType;	/* resqml2_0_1ForGsoap.h:1561 */
class gml__AbstractTimeObjectType;	/* resqml2_0_1ForGsoap.h:1567 */
class gml__RelatedTimeType;	/* resqml2_0_1ForGsoap.h:1570 */
class gml__MeasureType;	/* resqml2_0_1ForGsoap.h:1621 */
class gmd__EX_USCOREExtent_USCOREType;	/* resqml2_0_1ForGsoap.h:1681 */
class gmd__AbstractEX_USCOREGeographicExtent_USCOREType;	/* resqml2_0_1ForGsoap.h:1687 */
class gmd__EX_USCORETemporalExtent_USCOREType;	/* resqml2_0_1ForGsoap.h:1693 */
class gmd__EX_USCOREVerticalExtent_USCOREType;	/* resqml2_0_1ForGsoap.h:1699 */
class gmd__AbstractDQ_USCOREElement_USCOREType;	/* resqml2_0_1ForGsoap.h:1705 */
class gmd__MD_USCOREIdentifier_USCOREType;	/* resqml2_0_1ForGsoap.h:1711 */
class gmd__CI_USCORECitation_USCOREType;	/* resqml2_0_1ForGsoap.h:1717 */
class gmd__CI_USCOREDate_USCOREType;	/* resqml2_0_1ForGsoap.h:1723 */
class gmd__CI_USCOREResponsibleParty_USCOREType;	/* resqml2_0_1ForGsoap.h:1732 */
class gmd__CI_USCOREContact_USCOREType;	/* resqml2_0_1ForGsoap.h:1738 */
class gmd__CI_USCORETelephone_USCOREType;	/* resqml2_0_1ForGsoap.h:1744 */
class gmd__CI_USCOREAddress_USCOREType;	/* resqml2_0_1ForGsoap.h:1750 */
class gmd__CI_USCOREOnlineResource_USCOREType;	/* resqml2_0_1ForGsoap.h:1756 */
class gmd__CI_USCORESeries_USCOREType;	/* resqml2_0_1ForGsoap.h:1774 */
class gmd__AbstractDQ_USCOREResult_USCOREType;	/* resqml2_0_1ForGsoap.h:1783 */
class gco__CodeListValue_USCOREType;	/* resqml2_0_1ForGsoap.h:1804 */
class resqml2__IntegerArrayFromBooleanMaskArray;	/* resqml2_0_1ForGsoap.h:211 */
class resqml2__BooleanArrayFromIndexArray;	/* resqml2_0_1ForGsoap.h:214 */
class resqml2__BooleanConstantArray;	/* resqml2_0_1ForGsoap.h:217 */
class resqml2__IntegerConstantArray;	/* resqml2_0_1ForGsoap.h:220 */
class resqml2__IntegerHdf5Array;	/* resqml2_0_1ForGsoap.h:229 */
class resqml2__DoubleLatticeArray;	/* resqml2_0_1ForGsoap.h:241 */
class resqml2__DoubleConstantArray;	/* resqml2_0_1ForGsoap.h:244 */
class resqml2__DoubleHdf5Array;	/* resqml2_0_1ForGsoap.h:247 */
class resqml2__IntegerLatticeArray;	/* resqml2_0_1ForGsoap.h:265 */
class resqml2__BooleanHdf5Array;	/* resqml2_0_1ForGsoap.h:277 */
class resqml2__IntegerRangeArray;	/* resqml2_0_1ForGsoap.h:292 */
class resqml2__BooleanArrayFromDiscretePropertyArray;	/* resqml2_0_1ForGsoap.h:322 */
class resqml2__ParametricLineGeometry;	/* resqml2_0_1ForGsoap.h:331 */
class resqml2__HorizontalPlaneGeometry;	/* resqml2_0_1ForGsoap.h:343 */
class resqml2__ParametricLineFromRepresentationGeometry;	/* resqml2_0_1ForGsoap.h:361 */
class resqml2__TiltedPlaneGeometry;	/* resqml2_0_1ForGsoap.h:376 */
class resqml2__SubRepresentationPatch;	/* resqml2_0_1ForGsoap.h:406 */
class resqml2__ColumnSubnodePatch;	/* resqml2_0_1ForGsoap.h:448 */
class resqml2__UniformSubnodePatch;	/* resqml2_0_1ForGsoap.h:490 */
class resqml2__AbstractGridGeometry;	/* resqml2_0_1ForGsoap.h:571 */
class resqml2__VariableSubnodePatch;	/* resqml2_0_1ForGsoap.h:583 */
class resqml2__AbstractResqmlDataObject;	/* resqml2_0_1ForGsoap.h:754 */
class resqml2__ContactPatch;	/* resqml2_0_1ForGsoap.h:793 */
class resqml2__EdgePatch;	/* resqml2_0_1ForGsoap.h:811 */
class resqml2__NodePatch;	/* resqml2_0_1ForGsoap.h:823 */
class resqml2__TrianglePatch;	/* resqml2_0_1ForGsoap.h:829 */
class eml__ProjectedCrs;	/* resqml2_0_1ForGsoap.h:979 */
class eml__VerticalCrs;	/* resqml2_0_1ForGsoap.h:982 */
class eml__obj_USCOREEpcExternalPartReference;	/* resqml2_0_1ForGsoap.h:1003 */
class eml__PressureSquaredMeasure;	/* resqml2_0_1ForGsoap.h:1009 */
class eml__ForceLengthPerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1012 */
class eml__AmountOfSubstancePerTimePerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1015 */
class eml__VolumePerTimePerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1018 */
class eml__LengthPerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1021 */
class eml__TemperatureIntervalMeasure;	/* resqml2_0_1ForGsoap.h:1024 */
class eml__VolumePerTimePerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1027 */
class eml__VolumePerTimePerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1030 */
class eml__PermeabilityLengthMeasure;	/* resqml2_0_1ForGsoap.h:1033 */
class eml__ThermalInsulanceMeasure;	/* resqml2_0_1ForGsoap.h:1036 */
class eml__ForceAreaMeasure;	/* resqml2_0_1ForGsoap.h:1039 */
class eml__EnergyMeasure;	/* resqml2_0_1ForGsoap.h:1042 */
class eml__IlluminanceMeasure;	/* resqml2_0_1ForGsoap.h:1045 */
class eml__ForceMeasure;	/* resqml2_0_1ForGsoap.h:1048 */
class eml__RadiantIntensityMeasure;	/* resqml2_0_1ForGsoap.h:1051 */
class eml__PowerPerPowerMeasure;	/* resqml2_0_1ForGsoap.h:1054 */
class eml__DimensionlessMeasure;	/* resqml2_0_1ForGsoap.h:1057 */
class eml__HeatTransferCoefficientMeasure;	/* resqml2_0_1ForGsoap.h:1060 */
class eml__APINeutronMeasure;	/* resqml2_0_1ForGsoap.h:1063 */
class eml__MagneticVectorPotentialMeasure;	/* resqml2_0_1ForGsoap.h:1066 */
class eml__LinearAccelerationMeasure;	/* resqml2_0_1ForGsoap.h:1069 */
class eml__VolumePerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1072 */
class eml__MagneticFluxMeasure;	/* resqml2_0_1ForGsoap.h:1075 */
class eml__VolumetricThermalExpansionMeasure;	/* resqml2_0_1ForGsoap.h:1078 */
class eml__HeatFlowRateMeasure;	/* resqml2_0_1ForGsoap.h:1081 */
class eml__MassPerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1084 */
class eml__VolumePerMassMeasure;	/* resqml2_0_1ForGsoap.h:1087 */
class eml__MolarVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1090 */
class eml__ElectricConductanceMeasure;	/* resqml2_0_1ForGsoap.h:1093 */
class eml__ReciprocalPressureMeasure;	/* resqml2_0_1ForGsoap.h:1096 */
class eml__AreaPerAmountOfSubstanceMeasure;	/* resqml2_0_1ForGsoap.h:1099 */
class eml__LengthMeasure;	/* resqml2_0_1ForGsoap.h:1102 */
class eml__MassPerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1105 */
class eml__TemperatureIntervalPerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1108 */
class eml__AmountOfSubstancePerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1111 */
class eml__AmountOfSubstanceMeasure;	/* resqml2_0_1ForGsoap.h:1114 */
class eml__TimePerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1117 */
class eml__ReciprocalMassTimeMeasure;	/* resqml2_0_1ForGsoap.h:1120 */
class eml__ReciprocalVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1123 */
class eml__ForcePerForceMeasure;	/* resqml2_0_1ForGsoap.h:1126 */
class eml__LinearThermalExpansionMeasure;	/* resqml2_0_1ForGsoap.h:1129 */
class eml__EnergyPerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1132 */
class eml__TemperatureIntervalPerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1135 */
class eml__ThermalConductanceMeasure;	/* resqml2_0_1ForGsoap.h:1138 */
class eml__SolidAngleMeasure;	/* resqml2_0_1ForGsoap.h:1141 */
class eml__EnergyLengthPerTimeAreaTemperatureMeasure;	/* resqml2_0_1ForGsoap.h:1144 */
class eml__PowerMeasure;	/* resqml2_0_1ForGsoap.h:1147 */
class eml__VolumePerRotationMeasure;	/* resqml2_0_1ForGsoap.h:1150 */
class eml__ElectricChargePerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1153 */
class eml__LightExposureMeasure;	/* resqml2_0_1ForGsoap.h:1156 */
class eml__ElectricCurrentMeasure;	/* resqml2_0_1ForGsoap.h:1159 */
class eml__LuminousFluxMeasure;	/* resqml2_0_1ForGsoap.h:1162 */
class eml__HeatCapacityMeasure;	/* resqml2_0_1ForGsoap.h:1165 */
class eml__ElectricResistancePerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1168 */
class eml__AbsorbedDoseMeasure;	/* resqml2_0_1ForGsoap.h:1171 */
class eml__TemperatureIntervalPerPressureMeasure;	/* resqml2_0_1ForGsoap.h:1174 */
class eml__AttenuationPerFrequencyIntervalMeasure;	/* resqml2_0_1ForGsoap.h:1177 */
class eml__ThermalResistanceMeasure;	/* resqml2_0_1ForGsoap.h:1180 */
class eml__AnglePerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1183 */
class eml__LengthPerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1186 */
class eml__MassPerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1189 */
class eml__EnergyPerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1192 */
class eml__AreaPerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1195 */
class eml__ReluctanceMeasure;	/* resqml2_0_1ForGsoap.h:1198 */
class eml__ThermodynamicTemperatureMeasure;	/* resqml2_0_1ForGsoap.h:1201 */
class eml__PermittivityMeasure;	/* resqml2_0_1ForGsoap.h:1204 */
class eml__PressureTimePerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1207 */
class eml__DipoleMomentMeasure;	/* resqml2_0_1ForGsoap.h:1210 */
class eml__RadianceMeasure;	/* resqml2_0_1ForGsoap.h:1213 */
class eml__AreaPerMassMeasure;	/* resqml2_0_1ForGsoap.h:1216 */
class eml__EnergyPerMassPerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1219 */
class eml__ElectricCurrentDensityMeasure;	/* resqml2_0_1ForGsoap.h:1222 */
class eml__MassPerMassMeasure;	/* resqml2_0_1ForGsoap.h:1225 */
class eml__DataTransferSpeedMeasure;	/* resqml2_0_1ForGsoap.h:1228 */
class eml__MagneticDipoleMomentMeasure;	/* resqml2_0_1ForGsoap.h:1231 */
class eml__MassPerEnergyMeasure;	/* resqml2_0_1ForGsoap.h:1234 */
class eml__MagneticPermeabilityMeasure;	/* resqml2_0_1ForGsoap.h:1237 */
class eml__APIGravityMeasure;	/* resqml2_0_1ForGsoap.h:1240 */
class eml__VolumePerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1243 */
class eml__VolumeMeasure;	/* resqml2_0_1ForGsoap.h:1246 */
class eml__VolumePerTimePerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1249 */
class eml__VolumePerTimePerPressureMeasure;	/* resqml2_0_1ForGsoap.h:1252 */
class eml__TimeMeasure;	/* resqml2_0_1ForGsoap.h:1255 */
class eml__MomentOfForceMeasure;	/* resqml2_0_1ForGsoap.h:1258 */
class eml__LuminanceMeasure;	/* resqml2_0_1ForGsoap.h:1261 */
class eml__ForcePerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1264 */
class eml__MolarHeatCapacityMeasure;	/* resqml2_0_1ForGsoap.h:1267 */
class eml__DigitalStorageMeasure;	/* resqml2_0_1ForGsoap.h:1270 */
class eml__ElectricChargeMeasure;	/* resqml2_0_1ForGsoap.h:1273 */
class eml__LuminousIntensityMeasure;	/* resqml2_0_1ForGsoap.h:1276 */
class eml__MolarEnergyMeasure;	/* resqml2_0_1ForGsoap.h:1279 */
class eml__LengthPerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1282 */
class eml__SecondMomentOfAreaMeasure;	/* resqml2_0_1ForGsoap.h:1285 */
class eml__MagneticFluxDensityMeasure;	/* resqml2_0_1ForGsoap.h:1288 */
class eml__VolumePerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1291 */
class eml__QuantityOfLightMeasure;	/* resqml2_0_1ForGsoap.h:1294 */
class eml__LuminousEfficacyMeasure;	/* resqml2_0_1ForGsoap.h:1297 */
class eml__AreaPerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1300 */
class eml__VolumeFlowRatePerVolumeFlowRateMeasure;	/* resqml2_0_1ForGsoap.h:1303 */
class eml__MomentumMeasure;	/* resqml2_0_1ForGsoap.h:1306 */
class eml__PowerPerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1309 */
class eml__ThermalDiffusivityMeasure;	/* resqml2_0_1ForGsoap.h:1312 */
class eml__LogarithmicPowerRatioPerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1315 */
class eml__ReciprocalTimeMeasure;	/* resqml2_0_1ForGsoap.h:1318 */
class eml__SpecificHeatCapacityMeasure;	/* resqml2_0_1ForGsoap.h:1321 */
class eml__PotentialDifferencePerPowerDropMeasure;	/* resqml2_0_1ForGsoap.h:1324 */
class eml__MomentOfInertiaMeasure;	/* resqml2_0_1ForGsoap.h:1327 */
class eml__MassPerTimePerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1330 */
class eml__MolecularWeightMeasure;	/* resqml2_0_1ForGsoap.h:1333 */
class eml__ActivityOfRadioactivityMeasure;	/* resqml2_0_1ForGsoap.h:1336 */
class eml__SignalingEventPerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1339 */
class eml__FrequencyMeasure;	/* resqml2_0_1ForGsoap.h:1342 */
class eml__FrequencyIntervalMeasure;	/* resqml2_0_1ForGsoap.h:1345 */
class eml__CapacitanceMeasure;	/* resqml2_0_1ForGsoap.h:1348 */
class eml__ElectricalResistivityMeasure;	/* resqml2_0_1ForGsoap.h:1351 */
class eml__MassLengthMeasure;	/* resqml2_0_1ForGsoap.h:1354 */
class eml__ReciprocalAreaMeasure;	/* resqml2_0_1ForGsoap.h:1357 */
class eml__KinematicViscosityMeasure;	/* resqml2_0_1ForGsoap.h:1360 */
class eml__InductanceMeasure;	/* resqml2_0_1ForGsoap.h:1363 */
class eml__TimePerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1366 */
class eml__ElectromagneticMomentMeasure;	/* resqml2_0_1ForGsoap.h:1369 */
class eml__EnergyPerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1372 */
class eml__ElectricChargePerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1375 */
class eml__VolumetricHeatTransferCoefficientMeasure;	/* resqml2_0_1ForGsoap.h:1378 */
class eml__PressurePerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1381 */
class eml__TimePerMassMeasure;	/* resqml2_0_1ForGsoap.h:1384 */
class eml__ReciprocalLengthMeasure;	/* resqml2_0_1ForGsoap.h:1387 */
class eml__DynamicViscosityMeasure;	/* resqml2_0_1ForGsoap.h:1390 */
class eml__ReciprocalElectricPotentialDifferenceMeasure;	/* resqml2_0_1ForGsoap.h:1393 */
class eml__ElectricChargePerMassMeasure;	/* resqml2_0_1ForGsoap.h:1396 */
class eml__APIGammaRayMeasure;	/* resqml2_0_1ForGsoap.h:1399 */
class eml__DiffusionCoefficientMeasure;	/* resqml2_0_1ForGsoap.h:1402 */
class eml__ElectricPotentialDifferenceMeasure;	/* resqml2_0_1ForGsoap.h:1405 */
class eml__IsothermalCompressibilityMeasure;	/* resqml2_0_1ForGsoap.h:1408 */
class eml__MassPerVolumePerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1411 */
class eml__PressurePerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1414 */
class eml__ForcePerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1417 */
class eml__AmountOfSubstancePerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1420 */
class eml__LengthPerTemperatureMeasure;	/* resqml2_0_1ForGsoap.h:1423 */
class eml__VolumePerTimeLengthMeasure;	/* resqml2_0_1ForGsoap.h:1426 */
class eml__PressureSquaredPerForceTimePerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1429 */
class eml__AnglePerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1432 */
class eml__LengthPerPressureMeasure;	/* resqml2_0_1ForGsoap.h:1435 */
class eml__ThermalConductivityMeasure;	/* resqml2_0_1ForGsoap.h:1438 */
class eml__MassMeasure;	/* resqml2_0_1ForGsoap.h:1441 */
class eml__NormalizedPowerMeasure;	/* resqml2_0_1ForGsoap.h:1444 */
class eml__LogarithmicPowerRatioMeasure;	/* resqml2_0_1ForGsoap.h:1447 */
class eml__AngularAccelerationMeasure;	/* resqml2_0_1ForGsoap.h:1450 */
class eml__ReciprocalMassMeasure;	/* resqml2_0_1ForGsoap.h:1453 */
class eml__ReciprocalForceMeasure;	/* resqml2_0_1ForGsoap.h:1456 */
class eml__PlaneAngleMeasure;	/* resqml2_0_1ForGsoap.h:1459 */
class eml__EnergyLengthPerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1462 */
class eml__EnergyPerMassMeasure;	/* resqml2_0_1ForGsoap.h:1465 */
class eml__AngularVelocityMeasure;	/* resqml2_0_1ForGsoap.h:1468 */
class eml__ElectricConductivityMeasure;	/* resqml2_0_1ForGsoap.h:1471 */
class eml__AmountOfSubstancePerAmountOfSubstanceMeasure;	/* resqml2_0_1ForGsoap.h:1474 */
class eml__ElectricFieldStrengthMeasure;	/* resqml2_0_1ForGsoap.h:1477 */
class eml__PowerPerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1480 */
class eml__MagneticFluxDensityPerLengthMeasure;	/* resqml2_0_1ForGsoap.h:1483 */
class eml__PressureMeasure;	/* resqml2_0_1ForGsoap.h:1486 */
class eml__VolumePerTimePerPressureLengthMeasure;	/* resqml2_0_1ForGsoap.h:1489 */
class eml__MagneticFieldStrengthMeasure;	/* resqml2_0_1ForGsoap.h:1492 */
class eml__PermeabilityRockMeasure;	/* resqml2_0_1ForGsoap.h:1495 */
class eml__DoseEquivalentMeasure;	/* resqml2_0_1ForGsoap.h:1498 */
class eml__MassPerTimePerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1501 */
class eml__VolumePerPressureMeasure;	/* resqml2_0_1ForGsoap.h:1504 */
class eml__MassPerAreaMeasure;	/* resqml2_0_1ForGsoap.h:1507 */
class eml__AmountOfSubstancePerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1510 */
class eml__TimePerTimeMeasure;	/* resqml2_0_1ForGsoap.h:1513 */
class eml__AreaPerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1516 */
class eml__ElectricResistanceMeasure;	/* resqml2_0_1ForGsoap.h:1519 */
class eml__VolumePerVolumeMeasure;	/* resqml2_0_1ForGsoap.h:1522 */
class eml__AreaMeasure;	/* resqml2_0_1ForGsoap.h:1525 */
class eml__LengthPerMassMeasure;	/* resqml2_0_1ForGsoap.h:1528 */
class eml__MobilityMeasure;	/* resqml2_0_1ForGsoap.h:1531 */
class gml__DefinitionType;	/* resqml2_0_1ForGsoap.h:1543 */
class gml__CodeWithAuthorityType;	/* resqml2_0_1ForGsoap.h:1558 */
class gml__AbstractTimePrimitiveType;	/* resqml2_0_1ForGsoap.h:1564 */
class gml__AngleType;	/* resqml2_0_1ForGsoap.h:1618 */
class gml__LengthType;	/* resqml2_0_1ForGsoap.h:1630 */
class gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType;	/* resqml2_0_1ForGsoap.h:1702 */
class resqml2__obj_USCOREPropertyKind;	/* resqml2_0_1ForGsoap.h:268 */
class resqml2__AbstractPropertyLookup;	/* resqml2_0_1ForGsoap.h:289 */
class resqml2__obj_USCOREPropertySet;	/* resqml2_0_1ForGsoap.h:295 */
class resqml2__AbstractProperty;	/* resqml2_0_1ForGsoap.h:298 */
class resqml2__obj_USCORERepresentationIdentitySet;	/* resqml2_0_1ForGsoap.h:418 */
class resqml2__AbstractRepresentation;	/* resqml2_0_1ForGsoap.h:424 */
class resqml2__obj_USCORELocalGridSet;	/* resqml2_0_1ForGsoap.h:454 */
class resqml2__UnstructuredGridGeometry;	/* resqml2_0_1ForGsoap.h:547 */
class resqml2__AbstractColumnLayerGridGeometry;	/* resqml2_0_1ForGsoap.h:592 */
class resqml2__AbstractFeatureInterpretation;	/* resqml2_0_1ForGsoap.h:598 */
class resqml2__obj_USCOREStratigraphicColumn;	/* resqml2_0_1ForGsoap.h:646 */
class resqml2__obj_USCOREGlobalChronostratigraphicColumn;	/* resqml2_0_1ForGsoap.h:700 */
class resqml2__AbstractFeature;	/* resqml2_0_1ForGsoap.h:721 */
class resqml2__AbstractLocal3dCrs;	/* resqml2_0_1ForGsoap.h:739 */
class resqml2__obj_USCORETimeSeries;	/* resqml2_0_1ForGsoap.h:751 */
class resqml2__obj_USCOREMdDatum;	/* resqml2_0_1ForGsoap.h:772 */
class resqml2__WellboreMarker;	/* resqml2_0_1ForGsoap.h:775 */
class resqml2__obj_USCOREActivity;	/* resqml2_0_1ForGsoap.h:895 */
class resqml2__obj_USCOREActivityTemplate;	/* resqml2_0_1ForGsoap.h:922 */
class gml__IdentifiedObjectType;	/* resqml2_0_1ForGsoap.h:1540 */
class resqml2__obj_USCOREDoubleTableLookup;	/* resqml2_0_1ForGsoap.h:223 */
class resqml2__obj_USCOREPointsProperty;	/* resqml2_0_1ForGsoap.h:238 */
class resqml2__obj_USCOREStringTableLookup;	/* resqml2_0_1ForGsoap.h:271 */
class resqml2__AbstractValuesProperty;	/* resqml2_0_1ForGsoap.h:313 */
class resqml2__obj_USCORERepresentationSetRepresentation;	/* resqml2_0_1ForGsoap.h:409 */
class resqml2__obj_USCORERedefinedGeometryRepresentation;	/* resqml2_0_1ForGsoap.h:412 */
class resqml2__obj_USCORESubRepresentation;	/* resqml2_0_1ForGsoap.h:430 */
class resqml2__AbstractGridRepresentation;	/* resqml2_0_1ForGsoap.h:457 */
class resqml2__UnstructuredColumnLayerGridGeometry;	/* resqml2_0_1ForGsoap.h:526 */
class resqml2__IjkGridGeometry;	/* resqml2_0_1ForGsoap.h:529 */
class resqml2__obj_USCOREGridConnectionSetRepresentation;	/* resqml2_0_1ForGsoap.h:568 */
class resqml2__AbstractOrganizationInterpretation;	/* resqml2_0_1ForGsoap.h:607 */
class resqml2__obj_USCOREGenericFeatureInterpretation;	/* resqml2_0_1ForGsoap.h:622 */
class resqml2__obj_USCOREWellboreInterpretation;	/* resqml2_0_1ForGsoap.h:625 */
class resqml2__obj_USCOREBoundaryFeatureInterpretation;	/* resqml2_0_1ForGsoap.h:652 */
class resqml2__obj_USCOREEarthModelInterpretation;	/* resqml2_0_1ForGsoap.h:658 */
class resqml2__obj_USCOREGeologicUnitInterpretation;	/* resqml2_0_1ForGsoap.h:676 */
class resqml2__AbstractGeologicFeature;	/* resqml2_0_1ForGsoap.h:706 */
class resqml2__obj_USCORELocalTime3dCrs;	/* resqml2_0_1ForGsoap.h:730 */
class resqml2__obj_USCORELocalDepth3dCrs;	/* resqml2_0_1ForGsoap.h:748 */
class resqml2__obj_USCOREDeviationSurveyRepresentation;	/* resqml2_0_1ForGsoap.h:763 */
class resqml2__obj_USCOREWellboreFrameRepresentation;	/* resqml2_0_1ForGsoap.h:766 */
class resqml2__obj_USCOREWellboreTrajectoryRepresentation;	/* resqml2_0_1ForGsoap.h:769 */
class resqml2__obj_USCOREPointSetRepresentation;	/* resqml2_0_1ForGsoap.h:805 */
class resqml2__obj_USCOREPolylineSetRepresentation;	/* resqml2_0_1ForGsoap.h:820 */
class resqml2__obj_USCOREPolylineRepresentation;	/* resqml2_0_1ForGsoap.h:832 */
class resqml2__AbstractSurfaceRepresentation;	/* resqml2_0_1ForGsoap.h:841 */
class resqml2__AbstractTechnicalFeature;	/* resqml2_0_1ForGsoap.h:862 */
class resqml2__obj_USCOREStreamlinesRepresentation;	/* resqml2_0_1ForGsoap.h:931 */
class gml__AbstractCRSType;	/* resqml2_0_1ForGsoap.h:1537 */
class gml__AbstractCoordinateSystemType;	/* resqml2_0_1ForGsoap.h:1582 */
class gml__CoordinateSystemAxisType;	/* resqml2_0_1ForGsoap.h:1588 */
class gml__AbstractDatumType;	/* resqml2_0_1ForGsoap.h:1609 */
class gml__PrimeMeridianType;	/* resqml2_0_1ForGsoap.h:1615 */
class gml__EllipsoidType;	/* resqml2_0_1ForGsoap.h:1627 */
class gml__AbstractCoordinateOperationType;	/* resqml2_0_1ForGsoap.h:1645 */
class resqml2__obj_USCOREContinuousProperty;	/* resqml2_0_1ForGsoap.h:232 */
class resqml2__obj_USCORECommentProperty;	/* resqml2_0_1ForGsoap.h:253 */
class resqml2__obj_USCOREDiscreteProperty;	/* resqml2_0_1ForGsoap.h:256 */
class resqml2__obj_USCORECategoricalProperty;	/* resqml2_0_1ForGsoap.h:259 */
class resqml2__obj_USCOREUnstructuredGridRepresentation;	/* resqml2_0_1ForGsoap.h:433 */
class resqml2__obj_USCOREGpGridRepresentation;	/* resqml2_0_1ForGsoap.h:439 */
class resqml2__AbstractTruncatedColumnLayerGridRepresentation;	/* resqml2_0_1ForGsoap.h:535 */
class resqml2__AbstractColumnLayerGridRepresentation;	/* resqml2_0_1ForGsoap.h:559 */
class resqml2__obj_USCORERockFluidOrganizationInterpretation;	/* resqml2_0_1ForGsoap.h:601 */
class resqml2__obj_USCORERockFluidUnitInterpretation;	/* resqml2_0_1ForGsoap.h:619 */
class resqml2__obj_USCOREGeobodyBoundaryInterpretation;	/* resqml2_0_1ForGsoap.h:631 */
class resqml2__obj_USCOREStructuralOrganizationInterpretation;	/* resqml2_0_1ForGsoap.h:634 */
class resqml2__obj_USCOREFaultInterpretation;	/* resqml2_0_1ForGsoap.h:643 */
class resqml2__obj_USCOREGeobodyInterpretation;	/* resqml2_0_1ForGsoap.h:649 */
class resqml2__AbstractStratigraphicOrganizationInterpretation;	/* resqml2_0_1ForGsoap.h:667 */
class resqml2__obj_USCOREHorizonInterpretation;	/* resqml2_0_1ForGsoap.h:673 */
class resqml2__obj_USCOREStratigraphicUnitInterpretation;	/* resqml2_0_1ForGsoap.h:679 */
class resqml2__obj_USCOREGeologicUnitFeature;	/* resqml2_0_1ForGsoap.h:688 */
class resqml2__obj_USCOREBoundaryFeature;	/* resqml2_0_1ForGsoap.h:694 */
class resqml2__obj_USCOREOrganizationFeature;	/* resqml2_0_1ForGsoap.h:715 */
class resqml2__obj_USCOREBlockedWellboreRepresentation;	/* resqml2_0_1ForGsoap.h:757 */
class resqml2__obj_USCOREWellboreMarkerFrameRepresentation;	/* resqml2_0_1ForGsoap.h:778 */
class resqml2__obj_USCORETriangulatedSetRepresentation;	/* resqml2_0_1ForGsoap.h:784 */
class resqml2__obj_USCOREPlaneSetRepresentation;	/* resqml2_0_1ForGsoap.h:796 */
class resqml2__AbstractSurfaceFrameworkRepresentation;	/* resqml2_0_1ForGsoap.h:802 */
class resqml2__obj_USCORESealedVolumeFrameworkRepresentation;	/* resqml2_0_1ForGsoap.h:808 */
class resqml2__obj_USCOREGrid2dRepresentation;	/* resqml2_0_1ForGsoap.h:835 */
class resqml2__obj_USCOREGrid2dSetRepresentation;	/* resqml2_0_1ForGsoap.h:847 */
class resqml2__obj_USCOREFrontierFeature;	/* resqml2_0_1ForGsoap.h:865 */
class resqml2__obj_USCOREWellboreFeature;	/* resqml2_0_1ForGsoap.h:874 */
class resqml2__AbstractSeismicSurveyFeature;	/* resqml2_0_1ForGsoap.h:883 */
class resqml2__obj_USCOREStreamlinesFeature;	/* resqml2_0_1ForGsoap.h:928 */
union _gml__union_GeodeticCRSType;	/* resqml2_0_1ForGsoap.h:29533 */
class gml__GeodeticCRSType;	/* resqml2_0_1ForGsoap.h:1534 */
class gml__EllipsoidalCSType;	/* resqml2_0_1ForGsoap.h:1579 */
class gml__CartesianCSType;	/* resqml2_0_1ForGsoap.h:1594 */
class gml__SphericalCSType;	/* resqml2_0_1ForGsoap.h:1600 */
class gml__GeodeticDatumType;	/* resqml2_0_1ForGsoap.h:1606 */
class gml__AbstractGeneralDerivedCRSType;	/* resqml2_0_1ForGsoap.h:1636 */
class gml__AbstractGeneralConversionType;	/* resqml2_0_1ForGsoap.h:1642 */
class gml__VerticalCRSType;	/* resqml2_0_1ForGsoap.h:1654 */
class gml__VerticalCSType;	/* resqml2_0_1ForGsoap.h:1660 */
class gml__VerticalDatumType;	/* resqml2_0_1ForGsoap.h:1666 */
class resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation;	/* resqml2_0_1ForGsoap.h:466 */
class resqml2__obj_USCOREIjkGridRepresentation;	/* resqml2_0_1ForGsoap.h:472 */
class resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation;	/* resqml2_0_1ForGsoap.h:553 */
class resqml2__obj_USCORETruncatedIjkGridRepresentation;	/* resqml2_0_1ForGsoap.h:565 */
class resqml2__obj_USCOREStratigraphicColumnRankInterpretation;	/* resqml2_0_1ForGsoap.h:664 */
class resqml2__obj_USCOREStratigraphicOccurrenceInterpretation;	/* resqml2_0_1ForGsoap.h:682 */
class resqml2__obj_USCOREFluidBoundaryFeature;	/* resqml2_0_1ForGsoap.h:685 */
class resqml2__obj_USCORERockFluidUnitFeature;	/* resqml2_0_1ForGsoap.h:691 */
class resqml2__obj_USCOREStratigraphicUnitFeature;	/* resqml2_0_1ForGsoap.h:703 */
class resqml2__obj_USCOREGeneticBoundaryFeature;	/* resqml2_0_1ForGsoap.h:709 */
class resqml2__obj_USCOREGeobodyFeature;	/* resqml2_0_1ForGsoap.h:712 */
class resqml2__obj_USCORETectonicBoundaryFeature;	/* resqml2_0_1ForGsoap.h:718 */
class resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation;	/* resqml2_0_1ForGsoap.h:781 */
class resqml2__obj_USCORESealedSurfaceFrameworkRepresentation;	/* resqml2_0_1ForGsoap.h:826 */
class resqml2__SeismicLatticeSetFeature;	/* resqml2_0_1ForGsoap.h:868 */
class resqml2__obj_USCORESeismicLineSetFeature;	/* resqml2_0_1ForGsoap.h:871 */
class resqml2__obj_USCORESeismicLineFeature;	/* resqml2_0_1ForGsoap.h:877 */
class resqml2__obj_USCORESeismicLatticeFeature;	/* resqml2_0_1ForGsoap.h:880 */
class resqml2__obj_USCOREContinuousPropertySeries;	/* resqml2_0_1ForGsoap.h:943 */
class resqml2__obj_USCORECategoricalPropertySeries;	/* resqml2_0_1ForGsoap.h:946 */
class resqml2__obj_USCORECommentPropertySeries;	/* resqml2_0_1ForGsoap.h:949 */
class resqml2__obj_USCOREDiscretePropertySeries;	/* resqml2_0_1ForGsoap.h:952 */
union _gml__union_ProjectedCRSType;	/* resqml2_0_1ForGsoap.h:31113 */
class gml__ProjectedCRSType;	/* resqml2_0_1ForGsoap.h:1633 */

/* resqml2_0_1ForGsoap.h:226 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyKindFacet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyKindFacet (27)
/* complex XSD type 'resqml2:PropertyKindFacet': */
class SOAP_CMAC resqml2__PropertyKindFacet {
      public:
        /// Required element 'resqml2:Facet' of XSD type 'resqml2:Facet'
        enum resqml2__Facet Facet;
        /// Required element 'resqml2:Value' of XSD type 'xsd:string'
        std::string Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyKindFacet
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyKindFacet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__PropertyKindFacet, default initialized and not managed by a soap context
        virtual resqml2__PropertyKindFacet *soap_alloc(void) const { return SOAP_NEW(resqml2__PropertyKindFacet); }
      public:
        /// Constructor with initializations
        resqml2__PropertyKindFacet()
        {
          Facet = (enum resqml2__Facet)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__PropertyKindFacet() { }
        /// Friend allocator used by soap_new_resqml2__PropertyKindFacet(struct soap*, int)
        friend SOAP_FMAC1 resqml2__PropertyKindFacet * SOAP_FMAC2 soap_instantiate_resqml2__PropertyKindFacet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:235 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringLookup (30)
/* complex XSD type 'resqml2:StringLookup': */
class SOAP_CMAC resqml2__StringLookup {
      public:
        /// Required element 'resqml2:Key' of XSD type 'xsd:integer'
        LONG64 Key;
        /// Required element 'resqml2:Value' of XSD type 'xsd:string'
        std::string Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringLookup
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringLookup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__StringLookup, default initialized and not managed by a soap context
        virtual resqml2__StringLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__StringLookup); }
      public:
        /// Constructor with initializations
        resqml2__StringLookup()
        {
          Key = (LONG64)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__StringLookup() { }
        /// Friend allocator used by soap_new_resqml2__StringLookup(struct soap*, int)
        friend SOAP_FMAC1 resqml2__StringLookup * SOAP_FMAC2 soap_instantiate_resqml2__StringLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:250 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfPoints (35)
/* complex XSD type 'resqml2:PatchOfPoints': */
class SOAP_CMAC resqml2__PatchOfPoints {
      public:
        /// Optional element 'resqml2:RepresentationPatchIndex' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *RepresentationPatchIndex;
        /// Required element 'resqml2:Points' of XSD type 'resqml2:AbstractPoint3dArray'
        resqml2__AbstractPoint3dArray *Points;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfPoints
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfPoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__PatchOfPoints, default initialized and not managed by a soap context
        virtual resqml2__PatchOfPoints *soap_alloc(void) const { return SOAP_NEW(resqml2__PatchOfPoints); }
      public:
        /// Constructor with initializations
        resqml2__PatchOfPoints()
        {
          RepresentationPatchIndex = (ULONG64 *)0;
          Points = (resqml2__AbstractPoint3dArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__PatchOfPoints() { }
        /// Friend allocator used by soap_new_resqml2__PatchOfPoints(struct soap*, int)
        friend SOAP_FMAC1 resqml2__PatchOfPoints * SOAP_FMAC2 soap_instantiate_resqml2__PatchOfPoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:280 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyKind (45)
/* Type resqml2__AbstractPropertyKind is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractPropertyKind': */
class SOAP_CMAC resqml2__AbstractPropertyKind {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyKind
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyKind; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractPropertyKind, default initialized and not managed by a soap context
        virtual resqml2__AbstractPropertyKind *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractPropertyKind); }
      public:
        /// Constructor with initializations
        resqml2__AbstractPropertyKind()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractPropertyKind() { }
        /// Friend allocator used by soap_new_resqml2__AbstractPropertyKind(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractPropertyKind * SOAP_FMAC2 soap_instantiate_resqml2__AbstractPropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:283 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfValues
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfValues (46)
/* complex XSD type 'resqml2:PatchOfValues': */
class SOAP_CMAC resqml2__PatchOfValues {
      public:
        /// Optional element 'resqml2:RepresentationPatchIndex' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *RepresentationPatchIndex;
        /// Required element 'resqml2:Values' of XSD type 'resqml2:AbstractValueArray'
        resqml2__AbstractValueArray *Values;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfValues
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfValues; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__PatchOfValues, default initialized and not managed by a soap context
        virtual resqml2__PatchOfValues *soap_alloc(void) const { return SOAP_NEW(resqml2__PatchOfValues); }
      public:
        /// Constructor with initializations
        resqml2__PatchOfValues()
        {
          RepresentationPatchIndex = (ULONG64 *)0;
          Values = (resqml2__AbstractValueArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__PatchOfValues() { }
        /// Friend allocator used by soap_new_resqml2__PatchOfValues(struct soap*, int)
        friend SOAP_FMAC1 resqml2__PatchOfValues * SOAP_FMAC2 soap_instantiate_resqml2__PatchOfValues(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:286 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValueArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValueArray (47)
/* Type resqml2__AbstractValueArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractValueArray': */
class SOAP_CMAC resqml2__AbstractValueArray {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValueArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValueArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractValueArray, default initialized and not managed by a soap context
        virtual resqml2__AbstractValueArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractValueArray); }
      public:
        /// Constructor with initializations
        resqml2__AbstractValueArray()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractValueArray() { }
        /// Friend allocator used by soap_new_resqml2__AbstractValueArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractValueArray * SOAP_FMAC2 soap_instantiate_resqml2__AbstractValueArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:307 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyValuesPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyValuesPatch (54)
/* complex XSD type 'resqml2:PropertyValuesPatch': */
class SOAP_CMAC resqml2__PropertyValuesPatch {
      public:
        /// Required element 'resqml2:patchUid' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 patchUid;
        /// Required element 'resqml2:values' of XSD type 'resqml2:AbstractValueArray'
        resqml2__AbstractValueArray *values;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyValuesPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyValuesPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__PropertyValuesPatch, default initialized and not managed by a soap context
        virtual resqml2__PropertyValuesPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__PropertyValuesPatch); }
      public:
        /// Constructor with initializations
        resqml2__PropertyValuesPatch()
        {
          patchUid = (ULONG64)0;
          values = (resqml2__AbstractValueArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__PropertyValuesPatch() { }
        /// Friend allocator used by soap_new_resqml2__PropertyValuesPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__PropertyValuesPatch * SOAP_FMAC2 soap_instantiate_resqml2__PropertyValuesPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:319 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLookup (58)
/* complex XSD type 'resqml2:DoubleLookup': */
class SOAP_CMAC resqml2__DoubleLookup {
      public:
        /// Required element 'resqml2:Key' of XSD type 'xsd:double'
        double Key;
        /// Required element 'resqml2:Value' of XSD type 'xsd:double'
        double Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLookup
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLookup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__DoubleLookup, default initialized and not managed by a soap context
        virtual resqml2__DoubleLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__DoubleLookup); }
      public:
        /// Constructor with initializations
        resqml2__DoubleLookup()
        {
          Key = (double)0;
          Value = (double)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__DoubleLookup() { }
        /// Friend allocator used by soap_new_resqml2__DoubleLookup(struct soap*, int)
        friend SOAP_FMAC1 resqml2__DoubleLookup * SOAP_FMAC2 soap_instantiate_resqml2__DoubleLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:325 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dOffset
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dOffset (60)
/* complex XSD type 'resqml2:Point3dOffset': */
class SOAP_CMAC resqml2__Point3dOffset {
      public:
        /// Required element 'resqml2:Offset' of XSD type 'resqml2:Point3d'
        resqml2__Point3d *Offset;
        /// Required element 'resqml2:Spacing' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *Spacing;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dOffset
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dOffset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Point3dOffset, default initialized and not managed by a soap context
        virtual resqml2__Point3dOffset *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dOffset); }
      public:
        /// Constructor with initializations
        resqml2__Point3dOffset()
        {
          Offset = (resqml2__Point3d *)0;
          Spacing = (resqml2__AbstractDoubleArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__Point3dOffset() { }
        /// Friend allocator used by soap_new_resqml2__Point3dOffset(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Point3dOffset * SOAP_FMAC2 soap_instantiate_resqml2__Point3dOffset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:349 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPoint3dArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPoint3dArray (68)
/* Type resqml2__AbstractPoint3dArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractPoint3dArray': */
class SOAP_CMAC resqml2__AbstractPoint3dArray {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPoint3dArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPoint3dArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractPoint3dArray, default initialized and not managed by a soap context
        virtual resqml2__AbstractPoint3dArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractPoint3dArray); }
      public:
        /// Constructor with initializations
        resqml2__AbstractPoint3dArray()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractPoint3dArray() { }
        /// Friend allocator used by soap_new_resqml2__AbstractPoint3dArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractPoint3dArray * SOAP_FMAC2 soap_instantiate_resqml2__AbstractPoint3dArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:352 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeometry (69)
/* Type resqml2__AbstractGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractGeometry': */
class SOAP_CMAC resqml2__AbstractGeometry {
      public:
        /// Optional element 'resqml2:TimeIndex' of XSD type 'resqml2:TimeIndex'
        resqml2__TimeIndex *TimeIndex;
        /// Required element 'resqml2:LocalCrs' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *LocalCrs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractGeometry, default initialized and not managed by a soap context
        virtual resqml2__AbstractGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractGeometry); }
      public:
        /// Constructor with initializations
        resqml2__AbstractGeometry()
        {
          TimeIndex = (resqml2__TimeIndex *)0;
          LocalCrs = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractGeometry() { }
        /// Friend allocator used by soap_new_resqml2__AbstractGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractGeometry * SOAP_FMAC2 soap_instantiate_resqml2__AbstractGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:358 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThreePoint3d
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThreePoint3d (71)
/* complex XSD type 'resqml2:ThreePoint3d': */
class SOAP_CMAC resqml2__ThreePoint3d {
      public:
        /// Sequence of 3 to 3 elements 'resqml2:Point3d' of XSD type 'resqml2:Point3d'
        std::vector<resqml2__Point3d *> Point3d;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThreePoint3d
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThreePoint3d; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ThreePoint3d, default initialized and not managed by a soap context
        virtual resqml2__ThreePoint3d *soap_alloc(void) const { return SOAP_NEW(resqml2__ThreePoint3d); }
      public:
        /// Constructor with initializations
        resqml2__ThreePoint3d()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ThreePoint3d() { }
        /// Friend allocator used by soap_new_resqml2__ThreePoint3d(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ThreePoint3d * SOAP_FMAC2 soap_instantiate_resqml2__ThreePoint3d(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:370 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineArray (75)
/* Type resqml2__AbstractParametricLineArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractParametricLineArray': */
class SOAP_CMAC resqml2__AbstractParametricLineArray {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractParametricLineArray, default initialized and not managed by a soap context
        virtual resqml2__AbstractParametricLineArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractParametricLineArray); }
      public:
        /// Constructor with initializations
        resqml2__AbstractParametricLineArray()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractParametricLineArray() { }
        /// Friend allocator used by soap_new_resqml2__AbstractParametricLineArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractParametricLineArray * SOAP_FMAC2 soap_instantiate_resqml2__AbstractParametricLineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:373 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineIntersections
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineIntersections (76)
/* complex XSD type 'resqml2:ParametricLineIntersections': */
class SOAP_CMAC resqml2__ParametricLineIntersections {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:IntersectionLinePairs' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *IntersectionLinePairs;
        /// Required element 'resqml2:ParameterValuePairs' of XSD type 'resqml2:AbstractValueArray'
        resqml2__AbstractValueArray *ParameterValuePairs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineIntersections
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineIntersections; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ParametricLineIntersections, default initialized and not managed by a soap context
        virtual resqml2__ParametricLineIntersections *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineIntersections); }
      public:
        /// Constructor with initializations
        resqml2__ParametricLineIntersections()
        {
          Count = (ULONG64)0;
          IntersectionLinePairs = (resqml2__AbstractIntegerArray *)0;
          ParameterValuePairs = (resqml2__AbstractValueArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ParametricLineIntersections() { }
        /// Friend allocator used by soap_new_resqml2__ParametricLineIntersections(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ParametricLineIntersections * SOAP_FMAC2 soap_instantiate_resqml2__ParametricLineIntersections(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:391 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicCoordinates (82)
/* Type resqml2__AbstractSeismicCoordinates is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractSeismicCoordinates': */
class SOAP_CMAC resqml2__AbstractSeismicCoordinates {
      public:
        /// Required element 'resqml2:SeismicSupport' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *SeismicSupport;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicCoordinates
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractSeismicCoordinates, default initialized and not managed by a soap context
        virtual resqml2__AbstractSeismicCoordinates *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractSeismicCoordinates); }
      public:
        /// Constructor with initializations
        resqml2__AbstractSeismicCoordinates()
        {
          SeismicSupport = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractSeismicCoordinates() { }
        /// Friend allocator used by soap_new_resqml2__AbstractSeismicCoordinates(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractSeismicCoordinates * SOAP_FMAC2 soap_instantiate_resqml2__AbstractSeismicCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:400 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch (85)
/* Type resqml2__Patch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Patch': */
class SOAP_CMAC resqml2__Patch {
      public:
        /// Required element 'resqml2:PatchIndex' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 PatchIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Patch, default initialized and not managed by a soap context
        virtual resqml2__Patch *soap_alloc(void) const { return SOAP_NEW(resqml2__Patch); }
      public:
        /// Constructor with initializations
        resqml2__Patch()
        {
          PatchIndex = (ULONG64)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__Patch() { }
        /// Friend allocator used by soap_new_resqml2__Patch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Patch * SOAP_FMAC2 soap_instantiate_resqml2__Patch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:403 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIndices
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIndices (86)
/* complex XSD type 'resqml2:ElementIndices': */
class SOAP_CMAC resqml2__ElementIndices {
      public:
        /// Required element 'resqml2:IndexableElement' of XSD type 'resqml2:IndexableElements'
        enum resqml2__IndexableElements IndexableElement;
        /// Required element 'resqml2:Indices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *Indices;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIndices
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIndices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ElementIndices, default initialized and not managed by a soap context
        virtual resqml2__ElementIndices *soap_alloc(void) const { return SOAP_NEW(resqml2__ElementIndices); }
      public:
        /// Constructor with initializations
        resqml2__ElementIndices()
        {
          IndexableElement = (enum resqml2__IndexableElements)0;
          Indices = (resqml2__AbstractIntegerArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ElementIndices() { }
        /// Friend allocator used by soap_new_resqml2__ElementIndices(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ElementIndices * SOAP_FMAC2 soap_instantiate_resqml2__ElementIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:415 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RepresentationIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RepresentationIdentity (90)
/* complex XSD type 'resqml2:RepresentationIdentity': */
class SOAP_CMAC resqml2__RepresentationIdentity {
      public:
        /// Required element 'resqml2:IdenticalElementCount' of XSD type 'xsd:positiveInteger'
        ULONG64 IdenticalElementCount;
        /// Required element 'resqml2:ElementIdentity' of XSD type 'resqml2:ElementIdentity'
        std::vector<resqml2__ElementIdentity *> ElementIdentity;
        /// Optional element 'resqml2:AdditionalGridTopology' of XSD type 'resqml2:AdditionalGridTopology'
        resqml2__AdditionalGridTopology *AdditionalGridTopology;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RepresentationIdentity
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RepresentationIdentity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__RepresentationIdentity, default initialized and not managed by a soap context
        virtual resqml2__RepresentationIdentity *soap_alloc(void) const { return SOAP_NEW(resqml2__RepresentationIdentity); }
      public:
        /// Constructor with initializations
        resqml2__RepresentationIdentity()
        {
          IdenticalElementCount = (ULONG64)0;
          AdditionalGridTopology = (resqml2__AdditionalGridTopology *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__RepresentationIdentity() { }
        /// Friend allocator used by soap_new_resqml2__RepresentationIdentity(struct soap*, int)
        friend SOAP_FMAC1 resqml2__RepresentationIdentity * SOAP_FMAC2 soap_instantiate_resqml2__RepresentationIdentity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:421 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIdentity (92)
/* complex XSD type 'resqml2:ElementIdentity': */
class SOAP_CMAC resqml2__ElementIdentity {
      public:
        /// Optional element 'resqml2:ElementIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ElementIndices;
        /// Required element 'resqml2:IdentityKind' of XSD type 'resqml2:IdentityKind'
        enum resqml2__IdentityKind IdentityKind;
        /// Required element 'resqml2:IndexableElement' of XSD type 'resqml2:IndexableElements'
        enum resqml2__IndexableElements IndexableElement;
        /// Required element 'resqml2:Representation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Representation;
        /// Optional element 'resqml2:FromTimeIndex' of XSD type 'resqml2:TimeIndex'
        resqml2__TimeIndex *FromTimeIndex;
        /// Optional element 'resqml2:ToTimeIndex' of XSD type 'resqml2:TimeIndex'
        resqml2__TimeIndex *ToTimeIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIdentity
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIdentity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ElementIdentity, default initialized and not managed by a soap context
        virtual resqml2__ElementIdentity *soap_alloc(void) const { return SOAP_NEW(resqml2__ElementIdentity); }
      public:
        /// Constructor with initializations
        resqml2__ElementIdentity()
        {
          ElementIndices = (resqml2__AbstractIntegerArray *)0;
          IdentityKind = (enum resqml2__IdentityKind)0;
          IndexableElement = (enum resqml2__IndexableElements)0;
          Representation = (eml__DataObjectReference *)0;
          FromTimeIndex = (resqml2__TimeIndex *)0;
          ToTimeIndex = (resqml2__TimeIndex *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ElementIdentity() { }
        /// Friend allocator used by soap_new_resqml2__ElementIdentity(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ElementIdentity * SOAP_FMAC2 soap_instantiate_resqml2__ElementIdentity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:427 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfGeometry (94)
/* complex XSD type 'resqml2:PatchOfGeometry': */
class SOAP_CMAC resqml2__PatchOfGeometry {
      public:
        /// Optional element 'resqml2:RepresentationPatchIndex' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *RepresentationPatchIndex;
        /// Required element 'resqml2:Geometry' of XSD type 'resqml2:AbstractGeometry'
        resqml2__AbstractGeometry *Geometry;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__PatchOfGeometry, default initialized and not managed by a soap context
        virtual resqml2__PatchOfGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__PatchOfGeometry); }
      public:
        /// Constructor with initializations
        resqml2__PatchOfGeometry()
        {
          RepresentationPatchIndex = (ULONG64 *)0;
          Geometry = (resqml2__AbstractGeometry *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__PatchOfGeometry() { }
        /// Friend allocator used by soap_new_resqml2__PatchOfGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__PatchOfGeometry * SOAP_FMAC2 soap_instantiate_resqml2__PatchOfGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:436 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridTopology (97)
/* complex XSD type 'resqml2:AdditionalGridTopology': */
class SOAP_CMAC resqml2__AdditionalGridTopology {
      public:
        /// Optional element 'resqml2:SplitEdges' of XSD type 'resqml2:SplitEdges'
        resqml2__SplitEdges *SplitEdges;
        /// Optional element 'resqml2:SplitNodes' of XSD type 'resqml2:SplitNodePatch'
        resqml2__SplitNodePatch *SplitNodes;
        /// Optional element 'resqml2:SplitColumnEdges' of XSD type 'resqml2:ColumnLayerSplitColumnEdges'
        resqml2__ColumnLayerSplitColumnEdges *SplitColumnEdges;
        /// Optional element 'resqml2:UnstructuredColumnEdges' of XSD type 'resqml2:UnstructuredColumnEdges'
        resqml2__UnstructuredColumnEdges *UnstructuredColumnEdges;
        /// Optional element 'resqml2:SplitFaces' of XSD type 'resqml2:SplitFaces'
        resqml2__SplitFaces *SplitFaces;
        /// Optional element 'resqml2:IjSplitColumnEdges' of XSD type 'resqml2:IjSplitColumnEdges'
        resqml2__IjSplitColumnEdges *IjSplitColumnEdges;
        /// Optional element 'resqml2:UnstructuredSubnodeTopology' of XSD type 'resqml2:UnstructuredSubnodeTopology'
        resqml2__UnstructuredSubnodeTopology *UnstructuredSubnodeTopology;
        /// Optional element 'resqml2:ColumnLayerSubnodeTopology' of XSD type 'resqml2:ColumnLayerSubnodeTopology'
        resqml2__ColumnLayerSubnodeTopology *ColumnLayerSubnodeTopology;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridTopology
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridTopology; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AdditionalGridTopology, default initialized and not managed by a soap context
        virtual resqml2__AdditionalGridTopology *soap_alloc(void) const { return SOAP_NEW(resqml2__AdditionalGridTopology); }
      public:
        /// Constructor with initializations
        resqml2__AdditionalGridTopology()
        {
          SplitEdges = (resqml2__SplitEdges *)0;
          SplitNodes = (resqml2__SplitNodePatch *)0;
          SplitColumnEdges = (resqml2__ColumnLayerSplitColumnEdges *)0;
          UnstructuredColumnEdges = (resqml2__UnstructuredColumnEdges *)0;
          SplitFaces = (resqml2__SplitFaces *)0;
          IjSplitColumnEdges = (resqml2__IjSplitColumnEdges *)0;
          UnstructuredSubnodeTopology = (resqml2__UnstructuredSubnodeTopology *)0;
          ColumnLayerSubnodeTopology = (resqml2__ColumnLayerSubnodeTopology *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AdditionalGridTopology() { }
        /// Friend allocator used by soap_new_resqml2__AdditionalGridTopology(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AdditionalGridTopology * SOAP_FMAC2 soap_instantiate_resqml2__AdditionalGridTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:451 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellStratigraphicUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellStratigraphicUnits (102)
/* complex XSD type 'resqml2:CellStratigraphicUnits': */
class SOAP_CMAC resqml2__CellStratigraphicUnits {
      public:
        /// Required element 'resqml2:UnitIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *UnitIndices;
        /// Required element 'resqml2:StratigraphicOrganization' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *StratigraphicOrganization;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellStratigraphicUnits
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellStratigraphicUnits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__CellStratigraphicUnits, default initialized and not managed by a soap context
        virtual resqml2__CellStratigraphicUnits *soap_alloc(void) const { return SOAP_NEW(resqml2__CellStratigraphicUnits); }
      public:
        /// Constructor with initializations
        resqml2__CellStratigraphicUnits()
        {
          UnitIndices = (resqml2__AbstractIntegerArray *)0;
          StratigraphicOrganization = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__CellStratigraphicUnits() { }
        /// Friend allocator used by soap_new_resqml2__CellStratigraphicUnits(struct soap*, int)
        friend SOAP_FMAC1 resqml2__CellStratigraphicUnits * SOAP_FMAC2 soap_instantiate_resqml2__CellStratigraphicUnits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:460 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeTopology (105)
/* Type resqml2__SubnodeTopology is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:SubnodeTopology': */
class SOAP_CMAC resqml2__SubnodeTopology {
      public:
        /// Optional element 'resqml2:VariableSubnodes' of XSD type 'resqml2:VariableSubnodePatch'
        std::vector<resqml2__VariableSubnodePatch *> VariableSubnodes;
        /// Optional element 'resqml2:UniformSubnodes' of XSD type 'resqml2:UniformSubnodePatch'
        std::vector<resqml2__UniformSubnodePatch *> UniformSubnodes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeTopology
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeTopology; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__SubnodeTopology, default initialized and not managed by a soap context
        virtual resqml2__SubnodeTopology *soap_alloc(void) const { return SOAP_NEW(resqml2__SubnodeTopology); }
      public:
        /// Constructor with initializations
        resqml2__SubnodeTopology()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__SubnodeTopology() { }
        /// Friend allocator used by soap_new_resqml2__SubnodeTopology(struct soap*, int)
        friend SOAP_FMAC1 resqml2__SubnodeTopology * SOAP_FMAC2 soap_instantiate_resqml2__SubnodeTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:463 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitFaces
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitFaces (106)
/* complex XSD type 'resqml2:SplitFaces': */
class SOAP_CMAC resqml2__SplitFaces {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:ParentFaceIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ParentFaceIndices;
        /// Required element 'resqml2:CellIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *CellIndices;
        /// Optional element 'resqml2:SplitEdges' of XSD type 'resqml2:SplitEdges'
        resqml2__SplitEdges *SplitEdges;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitFaces
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitFaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__SplitFaces, default initialized and not managed by a soap context
        virtual resqml2__SplitFaces *soap_alloc(void) const { return SOAP_NEW(resqml2__SplitFaces); }
      public:
        /// Constructor with initializations
        resqml2__SplitFaces()
        {
          Count = (ULONG64)0;
          ParentFaceIndices = (resqml2__AbstractIntegerArray *)0;
          CellIndices = (resqml2__AbstractIntegerArray *)0;
          SplitEdges = (resqml2__SplitEdges *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__SplitFaces() { }
        /// Friend allocator used by soap_new_resqml2__SplitFaces(struct soap*, int)
        friend SOAP_FMAC1 resqml2__SplitFaces * SOAP_FMAC2 soap_instantiate_resqml2__SplitFaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:13484 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___resqml2__IjGaps_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___resqml2__IjGaps_sequence (825)
/* Wrapper: */
class SOAP_CMAC __resqml2__IjGaps_sequence {
      public:
        /// Required element 'resqml2:SplitPillarCount' of XSD type 'xsd:positiveInteger'
        ULONG64 SplitPillarCount;
        /// Required element 'resqml2:ParentPillarIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ParentPillarIndices;
        /// Required element 'resqml2:ColumnsPerSplitPillar' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *ColumnsPerSplitPillar;
        /// Optional element 'resqml2:IjSplitColumnEdges' of XSD type 'resqml2:IjSplitColumnEdges'
        resqml2__IjSplitColumnEdges *IjSplitColumnEdges;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___resqml2__IjGaps_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___resqml2__IjGaps_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __resqml2__IjGaps_sequence, default initialized and not managed by a soap context
        virtual __resqml2__IjGaps_sequence *soap_alloc(void) const { return SOAP_NEW(__resqml2__IjGaps_sequence); }
      public:
        /// Constructor with initializations
        __resqml2__IjGaps_sequence()
        {
          SplitPillarCount = (ULONG64)0;
          ParentPillarIndices = (resqml2__AbstractIntegerArray *)0;
          ColumnsPerSplitPillar = (resqml2__ResqmlJaggedArray *)0;
          IjSplitColumnEdges = (resqml2__IjSplitColumnEdges *)0;
        }
        virtual ~__resqml2__IjGaps_sequence() { }
        /// Friend allocator used by soap_new___resqml2__IjGaps_sequence(struct soap*, int)
        friend SOAP_FMAC1 __resqml2__IjGaps_sequence * SOAP_FMAC2 soap_instantiate___resqml2__IjGaps_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:469 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjGaps
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjGaps (108)
/* complex XSD type 'resqml2:IjGaps': */
class SOAP_CMAC resqml2__IjGaps {
      public:
        __resqml2__IjGaps_sequence *__IjGaps_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjGaps
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjGaps; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IjGaps, default initialized and not managed by a soap context
        virtual resqml2__IjGaps *soap_alloc(void) const { return SOAP_NEW(resqml2__IjGaps); }
      public:
        /// Constructor with initializations
        resqml2__IjGaps()
        {
          __IjGaps_sequence = (__resqml2__IjGaps_sequence *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__IjGaps() { }
        /// Friend allocator used by soap_new_resqml2__IjGaps(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IjGaps * SOAP_FMAC2 soap_instantiate_resqml2__IjGaps(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:484 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridColumnLayerGrid
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridColumnLayerGrid (113)
/* complex XSD type 'resqml2:GpGridColumnLayerGrid': */
class SOAP_CMAC resqml2__GpGridColumnLayerGrid {
      public:
        /// Required element 'resqml2:Nk' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Nk;
        /// Optional element 'resqml2:KGaps' of XSD type 'resqml2:KGaps'
        resqml2__KGaps *KGaps;
        /// Optional element 'resqml2:IjkGridPatch' of XSD type 'resqml2:GpGridIjkGridPatch'
        std::vector<resqml2__GpGridIjkGridPatch *> IjkGridPatch;
        /// Optional element 'resqml2:UnstructuredColumnLayerGridPatch' of XSD type 'resqml2:GpGridUnstructuredColumnLayerGridPatch'
        std::vector<resqml2__GpGridUnstructuredColumnLayerGridPatch *> UnstructuredColumnLayerGridPatch;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridColumnLayerGrid
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridColumnLayerGrid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__GpGridColumnLayerGrid, default initialized and not managed by a soap context
        virtual resqml2__GpGridColumnLayerGrid *soap_alloc(void) const { return SOAP_NEW(resqml2__GpGridColumnLayerGrid); }
      public:
        /// Constructor with initializations
        resqml2__GpGridColumnLayerGrid()
        {
          Nk = (ULONG64)0;
          KGaps = (resqml2__KGaps *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__GpGridColumnLayerGrid() { }
        /// Friend allocator used by soap_new_resqml2__GpGridColumnLayerGrid(struct soap*, int)
        friend SOAP_FMAC1 resqml2__GpGridColumnLayerGrid * SOAP_FMAC2 soap_instantiate_resqml2__GpGridColumnLayerGrid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:487 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitCoordinateLines
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitCoordinateLines (114)
/* complex XSD type 'resqml2:ColumnLayerSplitCoordinateLines': */
class SOAP_CMAC resqml2__ColumnLayerSplitCoordinateLines {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:PillarIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *PillarIndices;
        /// Required element 'resqml2:ColumnsPerSplitCoordinateLine' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *ColumnsPerSplitCoordinateLine;
        /// Optional element 'resqml2:SplitColumnEdges' of XSD type 'resqml2:ColumnLayerSplitColumnEdges'
        resqml2__ColumnLayerSplitColumnEdges *SplitColumnEdges;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitCoordinateLines
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitCoordinateLines; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ColumnLayerSplitCoordinateLines, default initialized and not managed by a soap context
        virtual resqml2__ColumnLayerSplitCoordinateLines *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnLayerSplitCoordinateLines); }
      public:
        /// Constructor with initializations
        resqml2__ColumnLayerSplitCoordinateLines()
        {
          Count = (ULONG64)0;
          PillarIndices = (resqml2__AbstractIntegerArray *)0;
          ColumnsPerSplitCoordinateLine = (resqml2__ResqmlJaggedArray *)0;
          SplitColumnEdges = (resqml2__ColumnLayerSplitColumnEdges *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ColumnLayerSplitCoordinateLines() { }
        /// Friend allocator used by soap_new_resqml2__ColumnLayerSplitCoordinateLines(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ColumnLayerSplitCoordinateLines * SOAP_FMAC2 soap_instantiate_resqml2__ColumnLayerSplitCoordinateLines(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:13603 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___resqml2__KGaps_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___resqml2__KGaps_sequence (833)
/* Wrapper: */
class SOAP_CMAC __resqml2__KGaps_sequence {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:GapAfterLayer' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *GapAfterLayer;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___resqml2__KGaps_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___resqml2__KGaps_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __resqml2__KGaps_sequence, default initialized and not managed by a soap context
        virtual __resqml2__KGaps_sequence *soap_alloc(void) const { return SOAP_NEW(__resqml2__KGaps_sequence); }
      public:
        /// Constructor with initializations
        __resqml2__KGaps_sequence()
        {
          Count = (ULONG64)0;
          GapAfterLayer = (resqml2__AbstractBooleanArray *)0;
        }
        virtual ~__resqml2__KGaps_sequence() { }
        /// Friend allocator used by soap_new___resqml2__KGaps_sequence(struct soap*, int)
        friend SOAP_FMAC1 __resqml2__KGaps_sequence * SOAP_FMAC2 soap_instantiate___resqml2__KGaps_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:493 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KGaps
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KGaps (116)
/* complex XSD type 'resqml2:KGaps': */
class SOAP_CMAC resqml2__KGaps {
      public:
        __resqml2__KGaps_sequence *__KGaps_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KGaps
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KGaps; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__KGaps, default initialized and not managed by a soap context
        virtual resqml2__KGaps *soap_alloc(void) const { return SOAP_NEW(resqml2__KGaps); }
      public:
        /// Constructor with initializations
        resqml2__KGaps()
        {
          __KGaps_sequence = (__resqml2__KGaps_sequence *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__KGaps() { }
        /// Friend allocator used by soap_new_resqml2__KGaps(struct soap*, int)
        friend SOAP_FMAC1 resqml2__KGaps * SOAP_FMAC2 soap_instantiate_resqml2__KGaps(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:502 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnEdges (119)
/* complex XSD type 'resqml2:UnstructuredColumnEdges': */
class SOAP_CMAC resqml2__UnstructuredColumnEdges {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:PillarsPerColumnEdge' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *PillarsPerColumnEdge;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnEdges
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnEdges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__UnstructuredColumnEdges, default initialized and not managed by a soap context
        virtual resqml2__UnstructuredColumnEdges *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredColumnEdges); }
      public:
        /// Constructor with initializations
        resqml2__UnstructuredColumnEdges()
        {
          Count = (ULONG64)0;
          PillarsPerColumnEdge = (resqml2__ResqmlJaggedArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__UnstructuredColumnEdges() { }
        /// Friend allocator used by soap_new_resqml2__UnstructuredColumnEdges(struct soap*, int)
        friend SOAP_FMAC1 resqml2__UnstructuredColumnEdges * SOAP_FMAC2 soap_instantiate_resqml2__UnstructuredColumnEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:505 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridPoints (120)
/* complex XSD type 'resqml2:AdditionalGridPoints': */
class SOAP_CMAC resqml2__AdditionalGridPoints {
      public:
        /// Optional element 'resqml2:RepresentationPatchIndex' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *RepresentationPatchIndex;
        /// Required element 'resqml2:Attachment' of XSD type 'resqml2:GridGeometryAttachment'
        enum resqml2__GridGeometryAttachment Attachment;
        /// Required element 'resqml2:Points' of XSD type 'resqml2:AbstractPoint3dArray'
        resqml2__AbstractPoint3dArray *Points;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridPoints
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridPoints; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AdditionalGridPoints, default initialized and not managed by a soap context
        virtual resqml2__AdditionalGridPoints *soap_alloc(void) const { return SOAP_NEW(resqml2__AdditionalGridPoints); }
      public:
        /// Constructor with initializations
        resqml2__AdditionalGridPoints()
        {
          RepresentationPatchIndex = (ULONG64 *)0;
          Attachment = (enum resqml2__GridGeometryAttachment)0;
          Points = (resqml2__AbstractPoint3dArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AdditionalGridPoints() { }
        /// Friend allocator used by soap_new_resqml2__AdditionalGridPoints(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AdditionalGridPoints * SOAP_FMAC2 soap_instantiate_resqml2__AdditionalGridPoints(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:508 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjSplitColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjSplitColumnEdges (121)
/* complex XSD type 'resqml2:IjSplitColumnEdges': */
class SOAP_CMAC resqml2__IjSplitColumnEdges {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:PillarsPerSplitColumnEdge' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *PillarsPerSplitColumnEdge;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjSplitColumnEdges
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjSplitColumnEdges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IjSplitColumnEdges, default initialized and not managed by a soap context
        virtual resqml2__IjSplitColumnEdges *soap_alloc(void) const { return SOAP_NEW(resqml2__IjSplitColumnEdges); }
      public:
        /// Constructor with initializations
        resqml2__IjSplitColumnEdges()
        {
          Count = (ULONG64)0;
          PillarsPerSplitColumnEdge = (resqml2__ResqmlJaggedArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__IjSplitColumnEdges() { }
        /// Friend allocator used by soap_new_resqml2__IjSplitColumnEdges(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IjSplitColumnEdges * SOAP_FMAC2 soap_instantiate_resqml2__IjSplitColumnEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:517 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalStratigraphicUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalStratigraphicUnits (124)
/* complex XSD type 'resqml2:IntervalStratigraphicUnits': */
class SOAP_CMAC resqml2__IntervalStratigraphicUnits {
      public:
        /// Required element 'resqml2:UnitIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *UnitIndices;
        /// Required element 'resqml2:StratigraphicOrganization' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *StratigraphicOrganization;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalStratigraphicUnits
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalStratigraphicUnits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IntervalStratigraphicUnits, default initialized and not managed by a soap context
        virtual resqml2__IntervalStratigraphicUnits *soap_alloc(void) const { return SOAP_NEW(resqml2__IntervalStratigraphicUnits); }
      public:
        /// Constructor with initializations
        resqml2__IntervalStratigraphicUnits()
        {
          UnitIndices = (resqml2__AbstractIntegerArray *)0;
          StratigraphicOrganization = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__IntervalStratigraphicUnits() { }
        /// Friend allocator used by soap_new_resqml2__IntervalStratigraphicUnits(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IntervalStratigraphicUnits * SOAP_FMAC2 soap_instantiate_resqml2__IntervalStratigraphicUnits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:520 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Regrid
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Regrid (125)
/* complex XSD type 'resqml2:Regrid': */
class SOAP_CMAC resqml2__Regrid {
      public:
        /// Required element 'resqml2:InitialIndexOnParentGrid' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 InitialIndexOnParentGrid;
        /// Optional element 'resqml2:Intervals' of XSD type 'resqml2:Intervals'
        resqml2__Intervals *Intervals;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Regrid
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Regrid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Regrid, default initialized and not managed by a soap context
        virtual resqml2__Regrid *soap_alloc(void) const { return SOAP_NEW(resqml2__Regrid); }
      public:
        /// Constructor with initializations
        resqml2__Regrid()
        {
          InitialIndexOnParentGrid = (ULONG64)0;
          Intervals = (resqml2__Intervals *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__Regrid() { }
        /// Friend allocator used by soap_new_resqml2__Regrid(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Regrid * SOAP_FMAC2 soap_instantiate_resqml2__Regrid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:523 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Activation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Activation (126)
/* complex XSD type 'resqml2:Activation': */
class SOAP_CMAC resqml2__Activation {
      public:
        /// Required element 'resqml2:ActivationToggleIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ActivationToggleIndices;
        /// Required element 'resqml2:TimeSeries' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Activation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Activation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Activation, default initialized and not managed by a soap context
        virtual resqml2__Activation *soap_alloc(void) const { return SOAP_NEW(resqml2__Activation); }
      public:
        /// Constructor with initializations
        resqml2__Activation()
        {
          ActivationToggleIndices = (resqml2__AbstractIntegerArray *)0;
          TimeSeries = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__Activation() { }
        /// Friend allocator used by soap_new_resqml2__Activation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Activation * SOAP_FMAC2 soap_instantiate_resqml2__Activation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:532 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ConnectionInterpretations
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ConnectionInterpretations (129)
/* complex XSD type 'resqml2:ConnectionInterpretations': */
class SOAP_CMAC resqml2__ConnectionInterpretations {
      public:
        /// Required element 'resqml2:InterpretationIndices' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *InterpretationIndices;
        /// Required element 'resqml2:FeatureInterpretation' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> FeatureInterpretation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ConnectionInterpretations
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ConnectionInterpretations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ConnectionInterpretations, default initialized and not managed by a soap context
        virtual resqml2__ConnectionInterpretations *soap_alloc(void) const { return SOAP_NEW(resqml2__ConnectionInterpretations); }
      public:
        /// Constructor with initializations
        resqml2__ConnectionInterpretations()
        {
          InterpretationIndices = (resqml2__ResqmlJaggedArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ConnectionInterpretations() { }
        /// Friend allocator used by soap_new_resqml2__ConnectionInterpretations(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ConnectionInterpretations * SOAP_FMAC2 soap_instantiate_resqml2__ConnectionInterpretations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:538 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitEdges (131)
/* complex XSD type 'resqml2:SplitEdges': */
class SOAP_CMAC resqml2__SplitEdges {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:ParentEdgeIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ParentEdgeIndices;
        /// Required element 'resqml2:FacesPerSplitEdge' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *FacesPerSplitEdge;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitEdges
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitEdges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__SplitEdges, default initialized and not managed by a soap context
        virtual resqml2__SplitEdges *soap_alloc(void) const { return SOAP_NEW(resqml2__SplitEdges); }
      public:
        /// Constructor with initializations
        resqml2__SplitEdges()
        {
          Count = (ULONG64)0;
          ParentEdgeIndices = (resqml2__AbstractIntegerArray *)0;
          FacesPerSplitEdge = (resqml2__ResqmlJaggedArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__SplitEdges() { }
        /// Friend allocator used by soap_new_resqml2__SplitEdges(struct soap*, int)
        friend SOAP_FMAC1 resqml2__SplitEdges * SOAP_FMAC2 soap_instantiate_resqml2__SplitEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:541 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellFluidPhaseUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellFluidPhaseUnits (132)
/* complex XSD type 'resqml2:CellFluidPhaseUnits': */
class SOAP_CMAC resqml2__CellFluidPhaseUnits {
      public:
        /// Required element 'resqml2:PhaseUnitIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *PhaseUnitIndices;
        /// Required element 'resqml2:FluidOrganization' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *FluidOrganization;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellFluidPhaseUnits
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellFluidPhaseUnits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__CellFluidPhaseUnits, default initialized and not managed by a soap context
        virtual resqml2__CellFluidPhaseUnits *soap_alloc(void) const { return SOAP_NEW(resqml2__CellFluidPhaseUnits); }
      public:
        /// Constructor with initializations
        resqml2__CellFluidPhaseUnits()
        {
          PhaseUnitIndices = (resqml2__AbstractIntegerArray *)0;
          FluidOrganization = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__CellFluidPhaseUnits() { }
        /// Friend allocator used by soap_new_resqml2__CellFluidPhaseUnits(struct soap*, int)
        friend SOAP_FMAC1 resqml2__CellFluidPhaseUnits * SOAP_FMAC2 soap_instantiate_resqml2__CellFluidPhaseUnits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:544 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodesPerCell
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodesPerCell (133)
/* complex XSD type 'resqml2:NodesPerCell': */
class SOAP_CMAC resqml2__NodesPerCell {
      public:
        /// Required element 'resqml2:NodesPerCell' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *NodesPerCell;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodesPerCell
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodesPerCell; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__NodesPerCell, default initialized and not managed by a soap context
        virtual resqml2__NodesPerCell *soap_alloc(void) const { return SOAP_NEW(resqml2__NodesPerCell); }
      public:
        /// Constructor with initializations
        resqml2__NodesPerCell()
        {
          NodesPerCell = (resqml2__ResqmlJaggedArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__NodesPerCell() { }
        /// Friend allocator used by soap_new_resqml2__NodesPerCell(struct soap*, int)
        friend SOAP_FMAC1 resqml2__NodesPerCell * SOAP_FMAC2 soap_instantiate_resqml2__NodesPerCell(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:550 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Edges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Edges (135)
/* complex XSD type 'resqml2:Edges': */
class SOAP_CMAC resqml2__Edges {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:NodesPerEdge' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *NodesPerEdge;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Edges
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Edges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Edges, default initialized and not managed by a soap context
        virtual resqml2__Edges *soap_alloc(void) const { return SOAP_NEW(resqml2__Edges); }
      public:
        /// Constructor with initializations
        resqml2__Edges()
        {
          Count = (ULONG64)0;
          NodesPerEdge = (resqml2__AbstractIntegerArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__Edges() { }
        /// Friend allocator used by soap_new_resqml2__Edges(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Edges * SOAP_FMAC2 soap_instantiate_resqml2__Edges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:574 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridHingeNodeFaces
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridHingeNodeFaces (143)
/* complex XSD type 'resqml2:UnstructuredGridHingeNodeFaces': */
class SOAP_CMAC resqml2__UnstructuredGridHingeNodeFaces {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:FaceIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *FaceIndices;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridHingeNodeFaces
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridHingeNodeFaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__UnstructuredGridHingeNodeFaces, default initialized and not managed by a soap context
        virtual resqml2__UnstructuredGridHingeNodeFaces *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredGridHingeNodeFaces); }
      public:
        /// Constructor with initializations
        resqml2__UnstructuredGridHingeNodeFaces()
        {
          Count = (ULONG64)0;
          FaceIndices = (resqml2__AbstractIntegerArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__UnstructuredGridHingeNodeFaces() { }
        /// Friend allocator used by soap_new_resqml2__UnstructuredGridHingeNodeFaces(struct soap*, int)
        friend SOAP_FMAC1 resqml2__UnstructuredGridHingeNodeFaces * SOAP_FMAC2 soap_instantiate_resqml2__UnstructuredGridHingeNodeFaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:14014 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___resqml2__CellOverlap_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___resqml2__CellOverlap_sequence (838)
/* Wrapper: */
class SOAP_CMAC __resqml2__CellOverlap_sequence {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:ParentChildCellPairs' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ParentChildCellPairs;
        /// Optional element 'resqml2:OverlapVolume' of XSD type 'resqml2:OverlapVolume'
        resqml2__OverlapVolume *OverlapVolume;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___resqml2__CellOverlap_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___resqml2__CellOverlap_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __resqml2__CellOverlap_sequence, default initialized and not managed by a soap context
        virtual __resqml2__CellOverlap_sequence *soap_alloc(void) const { return SOAP_NEW(__resqml2__CellOverlap_sequence); }
      public:
        /// Constructor with initializations
        __resqml2__CellOverlap_sequence()
        {
          Count = (ULONG64)0;
          ParentChildCellPairs = (resqml2__AbstractIntegerArray *)0;
          OverlapVolume = (resqml2__OverlapVolume *)0;
        }
        virtual ~__resqml2__CellOverlap_sequence() { }
        /// Friend allocator used by soap_new___resqml2__CellOverlap_sequence(struct soap*, int)
        friend SOAP_FMAC1 __resqml2__CellOverlap_sequence * SOAP_FMAC2 soap_instantiate___resqml2__CellOverlap_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:577 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellOverlap
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellOverlap (144)
/* complex XSD type 'resqml2:CellOverlap': */
class SOAP_CMAC resqml2__CellOverlap {
      public:
        __resqml2__CellOverlap_sequence *__CellOverlap_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellOverlap
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellOverlap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__CellOverlap, default initialized and not managed by a soap context
        virtual resqml2__CellOverlap *soap_alloc(void) const { return SOAP_NEW(resqml2__CellOverlap); }
      public:
        /// Constructor with initializations
        resqml2__CellOverlap()
        {
          __CellOverlap_sequence = (__resqml2__CellOverlap_sequence *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__CellOverlap() { }
        /// Friend allocator used by soap_new_resqml2__CellOverlap(struct soap*, int)
        friend SOAP_FMAC1 resqml2__CellOverlap * SOAP_FMAC2 soap_instantiate_resqml2__CellOverlap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:580 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitColumnEdges (145)
/* complex XSD type 'resqml2:ColumnLayerSplitColumnEdges': */
class SOAP_CMAC resqml2__ColumnLayerSplitColumnEdges {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:ParentColumnEdgeIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ParentColumnEdgeIndices;
        /// Required element 'resqml2:ColumnPerSplitColumnEdge' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ColumnPerSplitColumnEdge;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitColumnEdges
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitColumnEdges; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ColumnLayerSplitColumnEdges, default initialized and not managed by a soap context
        virtual resqml2__ColumnLayerSplitColumnEdges *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnLayerSplitColumnEdges); }
      public:
        /// Constructor with initializations
        resqml2__ColumnLayerSplitColumnEdges()
        {
          Count = (ULONG64)0;
          ParentColumnEdgeIndices = (resqml2__AbstractIntegerArray *)0;
          ColumnPerSplitColumnEdge = (resqml2__AbstractIntegerArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ColumnLayerSplitColumnEdges() { }
        /// Friend allocator used by soap_new_resqml2__ColumnLayerSplitColumnEdges(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ColumnLayerSplitColumnEdges * SOAP_FMAC2 soap_instantiate_resqml2__ColumnLayerSplitColumnEdges(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:14089 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___resqml2__OverlapVolume_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___resqml2__OverlapVolume_sequence (841)
/* Wrapper: */
class SOAP_CMAC __resqml2__OverlapVolume_sequence {
      public:
        /// Required element 'resqml2:VolumeUom' of XSD type 'eml:VolumeUom'
        enum eml__VolumeUom VolumeUom;
        /// Required element 'resqml2:OverlapVolumes' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *OverlapVolumes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___resqml2__OverlapVolume_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___resqml2__OverlapVolume_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __resqml2__OverlapVolume_sequence, default initialized and not managed by a soap context
        virtual __resqml2__OverlapVolume_sequence *soap_alloc(void) const { return SOAP_NEW(__resqml2__OverlapVolume_sequence); }
      public:
        /// Constructor with initializations
        __resqml2__OverlapVolume_sequence()
        {
          VolumeUom = (enum eml__VolumeUom)0;
          OverlapVolumes = (resqml2__AbstractDoubleArray *)0;
        }
        virtual ~__resqml2__OverlapVolume_sequence() { }
        /// Friend allocator used by soap_new___resqml2__OverlapVolume_sequence(struct soap*, int)
        friend SOAP_FMAC1 __resqml2__OverlapVolume_sequence * SOAP_FMAC2 soap_instantiate___resqml2__OverlapVolume_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:586 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OverlapVolume
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OverlapVolume (147)
/* complex XSD type 'resqml2:OverlapVolume': */
class SOAP_CMAC resqml2__OverlapVolume {
      public:
        __resqml2__OverlapVolume_sequence *__OverlapVolume_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OverlapVolume
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OverlapVolume; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__OverlapVolume, default initialized and not managed by a soap context
        virtual resqml2__OverlapVolume *soap_alloc(void) const { return SOAP_NEW(resqml2__OverlapVolume); }
      public:
        /// Constructor with initializations
        resqml2__OverlapVolume()
        {
          __OverlapVolume_sequence = (__resqml2__OverlapVolume_sequence *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__OverlapVolume() { }
        /// Friend allocator used by soap_new_resqml2__OverlapVolume(struct soap*, int)
        friend SOAP_FMAC1 resqml2__OverlapVolume * SOAP_FMAC2 soap_instantiate_resqml2__OverlapVolume(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:589 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Intervals
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Intervals (148)
/* complex XSD type 'resqml2:Intervals': */
class SOAP_CMAC resqml2__Intervals {
      public:
        /// Required element 'resqml2:IntervalCount' of XSD type 'xsd:positiveInteger'
        ULONG64 IntervalCount;
        /// Required element 'resqml2:ParentCountPerInterval' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ParentCountPerInterval;
        /// Required element 'resqml2:ChildCountPerInterval' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ChildCountPerInterval;
        /// Optional element 'resqml2:ChildCellWeights' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *ChildCellWeights;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Intervals
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Intervals; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Intervals, default initialized and not managed by a soap context
        virtual resqml2__Intervals *soap_alloc(void) const { return SOAP_NEW(resqml2__Intervals); }
      public:
        /// Constructor with initializations
        resqml2__Intervals()
        {
          IntervalCount = (ULONG64)0;
          ParentCountPerInterval = (resqml2__AbstractIntegerArray *)0;
          ChildCountPerInterval = (resqml2__AbstractIntegerArray *)0;
          ChildCellWeights = (resqml2__AbstractDoubleArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__Intervals() { }
        /// Friend allocator used by soap_new_resqml2__Intervals(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Intervals * SOAP_FMAC2 soap_instantiate_resqml2__Intervals(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:595 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParentWindow (150)
/* Type resqml2__AbstractParentWindow is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractParentWindow': */
class SOAP_CMAC resqml2__AbstractParentWindow {
      public:
        /// Optional element 'resqml2:CellOverlap' of XSD type 'resqml2:CellOverlap'
        resqml2__CellOverlap *CellOverlap;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParentWindow
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParentWindow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractParentWindow, default initialized and not managed by a soap context
        virtual resqml2__AbstractParentWindow *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractParentWindow); }
      public:
        /// Constructor with initializations
        resqml2__AbstractParentWindow()
        {
          CellOverlap = (resqml2__CellOverlap *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractParentWindow() { }
        /// Friend allocator used by soap_new_resqml2__AbstractParentWindow(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractParentWindow * SOAP_FMAC2 soap_instantiate_resqml2__AbstractParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:604 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeInterval
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeInterval (153)
/* complex XSD type 'resqml2:TimeInterval': */
class SOAP_CMAC resqml2__TimeInterval {
      public:
        /// Required element 'resqml2:ChronoBottom' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *ChronoBottom;
        /// Required element 'resqml2:ChronoTop' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *ChronoTop;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeInterval
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeInterval; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__TimeInterval, default initialized and not managed by a soap context
        virtual resqml2__TimeInterval *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeInterval); }
      public:
        /// Constructor with initializations
        resqml2__TimeInterval()
        {
          ChronoBottom = (eml__DataObjectReference *)0;
          ChronoTop = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__TimeInterval() { }
        /// Friend allocator used by soap_new_resqml2__TimeInterval(struct soap*, int)
        friend SOAP_FMAC1 resqml2__TimeInterval * SOAP_FMAC2 soap_instantiate_resqml2__TimeInterval(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:613 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StratigraphicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StratigraphicUnitInterpretationIndex (156)
/* complex XSD type 'resqml2:StratigraphicUnitInterpretationIndex': */
class SOAP_CMAC resqml2__StratigraphicUnitInterpretationIndex {
      public:
        /// Required element 'resqml2:Index' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Index;
        /// Required element 'resqml2:Unit' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Unit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StratigraphicUnitInterpretationIndex
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StratigraphicUnitInterpretationIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__StratigraphicUnitInterpretationIndex, default initialized and not managed by a soap context
        virtual resqml2__StratigraphicUnitInterpretationIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__StratigraphicUnitInterpretationIndex); }
      public:
        /// Constructor with initializations
        resqml2__StratigraphicUnitInterpretationIndex()
        {
          Index = (ULONG64)0;
          Unit = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__StratigraphicUnitInterpretationIndex() { }
        /// Friend allocator used by soap_new_resqml2__StratigraphicUnitInterpretationIndex(struct soap*, int)
        friend SOAP_FMAC1 resqml2__StratigraphicUnitInterpretationIndex * SOAP_FMAC2 soap_instantiate_resqml2__StratigraphicUnitInterpretationIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:628 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitInterpretationIndex (161)
/* complex XSD type 'resqml2:GeologicUnitInterpretationIndex': */
class SOAP_CMAC resqml2__GeologicUnitInterpretationIndex {
      public:
        /// Required element 'resqml2:Index' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Index;
        /// Required element 'resqml2:Unit' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Unit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitInterpretationIndex
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitInterpretationIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__GeologicUnitInterpretationIndex, default initialized and not managed by a soap context
        virtual resqml2__GeologicUnitInterpretationIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__GeologicUnitInterpretationIndex); }
      public:
        /// Constructor with initializations
        resqml2__GeologicUnitInterpretationIndex()
        {
          Index = (ULONG64)0;
          Unit = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__GeologicUnitInterpretationIndex() { }
        /// Friend allocator used by soap_new_resqml2__GeologicUnitInterpretationIndex(struct soap*, int)
        friend SOAP_FMAC1 resqml2__GeologicUnitInterpretationIndex * SOAP_FMAC2 soap_instantiate_resqml2__GeologicUnitInterpretationIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:640 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizonInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizonInterpretationIndex (165)
/* complex XSD type 'resqml2:HorizonInterpretationIndex': */
class SOAP_CMAC resqml2__HorizonInterpretationIndex {
      public:
        /// Required element 'resqml2:Index' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Index;
        /// Optional element 'resqml2:StratigraphicRank' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *StratigraphicRank;
        /// Required element 'resqml2:Horizon' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Horizon;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizonInterpretationIndex
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizonInterpretationIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__HorizonInterpretationIndex, default initialized and not managed by a soap context
        virtual resqml2__HorizonInterpretationIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__HorizonInterpretationIndex); }
      public:
        /// Constructor with initializations
        resqml2__HorizonInterpretationIndex()
        {
          Index = (ULONG64)0;
          StratigraphicRank = (ULONG64 *)0;
          Horizon = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__HorizonInterpretationIndex() { }
        /// Friend allocator used by soap_new_resqml2__HorizonInterpretationIndex(struct soap*, int)
        friend SOAP_FMAC1 resqml2__HorizonInterpretationIndex * SOAP_FMAC2 soap_instantiate_resqml2__HorizonInterpretationIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:655 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactInterpretationPart (170)
/* Type resqml2__AbstractContactInterpretationPart is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractContactInterpretationPart': */
class SOAP_CMAC resqml2__AbstractContactInterpretationPart {
      public:
        /// Required element 'resqml2:ContactRelationship' of XSD type 'resqml2:ContactRelationship'
        enum resqml2__ContactRelationship ContactRelationship;
        /// Required element 'resqml2:Index' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Index;
        /// Optional element 'resqml2:PartOf' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *PartOf;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactInterpretationPart
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactInterpretationPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractContactInterpretationPart, default initialized and not managed by a soap context
        virtual resqml2__AbstractContactInterpretationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractContactInterpretationPart); }
      public:
        /// Constructor with initializations
        resqml2__AbstractContactInterpretationPart()
        {
          ContactRelationship = (enum resqml2__ContactRelationship)0;
          Index = (ULONG64)0;
          PartOf = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractContactInterpretationPart() { }
        /// Friend allocator used by soap_new_resqml2__AbstractContactInterpretationPart(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractContactInterpretationPart * SOAP_FMAC2 soap_instantiate_resqml2__AbstractContactInterpretationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:661 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FaultThrow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FaultThrow (172)
/* complex XSD type 'resqml2:FaultThrow': */
class SOAP_CMAC resqml2__FaultThrow {
      public:
        /// Required element 'resqml2:Throw' of XSD type 'resqml2:ThrowKind'
        std::vector<enum resqml2__ThrowKind> Throw;
        /// Optional element 'resqml2:HasOccuredDuring' of XSD type 'resqml2:TimeInterval'
        resqml2__TimeInterval *HasOccuredDuring;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FaultThrow
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FaultThrow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__FaultThrow, default initialized and not managed by a soap context
        virtual resqml2__FaultThrow *soap_alloc(void) const { return SOAP_NEW(resqml2__FaultThrow); }
      public:
        /// Constructor with initializations
        resqml2__FaultThrow()
        {
          HasOccuredDuring = (resqml2__TimeInterval *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__FaultThrow() { }
        /// Friend allocator used by soap_new_resqml2__FaultThrow(struct soap*, int)
        friend SOAP_FMAC1 resqml2__FaultThrow * SOAP_FMAC2 soap_instantiate_resqml2__FaultThrow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:670 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RockFluidUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RockFluidUnitInterpretationIndex (175)
/* complex XSD type 'resqml2:RockFluidUnitInterpretationIndex': */
class SOAP_CMAC resqml2__RockFluidUnitInterpretationIndex {
      public:
        /// Required element 'resqml2:Index' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Index;
        /// Required element 'resqml2:RockFluidUnit' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *RockFluidUnit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RockFluidUnitInterpretationIndex
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RockFluidUnitInterpretationIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__RockFluidUnitInterpretationIndex, default initialized and not managed by a soap context
        virtual resqml2__RockFluidUnitInterpretationIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__RockFluidUnitInterpretationIndex); }
      public:
        /// Constructor with initializations
        resqml2__RockFluidUnitInterpretationIndex()
        {
          Index = (ULONG64)0;
          RockFluidUnit = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__RockFluidUnitInterpretationIndex() { }
        /// Friend allocator used by soap_new_resqml2__RockFluidUnitInterpretationIndex(struct soap*, int)
        friend SOAP_FMAC1 resqml2__RockFluidUnitInterpretationIndex * SOAP_FMAC2 soap_instantiate_resqml2__RockFluidUnitInterpretationIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:697 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ChronostratigraphicRank
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ChronostratigraphicRank (184)
/* complex XSD type 'resqml2:ChronostratigraphicRank': */
class SOAP_CMAC resqml2__ChronostratigraphicRank {
      public:
        /// Required element 'resqml2:Name' of XSD type 'eml:NameString'
        std::string Name;
        /// Required element 'resqml2:Contains' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> Contains;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ChronostratigraphicRank
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ChronostratigraphicRank; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ChronostratigraphicRank, default initialized and not managed by a soap context
        virtual resqml2__ChronostratigraphicRank *soap_alloc(void) const { return SOAP_NEW(resqml2__ChronostratigraphicRank); }
      public:
        /// Constructor with initializations
        resqml2__ChronostratigraphicRank()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ChronostratigraphicRank() { }
        /// Friend allocator used by soap_new_resqml2__ChronostratigraphicRank(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ChronostratigraphicRank * SOAP_FMAC2 soap_instantiate_resqml2__ChronostratigraphicRank(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:724 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3d
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3d (193)
/* complex XSD type 'resqml2:Point3d': */
class SOAP_CMAC resqml2__Point3d {
      public:
        /// Required element 'resqml2:Coordinate1' of XSD type 'xsd:double'
        double Coordinate1;
        /// Required element 'resqml2:Coordinate2' of XSD type 'xsd:double'
        double Coordinate2;
        /// Required element 'resqml2:Coordinate3' of XSD type 'xsd:double'
        double Coordinate3;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3d
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3d; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Point3d, default initialized and not managed by a soap context
        virtual resqml2__Point3d *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3d); }
      public:
        /// Constructor with initializations
        resqml2__Point3d()
        {
          Coordinate1 = (double)0;
          Coordinate2 = (double)0;
          Coordinate3 = (double)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__Point3d() { }
        /// Friend allocator used by soap_new_resqml2__Point3d(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Point3d * SOAP_FMAC2 soap_instantiate_resqml2__Point3d(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:727 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSeriesParentage
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSeriesParentage (194)
/* complex XSD type 'resqml2:TimeSeriesParentage': */
class SOAP_CMAC resqml2__TimeSeriesParentage {
      public:
        /// Required element 'resqml2:HasOverlap' of XSD type 'xsd:boolean'
        bool HasOverlap;
        /// Required element 'resqml2:ParentTimeIndex' of XSD type 'resqml2:TimeIndex'
        resqml2__TimeIndex *ParentTimeIndex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSeriesParentage
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSeriesParentage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__TimeSeriesParentage, default initialized and not managed by a soap context
        virtual resqml2__TimeSeriesParentage *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeSeriesParentage); }
      public:
        /// Constructor with initializations
        resqml2__TimeSeriesParentage()
        {
          HasOverlap = (bool)0;
          ParentTimeIndex = (resqml2__TimeIndex *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__TimeSeriesParentage() { }
        /// Friend allocator used by soap_new_resqml2__TimeSeriesParentage(struct soap*, int)
        friend SOAP_FMAC1 resqml2__TimeSeriesParentage * SOAP_FMAC2 soap_instantiate_resqml2__TimeSeriesParentage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:733 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndex (196)
/* complex XSD type 'resqml2:TimeIndex': */
class SOAP_CMAC resqml2__TimeIndex {
      public:
        /// Required element 'resqml2:Index' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Index;
        /// Required element 'resqml2:TimeSeries' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndex
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndex; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__TimeIndex, default initialized and not managed by a soap context
        virtual resqml2__TimeIndex *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeIndex); }
      public:
        /// Constructor with initializations
        resqml2__TimeIndex()
        {
          Index = (ULONG64)0;
          TimeSeries = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__TimeIndex() { }
        /// Friend allocator used by soap_new_resqml2__TimeIndex(struct soap*, int)
        friend SOAP_FMAC1 resqml2__TimeIndex * SOAP_FMAC2 soap_instantiate_resqml2__TimeIndex(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:736 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Timestamp
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Timestamp (197)
/* complex XSD type 'resqml2:Timestamp': */
class SOAP_CMAC resqml2__Timestamp {
      public:
        /// Required element 'resqml2:DateTime' of XSD type 'xsd:dateTime'
        time_t DateTime;
        /// Optional element 'resqml2:YearOffset' of XSD type 'xsd:long'
        LONG64 *YearOffset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Timestamp
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Timestamp; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Timestamp, default initialized and not managed by a soap context
        virtual resqml2__Timestamp *soap_alloc(void) const { return SOAP_NEW(resqml2__Timestamp); }
      public:
        /// Constructor with initializations
        resqml2__Timestamp()
        {
          DateTime = (time_t)0;
          YearOffset = (LONG64 *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__Timestamp() { }
        /// Friend allocator used by soap_new_resqml2__Timestamp(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Timestamp * SOAP_FMAC2 soap_instantiate_resqml2__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:742 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlJaggedArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlJaggedArray (199)
/* complex XSD type 'resqml2:ResqmlJaggedArray': */
class SOAP_CMAC resqml2__ResqmlJaggedArray {
      public:
        /// Required element 'resqml2:Elements' of XSD type 'resqml2:AbstractValueArray'
        resqml2__AbstractValueArray *Elements;
        /// Required element 'resqml2:CumulativeLength' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *CumulativeLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlJaggedArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlJaggedArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ResqmlJaggedArray, default initialized and not managed by a soap context
        virtual resqml2__ResqmlJaggedArray *soap_alloc(void) const { return SOAP_NEW(resqml2__ResqmlJaggedArray); }
      public:
        /// Constructor with initializations
        resqml2__ResqmlJaggedArray()
        {
          Elements = (resqml2__AbstractValueArray *)0;
          CumulativeLength = (resqml2__AbstractIntegerArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ResqmlJaggedArray() { }
        /// Friend allocator used by soap_new_resqml2__ResqmlJaggedArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ResqmlJaggedArray * SOAP_FMAC2 soap_instantiate_resqml2__ResqmlJaggedArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:745 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NameValuePair
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NameValuePair (200)
/* complex XSD type 'resqml2:NameValuePair': */
class SOAP_CMAC resqml2__NameValuePair {
      public:
        /// Required element 'resqml2:Name' of XSD type 'xsd:string'
        std::string Name;
        /// Required element 'resqml2:Value' of XSD type 'xsd:string'
        std::string Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NameValuePair
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NameValuePair; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__NameValuePair, default initialized and not managed by a soap context
        virtual resqml2__NameValuePair *soap_alloc(void) const { return SOAP_NEW(resqml2__NameValuePair); }
      public:
        /// Constructor with initializations
        resqml2__NameValuePair()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__NameValuePair() { }
        /// Friend allocator used by soap_new_resqml2__NameValuePair(struct soap*, int)
        friend SOAP_FMAC1 resqml2__NameValuePair * SOAP_FMAC2 soap_instantiate_resqml2__NameValuePair(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:760 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreTrajectoryParentIntersection
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreTrajectoryParentIntersection (205)
/* complex XSD type 'resqml2:WellboreTrajectoryParentIntersection': */
class SOAP_CMAC resqml2__WellboreTrajectoryParentIntersection {
      public:
        /// Required element 'resqml2:KickoffMd' of XSD type 'xsd:double'
        double KickoffMd;
        /// Required element 'resqml2:ParentMd' of XSD type 'xsd:double'
        double ParentMd;
        /// Required element 'resqml2:ParentTrajectory' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *ParentTrajectory;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreTrajectoryParentIntersection
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreTrajectoryParentIntersection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__WellboreTrajectoryParentIntersection, default initialized and not managed by a soap context
        virtual resqml2__WellboreTrajectoryParentIntersection *soap_alloc(void) const { return SOAP_NEW(resqml2__WellboreTrajectoryParentIntersection); }
      public:
        /// Constructor with initializations
        resqml2__WellboreTrajectoryParentIntersection()
        {
          KickoffMd = (double)0;
          ParentMd = (double)0;
          ParentTrajectory = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__WellboreTrajectoryParentIntersection() { }
        /// Friend allocator used by soap_new_resqml2__WellboreTrajectoryParentIntersection(struct soap*, int)
        friend SOAP_FMAC1 resqml2__WellboreTrajectoryParentIntersection * SOAP_FMAC2 soap_instantiate_resqml2__WellboreTrajectoryParentIntersection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:799 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactRepresentationPart (218)
/* Type resqml2__AbstractContactRepresentationPart is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractContactRepresentationPart': */
class SOAP_CMAC resqml2__AbstractContactRepresentationPart {
      public:
        /// Required element 'resqml2:Index' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Index;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactRepresentationPart
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactRepresentationPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractContactRepresentationPart, default initialized and not managed by a soap context
        virtual resqml2__AbstractContactRepresentationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractContactRepresentationPart); }
      public:
        /// Constructor with initializations
        resqml2__AbstractContactRepresentationPart()
        {
          Index = (ULONG64)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractContactRepresentationPart() { }
        /// Friend allocator used by soap_new_resqml2__AbstractContactRepresentationPart(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractContactRepresentationPart * SOAP_FMAC2 soap_instantiate_resqml2__AbstractContactRepresentationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:814 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeRegion
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeRegion (223)
/* complex XSD type 'resqml2:VolumeRegion': */
class SOAP_CMAC resqml2__VolumeRegion {
      public:
        /// Required element 'resqml2:PatchIndex' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 PatchIndex;
        /// Optional element 'resqml2:InternalShells' of XSD type 'resqml2:VolumeShell'
        std::vector<resqml2__VolumeShell *> InternalShells;
        /// Required element 'resqml2:Represents' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Represents;
        /// Required element 'resqml2:ExternalShell' of XSD type 'resqml2:VolumeShell'
        resqml2__VolumeShell *ExternalShell;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeRegion
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeRegion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__VolumeRegion, default initialized and not managed by a soap context
        virtual resqml2__VolumeRegion *soap_alloc(void) const { return SOAP_NEW(resqml2__VolumeRegion); }
      public:
        /// Constructor with initializations
        resqml2__VolumeRegion()
        {
          PatchIndex = (ULONG64)0;
          Represents = (eml__DataObjectReference *)0;
          ExternalShell = (resqml2__VolumeShell *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__VolumeRegion() { }
        /// Friend allocator used by soap_new_resqml2__VolumeRegion(struct soap*, int)
        friend SOAP_FMAC1 resqml2__VolumeRegion * SOAP_FMAC2 soap_instantiate_resqml2__VolumeRegion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:817 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeShell
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeShell (224)
/* complex XSD type 'resqml2:VolumeShell': */
class SOAP_CMAC resqml2__VolumeShell {
      public:
        /// Required element 'resqml2:ShellUid' of XSD type 'xsd:string'
        std::string ShellUid;
        /// Required element 'resqml2:MacroFaces' of XSD type 'resqml2:OrientedMacroFace'
        std::vector<resqml2__OrientedMacroFace *> MacroFaces;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeShell
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeShell; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__VolumeShell, default initialized and not managed by a soap context
        virtual resqml2__VolumeShell *soap_alloc(void) const { return SOAP_NEW(resqml2__VolumeShell); }
      public:
        /// Constructor with initializations
        resqml2__VolumeShell()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__VolumeShell() { }
        /// Friend allocator used by soap_new_resqml2__VolumeShell(struct soap*, int)
        friend SOAP_FMAC1 resqml2__VolumeShell * SOAP_FMAC2 soap_instantiate_resqml2__VolumeShell(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:838 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchBoundaries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchBoundaries (231)
/* complex XSD type 'resqml2:PatchBoundaries': */
class SOAP_CMAC resqml2__PatchBoundaries {
      public:
        /// Optional element 'resqml2:InnerRing' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> InnerRing;
        /// Optional element 'resqml2:OuterRing' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *OuterRing;
        /// Required element 'resqml2:ReferencedPatch' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 ReferencedPatch;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchBoundaries
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchBoundaries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__PatchBoundaries, default initialized and not managed by a soap context
        virtual resqml2__PatchBoundaries *soap_alloc(void) const { return SOAP_NEW(resqml2__PatchBoundaries); }
      public:
        /// Constructor with initializations
        resqml2__PatchBoundaries()
        {
          OuterRing = (eml__DataObjectReference *)0;
          ReferencedPatch = (ULONG64)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__PatchBoundaries() { }
        /// Friend allocator used by soap_new_resqml2__PatchBoundaries(struct soap*, int)
        friend SOAP_FMAC1 resqml2__PatchBoundaries * SOAP_FMAC2 soap_instantiate_resqml2__PatchBoundaries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:853 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrientedMacroFace
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrientedMacroFace (236)
/* complex XSD type 'resqml2:OrientedMacroFace': */
class SOAP_CMAC resqml2__OrientedMacroFace {
      public:
        /// Required element 'resqml2:PatchIndexOfRepresentation' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 PatchIndexOfRepresentation;
        /// Required element 'resqml2:RepresentationIndex' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 RepresentationIndex;
        /// Required element 'resqml2:SideIsPlus' of XSD type 'xsd:boolean'
        bool SideIsPlus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrientedMacroFace
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrientedMacroFace; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__OrientedMacroFace, default initialized and not managed by a soap context
        virtual resqml2__OrientedMacroFace *soap_alloc(void) const { return SOAP_NEW(resqml2__OrientedMacroFace); }
      public:
        /// Constructor with initializations
        resqml2__OrientedMacroFace()
        {
          PatchIndexOfRepresentation = (ULONG64)0;
          RepresentationIndex = (ULONG64)0;
          SideIsPlus = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__OrientedMacroFace() { }
        /// Friend allocator used by soap_new_resqml2__OrientedMacroFace(struct soap*, int)
        friend SOAP_FMAC1 resqml2__OrientedMacroFace * SOAP_FMAC2 soap_instantiate_resqml2__OrientedMacroFace(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:856 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactIdentity (237)
/* complex XSD type 'resqml2:ContactIdentity': */
class SOAP_CMAC resqml2__ContactIdentity {
      public:
        /// Required element 'resqml2:IdentityKind' of XSD type 'resqml2:IdentityKind'
        enum resqml2__IdentityKind IdentityKind;
        /// Required element 'resqml2:ListOfContactRepresentations' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ListOfContactRepresentations;
        /// Optional element 'resqml2:ListOfIdenticalNodes' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ListOfIdenticalNodes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactIdentity
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactIdentity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ContactIdentity, default initialized and not managed by a soap context
        virtual resqml2__ContactIdentity *soap_alloc(void) const { return SOAP_NEW(resqml2__ContactIdentity); }
      public:
        /// Constructor with initializations
        resqml2__ContactIdentity()
        {
          IdentityKind = (enum resqml2__IdentityKind)0;
          ListOfContactRepresentations = (resqml2__AbstractIntegerArray *)0;
          ListOfIdenticalNodes = (resqml2__AbstractIntegerArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ContactIdentity() { }
        /// Friend allocator used by soap_new_resqml2__ContactIdentity(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ContactIdentity * SOAP_FMAC2 soap_instantiate_resqml2__ContactIdentity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:886 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WitsmlWellboreReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WitsmlWellboreReference (247)
/* complex XSD type 'resqml2:WitsmlWellboreReference': */
class SOAP_CMAC resqml2__WitsmlWellboreReference {
      public:
        /// Required element 'resqml2:WitsmlWell' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *WitsmlWell;
        /// Required element 'resqml2:WitsmlWellbore' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *WitsmlWellbore;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WitsmlWellboreReference
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WitsmlWellboreReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__WitsmlWellboreReference, default initialized and not managed by a soap context
        virtual resqml2__WitsmlWellboreReference *soap_alloc(void) const { return SOAP_NEW(resqml2__WitsmlWellboreReference); }
      public:
        /// Constructor with initializations
        resqml2__WitsmlWellboreReference()
        {
          WitsmlWell = (eml__DataObjectReference *)0;
          WitsmlWellbore = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__WitsmlWellboreReference() { }
        /// Friend allocator used by soap_new_resqml2__WitsmlWellboreReference(struct soap*, int)
        friend SOAP_FMAC1 resqml2__WitsmlWellboreReference * SOAP_FMAC2 soap_instantiate_resqml2__WitsmlWellboreReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:901 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterTemplate (252)
/* complex XSD type 'resqml2:ParameterTemplate': */
class SOAP_CMAC resqml2__ParameterTemplate {
      public:
        /// Optional element 'resqml2:KeyConstraint' of XSD type 'xsd:string'
        std::vector<std::string> KeyConstraint;
        /// Required element 'resqml2:IsInput' of XSD type 'xsd:boolean'
        bool IsInput;
        /// Optional element 'resqml2:AllowedKind' of XSD type 'resqml2:ParameterKind'
        std::vector<enum resqml2__ParameterKind> AllowedKind;
        /// Required element 'resqml2:IsOutput' of XSD type 'xsd:boolean'
        bool IsOutput;
        /// Required element 'resqml2:Title' of XSD type 'xsd:string'
        std::string Title;
        /// Optional element 'resqml2:DataObjectContentType' of XSD type 'xsd:string'
        std::string *DataObjectContentType;
        /// Required element 'resqml2:MaxOccurs' of XSD type 'xsd:long'
        LONG64 MaxOccurs;
        /// Required element 'resqml2:MinOccurs' of XSD type 'xsd:long'
        LONG64 MinOccurs;
        /// Optional element 'resqml2:Constraint' of XSD type 'xsd:string'
        std::string *Constraint;
        /// Optional element 'resqml2:DefaultValue' of XSD type 'resqml2:AbstractActivityParameter'
        std::vector<resqml2__AbstractActivityParameter *> DefaultValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterTemplate
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ParameterTemplate, default initialized and not managed by a soap context
        virtual resqml2__ParameterTemplate *soap_alloc(void) const { return SOAP_NEW(resqml2__ParameterTemplate); }
      public:
        /// Constructor with initializations
        resqml2__ParameterTemplate()
        {
          IsInput = (bool)0;
          IsOutput = (bool)0;
          DataObjectContentType = (std::string *)0;
          MaxOccurs = (LONG64)0;
          MinOccurs = (LONG64)0;
          Constraint = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__ParameterTemplate() { }
        /// Friend allocator used by soap_new_resqml2__ParameterTemplate(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ParameterTemplate * SOAP_FMAC2 soap_instantiate_resqml2__ParameterTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:913 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParameterKey (256)
/* Type resqml2__AbstractParameterKey is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractParameterKey': */
class SOAP_CMAC resqml2__AbstractParameterKey {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParameterKey
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractParameterKey, default initialized and not managed by a soap context
        virtual resqml2__AbstractParameterKey *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractParameterKey); }
      public:
        /// Constructor with initializations
        resqml2__AbstractParameterKey()
        {
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractParameterKey() { }
        /// Friend allocator used by soap_new_resqml2__AbstractParameterKey(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractParameterKey * SOAP_FMAC2 soap_instantiate_resqml2__AbstractParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:919 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractActivityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractActivityParameter (258)
/* Type resqml2__AbstractActivityParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractActivityParameter': */
class SOAP_CMAC resqml2__AbstractActivityParameter {
      public:
        /// Required element 'resqml2:Title' of XSD type 'xsd:string'
        std::string Title;
        /// Optional element 'resqml2:Index' of XSD type 'xsd:long'
        LONG64 *Index;
        /// Optional element 'resqml2:Selection' of XSD type 'xsd:string'
        std::string *Selection;
        /// Optional element 'resqml2:Key' of XSD type 'resqml2:AbstractParameterKey'
        std::vector<resqml2__AbstractParameterKey *> Key;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractActivityParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractActivityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractActivityParameter, default initialized and not managed by a soap context
        virtual resqml2__AbstractActivityParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractActivityParameter); }
      public:
        /// Constructor with initializations
        resqml2__AbstractActivityParameter()
        {
          Index = (LONG64 *)0;
          Selection = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__AbstractActivityParameter() { }
        /// Friend allocator used by soap_new_resqml2__AbstractActivityParameter(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractActivityParameter * SOAP_FMAC2 soap_instantiate_resqml2__AbstractActivityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:934 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineWellbores
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineWellbores (263)
/* complex XSD type 'resqml2:StreamlineWellbores': */
class SOAP_CMAC resqml2__StreamlineWellbores {
      public:
        /// Required element 'resqml2:InjectorPerLine' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *InjectorPerLine;
        /// Required element 'resqml2:ProducerPerLine' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ProducerPerLine;
        /// Required element 'resqml2:WellboreTrajectoryRepresentation' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> WellboreTrajectoryRepresentation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineWellbores
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineWellbores; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__StreamlineWellbores, default initialized and not managed by a soap context
        virtual resqml2__StreamlineWellbores *soap_alloc(void) const { return SOAP_NEW(resqml2__StreamlineWellbores); }
      public:
        /// Constructor with initializations
        resqml2__StreamlineWellbores()
        {
          InjectorPerLine = (resqml2__AbstractIntegerArray *)0;
          ProducerPerLine = (resqml2__AbstractIntegerArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__StreamlineWellbores() { }
        /// Friend allocator used by soap_new_resqml2__StreamlineWellbores(struct soap*, int)
        friend SOAP_FMAC1 resqml2__StreamlineWellbores * SOAP_FMAC2 soap_instantiate_resqml2__StreamlineWellbores(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:937 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalGridCells
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalGridCells (264)
/* complex XSD type 'resqml2:IntervalGridCells': */
class SOAP_CMAC resqml2__IntervalGridCells {
      public:
        /// Required element 'resqml2:CellCount' of XSD type 'xsd:positiveInteger'
        ULONG64 CellCount;
        /// Required element 'resqml2:GridIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *GridIndices;
        /// Required element 'resqml2:CellIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *CellIndices;
        /// Required element 'resqml2:LocalFacePairPerCellIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *LocalFacePairPerCellIndices;
        /// Required element 'resqml2:Grids' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> Grids;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalGridCells
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalGridCells; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IntervalGridCells, default initialized and not managed by a soap context
        virtual resqml2__IntervalGridCells *soap_alloc(void) const { return SOAP_NEW(resqml2__IntervalGridCells); }
      public:
        /// Constructor with initializations
        resqml2__IntervalGridCells()
        {
          CellCount = (ULONG64)0;
          GridIndices = (resqml2__AbstractIntegerArray *)0;
          CellIndices = (resqml2__AbstractIntegerArray *)0;
          LocalFacePairPerCellIndices = (resqml2__AbstractIntegerArray *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__IntervalGridCells() { }
        /// Friend allocator used by soap_new_resqml2__IntervalGridCells(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IntervalGridCells * SOAP_FMAC2 soap_instantiate_resqml2__IntervalGridCells(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:940 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndices
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndices (265)
/* complex XSD type 'resqml2:TimeIndices': */
class SOAP_CMAC resqml2__TimeIndices {
      public:
        /// Required element 'resqml2:TimeIndexCount' of XSD type 'xsd:positiveInteger'
        ULONG64 TimeIndexCount;
        /// Optional element 'resqml2:TimeIndexStart' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *TimeIndexStart;
        /// Optional element 'resqml2:SimulatorTimeStep' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *SimulatorTimeStep;
        /// Required element 'resqml2:UseInterval' of XSD type 'xsd:boolean'
        bool UseInterval;
        /// Required element 'resqml2:TimeSeries' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *TimeSeries;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndices
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__TimeIndices, default initialized and not managed by a soap context
        virtual resqml2__TimeIndices *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeIndices); }
      public:
        /// Constructor with initializations
        resqml2__TimeIndices()
        {
          TimeIndexCount = (ULONG64)0;
          TimeIndexStart = (ULONG64 *)0;
          SimulatorTimeStep = (resqml2__AbstractIntegerArray *)0;
          UseInterval = (bool)0;
          TimeSeries = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~resqml2__TimeIndices() { }
        /// Friend allocator used by soap_new_resqml2__TimeIndices(struct soap*, int)
        friend SOAP_FMAC1 resqml2__TimeIndices * SOAP_FMAC2 soap_instantiate_resqml2__TimeIndices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:958 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CustomData
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CustomData (271)
/* complex XSD type 'eml:CustomData': */
class SOAP_CMAC eml__CustomData {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__CustomData
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__CustomData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__CustomData, default initialized and not managed by a soap context
        virtual eml__CustomData *soap_alloc(void) const { return SOAP_NEW(eml__CustomData); }
      public:
        /// Constructor with initializations
        eml__CustomData()
        {
          soap = (struct soap *)0;
        }
        virtual ~eml__CustomData() { }
        /// Friend allocator used by soap_new_eml__CustomData(struct soap*, int)
        friend SOAP_FMAC1 eml__CustomData * SOAP_FMAC2 soap_instantiate_eml__CustomData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:961 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__Citation
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__Citation (272)
/* complex XSD type 'eml:Citation': */
class SOAP_CMAC eml__Citation {
      public:
        /// Required element 'eml:Title' of XSD type 'eml:DescriptionString'
        std::string Title;
        /// Required element 'eml:Originator' of XSD type 'eml:NameString'
        std::string Originator;
        /// Required element 'eml:Creation' of XSD type 'xsd:dateTime'
        time_t Creation;
        /// Required element 'eml:Format' of XSD type 'eml:DescriptionString'
        std::string Format;
        /// Optional element 'eml:Editor' of XSD type 'eml:NameString'
        std::string *Editor;
        /// Optional element 'eml:LastUpdate' of XSD type 'xsd:dateTime'
        time_t *LastUpdate;
        /// Optional element 'eml:VersionString' of XSD type 'xsd:string'
        std::string *VersionString;
        /// Optional element 'eml:Description' of XSD type 'eml:CommentString'
        std::string *Description;
        /// Optional element 'eml:DescriptiveKeywords' of XSD type 'eml:CommentString'
        std::string *DescriptiveKeywords;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__Citation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__Citation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__Citation, default initialized and not managed by a soap context
        virtual eml__Citation *soap_alloc(void) const { return SOAP_NEW(eml__Citation); }
      public:
        /// Constructor with initializations
        eml__Citation()
        {
          Creation = (time_t)0;
          Editor = (std::string *)0;
          LastUpdate = (time_t *)0;
          VersionString = (std::string *)0;
          Description = (std::string *)0;
          DescriptiveKeywords = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__Citation() { }
        /// Friend allocator used by soap_new_eml__Citation(struct soap*, int)
        friend SOAP_FMAC1 eml__Citation * SOAP_FMAC2 soap_instantiate_eml__Citation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:964 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractObject
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractObject (273)
/* complex XSD type 'eml:AbstractObject': */
class SOAP_CMAC eml__AbstractObject {
      public:
        /// Optional element 'eml:Citation' of XSD type 'eml:Citation'
        eml__Citation *Citation;
        /// Optional element 'eml:Aliases' of XSD type 'eml:ObjectAlias'
        std::vector<eml__ObjectAlias *> Aliases;
        /// Optional element 'eml:CustomData' of XSD type 'eml:CustomData'
        eml__CustomData *CustomData;
        /// required attribute 'schemaVersion' of XSD type 'xsd:string'
        std::string schemaVersion;
        /// required attribute 'uuid' of XSD type 'eml:UuidString'
        std::string uuid;
        /// optional attribute 'objectVersion' of XSD type 'eml:NameString'
        std::string *objectVersion;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractObject
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AbstractObject, default initialized and not managed by a soap context
        virtual eml__AbstractObject *soap_alloc(void) const { return SOAP_NEW(eml__AbstractObject); }
      public:
        /// Constructor with initializations
        eml__AbstractObject()
        {
          Citation = (eml__Citation *)0;
          CustomData = (eml__CustomData *)0;
          objectVersion = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AbstractObject() { }
        /// Friend allocator used by soap_new_eml__AbstractObject(struct soap*, int)
        friend SOAP_FMAC1 eml__AbstractObject * SOAP_FMAC2 soap_instantiate_eml__AbstractObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:967 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ObjectAlias
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ObjectAlias (274)
/* complex XSD type 'eml:ObjectAlias': */
class SOAP_CMAC eml__ObjectAlias {
      public:
        /// Required element 'eml:Identifier' of XSD type 'xsd:string'
        std::string Identifier;
        /// Optional element 'eml:Description' of XSD type 'eml:DescriptionString'
        std::string *Description;
        /// optional attribute 'authority' of XSD type 'eml:NameString'
        std::string *authority;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ObjectAlias
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ObjectAlias; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ObjectAlias, default initialized and not managed by a soap context
        virtual eml__ObjectAlias *soap_alloc(void) const { return SOAP_NEW(eml__ObjectAlias); }
      public:
        /// Constructor with initializations
        eml__ObjectAlias()
        {
          Description = (std::string *)0;
          authority = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ObjectAlias() { }
        /// Friend allocator used by soap_new_eml__ObjectAlias(struct soap*, int)
        friend SOAP_FMAC1 eml__ObjectAlias * SOAP_FMAC2 soap_instantiate_eml__ObjectAlias(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:985 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractVerticalCrs (280)
/* Type eml__AbstractVerticalCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:AbstractVerticalCrs': */
class SOAP_CMAC eml__AbstractVerticalCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractVerticalCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractVerticalCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AbstractVerticalCrs, default initialized and not managed by a soap context
        virtual eml__AbstractVerticalCrs *soap_alloc(void) const { return SOAP_NEW(eml__AbstractVerticalCrs); }
      public:
        /// Constructor with initializations
        eml__AbstractVerticalCrs()
        {
          soap = (struct soap *)0;
        }
        virtual ~eml__AbstractVerticalCrs() { }
        /// Friend allocator used by soap_new_eml__AbstractVerticalCrs(struct soap*, int)
        friend SOAP_FMAC1 eml__AbstractVerticalCrs * SOAP_FMAC2 soap_instantiate_eml__AbstractVerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:988 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractProjectedCrs (281)
/* Type eml__AbstractProjectedCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:AbstractProjectedCrs': */
class SOAP_CMAC eml__AbstractProjectedCrs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractProjectedCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractProjectedCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AbstractProjectedCrs, default initialized and not managed by a soap context
        virtual eml__AbstractProjectedCrs *soap_alloc(void) const { return SOAP_NEW(eml__AbstractProjectedCrs); }
      public:
        /// Constructor with initializations
        eml__AbstractProjectedCrs()
        {
          soap = (struct soap *)0;
        }
        virtual ~eml__AbstractProjectedCrs() { }
        /// Friend allocator used by soap_new_eml__AbstractProjectedCrs(struct soap*, int)
        friend SOAP_FMAC1 eml__AbstractProjectedCrs * SOAP_FMAC2 soap_instantiate_eml__AbstractProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1000 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__Hdf5Dataset
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__Hdf5Dataset (285)
/* complex XSD type 'eml:Hdf5Dataset': */
class SOAP_CMAC eml__Hdf5Dataset {
      public:
        /// Required element 'eml:PathInHdfFile' of XSD type 'xsd:string'
        std::string PathInHdfFile;
        /// Required element 'eml:HdfProxy' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *HdfProxy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__Hdf5Dataset
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__Hdf5Dataset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__Hdf5Dataset, default initialized and not managed by a soap context
        virtual eml__Hdf5Dataset *soap_alloc(void) const { return SOAP_NEW(eml__Hdf5Dataset); }
      public:
        /// Constructor with initializations
        eml__Hdf5Dataset()
        {
          HdfProxy = (eml__DataObjectReference *)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__Hdf5Dataset() { }
        /// Friend allocator used by soap_new_eml__Hdf5Dataset(struct soap*, int)
        friend SOAP_FMAC1 eml__Hdf5Dataset * SOAP_FMAC2 soap_instantiate_eml__Hdf5Dataset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1006 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DataObjectReference
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DataObjectReference (287)
/* Type eml__DataObjectReference is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:DataObjectReference': */
class SOAP_CMAC eml__DataObjectReference {
      public:
        /// Required element 'eml:ContentType' of XSD type 'xsd:string'
        std::string ContentType;
        /// Required element 'eml:Title' of XSD type 'eml:DescriptionString'
        std::string Title;
        /// Required element 'eml:UUID' of XSD type 'eml:UuidString'
        std::string UUID;
        /// Optional element 'eml:UuidAuthority' of XSD type 'xsd:string'
        std::string *UuidAuthority;
        /// Optional element 'eml:VersionString' of XSD type 'eml:NameString'
        std::string *VersionString;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__DataObjectReference
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__DataObjectReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__DataObjectReference, default initialized and not managed by a soap context
        virtual eml__DataObjectReference *soap_alloc(void) const { return SOAP_NEW(eml__DataObjectReference); }
      public:
        /// Constructor with initializations
        eml__DataObjectReference()
        {
          UuidAuthority = (std::string *)0;
          VersionString = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__DataObjectReference() { }
        /// Friend allocator used by soap_new_eml__DataObjectReference(struct soap*, int)
        friend SOAP_FMAC1 eml__DataObjectReference * SOAP_FMAC2 soap_instantiate_eml__DataObjectReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1549 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGMLType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGMLType (468)
/* Type gml__AbstractGMLType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractGMLType': */
class SOAP_CMAC gml__AbstractGMLType {
      public:
        /// Optional element 'gml:description' of XSD type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XSD type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Optional element 'gml:identifier' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XSD type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// required attribute 'gml:id' of XSD type 'xsd:ID'
        std::string gml__id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGMLType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGMLType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGMLType, default initialized and not managed by a soap context
        virtual gml__AbstractGMLType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGMLType); }
      public:
        /// Constructor with initializations
        gml__AbstractGMLType()
        {
          description = (gml__StringOrRefType *)0;
          descriptionReference = (gml__ReferenceType *)0;
          identifier = (gml__CodeWithAuthorityType *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__AbstractGMLType() { }
        /// Friend allocator used by soap_new_gml__AbstractGMLType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGMLType * SOAP_FMAC2 soap_instantiate_gml__AbstractGMLType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1555 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__ReferenceType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__ReferenceType (470)
/* complex XSD type 'gml:ReferenceType': */
class SOAP_CMAC gml__ReferenceType {
      public:
        /// optional attribute 'owns' of XSD type 'xsd:boolean'
        bool owns;	///< default = (bool)0
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__ReferenceType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__ReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ReferenceType, default initialized and not managed by a soap context
        virtual gml__ReferenceType *soap_alloc(void) const { return SOAP_NEW(gml__ReferenceType); }
      public:
        /// Constructor with initializations
        gml__ReferenceType()
        {
          owns = (bool)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__ReferenceType() { }
        /// Friend allocator used by soap_new_gml__ReferenceType(struct soap*, int)
        friend SOAP_FMAC1 gml__ReferenceType * SOAP_FMAC2 soap_instantiate_gml__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15518 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_TimePrimitivePropertyType (879)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_TimePrimitivePropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:15507 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__TimePrimitivePropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__TimePrimitivePropertyType_sequence (878)
/* Wrapper: */
class SOAP_CMAC __gml__TimePrimitivePropertyType_sequence {
      public:
        /// Union with union _gml__union_TimePrimitivePropertyType variant selector __unionAbstractTimePrimitive set to one of:
        int __unionAbstractTimePrimitive;
        union _gml__union_TimePrimitivePropertyType union_TimePrimitivePropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__TimePrimitivePropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__TimePrimitivePropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__TimePrimitivePropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__TimePrimitivePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__TimePrimitivePropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__TimePrimitivePropertyType_sequence()
        {
          __unionAbstractTimePrimitive = -1;
        }
        virtual ~__gml__TimePrimitivePropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__TimePrimitivePropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__TimePrimitivePropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__TimePrimitivePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1573 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__TimePrimitivePropertyType (476)
/* Type gml__TimePrimitivePropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:TimePrimitivePropertyType': */
class SOAP_CMAC gml__TimePrimitivePropertyType {
      public:
        __gml__TimePrimitivePropertyType_sequence *__TimePrimitivePropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// optional attribute 'owns' of XSD type 'xsd:boolean'
        bool owns;	///< default = (bool)0
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__TimePrimitivePropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__TimePrimitivePropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__TimePrimitivePropertyType, default initialized and not managed by a soap context
        virtual gml__TimePrimitivePropertyType *soap_alloc(void) const { return SOAP_NEW(gml__TimePrimitivePropertyType); }
      public:
        /// Constructor with initializations
        gml__TimePrimitivePropertyType()
        {
          __TimePrimitivePropertyType_sequence = (__gml__TimePrimitivePropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          owns = (bool)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__TimePrimitivePropertyType() { }
        /// Friend allocator used by soap_new_gml__TimePrimitivePropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__TimePrimitivePropertyType * SOAP_FMAC2 soap_instantiate_gml__TimePrimitivePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15578 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidalCSPropertyType_sequence (881)
/* Wrapper: */
class SOAP_CMAC __gml__EllipsoidalCSPropertyType_sequence {
      public:
        /// Required element 'gml:EllipsoidalCS' of XSD type 'gml:EllipsoidalCSType'
        gml__EllipsoidalCSType *EllipsoidalCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidalCSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__EllipsoidalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__EllipsoidalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__EllipsoidalCSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__EllipsoidalCSPropertyType_sequence()
        {
          EllipsoidalCS = (gml__EllipsoidalCSType *)0;
        }
        virtual ~__gml__EllipsoidalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__EllipsoidalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__EllipsoidalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__EllipsoidalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1576 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSPropertyType (477)
/* complex XSD type 'gml:EllipsoidalCSPropertyType': */
class SOAP_CMAC gml__EllipsoidalCSPropertyType {
      public:
        __gml__EllipsoidalCSPropertyType_sequence *__EllipsoidalCSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__EllipsoidalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidalCSPropertyType); }
      public:
        /// Constructor with initializations
        gml__EllipsoidalCSPropertyType()
        {
          __EllipsoidalCSPropertyType_sequence = (__gml__EllipsoidalCSPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__EllipsoidalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15639 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__CoordinateSystemAxisPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__CoordinateSystemAxisPropertyType_sequence (884)
/* Wrapper: */
class SOAP_CMAC __gml__CoordinateSystemAxisPropertyType_sequence {
      public:
        /// Required element 'gml:CoordinateSystemAxis' of XSD type 'gml:CoordinateSystemAxisType'
        gml__CoordinateSystemAxisType *CoordinateSystemAxis;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__CoordinateSystemAxisPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__CoordinateSystemAxisPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CoordinateSystemAxisPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CoordinateSystemAxisPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CoordinateSystemAxisPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__CoordinateSystemAxisPropertyType_sequence()
        {
          CoordinateSystemAxis = (gml__CoordinateSystemAxisType *)0;
        }
        virtual ~__gml__CoordinateSystemAxisPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CoordinateSystemAxisPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CoordinateSystemAxisPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CoordinateSystemAxisPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1585 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisPropertyType (480)
/* complex XSD type 'gml:CoordinateSystemAxisPropertyType': */
class SOAP_CMAC gml__CoordinateSystemAxisPropertyType {
      public:
        __gml__CoordinateSystemAxisPropertyType_sequence *__CoordinateSystemAxisPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoordinateSystemAxisPropertyType, default initialized and not managed by a soap context
        virtual gml__CoordinateSystemAxisPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CoordinateSystemAxisPropertyType); }
      public:
        /// Constructor with initializations
        gml__CoordinateSystemAxisPropertyType()
        {
          __CoordinateSystemAxisPropertyType_sequence = (__gml__CoordinateSystemAxisPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__CoordinateSystemAxisPropertyType() { }
        /// Friend allocator used by soap_new_gml__CoordinateSystemAxisPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoordinateSystemAxisPropertyType * SOAP_FMAC2 soap_instantiate_gml__CoordinateSystemAxisPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15700 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__CartesianCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__CartesianCSPropertyType_sequence (887)
/* Wrapper: */
class SOAP_CMAC __gml__CartesianCSPropertyType_sequence {
      public:
        /// Required element 'gml:CartesianCS' of XSD type 'gml:CartesianCSType'
        gml__CartesianCSType *CartesianCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__CartesianCSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__CartesianCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CartesianCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CartesianCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CartesianCSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__CartesianCSPropertyType_sequence()
        {
          CartesianCS = (gml__CartesianCSType *)0;
        }
        virtual ~__gml__CartesianCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CartesianCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CartesianCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CartesianCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1591 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSPropertyType (482)
/* complex XSD type 'gml:CartesianCSPropertyType': */
class SOAP_CMAC gml__CartesianCSPropertyType {
      public:
        __gml__CartesianCSPropertyType_sequence *__CartesianCSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CartesianCSPropertyType, default initialized and not managed by a soap context
        virtual gml__CartesianCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CartesianCSPropertyType); }
      public:
        /// Constructor with initializations
        gml__CartesianCSPropertyType()
        {
          __CartesianCSPropertyType_sequence = (__gml__CartesianCSPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__CartesianCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__CartesianCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CartesianCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__CartesianCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15761 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__SphericalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__SphericalCSPropertyType_sequence (890)
/* Wrapper: */
class SOAP_CMAC __gml__SphericalCSPropertyType_sequence {
      public:
        /// Required element 'gml:SphericalCS' of XSD type 'gml:SphericalCSType'
        gml__SphericalCSType *SphericalCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__SphericalCSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__SphericalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__SphericalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__SphericalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__SphericalCSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__SphericalCSPropertyType_sequence()
        {
          SphericalCS = (gml__SphericalCSType *)0;
        }
        virtual ~__gml__SphericalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__SphericalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__SphericalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__SphericalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1597 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSPropertyType (484)
/* complex XSD type 'gml:SphericalCSPropertyType': */
class SOAP_CMAC gml__SphericalCSPropertyType {
      public:
        __gml__SphericalCSPropertyType_sequence *__SphericalCSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SphericalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__SphericalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__SphericalCSPropertyType); }
      public:
        /// Constructor with initializations
        gml__SphericalCSPropertyType()
        {
          __SphericalCSPropertyType_sequence = (__gml__SphericalCSPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__SphericalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__SphericalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__SphericalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__SphericalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15822 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticDatumPropertyType_sequence (893)
/* Wrapper: */
class SOAP_CMAC __gml__GeodeticDatumPropertyType_sequence {
      public:
        /// Required element 'gml:GeodeticDatum' of XSD type 'gml:GeodeticDatumType'
        gml__GeodeticDatumType *GeodeticDatum;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticDatumPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticDatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeodeticDatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeodeticDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeodeticDatumPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__GeodeticDatumPropertyType_sequence()
        {
          GeodeticDatum = (gml__GeodeticDatumType *)0;
        }
        virtual ~__gml__GeodeticDatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeodeticDatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeodeticDatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeodeticDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1603 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumPropertyType (486)
/* complex XSD type 'gml:GeodeticDatumPropertyType': */
class SOAP_CMAC gml__GeodeticDatumPropertyType {
      public:
        __gml__GeodeticDatumPropertyType_sequence *__GeodeticDatumPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticDatumPropertyType, default initialized and not managed by a soap context
        virtual gml__GeodeticDatumPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticDatumPropertyType); }
      public:
        /// Constructor with initializations
        gml__GeodeticDatumPropertyType()
        {
          __GeodeticDatumPropertyType_sequence = (__gml__GeodeticDatumPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__GeodeticDatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeodeticDatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticDatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeodeticDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15883 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__PrimeMeridianPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__PrimeMeridianPropertyType_sequence (896)
/* Wrapper: */
class SOAP_CMAC __gml__PrimeMeridianPropertyType_sequence {
      public:
        /// Required element 'gml:PrimeMeridian' of XSD type 'gml:PrimeMeridianType'
        gml__PrimeMeridianType *PrimeMeridian;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__PrimeMeridianPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__PrimeMeridianPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__PrimeMeridianPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__PrimeMeridianPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__PrimeMeridianPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__PrimeMeridianPropertyType_sequence()
        {
          PrimeMeridian = (gml__PrimeMeridianType *)0;
        }
        virtual ~__gml__PrimeMeridianPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__PrimeMeridianPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__PrimeMeridianPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__PrimeMeridianPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1612 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianPropertyType (489)
/* complex XSD type 'gml:PrimeMeridianPropertyType': */
class SOAP_CMAC gml__PrimeMeridianPropertyType {
      public:
        __gml__PrimeMeridianPropertyType_sequence *__PrimeMeridianPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PrimeMeridianPropertyType, default initialized and not managed by a soap context
        virtual gml__PrimeMeridianPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__PrimeMeridianPropertyType); }
      public:
        /// Constructor with initializations
        gml__PrimeMeridianPropertyType()
        {
          __PrimeMeridianPropertyType_sequence = (__gml__PrimeMeridianPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__PrimeMeridianPropertyType() { }
        /// Friend allocator used by soap_new_gml__PrimeMeridianPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__PrimeMeridianPropertyType * SOAP_FMAC2 soap_instantiate_gml__PrimeMeridianPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:15944 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidPropertyType_sequence (899)
/* Wrapper: */
class SOAP_CMAC __gml__EllipsoidPropertyType_sequence {
      public:
        /// Required element 'gml:Ellipsoid' of XSD type 'gml:EllipsoidType'
        gml__EllipsoidType *Ellipsoid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__EllipsoidPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__EllipsoidPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__EllipsoidPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__EllipsoidPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__EllipsoidPropertyType_sequence()
        {
          Ellipsoid = (gml__EllipsoidType *)0;
        }
        virtual ~__gml__EllipsoidPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__EllipsoidPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__EllipsoidPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__EllipsoidPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1624 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidPropertyType (493)
/* complex XSD type 'gml:EllipsoidPropertyType': */
class SOAP_CMAC gml__EllipsoidPropertyType {
      public:
        __gml__EllipsoidPropertyType_sequence *__EllipsoidPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidPropertyType, default initialized and not managed by a soap context
        virtual gml__EllipsoidPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidPropertyType); }
      public:
        /// Constructor with initializations
        gml__EllipsoidPropertyType()
        {
          __EllipsoidPropertyType_sequence = (__gml__EllipsoidPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__EllipsoidPropertyType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidPropertyType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16017 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_GeneralConversionPropertyType (903)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeneralConversionPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:16005 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__GeneralConversionPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__GeneralConversionPropertyType_sequence (902)
/* Wrapper: */
class SOAP_CMAC __gml__GeneralConversionPropertyType_sequence {
      public:
        /// Union with union _gml__union_GeneralConversionPropertyType variant selector __unionAbstractGeneralConversion set to one of:
        int __unionAbstractGeneralConversion;
        union _gml__union_GeneralConversionPropertyType union_GeneralConversionPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__GeneralConversionPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__GeneralConversionPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeneralConversionPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeneralConversionPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeneralConversionPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__GeneralConversionPropertyType_sequence()
        {
          __unionAbstractGeneralConversion = -1;
        }
        virtual ~__gml__GeneralConversionPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeneralConversionPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeneralConversionPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeneralConversionPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1639 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeneralConversionPropertyType (498)
/* complex XSD type 'gml:GeneralConversionPropertyType': */
class SOAP_CMAC gml__GeneralConversionPropertyType {
      public:
        __gml__GeneralConversionPropertyType_sequence *__GeneralConversionPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__GeneralConversionPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__GeneralConversionPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeneralConversionPropertyType, default initialized and not managed by a soap context
        virtual gml__GeneralConversionPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeneralConversionPropertyType); }
      public:
        /// Constructor with initializations
        gml__GeneralConversionPropertyType()
        {
          __GeneralConversionPropertyType_sequence = (__gml__GeneralConversionPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__GeneralConversionPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeneralConversionPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeneralConversionPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeneralConversionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16084 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_CRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_CRSPropertyType (906)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_CRSPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:16073 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__CRSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__CRSPropertyType_sequence (905)
/* Wrapper: */
class SOAP_CMAC __gml__CRSPropertyType_sequence {
      public:
        /// Union with union _gml__union_CRSPropertyType variant selector __unionAbstractCRS set to one of:
        int __unionAbstractCRS;
        union _gml__union_CRSPropertyType union_CRSPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__CRSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__CRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__CRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__CRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CRSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__CRSPropertyType_sequence()
        {
          __unionAbstractCRS = -1;
        }
        virtual ~__gml__CRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__CRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__CRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__CRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1648 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CRSPropertyType (501)
/* complex XSD type 'gml:CRSPropertyType': */
class SOAP_CMAC gml__CRSPropertyType {
      public:
        __gml__CRSPropertyType_sequence *__CRSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__CRSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__CRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CRSPropertyType, default initialized and not managed by a soap context
        virtual gml__CRSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CRSPropertyType); }
      public:
        /// Constructor with initializations
        gml__CRSPropertyType()
        {
          __CRSPropertyType_sequence = (__gml__CRSPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__CRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__CRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__CRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__CRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16140 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticCRSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticCRSPropertyType_sequence (908)
/* Wrapper: */
class SOAP_CMAC __gml__GeodeticCRSPropertyType_sequence {
      public:
        /// Required element 'gml:GeodeticCRS' of XSD type 'gml:GeodeticCRSType'
        gml__GeodeticCRSType *GeodeticCRS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticCRSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__GeodeticCRSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__GeodeticCRSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__GeodeticCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeodeticCRSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__GeodeticCRSPropertyType_sequence()
        {
          GeodeticCRS = (gml__GeodeticCRSType *)0;
        }
        virtual ~__gml__GeodeticCRSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__GeodeticCRSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__GeodeticCRSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__GeodeticCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1651 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSPropertyType (502)
/* complex XSD type 'gml:GeodeticCRSPropertyType': */
class SOAP_CMAC gml__GeodeticCRSPropertyType {
      public:
        __gml__GeodeticCRSPropertyType_sequence *__GeodeticCRSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticCRSPropertyType, default initialized and not managed by a soap context
        virtual gml__GeodeticCRSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticCRSPropertyType); }
      public:
        /// Constructor with initializations
        gml__GeodeticCRSPropertyType()
        {
          __GeodeticCRSPropertyType_sequence = (__gml__GeodeticCRSPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__GeodeticCRSPropertyType() { }
        /// Friend allocator used by soap_new_gml__GeodeticCRSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticCRSPropertyType * SOAP_FMAC2 soap_instantiate_gml__GeodeticCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16198 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalCSPropertyType_sequence (911)
/* Wrapper: */
class SOAP_CMAC __gml__VerticalCSPropertyType_sequence {
      public:
        /// Required element 'gml:VerticalCS' of XSD type 'gml:VerticalCSType'
        gml__VerticalCSType *VerticalCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalCSPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalCSPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__VerticalCSPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__VerticalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__VerticalCSPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__VerticalCSPropertyType_sequence()
        {
          VerticalCS = (gml__VerticalCSType *)0;
        }
        virtual ~__gml__VerticalCSPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__VerticalCSPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__VerticalCSPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__VerticalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1657 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSPropertyType (504)
/* complex XSD type 'gml:VerticalCSPropertyType': */
class SOAP_CMAC gml__VerticalCSPropertyType {
      public:
        __gml__VerticalCSPropertyType_sequence *__VerticalCSPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCSPropertyType, default initialized and not managed by a soap context
        virtual gml__VerticalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCSPropertyType); }
      public:
        /// Constructor with initializations
        gml__VerticalCSPropertyType()
        {
          __VerticalCSPropertyType_sequence = (__gml__VerticalCSPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__VerticalCSPropertyType() { }
        /// Friend allocator used by soap_new_gml__VerticalCSPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCSPropertyType * SOAP_FMAC2 soap_instantiate_gml__VerticalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16259 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalDatumPropertyType_sequence (914)
/* Wrapper: */
class SOAP_CMAC __gml__VerticalDatumPropertyType_sequence {
      public:
        /// Required element 'gml:VerticalDatum' of XSD type 'gml:VerticalDatumType'
        gml__VerticalDatumType *VerticalDatum;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalDatumPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__VerticalDatumPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__VerticalDatumPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gml__VerticalDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__VerticalDatumPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gml__VerticalDatumPropertyType_sequence()
        {
          VerticalDatum = (gml__VerticalDatumType *)0;
        }
        virtual ~__gml__VerticalDatumPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gml__VerticalDatumPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__VerticalDatumPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gml__VerticalDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1663 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumPropertyType (506)
/* complex XSD type 'gml:VerticalDatumPropertyType': */
class SOAP_CMAC gml__VerticalDatumPropertyType {
      public:
        __gml__VerticalDatumPropertyType_sequence *__VerticalDatumPropertyType_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalDatumPropertyType, default initialized and not managed by a soap context
        virtual gml__VerticalDatumPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalDatumPropertyType); }
      public:
        /// Constructor with initializations
        gml__VerticalDatumPropertyType()
        {
          __VerticalDatumPropertyType_sequence = (__gml__VerticalDatumPropertyType_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__VerticalDatumPropertyType() { }
        /// Friend allocator used by soap_new_gml__VerticalDatumPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalDatumPropertyType * SOAP_FMAC2 soap_instantiate_gml__VerticalDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16321 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__domainOfValidity_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__domainOfValidity_sequence (917)
/* Wrapper: */
class SOAP_CMAC __gml__domainOfValidity_sequence {
      public:
        /// Required element 'gmd:EX_Extent' of XSD type 'gmd:EX_Extent_Type'
        gmd__EX_USCOREExtent_USCOREType *gmd__EX_USCOREExtent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__domainOfValidity_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__domainOfValidity_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__domainOfValidity_sequence, default initialized and not managed by a soap context
        virtual __gml__domainOfValidity_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__domainOfValidity_sequence); }
      public:
        /// Constructor with initializations
        __gml__domainOfValidity_sequence()
        {
          gmd__EX_USCOREExtent = (gmd__EX_USCOREExtent_USCOREType *)0;
        }
        virtual ~__gml__domainOfValidity_sequence() { }
        /// Friend allocator used by soap_new___gml__domainOfValidity_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__domainOfValidity_sequence * SOAP_FMAC2 soap_instantiate___gml__domainOfValidity_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1669 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__domainOfValidity
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__domainOfValidity (508)
/* complex XSD type 'gml:domainOfValidity': */
class SOAP_CMAC _gml__domainOfValidity {
      public:
        __gml__domainOfValidity_sequence *__domainOfValidity_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1__gml__domainOfValidity
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1__gml__domainOfValidity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__domainOfValidity, default initialized and not managed by a soap context
        virtual _gml__domainOfValidity *soap_alloc(void) const { return SOAP_NEW(_gml__domainOfValidity); }
      public:
        /// Constructor with initializations
        _gml__domainOfValidity()
        {
          __domainOfValidity_sequence = (__gml__domainOfValidity_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~_gml__domainOfValidity() { }
        /// Friend allocator used by soap_new__gml__domainOfValidity(struct soap*, int)
        friend SOAP_FMAC1 _gml__domainOfValidity * SOAP_FMAC2 soap_instantiate__gml__domainOfValidity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1672 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__secondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__secondDefiningParameter (509)
/* complex XSD type 'gml:secondDefiningParameter': */
class SOAP_CMAC _gml__secondDefiningParameter {
      public:
        /// Required element 'gml:SecondDefiningParameter' of XSD type 'gml:SecondDefiningParameter'
        _gml__SecondDefiningParameter *SecondDefiningParameter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1__gml__secondDefiningParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1__gml__secondDefiningParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__secondDefiningParameter, default initialized and not managed by a soap context
        virtual _gml__secondDefiningParameter *soap_alloc(void) const { return SOAP_NEW(_gml__secondDefiningParameter); }
      public:
        /// Constructor with initializations
        _gml__secondDefiningParameter()
        {
          SecondDefiningParameter = (_gml__SecondDefiningParameter *)0;
          soap = (struct soap *)0;
        }
        virtual ~_gml__secondDefiningParameter() { }
        /// Friend allocator used by soap_new__gml__secondDefiningParameter(struct soap*, int)
        friend SOAP_FMAC1 _gml__secondDefiningParameter * SOAP_FMAC2 soap_instantiate__gml__secondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16413 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter (923)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_SecondDefiningParameter
{
        #define SOAP_UNION_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter_inverseFlattening	(1)	/**< union variant selector value for member inverseFlattening */
        gml__MeasureType *inverseFlattening;
        #define SOAP_UNION_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter_semiMinorAxis	(2)	/**< union variant selector value for member semiMinorAxis */
        gml__LengthType *semiMinorAxis;
        #define SOAP_UNION_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter_isSphere	(3)	/**< union variant selector value for member isSphere */
        bool isSphere;
};
#endif

/* resqml2_0_1ForGsoap.h:1675 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__SecondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__SecondDefiningParameter (510)
/* Choice: */
class SOAP_CMAC _gml__SecondDefiningParameter {
      public:
        /// Union with union _gml__union_SecondDefiningParameter variant selector __union_SecondDefiningParameter set to one of: SOAP_UNION_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter_inverseFlattening SOAP_UNION_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter_semiMinorAxis SOAP_UNION_gsoap_resqml2_0_1__gml__union_SecondDefiningParameter_isSphere
        int __union_SecondDefiningParameter;
        union _gml__union_SecondDefiningParameter union_SecondDefiningParameter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1__gml__SecondDefiningParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1__gml__SecondDefiningParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__SecondDefiningParameter, default initialized and not managed by a soap context
        virtual _gml__SecondDefiningParameter *soap_alloc(void) const { return SOAP_NEW(_gml__SecondDefiningParameter); }
      public:
        /// Constructor with initializations
        _gml__SecondDefiningParameter()
        {
          __union_SecondDefiningParameter = 0;
          soap = (struct soap *)0;
        }
        virtual ~_gml__SecondDefiningParameter() { }
        /// Friend allocator used by soap_new__gml__SecondDefiningParameter(struct soap*, int)
        friend SOAP_FMAC1 _gml__SecondDefiningParameter * SOAP_FMAC2 soap_instantiate__gml__SecondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16446 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_coordinateOperationAccuracy (925)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_coordinateOperationAccuracy
{
};
#endif

/* resqml2_0_1ForGsoap.h:16438 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gml__coordinateOperationAccuracy_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gml__coordinateOperationAccuracy_sequence (924)
/* Wrapper: */
class SOAP_CMAC __gml__coordinateOperationAccuracy_sequence {
      public:
        /// Union with union _gml__union_coordinateOperationAccuracy variant selector __unionAbstractDQ_USCOREPositionalAccuracy set to one of:
        int __unionAbstractDQ_USCOREPositionalAccuracy;
        union _gml__union_coordinateOperationAccuracy union_coordinateOperationAccuracy;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gml__coordinateOperationAccuracy_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gml__coordinateOperationAccuracy_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gml__coordinateOperationAccuracy_sequence, default initialized and not managed by a soap context
        virtual __gml__coordinateOperationAccuracy_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__coordinateOperationAccuracy_sequence); }
      public:
        /// Constructor with initializations
        __gml__coordinateOperationAccuracy_sequence()
        {
          __unionAbstractDQ_USCOREPositionalAccuracy = -1;
        }
        virtual ~__gml__coordinateOperationAccuracy_sequence() { }
        /// Friend allocator used by soap_new___gml__coordinateOperationAccuracy_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gml__coordinateOperationAccuracy_sequence * SOAP_FMAC2 soap_instantiate___gml__coordinateOperationAccuracy_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1678 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__coordinateOperationAccuracy (511)
/* complex XSD type 'gml:coordinateOperationAccuracy': */
class SOAP_CMAC _gml__coordinateOperationAccuracy {
      public:
        __gml__coordinateOperationAccuracy_sequence *__coordinateOperationAccuracy_sequence;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1__gml__coordinateOperationAccuracy
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1__gml__coordinateOperationAccuracy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _gml__coordinateOperationAccuracy, default initialized and not managed by a soap context
        virtual _gml__coordinateOperationAccuracy *soap_alloc(void) const { return SOAP_NEW(_gml__coordinateOperationAccuracy); }
      public:
        /// Constructor with initializations
        _gml__coordinateOperationAccuracy()
        {
          __coordinateOperationAccuracy_sequence = (__gml__coordinateOperationAccuracy_sequence *)0;
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~_gml__coordinateOperationAccuracy() { }
        /// Friend allocator used by soap_new__gml__coordinateOperationAccuracy(struct soap*, int)
        friend SOAP_FMAC1 _gml__coordinateOperationAccuracy * SOAP_FMAC2 soap_instantiate__gml__coordinateOperationAccuracy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16523 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType (928)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:16515 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence (927)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence {
      public:
        /// Union with union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType variant selector __unionAbstractEX_USCOREGeographicExtent set to one of:
        int __unionAbstractEX_USCOREGeographicExtent;
        union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType union_EX_USCOREGeographicExtent_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence()
        {
          __unionAbstractEX_USCOREGeographicExtent = -1;
        }
        virtual ~__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1684 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType (513)
/* complex XSD type 'gmd:EX_GeographicExtent_PropertyType': */
class SOAP_CMAC gmd__EX_USCOREGeographicExtent_USCOREPropertyType {
      public:
        __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *__EX_USCOREGeographicExtent_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCOREGeographicExtent_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_USCOREGeographicExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREGeographicExtent_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCOREGeographicExtent_USCOREPropertyType()
        {
          __EX_USCOREGeographicExtent_USCOREPropertyType_sequence = (__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__EX_USCOREGeographicExtent_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCOREGeographicExtent_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCOREGeographicExtent_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCOREGeographicExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16578 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence (930)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_TemporalExtent' of XSD type 'gmd:EX_TemporalExtent_Type'
        gmd__EX_USCORETemporalExtent_USCOREType *EX_USCORETemporalExtent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence()
        {
          EX_USCORETemporalExtent = (gmd__EX_USCORETemporalExtent_USCOREType *)0;
        }
        virtual ~__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1690 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType (515)
/* complex XSD type 'gmd:EX_TemporalExtent_PropertyType': */
class SOAP_CMAC gmd__EX_USCORETemporalExtent_USCOREPropertyType {
      public:
        __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *__EX_USCORETemporalExtent_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCORETemporalExtent_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_USCORETemporalExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCORETemporalExtent_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCORETemporalExtent_USCOREPropertyType()
        {
          __EX_USCORETemporalExtent_USCOREPropertyType_sequence = (__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__EX_USCORETemporalExtent_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCORETemporalExtent_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCORETemporalExtent_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCORETemporalExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16635 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence (933)
/* Wrapper: */
class SOAP_CMAC __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:EX_VerticalExtent' of XSD type 'gmd:EX_VerticalExtent_Type'
        gmd__EX_USCOREVerticalExtent_USCOREType *EX_USCOREVerticalExtent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence()
        {
          EX_USCOREVerticalExtent = (gmd__EX_USCOREVerticalExtent_USCOREType *)0;
        }
        virtual ~__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1696 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType (517)
/* complex XSD type 'gmd:EX_VerticalExtent_PropertyType': */
class SOAP_CMAC gmd__EX_USCOREVerticalExtent_USCOREPropertyType {
      public:
        __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *__EX_USCOREVerticalExtent_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCOREVerticalExtent_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__EX_USCOREVerticalExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREVerticalExtent_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCOREVerticalExtent_USCOREPropertyType()
        {
          __EX_USCOREVerticalExtent_USCOREPropertyType_sequence = (__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__EX_USCOREVerticalExtent_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCOREVerticalExtent_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCOREVerticalExtent_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCOREVerticalExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16692 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence (936)
/* Wrapper: */
class SOAP_CMAC __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:MD_Identifier' of XSD type 'gmd:MD_Identifier_Type'
        gmd__MD_USCOREIdentifier_USCOREType *MD_USCOREIdentifier;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence()
        {
          MD_USCOREIdentifier = (gmd__MD_USCOREIdentifier_USCOREType *)0;
        }
        virtual ~__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1708 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREPropertyType (521)
/* Type gmd__MD_USCOREIdentifier_USCOREPropertyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:MD_Identifier_PropertyType': */
class SOAP_CMAC gmd__MD_USCOREIdentifier_USCOREPropertyType {
      public:
        __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *__MD_USCOREIdentifier_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_USCOREIdentifier_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__MD_USCOREIdentifier_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__MD_USCOREIdentifier_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__MD_USCOREIdentifier_USCOREPropertyType()
        {
          __MD_USCOREIdentifier_USCOREPropertyType_sequence = (__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__MD_USCOREIdentifier_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__MD_USCOREIdentifier_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_USCOREIdentifier_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__MD_USCOREIdentifier_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16749 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence (939)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCORECitation_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Citation' of XSD type 'gmd:CI_Citation_Type'
        gmd__CI_USCORECitation_USCOREType *CI_USCORECitation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCORECitation_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCORECitation_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORECitation_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCORECitation_USCOREPropertyType_sequence()
        {
          CI_USCORECitation = (gmd__CI_USCORECitation_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCORECitation_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCORECitation_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCORECitation_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCORECitation_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1714 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREPropertyType (523)
/* complex XSD type 'gmd:CI_Citation_PropertyType': */
class SOAP_CMAC gmd__CI_USCORECitation_USCOREPropertyType {
      public:
        __gmd__CI_USCORECitation_USCOREPropertyType_sequence *__CI_USCORECitation_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORECitation_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORECitation_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORECitation_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORECitation_USCOREPropertyType()
        {
          __CI_USCORECitation_USCOREPropertyType_sequence = (__gmd__CI_USCORECitation_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCORECitation_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORECitation_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORECitation_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORECitation_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16806 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence (942)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREDate_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Date' of XSD type 'gmd:CI_Date_Type'
        gmd__CI_USCOREDate_USCOREType *CI_USCOREDate;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREDate_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREDate_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREDate_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREDate_USCOREPropertyType_sequence()
        {
          CI_USCOREDate = (gmd__CI_USCOREDate_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCOREDate_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREDate_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREDate_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREDate_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1720 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREPropertyType (525)
/* complex XSD type 'gmd:CI_Date_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREDate_USCOREPropertyType {
      public:
        __gmd__CI_USCOREDate_USCOREPropertyType_sequence *__CI_USCOREDate_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREDate_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREDate_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDate_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREDate_USCOREPropertyType()
        {
          __CI_USCOREDate_USCOREPropertyType_sequence = (__gmd__CI_USCOREDate_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCOREDate_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREDate_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREDate_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREDate_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16863 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence (945)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_DateTypeCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *CI_USCOREDateTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence()
        {
          CI_USCOREDateTypeCode = (gco__CodeListValue_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1726 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType (527)
/* complex XSD type 'gmd:CI_DateTypeCode_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREDateTypeCode_USCOREPropertyType {
      public:
        __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *__CI_USCOREDateTypeCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREDateTypeCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREDateTypeCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDateTypeCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREDateTypeCode_USCOREPropertyType()
        {
          __CI_USCOREDateTypeCode_USCOREPropertyType_sequence = (__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCOREDateTypeCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREDateTypeCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREDateTypeCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREDateTypeCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16890 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence (948)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_ResponsibleParty' of XSD type 'gmd:CI_ResponsibleParty_Type'
        gmd__CI_USCOREResponsibleParty_USCOREType *CI_USCOREResponsibleParty;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence()
        {
          CI_USCOREResponsibleParty = (gmd__CI_USCOREResponsibleParty_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1729 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType (528)
/* complex XSD type 'gmd:CI_ResponsibleParty_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREResponsibleParty_USCOREPropertyType {
      public:
        __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *__CI_USCOREResponsibleParty_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREResponsibleParty_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREResponsibleParty_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREResponsibleParty_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREResponsibleParty_USCOREPropertyType()
        {
          __CI_USCOREResponsibleParty_USCOREPropertyType_sequence = (__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCOREResponsibleParty_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREResponsibleParty_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREResponsibleParty_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREResponsibleParty_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:16947 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence (951)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREContact_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Contact' of XSD type 'gmd:CI_Contact_Type'
        gmd__CI_USCOREContact_USCOREType *CI_USCOREContact;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREContact_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREContact_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREContact_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREContact_USCOREPropertyType_sequence()
        {
          CI_USCOREContact = (gmd__CI_USCOREContact_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCOREContact_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREContact_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREContact_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREContact_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1735 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREPropertyType (530)
/* complex XSD type 'gmd:CI_Contact_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREContact_USCOREPropertyType {
      public:
        __gmd__CI_USCOREContact_USCOREPropertyType_sequence *__CI_USCOREContact_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREContact_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREContact_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREContact_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREContact_USCOREPropertyType()
        {
          __CI_USCOREContact_USCOREPropertyType_sequence = (__gmd__CI_USCOREContact_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCOREContact_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREContact_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREContact_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREContact_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17004 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence (954)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCORETelephone_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Telephone' of XSD type 'gmd:CI_Telephone_Type'
        gmd__CI_USCORETelephone_USCOREType *CI_USCORETelephone;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCORETelephone_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCORETelephone_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORETelephone_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCORETelephone_USCOREPropertyType_sequence()
        {
          CI_USCORETelephone = (gmd__CI_USCORETelephone_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCORETelephone_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCORETelephone_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCORETelephone_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCORETelephone_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1741 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREPropertyType (532)
/* complex XSD type 'gmd:CI_Telephone_PropertyType': */
class SOAP_CMAC gmd__CI_USCORETelephone_USCOREPropertyType {
      public:
        __gmd__CI_USCORETelephone_USCOREPropertyType_sequence *__CI_USCORETelephone_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORETelephone_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORETelephone_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORETelephone_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORETelephone_USCOREPropertyType()
        {
          __CI_USCORETelephone_USCOREPropertyType_sequence = (__gmd__CI_USCORETelephone_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCORETelephone_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORETelephone_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORETelephone_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORETelephone_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17061 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence (957)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREAddress_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Address' of XSD type 'gmd:CI_Address_Type'
        gmd__CI_USCOREAddress_USCOREType *CI_USCOREAddress;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREAddress_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREAddress_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREAddress_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREAddress_USCOREPropertyType_sequence()
        {
          CI_USCOREAddress = (gmd__CI_USCOREAddress_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCOREAddress_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREAddress_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREAddress_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREAddress_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1747 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREPropertyType (534)
/* complex XSD type 'gmd:CI_Address_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREAddress_USCOREPropertyType {
      public:
        __gmd__CI_USCOREAddress_USCOREPropertyType_sequence *__CI_USCOREAddress_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREAddress_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREAddress_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREAddress_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREAddress_USCOREPropertyType()
        {
          __CI_USCOREAddress_USCOREPropertyType_sequence = (__gmd__CI_USCOREAddress_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCOREAddress_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREAddress_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREAddress_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREAddress_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17118 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence (960)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_OnlineResource' of XSD type 'gmd:CI_OnlineResource_Type'
        gmd__CI_USCOREOnlineResource_USCOREType *CI_USCOREOnlineResource;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence()
        {
          CI_USCOREOnlineResource = (gmd__CI_USCOREOnlineResource_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1753 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType (536)
/* complex XSD type 'gmd:CI_OnlineResource_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREOnlineResource_USCOREPropertyType {
      public:
        __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *__CI_USCOREOnlineResource_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREOnlineResource_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREOnlineResource_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnlineResource_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREOnlineResource_USCOREPropertyType()
        {
          __CI_USCOREOnlineResource_USCOREPropertyType_sequence = (__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCOREOnlineResource_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREOnlineResource_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREOnlineResource_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREOnlineResource_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17175 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__URL_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__URL_USCOREPropertyType_sequence (963)
/* Wrapper: */
class SOAP_CMAC __gmd__URL_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:URL' of XSD type 'xsd:anyURI'
        std::string URL;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__URL_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__URL_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__URL_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__URL_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__URL_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__URL_USCOREPropertyType_sequence()
        {
        }
        virtual ~__gmd__URL_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__URL_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__URL_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__URL_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1759 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__URL_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__URL_USCOREPropertyType (538)
/* complex XSD type 'gmd:URL_PropertyType': */
class SOAP_CMAC gmd__URL_USCOREPropertyType {
      public:
        __gmd__URL_USCOREPropertyType_sequence *__URL_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__URL_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__URL_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__URL_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__URL_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__URL_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__URL_USCOREPropertyType()
        {
          __URL_USCOREPropertyType_sequence = (__gmd__URL_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__URL_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__URL_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__URL_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__URL_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17202 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence (965)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_OnLineFunctionCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *CI_USCOREOnLineFunctionCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence()
        {
          CI_USCOREOnLineFunctionCode = (gco__CodeListValue_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1762 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (539)
/* complex XSD type 'gmd:CI_OnLineFunctionCode_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType {
      public:
        __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType()
        {
          __CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence = (__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17229 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence (967)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_RoleCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *CI_USCORERoleCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence()
        {
          CI_USCORERoleCode = (gco__CodeListValue_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1765 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORERoleCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORERoleCode_USCOREPropertyType (540)
/* complex XSD type 'gmd:CI_RoleCode_PropertyType': */
class SOAP_CMAC gmd__CI_USCORERoleCode_USCOREPropertyType {
      public:
        __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *__CI_USCORERoleCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORERoleCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORERoleCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORERoleCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORERoleCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORERoleCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORERoleCode_USCOREPropertyType()
        {
          __CI_USCORERoleCode_USCOREPropertyType_sequence = (__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCORERoleCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORERoleCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORERoleCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORERoleCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17256 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence (969)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_PresentationFormCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *CI_USCOREPresentationFormCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence()
        {
          CI_USCOREPresentationFormCode = (gco__CodeListValue_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1768 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType (541)
/* complex XSD type 'gmd:CI_PresentationFormCode_PropertyType': */
class SOAP_CMAC gmd__CI_USCOREPresentationFormCode_USCOREPropertyType {
      public:
        __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREPresentationFormCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREPresentationFormCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREPresentationFormCode_USCOREPropertyType()
        {
          __CI_USCOREPresentationFormCode_USCOREPropertyType_sequence = (__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCOREPresentationFormCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREPresentationFormCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17283 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence (971)
/* Wrapper: */
class SOAP_CMAC __gmd__CI_USCORESeries_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:CI_Series' of XSD type 'gmd:CI_Series_Type'
        gmd__CI_USCORESeries_USCOREType *CI_USCORESeries;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__CI_USCORESeries_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__CI_USCORESeries_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORESeries_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__CI_USCORESeries_USCOREPropertyType_sequence()
        {
          CI_USCORESeries = (gmd__CI_USCORESeries_USCOREType *)0;
        }
        virtual ~__gmd__CI_USCORESeries_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__CI_USCORESeries_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__CI_USCORESeries_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__CI_USCORESeries_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1771 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREPropertyType (542)
/* complex XSD type 'gmd:CI_Series_PropertyType': */
class SOAP_CMAC gmd__CI_USCORESeries_USCOREPropertyType {
      public:
        __gmd__CI_USCORESeries_USCOREPropertyType_sequence *__CI_USCORESeries_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORESeries_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORESeries_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORESeries_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORESeries_USCOREPropertyType()
        {
          __CI_USCORESeries_USCOREPropertyType_sequence = (__gmd__CI_USCORESeries_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__CI_USCORESeries_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORESeries_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORESeries_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORESeries_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17340 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence (974)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence {
      public:
        /// Required element 'gmd:DQ_EvaluationMethodTypeCode' of XSD type 'gco:CodeListValue_Type'
        gco__CodeListValue_USCOREType *DQ_USCOREEvaluationMethodTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence()
        {
          DQ_USCOREEvaluationMethodTypeCode = (gco__CodeListValue_USCOREType *)0;
        }
        virtual ~__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1777 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (544)
/* complex XSD type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType': */
class SOAP_CMAC gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType {
      public:
        __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType()
        {
          __DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence = (__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17375 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__union_DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__union_DQ_USCOREResult_USCOREPropertyType (977)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gmd__union_DQ_USCOREResult_USCOREPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:17367 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence (976)
/* Wrapper: */
class SOAP_CMAC __gmd__DQ_USCOREResult_USCOREPropertyType_sequence {
      public:
        /// Union with union _gmd__union_DQ_USCOREResult_USCOREPropertyType variant selector __unionAbstractDQ_USCOREResult set to one of:
        int __unionAbstractDQ_USCOREResult;
        union _gmd__union_DQ_USCOREResult_USCOREPropertyType union_DQ_USCOREResult_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gmd__DQ_USCOREResult_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gmd__DQ_USCOREResult_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__DQ_USCOREResult_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gmd__DQ_USCOREResult_USCOREPropertyType_sequence()
        {
          __unionAbstractDQ_USCOREResult = -1;
        }
        virtual ~__gmd__DQ_USCOREResult_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gmd__DQ_USCOREResult_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gmd__DQ_USCOREResult_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gmd__DQ_USCOREResult_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1780 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREResult_USCOREPropertyType (545)
/* complex XSD type 'gmd:DQ_Result_PropertyType': */
class SOAP_CMAC gmd__DQ_USCOREResult_USCOREPropertyType {
      public:
        __gmd__DQ_USCOREResult_USCOREPropertyType_sequence *__DQ_USCOREResult_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREResult_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREResult_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__DQ_USCOREResult_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gmd__DQ_USCOREResult_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__DQ_USCOREResult_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gmd__DQ_USCOREResult_USCOREPropertyType()
        {
          __DQ_USCOREResult_USCOREPropertyType_sequence = (__gmd__DQ_USCOREResult_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gmd__DQ_USCOREResult_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gmd__DQ_USCOREResult_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gmd__DQ_USCOREResult_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gmd__DQ_USCOREResult_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17449 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gts__union_TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gts__union_TM_USCOREPrimitive_USCOREPropertyType (980)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gts__union_TM_USCOREPrimitive_USCOREPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:17438 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence (979)
/* Wrapper: */
class SOAP_CMAC __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence {
      public:
        /// Union with union _gts__union_TM_USCOREPrimitive_USCOREPropertyType variant selector __unionAbstractTimePrimitive set to one of:
        int __unionAbstractTimePrimitive;
        union _gts__union_TM_USCOREPrimitive_USCOREPropertyType union_TM_USCOREPrimitive_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence()
        {
          __unionAbstractTimePrimitive = -1;
        }
        virtual ~__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1786 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gts__TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gts__TM_USCOREPrimitive_USCOREPropertyType (547)
/* complex XSD type 'gts:TM_Primitive_PropertyType': */
class SOAP_CMAC gts__TM_USCOREPrimitive_USCOREPropertyType {
      public:
        __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *__TM_USCOREPrimitive_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gts__TM_USCOREPrimitive_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gts__TM_USCOREPrimitive_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gts__TM_USCOREPrimitive_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gts__TM_USCOREPrimitive_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gts__TM_USCOREPrimitive_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gts__TM_USCOREPrimitive_USCOREPropertyType()
        {
          __TM_USCOREPrimitive_USCOREPropertyType_sequence = (__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gts__TM_USCOREPrimitive_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gts__TM_USCOREPrimitive_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gts__TM_USCOREPrimitive_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gts__TM_USCOREPrimitive_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1789 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__AbstractObject_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__AbstractObject_USCOREType (548)
/* Type gco__AbstractObject_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gco:AbstractObject_Type': */
class SOAP_CMAC gco__AbstractObject_USCOREType {
      public:
        /// optional attribute 'id' of XSD type 'xsd:ID'
        std::string *id;
        /// optional attribute 'uuid' of XSD type 'xsd:string'
        std::string *uuid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gco__AbstractObject_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gco__AbstractObject_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__AbstractObject_USCOREType, default initialized and not managed by a soap context
        virtual gco__AbstractObject_USCOREType *soap_alloc(void) const { return SOAP_NEW(gco__AbstractObject_USCOREType); }
      public:
        /// Constructor with initializations
        gco__AbstractObject_USCOREType()
        {
          id = (std::string *)0;
          uuid = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gco__AbstractObject_USCOREType() { }
        /// Friend allocator used by soap_new_gco__AbstractObject_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gco__AbstractObject_USCOREType * SOAP_FMAC2 soap_instantiate_gco__AbstractObject_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17565 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType (984)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_CharacterString_USCOREPropertyType
{
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_CharacterString	(1)	/**< union variant selector value for member CharacterString */
        std::string *CharacterString;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode	(2)	/**< union variant selector value for member gmd__CI_USCOREDateTypeCode */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREDateTypeCode;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode_	(3)	/**< union variant selector value for member gmd__CI_USCOREDateTypeCode_ */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREDateTypeCode_;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode	(4)	/**< union variant selector value for member gmd__CI_USCOREOnLineFunctionCode */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREOnLineFunctionCode;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode_	(5)	/**< union variant selector value for member gmd__CI_USCOREOnLineFunctionCode_ */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREOnLineFunctionCode_;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode	(6)	/**< union variant selector value for member gmd__CI_USCORERoleCode */
        gco__CodeListValue_USCOREType *gmd__CI_USCORERoleCode;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode_	(7)	/**< union variant selector value for member gmd__CI_USCORERoleCode_ */
        gco__CodeListValue_USCOREType *gmd__CI_USCORERoleCode_;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode	(8)	/**< union variant selector value for member gmd__CI_USCOREPresentationFormCode */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREPresentationFormCode;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode_	(9)	/**< union variant selector value for member gmd__CI_USCOREPresentationFormCode_ */
        gco__CodeListValue_USCOREType *gmd__CI_USCOREPresentationFormCode_;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode	(10)	/**< union variant selector value for member gmd__DQ_USCOREEvaluationMethodTypeCode */
        gco__CodeListValue_USCOREType *gmd__DQ_USCOREEvaluationMethodTypeCode;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode_	(11)	/**< union variant selector value for member gmd__DQ_USCOREEvaluationMethodTypeCode_ */
        gco__CodeListValue_USCOREType *gmd__DQ_USCOREEvaluationMethodTypeCode_;
};
#endif

/* resqml2_0_1ForGsoap.h:17536 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gco__CharacterString_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gco__CharacterString_USCOREPropertyType_sequence (983)
/* Wrapper: */
class SOAP_CMAC __gco__CharacterString_USCOREPropertyType_sequence {
      public:
        /// Union with union _gco__union_CharacterString_USCOREPropertyType variant selector __unionCharacterString set to one of: SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_CharacterString SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode_ SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode_ SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode_ SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode_ SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode SOAP_UNION_gsoap_resqml2_0_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode_
        int __unionCharacterString;
        union _gco__union_CharacterString_USCOREPropertyType union_CharacterString_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gco__CharacterString_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gco__CharacterString_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__CharacterString_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__CharacterString_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__CharacterString_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gco__CharacterString_USCOREPropertyType_sequence()
        {
          __unionCharacterString = -1;
        }
        virtual ~__gco__CharacterString_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__CharacterString_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__CharacterString_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__CharacterString_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1792 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__CharacterString_USCOREPropertyType (549)
/* complex XSD type 'gco:CharacterString_PropertyType': */
class SOAP_CMAC gco__CharacterString_USCOREPropertyType {
      public:
        __gco__CharacterString_USCOREPropertyType_sequence *__CharacterString_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gco__CharacterString_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gco__CharacterString_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__CharacterString_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__CharacterString_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__CharacterString_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__CharacterString_USCOREPropertyType()
        {
          __CharacterString_USCOREPropertyType_sequence = (__gco__CharacterString_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gco__CharacterString_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__CharacterString_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__CharacterString_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__CharacterString_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17590 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gco__Boolean_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gco__Boolean_USCOREPropertyType_sequence (986)
/* Wrapper: */
class SOAP_CMAC __gco__Boolean_USCOREPropertyType_sequence {
      public:
        /// Required element 'gco:Boolean' of XSD type 'xsd:boolean'
        bool Boolean;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gco__Boolean_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gco__Boolean_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Boolean_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Boolean_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__Boolean_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gco__Boolean_USCOREPropertyType_sequence()
        {
          Boolean = (bool)0;
        }
        virtual ~__gco__Boolean_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Boolean_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Boolean_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Boolean_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1795 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Boolean_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Boolean_USCOREPropertyType (550)
/* complex XSD type 'gco:Boolean_PropertyType': */
class SOAP_CMAC gco__Boolean_USCOREPropertyType {
      public:
        __gco__Boolean_USCOREPropertyType_sequence *__Boolean_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gco__Boolean_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gco__Boolean_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Boolean_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__Boolean_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Boolean_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__Boolean_USCOREPropertyType()
        {
          __Boolean_USCOREPropertyType_sequence = (__gco__Boolean_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gco__Boolean_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__Boolean_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Boolean_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__Boolean_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17617 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gco__Real_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gco__Real_USCOREPropertyType_sequence (988)
/* Wrapper: */
class SOAP_CMAC __gco__Real_USCOREPropertyType_sequence {
      public:
        /// Required element 'gco:Real' of XSD type 'xsd:double'
        double Real;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gco__Real_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gco__Real_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__Real_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__Real_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__Real_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gco__Real_USCOREPropertyType_sequence()
        {
          Real = (double)0;
        }
        virtual ~__gco__Real_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__Real_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__Real_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__Real_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1798 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Real_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Real_USCOREPropertyType (551)
/* complex XSD type 'gco:Real_PropertyType': */
class SOAP_CMAC gco__Real_USCOREPropertyType {
      public:
        __gco__Real_USCOREPropertyType_sequence *__Real_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gco__Real_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gco__Real_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Real_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__Real_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Real_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__Real_USCOREPropertyType()
        {
          __Real_USCOREPropertyType_sequence = (__gco__Real_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gco__Real_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__Real_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Real_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__Real_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17652 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType (991)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gco__union_Date_USCOREPropertyType
{
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType_Date	(1)	/**< union variant selector value for member Date */
        std::string *Date;
        #define SOAP_UNION_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType_DateTime	(2)	/**< union variant selector value for member DateTime */
        time_t DateTime;
};
#endif

/* resqml2_0_1ForGsoap.h:1801 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREPropertyType (552)
/* complex XSD type 'gco:Date_PropertyType': */
class SOAP_CMAC gco__Date_USCOREPropertyType {
      public:
        /// Union with union _gco__union_Date_USCOREPropertyType variant selector __union_Date_USCOREPropertyType set to one of: SOAP_UNION_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType_Date SOAP_UNION_gsoap_resqml2_0_1__gco__union_Date_USCOREPropertyType_DateTime
        int __union_Date_USCOREPropertyType;
        union _gco__union_Date_USCOREPropertyType union_Date_USCOREPropertyType;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__Date_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__Date_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Date_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__Date_USCOREPropertyType()
        {
          __union_Date_USCOREPropertyType = -1;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gco__Date_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__Date_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__Date_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__Date_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17675 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gco__DateTime_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gco__DateTime_USCOREPropertyType_sequence (992)
/* Wrapper: */
class SOAP_CMAC __gco__DateTime_USCOREPropertyType_sequence {
      public:
        /// Required element 'gco:DateTime' of XSD type 'xsd:dateTime'
        time_t DateTime;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gco__DateTime_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gco__DateTime_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gco__DateTime_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gco__DateTime_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__DateTime_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gco__DateTime_USCOREPropertyType_sequence()
        {
          DateTime = (time_t)0;
        }
        virtual ~__gco__DateTime_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gco__DateTime_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gco__DateTime_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gco__DateTime_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1807 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__DateTime_USCOREPropertyType (554)
/* complex XSD type 'gco:DateTime_PropertyType': */
class SOAP_CMAC gco__DateTime_USCOREPropertyType {
      public:
        __gco__DateTime_USCOREPropertyType_sequence *__DateTime_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gco__DateTime_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gco__DateTime_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__DateTime_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gco__DateTime_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__DateTime_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gco__DateTime_USCOREPropertyType()
        {
          __DateTime_USCOREPropertyType_sequence = (__gco__DateTime_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gco__DateTime_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gco__DateTime_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gco__DateTime_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gco__DateTime_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:17721 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gsr__union_SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1__gsr__union_SC_USCORECRS_USCOREPropertyType (995)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gsr__union_SC_USCORECRS_USCOREPropertyType
{
};
#endif

/* resqml2_0_1ForGsoap.h:17710 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence (994)
/* Wrapper: */
class SOAP_CMAC __gsr__SC_USCORECRS_USCOREPropertyType_sequence {
      public:
        /// Union with union _gsr__union_SC_USCORECRS_USCOREPropertyType variant selector __unionAbstractCRS set to one of:
        int __unionAbstractCRS;
        union _gsr__union_SC_USCORECRS_USCOREPropertyType union_SC_USCORECRS_USCOREPropertyType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __gsr__SC_USCORECRS_USCOREPropertyType_sequence, default initialized and not managed by a soap context
        virtual __gsr__SC_USCORECRS_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gsr__SC_USCORECRS_USCOREPropertyType_sequence); }
      public:
        /// Constructor with initializations
        __gsr__SC_USCORECRS_USCOREPropertyType_sequence()
        {
          __unionAbstractCRS = -1;
        }
        virtual ~__gsr__SC_USCORECRS_USCOREPropertyType_sequence() { }
        /// Friend allocator used by soap_new___gsr__SC_USCORECRS_USCOREPropertyType_sequence(struct soap*, int)
        friend SOAP_FMAC1 __gsr__SC_USCORECRS_USCOREPropertyType_sequence * SOAP_FMAC2 soap_instantiate___gsr__SC_USCORECRS_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1810 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gsr__SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gsr__SC_USCORECRS_USCOREPropertyType (555)
/* complex XSD type 'gsr:SC_CRS_PropertyType': */
class SOAP_CMAC gsr__SC_USCORECRS_USCOREPropertyType {
      public:
        __gsr__SC_USCORECRS_USCOREPropertyType_sequence *__SC_USCORECRS_USCOREPropertyType_sequence;
        /// optional attribute 'gco:nilReason' of XSD type 'gml:NilReasonType'
        std::string *gco__nilReason;
        /// optional attribute 'uuidref' of XSD type 'xsd:string'
        std::string *uuidref;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gsr__SC_USCORECRS_USCOREPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gsr__SC_USCORECRS_USCOREPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gsr__SC_USCORECRS_USCOREPropertyType, default initialized and not managed by a soap context
        virtual gsr__SC_USCORECRS_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gsr__SC_USCORECRS_USCOREPropertyType); }
      public:
        /// Constructor with initializations
        gsr__SC_USCORECRS_USCOREPropertyType()
        {
          __SC_USCORECRS_USCOREPropertyType_sequence = (__gsr__SC_USCORECRS_USCOREPropertyType_sequence *)0;
          gco__nilReason = (std::string *)0;
          uuidref = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gsr__SC_USCORECRS_USCOREPropertyType() { }
        /// Friend allocator used by soap_new_gsr__SC_USCORECRS_USCOREPropertyType(struct soap*, int)
        friend SOAP_FMAC1 gsr__SC_USCORECRS_USCOREPropertyType * SOAP_FMAC2 soap_instantiate_gsr__SC_USCORECRS_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1813 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyTypeSet
#define SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyTypeSet (556)
/* complex XSD type 'ptm:standardEnergisticsPropertyTypeSet': */
class SOAP_CMAC ptm__standardEnergisticsPropertyTypeSet {
      public:
        /// Required element 'ptm:standardEnergisticsPropertyType' of XSD type 'ptm:standardEnergisticsPropertyType'
        std::vector<ptm__standardEnergisticsPropertyType *> standardEnergisticsPropertyType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyTypeSet
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyTypeSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ptm__standardEnergisticsPropertyTypeSet, default initialized and not managed by a soap context
        virtual ptm__standardEnergisticsPropertyTypeSet *soap_alloc(void) const { return SOAP_NEW(ptm__standardEnergisticsPropertyTypeSet); }
      public:
        /// Constructor with initializations
        ptm__standardEnergisticsPropertyTypeSet()
        {
          soap = (struct soap *)0;
        }
        virtual ~ptm__standardEnergisticsPropertyTypeSet() { }
        /// Friend allocator used by soap_new_ptm__standardEnergisticsPropertyTypeSet(struct soap*, int)
        friend SOAP_FMAC1 ptm__standardEnergisticsPropertyTypeSet * SOAP_FMAC2 soap_instantiate_ptm__standardEnergisticsPropertyTypeSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1816 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyType (557)
/* complex XSD type 'ptm:standardEnergisticsPropertyType': */
class SOAP_CMAC ptm__standardEnergisticsPropertyType {
      public:
        /// Required element 'ptm:name' of XSD type 'resqml2:ResqmlPropertyKind'
        enum resqml2__ResqmlPropertyKind name;
        /// Optional element 'ptm:description' of XSD type 'xsd:string'
        std::string *description;
        /// Optional element 'ptm:version' of XSD type 'xsd:string'
        std::string *version;
        /// Optional element 'ptm:deprecated' of XSD type 'xsd:string'
        std::string *deprecated;
        /// Optional element 'ptm:replacedBy' of XSD type 'xsd:string'
        std::string *replacedBy;
        /// Optional element 'ptm:isAbstract' of XSD type 'xsd:boolean'
        bool *isAbstract;
        /// Optional element 'ptm:parentKind' of XSD type 'resqml2:ResqmlPropertyKind'
        enum resqml2__ResqmlPropertyKind *parentKind;
        /// Optional element 'ptm:equivalentPropertyType' of XSD type 'ptm:equivalentPropertyType'
        std::vector<ptm__equivalentPropertyType *> equivalentPropertyType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ptm__standardEnergisticsPropertyType, default initialized and not managed by a soap context
        virtual ptm__standardEnergisticsPropertyType *soap_alloc(void) const { return SOAP_NEW(ptm__standardEnergisticsPropertyType); }
      public:
        /// Constructor with initializations
        ptm__standardEnergisticsPropertyType()
        {
          name = (enum resqml2__ResqmlPropertyKind)0;
          description = (std::string *)0;
          version = (std::string *)0;
          deprecated = (std::string *)0;
          replacedBy = (std::string *)0;
          isAbstract = (bool *)0;
          parentKind = (enum resqml2__ResqmlPropertyKind *)0;
          soap = (struct soap *)0;
        }
        virtual ~ptm__standardEnergisticsPropertyType() { }
        /// Friend allocator used by soap_new_ptm__standardEnergisticsPropertyType(struct soap*, int)
        friend SOAP_FMAC1 ptm__standardEnergisticsPropertyType * SOAP_FMAC2 soap_instantiate_ptm__standardEnergisticsPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1819 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ptm__equivalentPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_ptm__equivalentPropertyType (558)
/* complex XSD type 'ptm:equivalentPropertyType': */
class SOAP_CMAC ptm__equivalentPropertyType {
      public:
        /// Required element 'ptm:name' of XSD type 'xsd:string'
        std::string name;
        /// Required element 'ptm:namingSystem' of XSD type 'xsd:string'
        std::string namingSystem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_ptm__equivalentPropertyType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_ptm__equivalentPropertyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ptm__equivalentPropertyType, default initialized and not managed by a soap context
        virtual ptm__equivalentPropertyType *soap_alloc(void) const { return SOAP_NEW(ptm__equivalentPropertyType); }
      public:
        /// Constructor with initializations
        ptm__equivalentPropertyType()
        {
          soap = (struct soap *)0;
        }
        virtual ~ptm__equivalentPropertyType() { }
        /// Friend allocator used by soap_new_ptm__equivalentPropertyType(struct soap*, int)
        friend SOAP_FMAC1 ptm__equivalentPropertyType * SOAP_FMAC2 soap_instantiate_ptm__equivalentPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:262 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractDoubleArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractDoubleArray (39)
/* Type resqml2__AbstractDoubleArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractDoubleArray': */
class SOAP_CMAC resqml2__AbstractDoubleArray : public resqml2__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractDoubleArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractDoubleArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractDoubleArray, default initialized and not managed by a soap context
        virtual resqml2__AbstractDoubleArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractDoubleArray); }
      public:
        /// Constructor with initializations
        resqml2__AbstractDoubleArray()
        {
        }
        virtual ~resqml2__AbstractDoubleArray() { }
        /// Friend allocator used by soap_new_resqml2__AbstractDoubleArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractDoubleArray * SOAP_FMAC2 soap_instantiate_resqml2__AbstractDoubleArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:274 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringHdf5Array (43)
/* Type resqml2__StringHdf5Array is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:StringHdf5Array': */
class SOAP_CMAC resqml2__StringHdf5Array : public resqml2__AbstractValueArray {
      public:
        /// Required element 'resqml2:Values' of XSD type 'eml:Hdf5Dataset'
        eml__Hdf5Dataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringHdf5Array
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringHdf5Array; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__StringHdf5Array, default initialized and not managed by a soap context
        virtual resqml2__StringHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__StringHdf5Array); }
      public:
        /// Constructor with initializations
        resqml2__StringHdf5Array()
        {
          Values = (eml__Hdf5Dataset *)0;
        }
        virtual ~resqml2__StringHdf5Array() { }
        /// Friend allocator used by soap_new_resqml2__StringHdf5Array(struct soap*, int)
        friend SOAP_FMAC1 resqml2__StringHdf5Array * SOAP_FMAC2 soap_instantiate_resqml2__StringHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:301 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractIntegerArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractIntegerArray (52)
/* Type resqml2__AbstractIntegerArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractIntegerArray': */
class SOAP_CMAC resqml2__AbstractIntegerArray : public resqml2__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractIntegerArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractIntegerArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractIntegerArray, default initialized and not managed by a soap context
        virtual resqml2__AbstractIntegerArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractIntegerArray); }
      public:
        /// Constructor with initializations
        resqml2__AbstractIntegerArray()
        {
        }
        virtual ~resqml2__AbstractIntegerArray() { }
        /// Friend allocator used by soap_new_resqml2__AbstractIntegerArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractIntegerArray * SOAP_FMAC2 soap_instantiate_resqml2__AbstractIntegerArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:304 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractBooleanArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractBooleanArray (53)
/* Type resqml2__AbstractBooleanArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractBooleanArray': */
class SOAP_CMAC resqml2__AbstractBooleanArray : public resqml2__AbstractValueArray {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractBooleanArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractBooleanArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractBooleanArray, default initialized and not managed by a soap context
        virtual resqml2__AbstractBooleanArray *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractBooleanArray); }
      public:
        /// Constructor with initializations
        resqml2__AbstractBooleanArray()
        {
        }
        virtual ~resqml2__AbstractBooleanArray() { }
        /// Friend allocator used by soap_new_resqml2__AbstractBooleanArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractBooleanArray * SOAP_FMAC2 soap_instantiate_resqml2__AbstractBooleanArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:310 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StandardPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StandardPropertyKind (55)
/* Type resqml2__StandardPropertyKind is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:StandardPropertyKind': */
class SOAP_CMAC resqml2__StandardPropertyKind : public resqml2__AbstractPropertyKind {
      public:
        /// Required element 'resqml2:Kind' of XSD type 'resqml2:ResqmlPropertyKind'
        enum resqml2__ResqmlPropertyKind Kind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StandardPropertyKind
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StandardPropertyKind; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__StandardPropertyKind, default initialized and not managed by a soap context
        virtual resqml2__StandardPropertyKind *soap_alloc(void) const { return SOAP_NEW(resqml2__StandardPropertyKind); }
      public:
        /// Constructor with initializations
        resqml2__StandardPropertyKind()
        {
          Kind = (enum resqml2__ResqmlPropertyKind)0;
        }
        virtual ~resqml2__StandardPropertyKind() { }
        /// Friend allocator used by soap_new_resqml2__StandardPropertyKind(struct soap*, int)
        friend SOAP_FMAC1 resqml2__StandardPropertyKind * SOAP_FMAC2 soap_instantiate_resqml2__StandardPropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:316 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LocalPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LocalPropertyKind (57)
/* Type resqml2__LocalPropertyKind is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:LocalPropertyKind': */
class SOAP_CMAC resqml2__LocalPropertyKind : public resqml2__AbstractPropertyKind {
      public:
        /// Required element 'resqml2:LocalPropertyKind' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *LocalPropertyKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LocalPropertyKind
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LocalPropertyKind; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__LocalPropertyKind, default initialized and not managed by a soap context
        virtual resqml2__LocalPropertyKind *soap_alloc(void) const { return SOAP_NEW(resqml2__LocalPropertyKind); }
      public:
        /// Constructor with initializations
        resqml2__LocalPropertyKind()
        {
          LocalPropertyKind = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__LocalPropertyKind() { }
        /// Friend allocator used by soap_new_resqml2__LocalPropertyKind(struct soap*, int)
        friend SOAP_FMAC1 resqml2__LocalPropertyKind * SOAP_FMAC2 soap_instantiate_resqml2__LocalPropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:328 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point2dHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point2dHdf5Array (61)
/* Type resqml2__Point2dHdf5Array is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Point2dHdf5Array': */
class SOAP_CMAC resqml2__Point2dHdf5Array : public resqml2__AbstractPoint3dArray {
      public:
        /// Required element 'resqml2:Coordinates' of XSD type 'eml:Hdf5Dataset'
        eml__Hdf5Dataset *Coordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point2dHdf5Array
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point2dHdf5Array; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Point2dHdf5Array, default initialized and not managed by a soap context
        virtual resqml2__Point2dHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__Point2dHdf5Array); }
      public:
        /// Constructor with initializations
        resqml2__Point2dHdf5Array()
        {
          Coordinates = (eml__Hdf5Dataset *)0;
        }
        virtual ~resqml2__Point2dHdf5Array() { }
        /// Friend allocator used by soap_new_resqml2__Point2dHdf5Array(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Point2dHdf5Array * SOAP_FMAC2 soap_instantiate_resqml2__Point2dHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:334 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationLatticeArray (63)
/* Type resqml2__ParametricLineFromRepresentationLatticeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ParametricLineFromRepresentationLatticeArray': */
class SOAP_CMAC resqml2__ParametricLineFromRepresentationLatticeArray : public resqml2__AbstractParametricLineArray {
      public:
        /// Required element 'resqml2:LineIndicesOnSupportingRepresentation' of XSD type 'resqml2:IntegerLatticeArray'
        resqml2__IntegerLatticeArray *LineIndicesOnSupportingRepresentation;
        /// Required element 'resqml2:SupportingRepresentation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *SupportingRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationLatticeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ParametricLineFromRepresentationLatticeArray, default initialized and not managed by a soap context
        virtual resqml2__ParametricLineFromRepresentationLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineFromRepresentationLatticeArray); }
      public:
        /// Constructor with initializations
        resqml2__ParametricLineFromRepresentationLatticeArray()
        {
          LineIndicesOnSupportingRepresentation = (resqml2__IntegerLatticeArray *)0;
          SupportingRepresentation = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__ParametricLineFromRepresentationLatticeArray() { }
        /// Friend allocator used by soap_new_resqml2__ParametricLineFromRepresentationLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ParametricLineFromRepresentationLatticeArray * SOAP_FMAC2 soap_instantiate_resqml2__ParametricLineFromRepresentationLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:337 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dLatticeArray (64)
/* Type resqml2__Point3dLatticeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Point3dLatticeArray': */
class SOAP_CMAC resqml2__Point3dLatticeArray : public resqml2__AbstractPoint3dArray {
      public:
        /// Optional element 'resqml2:AllDimensionsAreOrthogonal' of XSD type 'xsd:boolean'
        bool *AllDimensionsAreOrthogonal;
        /// Required element 'resqml2:Origin' of XSD type 'resqml2:Point3d'
        resqml2__Point3d *Origin;
        /// Required element 'resqml2:Offset' of XSD type 'resqml2:Point3dOffset'
        std::vector<resqml2__Point3dOffset *> Offset;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dLatticeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Point3dLatticeArray, default initialized and not managed by a soap context
        virtual resqml2__Point3dLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dLatticeArray); }
      public:
        /// Constructor with initializations
        resqml2__Point3dLatticeArray()
        {
          AllDimensionsAreOrthogonal = (bool *)0;
          Origin = (resqml2__Point3d *)0;
        }
        virtual ~resqml2__Point3dLatticeArray() { }
        /// Friend allocator used by soap_new_resqml2__Point3dLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Point3dLatticeArray * SOAP_FMAC2 soap_instantiate_resqml2__Point3dLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:340 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dZValueArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dZValueArray (65)
/* Type resqml2__Point3dZValueArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Point3dZValueArray': */
class SOAP_CMAC resqml2__Point3dZValueArray : public resqml2__AbstractPoint3dArray {
      public:
        /// Required element 'resqml2:SupportingGeometry' of XSD type 'resqml2:AbstractPoint3dArray'
        resqml2__AbstractPoint3dArray *SupportingGeometry;
        /// Required element 'resqml2:ZValues' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *ZValues;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dZValueArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dZValueArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Point3dZValueArray, default initialized and not managed by a soap context
        virtual resqml2__Point3dZValueArray *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dZValueArray); }
      public:
        /// Constructor with initializations
        resqml2__Point3dZValueArray()
        {
          SupportingGeometry = (resqml2__AbstractPoint3dArray *)0;
          ZValues = (resqml2__AbstractDoubleArray *)0;
        }
        virtual ~resqml2__Point3dZValueArray() { }
        /// Friend allocator used by soap_new_resqml2__Point3dZValueArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Point3dZValueArray * SOAP_FMAC2 soap_instantiate_resqml2__Point3dZValueArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:346 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PointGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PointGeometry (67)
/* Type resqml2__PointGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:PointGeometry': */
class SOAP_CMAC resqml2__PointGeometry : public resqml2__AbstractGeometry {
      public:
        /// Required element 'resqml2:Points' of XSD type 'resqml2:AbstractPoint3dArray'
        resqml2__AbstractPoint3dArray *Points;
        /// Optional element 'resqml2:SeismicCoordinates' of XSD type 'resqml2:AbstractSeismicCoordinates'
        resqml2__AbstractSeismicCoordinates *SeismicCoordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PointGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PointGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__PointGeometry, default initialized and not managed by a soap context
        virtual resqml2__PointGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__PointGeometry); }
      public:
        /// Constructor with initializations
        resqml2__PointGeometry()
        {
          Points = (resqml2__AbstractPoint3dArray *)0;
          SeismicCoordinates = (resqml2__AbstractSeismicCoordinates *)0;
        }
        virtual ~resqml2__PointGeometry() { }
        /// Friend allocator used by soap_new_resqml2__PointGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__PointGeometry * SOAP_FMAC2 soap_instantiate_resqml2__PointGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:355 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dHdf5Array (70)
/* Type resqml2__Point3dHdf5Array is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Point3dHdf5Array': */
class SOAP_CMAC resqml2__Point3dHdf5Array : public resqml2__AbstractPoint3dArray {
      public:
        /// Required element 'resqml2:Coordinates' of XSD type 'eml:Hdf5Dataset'
        eml__Hdf5Dataset *Coordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dHdf5Array
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dHdf5Array; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Point3dHdf5Array, default initialized and not managed by a soap context
        virtual resqml2__Point3dHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dHdf5Array); }
      public:
        /// Constructor with initializations
        resqml2__Point3dHdf5Array()
        {
          Coordinates = (eml__Hdf5Dataset *)0;
        }
        virtual ~resqml2__Point3dHdf5Array() { }
        /// Friend allocator used by soap_new_resqml2__Point3dHdf5Array(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Point3dHdf5Array * SOAP_FMAC2 soap_instantiate_resqml2__Point3dHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:364 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineArray (73)
/* Type resqml2__ParametricLineArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ParametricLineArray': */
class SOAP_CMAC resqml2__ParametricLineArray : public resqml2__AbstractParametricLineArray {
      public:
        /// Optional element 'resqml2:ControlPointParameters' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *ControlPointParameters;
        /// Required element 'resqml2:ControlPoints' of XSD type 'resqml2:AbstractPoint3dArray'
        resqml2__AbstractPoint3dArray *ControlPoints;
        /// Required element 'resqml2:KnotCount' of XSD type 'xsd:positiveInteger'
        ULONG64 KnotCount;
        /// Required element 'resqml2:LineKindIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *LineKindIndices;
        /// Optional element 'resqml2:TangentVectors' of XSD type 'resqml2:AbstractPoint3dArray'
        resqml2__AbstractPoint3dArray *TangentVectors;
        /// Optional element 'resqml2:ParametricLineIntersections' of XSD type 'resqml2:ParametricLineIntersections'
        resqml2__ParametricLineIntersections *ParametricLineIntersections;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ParametricLineArray, default initialized and not managed by a soap context
        virtual resqml2__ParametricLineArray *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineArray); }
      public:
        /// Constructor with initializations
        resqml2__ParametricLineArray()
        {
          ControlPointParameters = (resqml2__AbstractDoubleArray *)0;
          ControlPoints = (resqml2__AbstractPoint3dArray *)0;
          KnotCount = (ULONG64)0;
          LineKindIndices = (resqml2__AbstractIntegerArray *)0;
          TangentVectors = (resqml2__AbstractPoint3dArray *)0;
          ParametricLineIntersections = (resqml2__ParametricLineIntersections *)0;
        }
        virtual ~resqml2__ParametricLineArray() { }
        /// Friend allocator used by soap_new_resqml2__ParametricLineArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ParametricLineArray * SOAP_FMAC2 soap_instantiate_resqml2__ParametricLineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:367 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dParametricArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dParametricArray (74)
/* Type resqml2__Point3dParametricArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Point3dParametricArray': */
class SOAP_CMAC resqml2__Point3dParametricArray : public resqml2__AbstractPoint3dArray {
      public:
        /// Required element 'resqml2:Parameters' of XSD type 'resqml2:AbstractValueArray'
        resqml2__AbstractValueArray *Parameters;
        /// Optional element 'resqml2:ParametricLineIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ParametricLineIndices;
        /// Optional element 'resqml2:TruncatedLineIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *TruncatedLineIndices;
        /// Required element 'resqml2:ParametricLines' of XSD type 'resqml2:AbstractParametricLineArray'
        resqml2__AbstractParametricLineArray *ParametricLines;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dParametricArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dParametricArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Point3dParametricArray, default initialized and not managed by a soap context
        virtual resqml2__Point3dParametricArray *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dParametricArray); }
      public:
        /// Constructor with initializations
        resqml2__Point3dParametricArray()
        {
          Parameters = (resqml2__AbstractValueArray *)0;
          ParametricLineIndices = (resqml2__AbstractIntegerArray *)0;
          TruncatedLineIndices = (resqml2__AbstractIntegerArray *)0;
          ParametricLines = (resqml2__AbstractParametricLineArray *)0;
        }
        virtual ~resqml2__Point3dParametricArray() { }
        /// Friend allocator used by soap_new_resqml2__Point3dParametricArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Point3dParametricArray * SOAP_FMAC2 soap_instantiate_resqml2__Point3dParametricArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:379 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPlaneGeometry (78)
/* Type resqml2__AbstractPlaneGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractPlaneGeometry': */
class SOAP_CMAC resqml2__AbstractPlaneGeometry : public resqml2__AbstractGeometry {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPlaneGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPlaneGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractPlaneGeometry, default initialized and not managed by a soap context
        virtual resqml2__AbstractPlaneGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractPlaneGeometry); }
      public:
        /// Constructor with initializations
        resqml2__AbstractPlaneGeometry()
        {
        }
        virtual ~resqml2__AbstractPlaneGeometry() { }
        /// Friend allocator used by soap_new_resqml2__AbstractPlaneGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractPlaneGeometry * SOAP_FMAC2 soap_instantiate_resqml2__AbstractPlaneGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:382 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineGeometry (79)
/* Type resqml2__AbstractParametricLineGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractParametricLineGeometry': */
class SOAP_CMAC resqml2__AbstractParametricLineGeometry : public resqml2__AbstractGeometry {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractParametricLineGeometry, default initialized and not managed by a soap context
        virtual resqml2__AbstractParametricLineGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractParametricLineGeometry); }
      public:
        /// Constructor with initializations
        resqml2__AbstractParametricLineGeometry()
        {
        }
        virtual ~resqml2__AbstractParametricLineGeometry() { }
        /// Friend allocator used by soap_new_resqml2__AbstractParametricLineGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractParametricLineGeometry * SOAP_FMAC2 soap_instantiate_resqml2__AbstractParametricLineGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:385 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dFromRepresentationLatticeArray (80)
/* Type resqml2__Point3dFromRepresentationLatticeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Point3dFromRepresentationLatticeArray': */
class SOAP_CMAC resqml2__Point3dFromRepresentationLatticeArray : public resqml2__AbstractPoint3dArray {
      public:
        /// Required element 'resqml2:NodeIndicesOnSupportingRepresentation' of XSD type 'resqml2:IntegerLatticeArray'
        resqml2__IntegerLatticeArray *NodeIndicesOnSupportingRepresentation;
        /// Required element 'resqml2:SupportingRepresentation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *SupportingRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dFromRepresentationLatticeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dFromRepresentationLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Point3dFromRepresentationLatticeArray, default initialized and not managed by a soap context
        virtual resqml2__Point3dFromRepresentationLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__Point3dFromRepresentationLatticeArray); }
      public:
        /// Constructor with initializations
        resqml2__Point3dFromRepresentationLatticeArray()
        {
          NodeIndicesOnSupportingRepresentation = (resqml2__IntegerLatticeArray *)0;
          SupportingRepresentation = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__Point3dFromRepresentationLatticeArray() { }
        /// Friend allocator used by soap_new_resqml2__Point3dFromRepresentationLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Point3dFromRepresentationLatticeArray * SOAP_FMAC2 soap_instantiate_resqml2__Point3dFromRepresentationLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:388 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic3dCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic3dCoordinates (81)
/* Type resqml2__Seismic3dCoordinates is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Seismic3dCoordinates': */
class SOAP_CMAC resqml2__Seismic3dCoordinates : public resqml2__AbstractSeismicCoordinates {
      public:
        /// Required element 'resqml2:CrosslineCoordinates' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *CrosslineCoordinates;
        /// Required element 'resqml2:InlineCoordinates' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *InlineCoordinates;
        /// Optional element 'resqml2:VerticalCoordinates' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *VerticalCoordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic3dCoordinates
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic3dCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Seismic3dCoordinates, default initialized and not managed by a soap context
        virtual resqml2__Seismic3dCoordinates *soap_alloc(void) const { return SOAP_NEW(resqml2__Seismic3dCoordinates); }
      public:
        /// Constructor with initializations
        resqml2__Seismic3dCoordinates()
        {
          CrosslineCoordinates = (resqml2__AbstractDoubleArray *)0;
          InlineCoordinates = (resqml2__AbstractDoubleArray *)0;
          VerticalCoordinates = (resqml2__AbstractDoubleArray *)0;
        }
        virtual ~resqml2__Seismic3dCoordinates() { }
        /// Friend allocator used by soap_new_resqml2__Seismic3dCoordinates(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Seismic3dCoordinates * SOAP_FMAC2 soap_instantiate_resqml2__Seismic3dCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:394 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic2dCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic2dCoordinates (83)
/* Type resqml2__Seismic2dCoordinates is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Seismic2dCoordinates': */
class SOAP_CMAC resqml2__Seismic2dCoordinates : public resqml2__AbstractSeismicCoordinates {
      public:
        /// Required element 'resqml2:LineAbscissa' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *LineAbscissa;
        /// Optional element 'resqml2:VerticalCoordinates' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *VerticalCoordinates;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic2dCoordinates
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic2dCoordinates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Seismic2dCoordinates, default initialized and not managed by a soap context
        virtual resqml2__Seismic2dCoordinates *soap_alloc(void) const { return SOAP_NEW(resqml2__Seismic2dCoordinates); }
      public:
        /// Constructor with initializations
        resqml2__Seismic2dCoordinates()
        {
          LineAbscissa = (resqml2__AbstractDoubleArray *)0;
          VerticalCoordinates = (resqml2__AbstractDoubleArray *)0;
        }
        virtual ~resqml2__Seismic2dCoordinates() { }
        /// Friend allocator used by soap_new_resqml2__Seismic2dCoordinates(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Seismic2dCoordinates * SOAP_FMAC2 soap_instantiate_resqml2__Seismic2dCoordinates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:397 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch1d
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch1d (84)
/* Type resqml2__Patch1d is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Patch1d': */
class SOAP_CMAC resqml2__Patch1d : public resqml2__Patch {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch1d
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch1d; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Patch1d, default initialized and not managed by a soap context
        virtual resqml2__Patch1d *soap_alloc(void) const { return SOAP_NEW(resqml2__Patch1d); }
      public:
        /// Constructor with initializations
        resqml2__Patch1d()
        {
          Count = (ULONG64)0;
        }
        virtual ~resqml2__Patch1d() { }
        /// Friend allocator used by soap_new_resqml2__Patch1d(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Patch1d * SOAP_FMAC2 soap_instantiate_resqml2__Patch1d(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:442 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitNodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitNodePatch (99)
/* Type resqml2__SplitNodePatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:SplitNodePatch': */
class SOAP_CMAC resqml2__SplitNodePatch : public resqml2__Patch {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:ParentNodeIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ParentNodeIndices;
        /// Required element 'resqml2:CellsPerSplitNode' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *CellsPerSplitNode;
        /// Optional element 'resqml2:SplitFaces' of XSD type 'resqml2:SplitFaces'
        resqml2__SplitFaces *SplitFaces;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitNodePatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitNodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__SplitNodePatch, default initialized and not managed by a soap context
        virtual resqml2__SplitNodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__SplitNodePatch); }
      public:
        /// Constructor with initializations
        resqml2__SplitNodePatch()
        {
          Count = (ULONG64)0;
          ParentNodeIndices = (resqml2__AbstractIntegerArray *)0;
          CellsPerSplitNode = (resqml2__ResqmlJaggedArray *)0;
          SplitFaces = (resqml2__SplitFaces *)0;
        }
        virtual ~resqml2__SplitNodePatch() { }
        /// Friend allocator used by soap_new_resqml2__SplitNodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__SplitNodePatch * SOAP_FMAC2 soap_instantiate_resqml2__SplitNodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:445 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkParentWindow (100)
/* Type resqml2__IjkParentWindow is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:IjkParentWindow': */
class SOAP_CMAC resqml2__IjkParentWindow : public resqml2__AbstractParentWindow {
      public:
        /// Optional element 'resqml2:OmitParentCells' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *OmitParentCells;
        /// Required element 'resqml2:JRegrid' of XSD type 'resqml2:Regrid'
        resqml2__Regrid *JRegrid;
        /// Required element 'resqml2:ParentGrid' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *ParentGrid;
        /// Required element 'resqml2:KRegrid' of XSD type 'resqml2:Regrid'
        resqml2__Regrid *KRegrid;
        /// Required element 'resqml2:IRegrid' of XSD type 'resqml2:Regrid'
        resqml2__Regrid *IRegrid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkParentWindow
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkParentWindow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IjkParentWindow, default initialized and not managed by a soap context
        virtual resqml2__IjkParentWindow *soap_alloc(void) const { return SOAP_NEW(resqml2__IjkParentWindow); }
      public:
        /// Constructor with initializations
        resqml2__IjkParentWindow()
        {
          OmitParentCells = (resqml2__AbstractIntegerArray *)0;
          JRegrid = (resqml2__Regrid *)0;
          ParentGrid = (eml__DataObjectReference *)0;
          KRegrid = (resqml2__Regrid *)0;
          IRegrid = (resqml2__Regrid *)0;
        }
        virtual ~resqml2__IjkParentWindow() { }
        /// Friend allocator used by soap_new_resqml2__IjkParentWindow(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IjkParentWindow * SOAP_FMAC2 soap_instantiate_resqml2__IjkParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:475 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerParentWindow (110)
/* Type resqml2__ColumnLayerParentWindow is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ColumnLayerParentWindow': */
class SOAP_CMAC resqml2__ColumnLayerParentWindow : public resqml2__AbstractParentWindow {
      public:
        /// Required element 'resqml2:ColumnIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ColumnIndices;
        /// Optional element 'resqml2:OmitParentCells' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *OmitParentCells;
        /// Required element 'resqml2:KRegrid' of XSD type 'resqml2:Regrid'
        resqml2__Regrid *KRegrid;
        /// Required element 'resqml2:ParentGrid' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *ParentGrid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerParentWindow
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerParentWindow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ColumnLayerParentWindow, default initialized and not managed by a soap context
        virtual resqml2__ColumnLayerParentWindow *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnLayerParentWindow); }
      public:
        /// Constructor with initializations
        resqml2__ColumnLayerParentWindow()
        {
          ColumnIndices = (resqml2__AbstractIntegerArray *)0;
          OmitParentCells = (resqml2__AbstractIntegerArray *)0;
          KRegrid = (resqml2__Regrid *)0;
          ParentGrid = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__ColumnLayerParentWindow() { }
        /// Friend allocator used by soap_new_resqml2__ColumnLayerParentWindow(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ColumnLayerParentWindow * SOAP_FMAC2 soap_instantiate_resqml2__ColumnLayerParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:478 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredSubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredSubnodeTopology (111)
/* Type resqml2__UnstructuredSubnodeTopology is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:UnstructuredSubnodeTopology': */
class SOAP_CMAC resqml2__UnstructuredSubnodeTopology : public resqml2__SubnodeTopology {
      public:
        /// Optional element 'resqml2:Edges' of XSD type 'resqml2:Edges'
        resqml2__Edges *Edges;
        /// Optional element 'resqml2:NodesPerCell' of XSD type 'resqml2:NodesPerCell'
        resqml2__NodesPerCell *NodesPerCell;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredSubnodeTopology
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredSubnodeTopology; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__UnstructuredSubnodeTopology, default initialized and not managed by a soap context
        virtual resqml2__UnstructuredSubnodeTopology *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredSubnodeTopology); }
      public:
        /// Constructor with initializations
        resqml2__UnstructuredSubnodeTopology()
        {
          Edges = (resqml2__Edges *)0;
          NodesPerCell = (resqml2__NodesPerCell *)0;
        }
        virtual ~resqml2__UnstructuredSubnodeTopology() { }
        /// Friend allocator used by soap_new_resqml2__UnstructuredSubnodeTopology(struct soap*, int)
        friend SOAP_FMAC1 resqml2__UnstructuredSubnodeTopology * SOAP_FMAC2 soap_instantiate_resqml2__UnstructuredSubnodeTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:481 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredColumnLayerGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredColumnLayerGridPatch (112)
/* Type resqml2__GpGridUnstructuredColumnLayerGridPatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:GpGridUnstructuredColumnLayerGridPatch': */
class SOAP_CMAC resqml2__GpGridUnstructuredColumnLayerGridPatch : public resqml2__Patch {
      public:
        /// Required element 'resqml2:UnstructuredColumnCount' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 UnstructuredColumnCount;
        /// Optional element 'resqml2:Geometry' of XSD type 'resqml2:UnstructuredColumnLayerGridGeometry'
        resqml2__UnstructuredColumnLayerGridGeometry *Geometry;
        /// Optional element 'resqml2:TruncationCells' of XSD type 'resqml2:TruncationCellPatch'
        resqml2__TruncationCellPatch *TruncationCells;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredColumnLayerGridPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredColumnLayerGridPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__GpGridUnstructuredColumnLayerGridPatch, default initialized and not managed by a soap context
        virtual resqml2__GpGridUnstructuredColumnLayerGridPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__GpGridUnstructuredColumnLayerGridPatch); }
      public:
        /// Constructor with initializations
        resqml2__GpGridUnstructuredColumnLayerGridPatch()
        {
          UnstructuredColumnCount = (ULONG64)0;
          Geometry = (resqml2__UnstructuredColumnLayerGridGeometry *)0;
          TruncationCells = (resqml2__TruncationCellPatch *)0;
        }
        virtual ~resqml2__GpGridUnstructuredColumnLayerGridPatch() { }
        /// Friend allocator used by soap_new_resqml2__GpGridUnstructuredColumnLayerGridPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__GpGridUnstructuredColumnLayerGridPatch * SOAP_FMAC2 soap_instantiate_resqml2__GpGridUnstructuredColumnLayerGridPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:496 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodePatch (117)
/* Type resqml2__SubnodePatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:SubnodePatch': */
class SOAP_CMAC resqml2__SubnodePatch : public resqml2__Patch {
      public:
        /// Required element 'resqml2:SubnodeNodeObject' of XSD type 'resqml2:SubnodeNodeObject'
        enum resqml2__SubnodeNodeObject SubnodeNodeObject;
        /// Required element 'resqml2:NodeWeightsPerSubnode' of XSD type 'resqml2:AbstractValueArray'
        resqml2__AbstractValueArray *NodeWeightsPerSubnode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodePatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__SubnodePatch, default initialized and not managed by a soap context
        virtual resqml2__SubnodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__SubnodePatch); }
      public:
        /// Constructor with initializations
        resqml2__SubnodePatch()
        {
          SubnodeNodeObject = (enum resqml2__SubnodeNodeObject)0;
          NodeWeightsPerSubnode = (resqml2__AbstractValueArray *)0;
        }
        virtual ~resqml2__SubnodePatch() { }
        /// Friend allocator used by soap_new_resqml2__SubnodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__SubnodePatch * SOAP_FMAC2 soap_instantiate_resqml2__SubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:499 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSubnodeTopology (118)
/* Type resqml2__ColumnLayerSubnodeTopology is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ColumnLayerSubnodeTopology': */
class SOAP_CMAC resqml2__ColumnLayerSubnodeTopology : public resqml2__SubnodeTopology {
      public:
        /// Optional element 'resqml2:ColumnSubnodes' of XSD type 'resqml2:ColumnSubnodePatch'
        std::vector<resqml2__ColumnSubnodePatch *> ColumnSubnodes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSubnodeTopology
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSubnodeTopology; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ColumnLayerSubnodeTopology, default initialized and not managed by a soap context
        virtual resqml2__ColumnLayerSubnodeTopology *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnLayerSubnodeTopology); }
      public:
        /// Constructor with initializations
        resqml2__ColumnLayerSubnodeTopology()
        {
        }
        virtual ~resqml2__ColumnLayerSubnodeTopology() { }
        /// Friend allocator used by soap_new_resqml2__ColumnLayerSubnodeTopology(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ColumnLayerSubnodeTopology * SOAP_FMAC2 soap_instantiate_resqml2__ColumnLayerSubnodeTopology(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:511 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TruncationCellPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TruncationCellPatch (122)
/* Type resqml2__TruncationCellPatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:TruncationCellPatch': */
class SOAP_CMAC resqml2__TruncationCellPatch : public resqml2__Patch {
      public:
        /// Required element 'resqml2:TruncationNodeCount' of XSD type 'xsd:positiveInteger'
        ULONG64 TruncationNodeCount;
        /// Required element 'resqml2:TruncationFaceCount' of XSD type 'xsd:positiveInteger'
        ULONG64 TruncationFaceCount;
        /// Required element 'resqml2:TruncationCellCount' of XSD type 'xsd:positiveInteger'
        ULONG64 TruncationCellCount;
        /// Required element 'resqml2:NodesPerTruncationFace' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *NodesPerTruncationFace;
        /// Required element 'resqml2:ParentCellIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ParentCellIndices;
        /// Required element 'resqml2:LocalFacesPerCell' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *LocalFacesPerCell;
        /// Required element 'resqml2:TruncationFacesPerCell' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *TruncationFacesPerCell;
        /// Required element 'resqml2:TruncationCellFaceIsRightHanded' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *TruncationCellFaceIsRightHanded;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TruncationCellPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TruncationCellPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__TruncationCellPatch, default initialized and not managed by a soap context
        virtual resqml2__TruncationCellPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__TruncationCellPatch); }
      public:
        /// Constructor with initializations
        resqml2__TruncationCellPatch()
        {
          TruncationNodeCount = (ULONG64)0;
          TruncationFaceCount = (ULONG64)0;
          TruncationCellCount = (ULONG64)0;
          NodesPerTruncationFace = (resqml2__ResqmlJaggedArray *)0;
          ParentCellIndices = (resqml2__AbstractIntegerArray *)0;
          LocalFacesPerCell = (resqml2__ResqmlJaggedArray *)0;
          TruncationFacesPerCell = (resqml2__ResqmlJaggedArray *)0;
          TruncationCellFaceIsRightHanded = (resqml2__AbstractBooleanArray *)0;
        }
        virtual ~resqml2__TruncationCellPatch() { }
        /// Friend allocator used by soap_new_resqml2__TruncationCellPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__TruncationCellPatch * SOAP_FMAC2 soap_instantiate_resqml2__TruncationCellPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:514 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredGridPatch (123)
/* Type resqml2__GpGridUnstructuredGridPatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:GpGridUnstructuredGridPatch': */
class SOAP_CMAC resqml2__GpGridUnstructuredGridPatch : public resqml2__Patch {
      public:
        /// Required element 'resqml2:UnstructuredCellCount' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 UnstructuredCellCount;
        /// Optional element 'resqml2:Geometry' of XSD type 'resqml2:UnstructuredGridGeometry'
        resqml2__UnstructuredGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredGridPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredGridPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__GpGridUnstructuredGridPatch, default initialized and not managed by a soap context
        virtual resqml2__GpGridUnstructuredGridPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__GpGridUnstructuredGridPatch); }
      public:
        /// Constructor with initializations
        resqml2__GpGridUnstructuredGridPatch()
        {
          UnstructuredCellCount = (ULONG64)0;
          Geometry = (resqml2__UnstructuredGridGeometry *)0;
        }
        virtual ~resqml2__GpGridUnstructuredGridPatch() { }
        /// Friend allocator used by soap_new_resqml2__GpGridUnstructuredGridPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__GpGridUnstructuredGridPatch * SOAP_FMAC2 soap_instantiate_resqml2__GpGridUnstructuredGridPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:556 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellParentWindow (137)
/* Type resqml2__CellParentWindow is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:CellParentWindow': */
class SOAP_CMAC resqml2__CellParentWindow : public resqml2__AbstractParentWindow {
      public:
        /// Required element 'resqml2:CellIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *CellIndices;
        /// Required element 'resqml2:ParentGrid' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *ParentGrid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellParentWindow
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellParentWindow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__CellParentWindow, default initialized and not managed by a soap context
        virtual resqml2__CellParentWindow *soap_alloc(void) const { return SOAP_NEW(resqml2__CellParentWindow); }
      public:
        /// Constructor with initializations
        resqml2__CellParentWindow()
        {
          CellIndices = (resqml2__AbstractIntegerArray *)0;
          ParentGrid = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__CellParentWindow() { }
        /// Friend allocator used by soap_new_resqml2__CellParentWindow(struct soap*, int)
        friend SOAP_FMAC1 resqml2__CellParentWindow * SOAP_FMAC2 soap_instantiate_resqml2__CellParentWindow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:562 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridIjkGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridIjkGridPatch (139)
/* Type resqml2__GpGridIjkGridPatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:GpGridIjkGridPatch': */
class SOAP_CMAC resqml2__GpGridIjkGridPatch : public resqml2__Patch {
      public:
        /// Required element 'resqml2:Ni' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Ni;
        /// Required element 'resqml2:Nj' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Nj;
        /// Optional element 'resqml2:RadialGridIsComplete' of XSD type 'xsd:boolean'
        bool *RadialGridIsComplete;
        /// Optional element 'resqml2:Geometry' of XSD type 'resqml2:IjkGridGeometry'
        resqml2__IjkGridGeometry *Geometry;
        /// Optional element 'resqml2:TruncationCells' of XSD type 'resqml2:TruncationCellPatch'
        resqml2__TruncationCellPatch *TruncationCells;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridIjkGridPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridIjkGridPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__GpGridIjkGridPatch, default initialized and not managed by a soap context
        virtual resqml2__GpGridIjkGridPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__GpGridIjkGridPatch); }
      public:
        /// Constructor with initializations
        resqml2__GpGridIjkGridPatch()
        {
          Ni = (ULONG64)0;
          Nj = (ULONG64)0;
          RadialGridIsComplete = (bool *)0;
          Geometry = (resqml2__IjkGridGeometry *)0;
          TruncationCells = (resqml2__TruncationCellPatch *)0;
        }
        virtual ~resqml2__GpGridIjkGridPatch() { }
        /// Friend allocator used by soap_new_resqml2__GpGridIjkGridPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__GpGridIjkGridPatch * SOAP_FMAC2 soap_instantiate_resqml2__GpGridIjkGridPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:610 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BinaryContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BinaryContactInterpretationPart (155)
/* Type resqml2__BinaryContactInterpretationPart is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:BinaryContactInterpretationPart': */
class SOAP_CMAC resqml2__BinaryContactInterpretationPart : public resqml2__AbstractContactInterpretationPart {
      public:
        /// Required element 'resqml2:DirectObject' of XSD type 'resqml2:ContactElementReference'
        resqml2__ContactElementReference *DirectObject;
        /// Required element 'resqml2:Verb' of XSD type 'resqml2:ContactVerb'
        enum resqml2__ContactVerb Verb;
        /// Required element 'resqml2:Subject' of XSD type 'resqml2:ContactElementReference'
        resqml2__ContactElementReference *Subject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BinaryContactInterpretationPart
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BinaryContactInterpretationPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__BinaryContactInterpretationPart, default initialized and not managed by a soap context
        virtual resqml2__BinaryContactInterpretationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__BinaryContactInterpretationPart); }
      public:
        /// Constructor with initializations
        resqml2__BinaryContactInterpretationPart()
        {
          DirectObject = (resqml2__ContactElementReference *)0;
          Verb = (enum resqml2__ContactVerb)0;
          Subject = (resqml2__ContactElementReference *)0;
        }
        virtual ~resqml2__BinaryContactInterpretationPart() { }
        /// Friend allocator used by soap_new_resqml2__BinaryContactInterpretationPart(struct soap*, int)
        friend SOAP_FMAC1 resqml2__BinaryContactInterpretationPart * SOAP_FMAC2 soap_instantiate_resqml2__BinaryContactInterpretationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:616 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactElementReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactElementReference (157)
/* Type resqml2__ContactElementReference is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ContactElementReference': */
class SOAP_CMAC resqml2__ContactElementReference : public eml__DataObjectReference {
      public:
        /// Optional element 'resqml2:Qualifier' of XSD type 'resqml2:ContactSide'
        enum resqml2__ContactSide *Qualifier;
        /// Optional element 'resqml2:SecondaryQualifier' of XSD type 'resqml2:ContactMode'
        enum resqml2__ContactMode *SecondaryQualifier;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactElementReference
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactElementReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ContactElementReference, default initialized and not managed by a soap context
        virtual resqml2__ContactElementReference *soap_alloc(void) const { return SOAP_NEW(resqml2__ContactElementReference); }
      public:
        /// Constructor with initializations
        resqml2__ContactElementReference()
        {
          Qualifier = (enum resqml2__ContactSide *)0;
          SecondaryQualifier = (enum resqml2__ContactMode *)0;
        }
        virtual ~resqml2__ContactElementReference() { }
        /// Friend allocator used by soap_new_resqml2__ContactElementReference(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ContactElementReference * SOAP_FMAC2 soap_instantiate_resqml2__ContactElementReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:637 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MultipleContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MultipleContactInterpretationPart (164)
/* Type resqml2__MultipleContactInterpretationPart is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:MultipleContactInterpretationPart': */
class SOAP_CMAC resqml2__MultipleContactInterpretationPart : public resqml2__AbstractContactInterpretationPart {
      public:
        /// Required element 'resqml2:With' of XSD type 'xsd:nonNegativeInteger'
        std::vector<ULONG64> With;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MultipleContactInterpretationPart
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MultipleContactInterpretationPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__MultipleContactInterpretationPart, default initialized and not managed by a soap context
        virtual resqml2__MultipleContactInterpretationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__MultipleContactInterpretationPart); }
      public:
        /// Constructor with initializations
        resqml2__MultipleContactInterpretationPart()
        {
        }
        virtual ~resqml2__MultipleContactInterpretationPart() { }
        /// Friend allocator used by soap_new_resqml2__MultipleContactInterpretationPart(struct soap*, int)
        friend SOAP_FMAC1 resqml2__MultipleContactInterpretationPart * SOAP_FMAC2 soap_instantiate_resqml2__MultipleContactInterpretationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:787 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NonSealedContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NonSealedContactRepresentationPart (214)
/* Type resqml2__NonSealedContactRepresentationPart is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:NonSealedContactRepresentationPart': */
class SOAP_CMAC resqml2__NonSealedContactRepresentationPart : public resqml2__AbstractContactRepresentationPart {
      public:
        /// Optional element 'resqml2:Contact' of XSD type 'resqml2:ContactPatch'
        std::vector<resqml2__ContactPatch *> Contact;
        /// Required element 'resqml2:Geometry' of XSD type 'resqml2:AbstractGeometry'
        resqml2__AbstractGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NonSealedContactRepresentationPart
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NonSealedContactRepresentationPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__NonSealedContactRepresentationPart, default initialized and not managed by a soap context
        virtual resqml2__NonSealedContactRepresentationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__NonSealedContactRepresentationPart); }
      public:
        /// Constructor with initializations
        resqml2__NonSealedContactRepresentationPart()
        {
          Geometry = (resqml2__AbstractGeometry *)0;
        }
        virtual ~resqml2__NonSealedContactRepresentationPart() { }
        /// Friend allocator used by soap_new_resqml2__NonSealedContactRepresentationPart(struct soap*, int)
        friend SOAP_FMAC1 resqml2__NonSealedContactRepresentationPart * SOAP_FMAC2 soap_instantiate_resqml2__NonSealedContactRepresentationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:790 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SealedContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SealedContactRepresentationPart (215)
/* Type resqml2__SealedContactRepresentationPart is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:SealedContactRepresentationPart': */
class SOAP_CMAC resqml2__SealedContactRepresentationPart : public resqml2__AbstractContactRepresentationPart {
      public:
        /// Optional element 'resqml2:IdenticalNodeIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *IdenticalNodeIndices;
        /// Required element 'resqml2:IdentityKind' of XSD type 'resqml2:IdentityKind'
        enum resqml2__IdentityKind IdentityKind;
        /// Required element 'resqml2:Contact' of XSD type 'resqml2:ContactPatch'
        std::vector<resqml2__ContactPatch *> Contact;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SealedContactRepresentationPart
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SealedContactRepresentationPart; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__SealedContactRepresentationPart, default initialized and not managed by a soap context
        virtual resqml2__SealedContactRepresentationPart *soap_alloc(void) const { return SOAP_NEW(resqml2__SealedContactRepresentationPart); }
      public:
        /// Constructor with initializations
        resqml2__SealedContactRepresentationPart()
        {
          IdenticalNodeIndices = (resqml2__AbstractIntegerArray *)0;
          IdentityKind = (enum resqml2__IdentityKind)0;
        }
        virtual ~resqml2__SealedContactRepresentationPart() { }
        /// Friend allocator used by soap_new_resqml2__SealedContactRepresentationPart(struct soap*, int)
        friend SOAP_FMAC1 resqml2__SealedContactRepresentationPart * SOAP_FMAC2 soap_instantiate_resqml2__SealedContactRepresentationPart(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:844 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Grid2dPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Grid2dPatch (233)
/* Type resqml2__Grid2dPatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:Grid2dPatch': */
class SOAP_CMAC resqml2__Grid2dPatch : public resqml2__Patch {
      public:
        /// Required element 'resqml2:FastestAxisCount' of XSD type 'xsd:positiveInteger'
        ULONG64 FastestAxisCount;
        /// Required element 'resqml2:SlowestAxisCount' of XSD type 'xsd:positiveInteger'
        ULONG64 SlowestAxisCount;
        /// Required element 'resqml2:Geometry' of XSD type 'resqml2:PointGeometry'
        resqml2__PointGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Grid2dPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Grid2dPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__Grid2dPatch, default initialized and not managed by a soap context
        virtual resqml2__Grid2dPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__Grid2dPatch); }
      public:
        /// Constructor with initializations
        resqml2__Grid2dPatch()
        {
          FastestAxisCount = (ULONG64)0;
          SlowestAxisCount = (ULONG64)0;
          Geometry = (resqml2__PointGeometry *)0;
        }
        virtual ~resqml2__Grid2dPatch() { }
        /// Friend allocator used by soap_new_resqml2__Grid2dPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__Grid2dPatch * SOAP_FMAC2 soap_instantiate_resqml2__Grid2dPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:850 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PolylineSetPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PolylineSetPatch (235)
/* Type resqml2__PolylineSetPatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:PolylineSetPatch': */
class SOAP_CMAC resqml2__PolylineSetPatch : public resqml2__Patch {
      public:
        /// Required element 'resqml2:ClosedPolylines' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *ClosedPolylines;
        /// Required element 'resqml2:NodeCountPerPolyline' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *NodeCountPerPolyline;
        /// Required element 'resqml2:Geometry' of XSD type 'resqml2:PointGeometry'
        resqml2__PointGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PolylineSetPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PolylineSetPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__PolylineSetPatch, default initialized and not managed by a soap context
        virtual resqml2__PolylineSetPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__PolylineSetPatch); }
      public:
        /// Constructor with initializations
        resqml2__PolylineSetPatch()
        {
          ClosedPolylines = (resqml2__AbstractBooleanArray *)0;
          NodeCountPerPolyline = (resqml2__AbstractIntegerArray *)0;
          Geometry = (resqml2__PointGeometry *)0;
        }
        virtual ~resqml2__PolylineSetPatch() { }
        /// Friend allocator used by soap_new_resqml2__PolylineSetPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__PolylineSetPatch * SOAP_FMAC2 soap_instantiate_resqml2__PolylineSetPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:859 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRepresentationReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRepresentationReference (238)
/* Type resqml2__ContactRepresentationReference is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ContactRepresentationReference': */
class SOAP_CMAC resqml2__ContactRepresentationReference : public resqml2__AbstractContactRepresentationPart {
      public:
        /// Required element 'resqml2:Representation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Representation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRepresentationReference
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRepresentationReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ContactRepresentationReference, default initialized and not managed by a soap context
        virtual resqml2__ContactRepresentationReference *soap_alloc(void) const { return SOAP_NEW(resqml2__ContactRepresentationReference); }
      public:
        /// Constructor with initializations
        resqml2__ContactRepresentationReference()
        {
          Representation = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__ContactRepresentationReference() { }
        /// Friend allocator used by soap_new_resqml2__ContactRepresentationReference(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ContactRepresentationReference * SOAP_FMAC2 soap_instantiate_resqml2__ContactRepresentationReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:889 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DataObjectParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DataObjectParameter (248)
/* Type resqml2__DataObjectParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:DataObjectParameter': */
class SOAP_CMAC resqml2__DataObjectParameter : public resqml2__AbstractActivityParameter {
      public:
        /// Required element 'resqml2:DataObject' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *DataObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DataObjectParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DataObjectParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__DataObjectParameter, default initialized and not managed by a soap context
        virtual resqml2__DataObjectParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__DataObjectParameter); }
      public:
        /// Constructor with initializations
        resqml2__DataObjectParameter()
        {
          DataObject = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__DataObjectParameter() { }
        /// Friend allocator used by soap_new_resqml2__DataObjectParameter(struct soap*, int)
        friend SOAP_FMAC1 resqml2__DataObjectParameter * SOAP_FMAC2 soap_instantiate_resqml2__DataObjectParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:892 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ObjectParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ObjectParameterKey (249)
/* Type resqml2__ObjectParameterKey is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ObjectParameterKey': */
class SOAP_CMAC resqml2__ObjectParameterKey : public resqml2__AbstractParameterKey {
      public:
        /// Required element 'resqml2:DataObject' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *DataObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ObjectParameterKey
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ObjectParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ObjectParameterKey, default initialized and not managed by a soap context
        virtual resqml2__ObjectParameterKey *soap_alloc(void) const { return SOAP_NEW(resqml2__ObjectParameterKey); }
      public:
        /// Constructor with initializations
        resqml2__ObjectParameterKey()
        {
          DataObject = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__ObjectParameterKey() { }
        /// Friend allocator used by soap_new_resqml2__ObjectParameterKey(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ObjectParameterKey * SOAP_FMAC2 soap_instantiate_resqml2__ObjectParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:898 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringParameter (251)
/* Type resqml2__StringParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:StringParameter': */
class SOAP_CMAC resqml2__StringParameter : public resqml2__AbstractActivityParameter {
      public:
        /// Required element 'resqml2:Value' of XSD type 'xsd:string'
        std::string Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__StringParameter, default initialized and not managed by a soap context
        virtual resqml2__StringParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__StringParameter); }
      public:
        /// Constructor with initializations
        resqml2__StringParameter()
        {
        }
        virtual ~resqml2__StringParameter() { }
        /// Friend allocator used by soap_new_resqml2__StringParameter(struct soap*, int)
        friend SOAP_FMAC1 resqml2__StringParameter * SOAP_FMAC2 soap_instantiate_resqml2__StringParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:904 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerQuantityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerQuantityParameter (253)
/* Type resqml2__IntegerQuantityParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:IntegerQuantityParameter': */
class SOAP_CMAC resqml2__IntegerQuantityParameter : public resqml2__AbstractActivityParameter {
      public:
        /// Required element 'resqml2:Value' of XSD type 'xsd:long'
        LONG64 Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerQuantityParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerQuantityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IntegerQuantityParameter, default initialized and not managed by a soap context
        virtual resqml2__IntegerQuantityParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerQuantityParameter); }
      public:
        /// Constructor with initializations
        resqml2__IntegerQuantityParameter()
        {
          Value = (LONG64)0;
        }
        virtual ~resqml2__IntegerQuantityParameter() { }
        /// Friend allocator used by soap_new_resqml2__IntegerQuantityParameter(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IntegerQuantityParameter * SOAP_FMAC2 soap_instantiate_resqml2__IntegerQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:907 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameterKey (254)
/* Type resqml2__TimeIndexParameterKey is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:TimeIndexParameterKey': */
class SOAP_CMAC resqml2__TimeIndexParameterKey : public resqml2__AbstractParameterKey {
      public:
        /// Required element 'resqml2:TimeIndex' of XSD type 'resqml2:TimeIndex'
        resqml2__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameterKey
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameterKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__TimeIndexParameterKey, default initialized and not managed by a soap context
        virtual resqml2__TimeIndexParameterKey *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeIndexParameterKey); }
      public:
        /// Constructor with initializations
        resqml2__TimeIndexParameterKey()
        {
          TimeIndex = (resqml2__TimeIndex *)0;
        }
        virtual ~resqml2__TimeIndexParameterKey() { }
        /// Friend allocator used by soap_new_resqml2__TimeIndexParameterKey(struct soap*, int)
        friend SOAP_FMAC1 resqml2__TimeIndexParameterKey * SOAP_FMAC2 soap_instantiate_resqml2__TimeIndexParameterKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:910 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FloatingPointQuantityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FloatingPointQuantityParameter (255)
/* Type resqml2__FloatingPointQuantityParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:FloatingPointQuantityParameter': */
class SOAP_CMAC resqml2__FloatingPointQuantityParameter : public resqml2__AbstractActivityParameter {
      public:
        /// Required element 'resqml2:Value' of XSD type 'xsd:double'
        double Value;
        /// Required element 'resqml2:Uom' of XSD type 'resqml2:ResqmlUom'
        enum resqml2__ResqmlUom Uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FloatingPointQuantityParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FloatingPointQuantityParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__FloatingPointQuantityParameter, default initialized and not managed by a soap context
        virtual resqml2__FloatingPointQuantityParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__FloatingPointQuantityParameter); }
      public:
        /// Constructor with initializations
        resqml2__FloatingPointQuantityParameter()
        {
          Value = (double)0;
          Uom = (enum resqml2__ResqmlUom)0;
        }
        virtual ~resqml2__FloatingPointQuantityParameter() { }
        /// Friend allocator used by soap_new_resqml2__FloatingPointQuantityParameter(struct soap*, int)
        friend SOAP_FMAC1 resqml2__FloatingPointQuantityParameter * SOAP_FMAC2 soap_instantiate_resqml2__FloatingPointQuantityParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:916 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameter (257)
/* Type resqml2__TimeIndexParameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:TimeIndexParameter': */
class SOAP_CMAC resqml2__TimeIndexParameter : public resqml2__AbstractActivityParameter {
      public:
        /// Required element 'resqml2:TimeIndex' of XSD type 'resqml2:TimeIndex'
        resqml2__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameter
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__TimeIndexParameter, default initialized and not managed by a soap context
        virtual resqml2__TimeIndexParameter *soap_alloc(void) const { return SOAP_NEW(resqml2__TimeIndexParameter); }
      public:
        /// Constructor with initializations
        resqml2__TimeIndexParameter()
        {
          TimeIndex = (resqml2__TimeIndex *)0;
        }
        virtual ~resqml2__TimeIndexParameter() { }
        /// Friend allocator used by soap_new_resqml2__TimeIndexParameter(struct soap*, int)
        friend SOAP_FMAC1 resqml2__TimeIndexParameter * SOAP_FMAC2 soap_instantiate_resqml2__TimeIndexParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:925 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlinePolylineSetPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlinePolylineSetPatch (260)
/* Type resqml2__StreamlinePolylineSetPatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:StreamlinePolylineSetPatch': */
class SOAP_CMAC resqml2__StreamlinePolylineSetPatch : public resqml2__Patch {
      public:
        /// Required element 'resqml2:NodeCount' of XSD type 'xsd:positiveInteger'
        ULONG64 NodeCount;
        /// Required element 'resqml2:IntervalCount' of XSD type 'xsd:positiveInteger'
        ULONG64 IntervalCount;
        /// Required element 'resqml2:ClosedPolylines' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *ClosedPolylines;
        /// Required element 'resqml2:NodeCountPerPolyline' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *NodeCountPerPolyline;
        /// Optional element 'resqml2:IntervalGridCells' of XSD type 'resqml2:IntervalGridCells'
        resqml2__IntervalGridCells *IntervalGridCells;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlinePolylineSetPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlinePolylineSetPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__StreamlinePolylineSetPatch, default initialized and not managed by a soap context
        virtual resqml2__StreamlinePolylineSetPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__StreamlinePolylineSetPatch); }
      public:
        /// Constructor with initializations
        resqml2__StreamlinePolylineSetPatch()
        {
          NodeCount = (ULONG64)0;
          IntervalCount = (ULONG64)0;
          ClosedPolylines = (resqml2__AbstractBooleanArray *)0;
          NodeCountPerPolyline = (resqml2__AbstractIntegerArray *)0;
          IntervalGridCells = (resqml2__IntervalGridCells *)0;
        }
        virtual ~resqml2__StreamlinePolylineSetPatch() { }
        /// Friend allocator used by soap_new_resqml2__StreamlinePolylineSetPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__StreamlinePolylineSetPatch * SOAP_FMAC2 soap_instantiate_resqml2__StreamlinePolylineSetPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:955 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractCitedDataObject
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractCitedDataObject (270)
/* Type eml__AbstractCitedDataObject is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:AbstractCitedDataObject': */
class SOAP_CMAC eml__AbstractCitedDataObject {
      public:
        /// Required element 'eml:Citation' of XSD type 'eml:Citation'
        eml__Citation *Citation;
        /// Optional element 'eml:Aliases' of XSD type 'eml:ObjectAlias'
        std::vector<eml__ObjectAlias *> Aliases;
        /// Optional element 'eml:CustomData' of XSD type 'eml:CustomData'
        eml__CustomData *CustomData;
        /// required attribute 'schemaVersion' of XSD type 'xsd:string'
        std::string schemaVersion;
        /// required attribute 'uuid' of XSD type 'eml:UuidString'
        std::string uuid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractCitedDataObject
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractCitedDataObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AbstractCitedDataObject, default initialized and not managed by a soap context
        virtual eml__AbstractCitedDataObject *soap_alloc(void) const { return SOAP_NEW(eml__AbstractCitedDataObject); }
      public:
        /// Constructor with initializations
        eml__AbstractCitedDataObject()
        {
          Citation = (eml__Citation *)0;
          CustomData = (eml__CustomData *)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AbstractCitedDataObject() { }
        /// Friend allocator used by soap_new_eml__AbstractCitedDataObject(struct soap*, int)
        friend SOAP_FMAC1 eml__AbstractCitedDataObject * SOAP_FMAC2 soap_instantiate_eml__AbstractCitedDataObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:970 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrsEpsgCode
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrsEpsgCode (275)
/* Type eml__VerticalCrsEpsgCode is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:VerticalCrsEpsgCode': */
class SOAP_CMAC eml__VerticalCrsEpsgCode : public eml__AbstractVerticalCrs {
      public:
        /// Required element 'eml:EpsgCode' of XSD type 'xsd:positiveInteger'
        ULONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrsEpsgCode
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrsEpsgCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VerticalCrsEpsgCode, default initialized and not managed by a soap context
        virtual eml__VerticalCrsEpsgCode *soap_alloc(void) const { return SOAP_NEW(eml__VerticalCrsEpsgCode); }
      public:
        /// Constructor with initializations
        eml__VerticalCrsEpsgCode()
        {
          EpsgCode = (ULONG64)0;
        }
        virtual ~eml__VerticalCrsEpsgCode() { }
        /// Friend allocator used by soap_new_eml__VerticalCrsEpsgCode(struct soap*, int)
        friend SOAP_FMAC1 eml__VerticalCrsEpsgCode * SOAP_FMAC2 soap_instantiate_eml__VerticalCrsEpsgCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:973 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlVerticalCrsDefinition
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlVerticalCrsDefinition (276)
/* Type eml__GmlVerticalCrsDefinition is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:GmlVerticalCrsDefinition': */
class SOAP_CMAC eml__GmlVerticalCrsDefinition : public eml__AbstractVerticalCrs {
      public:
        /// Required element 'eml:GmlVerticalCrsDefinition' of XSD type 'gml:VerticalCRSType'
        gml__VerticalCRSType *GmlVerticalCrsDefinition;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlVerticalCrsDefinition
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlVerticalCrsDefinition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__GmlVerticalCrsDefinition, default initialized and not managed by a soap context
        virtual eml__GmlVerticalCrsDefinition *soap_alloc(void) const { return SOAP_NEW(eml__GmlVerticalCrsDefinition); }
      public:
        /// Constructor with initializations
        eml__GmlVerticalCrsDefinition()
        {
          GmlVerticalCrsDefinition = (gml__VerticalCRSType *)0;
        }
        virtual ~eml__GmlVerticalCrsDefinition() { }
        /// Friend allocator used by soap_new_eml__GmlVerticalCrsDefinition(struct soap*, int)
        friend SOAP_FMAC1 eml__GmlVerticalCrsDefinition * SOAP_FMAC2 soap_instantiate_eml__GmlVerticalCrsDefinition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:976 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalUnknownCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalUnknownCrs (277)
/* Type eml__VerticalUnknownCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:VerticalUnknownCrs': */
class SOAP_CMAC eml__VerticalUnknownCrs : public eml__AbstractVerticalCrs {
      public:
        /// Required element 'eml:Unknown' of XSD type 'eml:DescriptionString'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalUnknownCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VerticalUnknownCrs, default initialized and not managed by a soap context
        virtual eml__VerticalUnknownCrs *soap_alloc(void) const { return SOAP_NEW(eml__VerticalUnknownCrs); }
      public:
        /// Constructor with initializations
        eml__VerticalUnknownCrs()
        {
        }
        virtual ~eml__VerticalUnknownCrs() { }
        /// Friend allocator used by soap_new_eml__VerticalUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml__VerticalUnknownCrs * SOAP_FMAC2 soap_instantiate_eml__VerticalUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:991 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrsEpsgCode
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrsEpsgCode (282)
/* Type eml__ProjectedCrsEpsgCode is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:ProjectedCrsEpsgCode': */
class SOAP_CMAC eml__ProjectedCrsEpsgCode : public eml__AbstractProjectedCrs {
      public:
        /// Required element 'eml:EpsgCode' of XSD type 'xsd:positiveInteger'
        ULONG64 EpsgCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrsEpsgCode
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrsEpsgCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ProjectedCrsEpsgCode, default initialized and not managed by a soap context
        virtual eml__ProjectedCrsEpsgCode *soap_alloc(void) const { return SOAP_NEW(eml__ProjectedCrsEpsgCode); }
      public:
        /// Constructor with initializations
        eml__ProjectedCrsEpsgCode()
        {
          EpsgCode = (ULONG64)0;
        }
        virtual ~eml__ProjectedCrsEpsgCode() { }
        /// Friend allocator used by soap_new_eml__ProjectedCrsEpsgCode(struct soap*, int)
        friend SOAP_FMAC1 eml__ProjectedCrsEpsgCode * SOAP_FMAC2 soap_instantiate_eml__ProjectedCrsEpsgCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:994 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlProjectedCrsDefinition
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlProjectedCrsDefinition (283)
/* Type eml__GmlProjectedCrsDefinition is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:GmlProjectedCrsDefinition': */
class SOAP_CMAC eml__GmlProjectedCrsDefinition : public eml__AbstractProjectedCrs {
      public:
        /// Required element 'eml:GmlProjectedCrsDefinition' of XSD type 'gml:ProjectedCRSType'
        gml__ProjectedCRSType *GmlProjectedCrsDefinition;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlProjectedCrsDefinition
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlProjectedCrsDefinition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__GmlProjectedCrsDefinition, default initialized and not managed by a soap context
        virtual eml__GmlProjectedCrsDefinition *soap_alloc(void) const { return SOAP_NEW(eml__GmlProjectedCrsDefinition); }
      public:
        /// Constructor with initializations
        eml__GmlProjectedCrsDefinition()
        {
          GmlProjectedCrsDefinition = (gml__ProjectedCRSType *)0;
        }
        virtual ~eml__GmlProjectedCrsDefinition() { }
        /// Friend allocator used by soap_new_eml__GmlProjectedCrsDefinition(struct soap*, int)
        friend SOAP_FMAC1 eml__GmlProjectedCrsDefinition * SOAP_FMAC2 soap_instantiate_eml__GmlProjectedCrsDefinition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:997 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedUnknownCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedUnknownCrs (284)
/* Type eml__ProjectedUnknownCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:ProjectedUnknownCrs': */
class SOAP_CMAC eml__ProjectedUnknownCrs : public eml__AbstractProjectedCrs {
      public:
        /// Required element 'eml:Unknown' of XSD type 'eml:DescriptionString'
        std::string Unknown;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedUnknownCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedUnknownCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ProjectedUnknownCrs, default initialized and not managed by a soap context
        virtual eml__ProjectedUnknownCrs *soap_alloc(void) const { return SOAP_NEW(eml__ProjectedUnknownCrs); }
      public:
        /// Constructor with initializations
        eml__ProjectedUnknownCrs()
        {
        }
        virtual ~eml__ProjectedUnknownCrs() { }
        /// Friend allocator used by soap_new_eml__ProjectedUnknownCrs(struct soap*, int)
        friend SOAP_FMAC1 eml__ProjectedUnknownCrs * SOAP_FMAC2 soap_instantiate_eml__ProjectedUnknownCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1546 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionBaseType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionBaseType (467)
/* Type gml__DefinitionBaseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:DefinitionBaseType': */
class SOAP_CMAC gml__DefinitionBaseType {
      public:
        /// Optional element 'gml:description' of XSD type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XSD type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Required element 'gml:identifier' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XSD type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// required attribute 'gml:id' of XSD type 'xsd:ID'
        std::string gml__id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionBaseType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionBaseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DefinitionBaseType, default initialized and not managed by a soap context
        virtual gml__DefinitionBaseType *soap_alloc(void) const { return SOAP_NEW(gml__DefinitionBaseType); }
      public:
        /// Constructor with initializations
        gml__DefinitionBaseType()
        {
          description = (gml__StringOrRefType *)0;
          descriptionReference = (gml__ReferenceType *)0;
          identifier = (gml__CodeWithAuthorityType *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__DefinitionBaseType() { }
        /// Friend allocator used by soap_new_gml__DefinitionBaseType(struct soap*, int)
        friend SOAP_FMAC1 gml__DefinitionBaseType * SOAP_FMAC2 soap_instantiate_gml__DefinitionBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1552 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__StringOrRefType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__StringOrRefType (469)
/* simple XSD type 'gml:StringOrRefType': */
class SOAP_CMAC gml__StringOrRefType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// optional attribute 'nilReason' of XSD type 'gml:NilReasonType'
        std::string *nilReason;
        /// optional attribute 'xlink:type' of XSD type 'xsd:string'
        std::string *xlink__type;
        /// optional attribute 'xlink:href' of XSD type 'xsd:anyURI'
        std::string *xlink__href;
        /// optional attribute 'xlink:role' of XSD type 'xsd:anyURI'
        std::string *xlink__role;
        /// optional attribute 'xlink:arcrole' of XSD type 'xsd:anyURI'
        std::string *xlink__arcrole;
        /// optional attribute 'xlink:title' of XSD type 'xsd:string'
        std::string *xlink__title;
        /// optional attribute 'xlink:show' of XSD type 'xlink:show'
        enum _xlink__show *xlink__show;
        /// optional attribute 'xlink:actuate' of XSD type 'xlink:actuate'
        enum _xlink__actuate *xlink__actuate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__StringOrRefType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__StringOrRefType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__StringOrRefType, default initialized and not managed by a soap context
        virtual gml__StringOrRefType *soap_alloc(void) const { return SOAP_NEW(gml__StringOrRefType); }
      public:
        /// Constructor with initializations
        gml__StringOrRefType()
        {
          nilReason = (std::string *)0;
          xlink__type = (std::string *)0;
          xlink__href = (std::string *)0;
          xlink__role = (std::string *)0;
          xlink__arcrole = (std::string *)0;
          xlink__title = (std::string *)0;
          xlink__show = (enum _xlink__show *)0;
          xlink__actuate = (enum _xlink__actuate *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__StringOrRefType() { }
        /// Friend allocator used by soap_new_gml__StringOrRefType(struct soap*, int)
        friend SOAP_FMAC1 gml__StringOrRefType * SOAP_FMAC2 soap_instantiate_gml__StringOrRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1561 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeType (472)
/* simple XSD type 'gml:CodeType': */
class SOAP_CMAC gml__CodeType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// optional attribute 'codeSpace' of XSD type 'xsd:anyURI'
        std::string *codeSpace;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CodeType, default initialized and not managed by a soap context
        virtual gml__CodeType *soap_alloc(void) const { return SOAP_NEW(gml__CodeType); }
      public:
        /// Constructor with initializations
        gml__CodeType()
        {
          codeSpace = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__CodeType() { }
        /// Friend allocator used by soap_new_gml__CodeType(struct soap*, int)
        friend SOAP_FMAC1 gml__CodeType * SOAP_FMAC2 soap_instantiate_gml__CodeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1567 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimeObjectType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimeObjectType (474)
/* Type gml__AbstractTimeObjectType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractTimeObjectType': */
class SOAP_CMAC gml__AbstractTimeObjectType : public gml__AbstractGMLType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimeObjectType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimeObjectType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimeObjectType, default initialized and not managed by a soap context
        virtual gml__AbstractTimeObjectType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractTimeObjectType); }
      public:
        /// Constructor with initializations
        gml__AbstractTimeObjectType()
        {
        }
        virtual ~gml__AbstractTimeObjectType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimeObjectType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimeObjectType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimeObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1570 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__RelatedTimeType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__RelatedTimeType (475)
/* Type gml__RelatedTimeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:RelatedTimeType': */
class SOAP_CMAC gml__RelatedTimeType : public gml__TimePrimitivePropertyType {
      public:
        /// optional attribute 'relativePosition' of XSD type 'gml:RelatedTimeType-relativePosition'
        enum _gml__RelatedTimeType_relativePosition *relativePosition;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__RelatedTimeType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__RelatedTimeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__RelatedTimeType, default initialized and not managed by a soap context
        virtual gml__RelatedTimeType *soap_alloc(void) const { return SOAP_NEW(gml__RelatedTimeType); }
      public:
        /// Constructor with initializations
        gml__RelatedTimeType()
        {
          relativePosition = (enum _gml__RelatedTimeType_relativePosition *)0;
        }
        virtual ~gml__RelatedTimeType() { }
        /// Friend allocator used by soap_new_gml__RelatedTimeType(struct soap*, int)
        friend SOAP_FMAC1 gml__RelatedTimeType * SOAP_FMAC2 soap_instantiate_gml__RelatedTimeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1621 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__MeasureType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__MeasureType (492)
/* Type gml__MeasureType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'gml:MeasureType': */
class SOAP_CMAC gml__MeasureType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__MeasureType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__MeasureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__MeasureType, default initialized and not managed by a soap context
        virtual gml__MeasureType *soap_alloc(void) const { return SOAP_NEW(gml__MeasureType); }
      public:
        /// Constructor with initializations
        gml__MeasureType()
        {
          __item = (double)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__MeasureType() { }
        /// Friend allocator used by soap_new_gml__MeasureType(struct soap*, int)
        friend SOAP_FMAC1 gml__MeasureType * SOAP_FMAC2 soap_instantiate_gml__MeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1681 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREExtent_USCOREType (512)
/* Type gmd__EX_USCOREExtent_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:EX_Extent_Type': */
class SOAP_CMAC gmd__EX_USCOREExtent_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:description' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *description;
        /// Optional element 'gmd:geographicElement' of XSD type 'gmd:EX_GeographicExtent_PropertyType'
        std::vector<gmd__EX_USCOREGeographicExtent_USCOREPropertyType *> geographicElement;
        /// Optional element 'gmd:temporalElement' of XSD type 'gmd:EX_TemporalExtent_PropertyType'
        std::vector<gmd__EX_USCORETemporalExtent_USCOREPropertyType *> temporalElement;
        /// Optional element 'gmd:verticalElement' of XSD type 'gmd:EX_VerticalExtent_PropertyType'
        std::vector<gmd__EX_USCOREVerticalExtent_USCOREPropertyType *> verticalElement;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREExtent_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREExtent_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCOREExtent_USCOREType, default initialized and not managed by a soap context
        virtual gmd__EX_USCOREExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREExtent_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCOREExtent_USCOREType()
        {
          description = (gco__CharacterString_USCOREPropertyType *)0;
        }
        virtual ~gmd__EX_USCOREExtent_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCOREExtent_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCOREExtent_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCOREExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1687 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType (514)
/* Type gmd__AbstractEX_USCOREGeographicExtent_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:AbstractEX_GeographicExtent_Type': */
class SOAP_CMAC gmd__AbstractEX_USCOREGeographicExtent_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:extentTypeCode' of XSD type 'gco:Boolean_PropertyType'
        gco__Boolean_USCOREPropertyType *extentTypeCode;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractEX_USCOREGeographicExtent_USCOREType, default initialized and not managed by a soap context
        virtual gmd__AbstractEX_USCOREGeographicExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractEX_USCOREGeographicExtent_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__AbstractEX_USCOREGeographicExtent_USCOREType()
        {
          extentTypeCode = (gco__Boolean_USCOREPropertyType *)0;
        }
        virtual ~gmd__AbstractEX_USCOREGeographicExtent_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__AbstractEX_USCOREGeographicExtent_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractEX_USCOREGeographicExtent_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__AbstractEX_USCOREGeographicExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1693 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREType (516)
/* Type gmd__EX_USCORETemporalExtent_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:EX_TemporalExtent_Type': */
class SOAP_CMAC gmd__EX_USCORETemporalExtent_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:extent' of XSD type 'gts:TM_Primitive_PropertyType'
        gts__TM_USCOREPrimitive_USCOREPropertyType *extent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCORETemporalExtent_USCOREType, default initialized and not managed by a soap context
        virtual gmd__EX_USCORETemporalExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCORETemporalExtent_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCORETemporalExtent_USCOREType()
        {
          extent = (gts__TM_USCOREPrimitive_USCOREPropertyType *)0;
        }
        virtual ~gmd__EX_USCORETemporalExtent_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCORETemporalExtent_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCORETemporalExtent_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCORETemporalExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1699 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREType (518)
/* Type gmd__EX_USCOREVerticalExtent_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:EX_VerticalExtent_Type': */
class SOAP_CMAC gmd__EX_USCOREVerticalExtent_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:minimumValue' of XSD type 'gco:Real_PropertyType'
        gco__Real_USCOREPropertyType *minimumValue;
        /// Required element 'gmd:maximumValue' of XSD type 'gco:Real_PropertyType'
        gco__Real_USCOREPropertyType *maximumValue;
        /// Required element 'gmd:verticalCRS' of XSD type 'gsr:SC_CRS_PropertyType'
        gsr__SC_USCORECRS_USCOREPropertyType *verticalCRS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__EX_USCOREVerticalExtent_USCOREType, default initialized and not managed by a soap context
        virtual gmd__EX_USCOREVerticalExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREVerticalExtent_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__EX_USCOREVerticalExtent_USCOREType()
        {
          minimumValue = (gco__Real_USCOREPropertyType *)0;
          maximumValue = (gco__Real_USCOREPropertyType *)0;
          verticalCRS = (gsr__SC_USCORECRS_USCOREPropertyType *)0;
        }
        virtual ~gmd__EX_USCOREVerticalExtent_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__EX_USCOREVerticalExtent_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__EX_USCOREVerticalExtent_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__EX_USCOREVerticalExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1705 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREElement_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREElement_USCOREType (520)
/* Type gmd__AbstractDQ_USCOREElement_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:AbstractDQ_Element_Type': */
class SOAP_CMAC gmd__AbstractDQ_USCOREElement_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:nameOfMeasure' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> nameOfMeasure;
        /// Optional element 'gmd:measureIdentification' of XSD type 'gmd:MD_Identifier_PropertyType'
        gmd__MD_USCOREIdentifier_USCOREPropertyType *measureIdentification;
        /// Optional element 'gmd:measureDescription' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *measureDescription;
        /// Optional element 'gmd:evaluationMethodType' of XSD type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType'
        gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *evaluationMethodType;
        /// Optional element 'gmd:evaluationMethodDescription' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *evaluationMethodDescription;
        /// Optional element 'gmd:evaluationProcedure' of XSD type 'gmd:CI_Citation_PropertyType'
        gmd__CI_USCORECitation_USCOREPropertyType *evaluationProcedure;
        /// Optional element 'gmd:dateTime' of XSD type 'gco:DateTime_PropertyType'
        std::vector<gco__DateTime_USCOREPropertyType *> dateTime;
        /// Sequence of 1 to 2 elements 'gmd:result' of XSD type 'gmd:DQ_Result_PropertyType'
        std::vector<gmd__DQ_USCOREResult_USCOREPropertyType *> result;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREElement_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREElement_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_USCOREElement_USCOREType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_USCOREElement_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREElement_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__AbstractDQ_USCOREElement_USCOREType()
        {
          measureIdentification = (gmd__MD_USCOREIdentifier_USCOREPropertyType *)0;
          measureDescription = (gco__CharacterString_USCOREPropertyType *)0;
          evaluationMethodType = (gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *)0;
          evaluationMethodDescription = (gco__CharacterString_USCOREPropertyType *)0;
          evaluationProcedure = (gmd__CI_USCORECitation_USCOREPropertyType *)0;
        }
        virtual ~gmd__AbstractDQ_USCOREElement_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_USCOREElement_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_USCOREElement_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_USCOREElement_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1711 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREType (522)
/* Type gmd__MD_USCOREIdentifier_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:MD_Identifier_Type': */
class SOAP_CMAC gmd__MD_USCOREIdentifier_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:authority' of XSD type 'gmd:CI_Citation_PropertyType'
        gmd__CI_USCORECitation_USCOREPropertyType *authority;
        /// Required element 'gmd:code' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *code;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__MD_USCOREIdentifier_USCOREType, default initialized and not managed by a soap context
        virtual gmd__MD_USCOREIdentifier_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__MD_USCOREIdentifier_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__MD_USCOREIdentifier_USCOREType()
        {
          authority = (gmd__CI_USCORECitation_USCOREPropertyType *)0;
          code = (gco__CharacterString_USCOREPropertyType *)0;
        }
        virtual ~gmd__MD_USCOREIdentifier_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__MD_USCOREIdentifier_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__MD_USCOREIdentifier_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__MD_USCOREIdentifier_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1717 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREType (524)
/* Type gmd__CI_USCORECitation_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Citation_Type': */
class SOAP_CMAC gmd__CI_USCORECitation_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:title' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *title;
        /// Optional element 'gmd:alternateTitle' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> alternateTitle;
        /// Required element 'gmd:date' of XSD type 'gmd:CI_Date_PropertyType'
        std::vector<gmd__CI_USCOREDate_USCOREPropertyType *> date;
        /// Optional element 'gmd:edition' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *edition;
        /// Optional element 'gmd:editionDate' of XSD type 'gco:Date_PropertyType'
        gco__Date_USCOREPropertyType *editionDate;
        /// Optional element 'gmd:identifier' of XSD type 'gmd:MD_Identifier_PropertyType'
        std::vector<gmd__MD_USCOREIdentifier_USCOREPropertyType *> identifier;
        /// Optional element 'gmd:citedResponsibleParty' of XSD type 'gmd:CI_ResponsibleParty_PropertyType'
        std::vector<gmd__CI_USCOREResponsibleParty_USCOREPropertyType *> citedResponsibleParty;
        /// Optional element 'gmd:presentationForm' of XSD type 'gmd:CI_PresentationFormCode_PropertyType'
        std::vector<gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *> presentationForm;
        /// Optional element 'gmd:series' of XSD type 'gmd:CI_Series_PropertyType'
        gmd__CI_USCORESeries_USCOREPropertyType *series;
        /// Optional element 'gmd:otherCitationDetails' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *otherCitationDetails;
        /// Optional element 'gmd:collectiveTitle' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *collectiveTitle;
        /// Optional element 'gmd:ISBN' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *ISBN;
        /// Optional element 'gmd:ISSN' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *ISSN;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORECitation_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORECitation_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORECitation_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORECitation_USCOREType()
        {
          title = (gco__CharacterString_USCOREPropertyType *)0;
          edition = (gco__CharacterString_USCOREPropertyType *)0;
          editionDate = (gco__Date_USCOREPropertyType *)0;
          series = (gmd__CI_USCORESeries_USCOREPropertyType *)0;
          otherCitationDetails = (gco__CharacterString_USCOREPropertyType *)0;
          collectiveTitle = (gco__CharacterString_USCOREPropertyType *)0;
          ISBN = (gco__CharacterString_USCOREPropertyType *)0;
          ISSN = (gco__CharacterString_USCOREPropertyType *)0;
        }
        virtual ~gmd__CI_USCORECitation_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORECitation_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORECitation_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORECitation_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1723 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREType (526)
/* Type gmd__CI_USCOREDate_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Date_Type': */
class SOAP_CMAC gmd__CI_USCOREDate_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:date' of XSD type 'gco:Date_PropertyType'
        gco__Date_USCOREPropertyType *date;
        /// Required element 'gmd:dateType' of XSD type 'gmd:CI_DateTypeCode_PropertyType'
        gmd__CI_USCOREDateTypeCode_USCOREPropertyType *dateType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREDate_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREDate_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDate_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREDate_USCOREType()
        {
          date = (gco__Date_USCOREPropertyType *)0;
          dateType = (gmd__CI_USCOREDateTypeCode_USCOREPropertyType *)0;
        }
        virtual ~gmd__CI_USCOREDate_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREDate_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREDate_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREDate_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1732 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREType (529)
/* Type gmd__CI_USCOREResponsibleParty_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_ResponsibleParty_Type': */
class SOAP_CMAC gmd__CI_USCOREResponsibleParty_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:individualName' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *individualName;
        /// Optional element 'gmd:organisationName' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *organisationName;
        /// Optional element 'gmd:positionName' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *positionName;
        /// Optional element 'gmd:contactInfo' of XSD type 'gmd:CI_Contact_PropertyType'
        gmd__CI_USCOREContact_USCOREPropertyType *contactInfo;
        /// Required element 'gmd:role' of XSD type 'gmd:CI_RoleCode_PropertyType'
        gmd__CI_USCORERoleCode_USCOREPropertyType *role;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREResponsibleParty_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREResponsibleParty_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREResponsibleParty_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREResponsibleParty_USCOREType()
        {
          individualName = (gco__CharacterString_USCOREPropertyType *)0;
          organisationName = (gco__CharacterString_USCOREPropertyType *)0;
          positionName = (gco__CharacterString_USCOREPropertyType *)0;
          contactInfo = (gmd__CI_USCOREContact_USCOREPropertyType *)0;
          role = (gmd__CI_USCORERoleCode_USCOREPropertyType *)0;
        }
        virtual ~gmd__CI_USCOREResponsibleParty_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREResponsibleParty_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREResponsibleParty_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREResponsibleParty_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1738 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREType (531)
/* Type gmd__CI_USCOREContact_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Contact_Type': */
class SOAP_CMAC gmd__CI_USCOREContact_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:phone' of XSD type 'gmd:CI_Telephone_PropertyType'
        gmd__CI_USCORETelephone_USCOREPropertyType *phone;
        /// Optional element 'gmd:address' of XSD type 'gmd:CI_Address_PropertyType'
        gmd__CI_USCOREAddress_USCOREPropertyType *address;
        /// Optional element 'gmd:onlineResource' of XSD type 'gmd:CI_OnlineResource_PropertyType'
        gmd__CI_USCOREOnlineResource_USCOREPropertyType *onlineResource;
        /// Optional element 'gmd:hoursOfService' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *hoursOfService;
        /// Optional element 'gmd:contactInstructions' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *contactInstructions;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREContact_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREContact_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREContact_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREContact_USCOREType()
        {
          phone = (gmd__CI_USCORETelephone_USCOREPropertyType *)0;
          address = (gmd__CI_USCOREAddress_USCOREPropertyType *)0;
          onlineResource = (gmd__CI_USCOREOnlineResource_USCOREPropertyType *)0;
          hoursOfService = (gco__CharacterString_USCOREPropertyType *)0;
          contactInstructions = (gco__CharacterString_USCOREPropertyType *)0;
        }
        virtual ~gmd__CI_USCOREContact_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREContact_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREContact_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREContact_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1744 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREType (533)
/* Type gmd__CI_USCORETelephone_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Telephone_Type': */
class SOAP_CMAC gmd__CI_USCORETelephone_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:voice' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> voice;
        /// Optional element 'gmd:facsimile' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> facsimile;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORETelephone_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORETelephone_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORETelephone_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORETelephone_USCOREType()
        {
        }
        virtual ~gmd__CI_USCORETelephone_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORETelephone_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORETelephone_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORETelephone_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1750 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREType (535)
/* Type gmd__CI_USCOREAddress_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Address_Type': */
class SOAP_CMAC gmd__CI_USCOREAddress_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:deliveryPoint' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> deliveryPoint;
        /// Optional element 'gmd:city' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *city;
        /// Optional element 'gmd:administrativeArea' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *administrativeArea;
        /// Optional element 'gmd:postalCode' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *postalCode;
        /// Optional element 'gmd:country' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *country;
        /// Optional element 'gmd:electronicMailAddress' of XSD type 'gco:CharacterString_PropertyType'
        std::vector<gco__CharacterString_USCOREPropertyType *> electronicMailAddress;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREAddress_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREAddress_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREAddress_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREAddress_USCOREType()
        {
          city = (gco__CharacterString_USCOREPropertyType *)0;
          administrativeArea = (gco__CharacterString_USCOREPropertyType *)0;
          postalCode = (gco__CharacterString_USCOREPropertyType *)0;
          country = (gco__CharacterString_USCOREPropertyType *)0;
        }
        virtual ~gmd__CI_USCOREAddress_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREAddress_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREAddress_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREAddress_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1756 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREType (537)
/* Type gmd__CI_USCOREOnlineResource_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_OnlineResource_Type': */
class SOAP_CMAC gmd__CI_USCOREOnlineResource_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Required element 'gmd:linkage' of XSD type 'gmd:URL_PropertyType'
        gmd__URL_USCOREPropertyType *linkage;
        /// Optional element 'gmd:protocol' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *protocol;
        /// Optional element 'gmd:applicationProfile' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *applicationProfile;
        /// Optional element 'gmd:name' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *name;
        /// Optional element 'gmd:description' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *description;
        /// Optional element 'gmd:function' of XSD type 'gmd:CI_OnLineFunctionCode_PropertyType'
        gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *function;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCOREOnlineResource_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCOREOnlineResource_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnlineResource_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCOREOnlineResource_USCOREType()
        {
          linkage = (gmd__URL_USCOREPropertyType *)0;
          protocol = (gco__CharacterString_USCOREPropertyType *)0;
          applicationProfile = (gco__CharacterString_USCOREPropertyType *)0;
          name = (gco__CharacterString_USCOREPropertyType *)0;
          description = (gco__CharacterString_USCOREPropertyType *)0;
          function = (gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *)0;
        }
        virtual ~gmd__CI_USCOREOnlineResource_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCOREOnlineResource_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCOREOnlineResource_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCOREOnlineResource_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1774 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREType (543)
/* Type gmd__CI_USCORESeries_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:CI_Series_Type': */
class SOAP_CMAC gmd__CI_USCORESeries_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Optional element 'gmd:name' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *name;
        /// Optional element 'gmd:issueIdentification' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *issueIdentification;
        /// Optional element 'gmd:page' of XSD type 'gco:CharacterString_PropertyType'
        gco__CharacterString_USCOREPropertyType *page;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__CI_USCORESeries_USCOREType, default initialized and not managed by a soap context
        virtual gmd__CI_USCORESeries_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORESeries_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__CI_USCORESeries_USCOREType()
        {
          name = (gco__CharacterString_USCOREPropertyType *)0;
          issueIdentification = (gco__CharacterString_USCOREPropertyType *)0;
          page = (gco__CharacterString_USCOREPropertyType *)0;
        }
        virtual ~gmd__CI_USCORESeries_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__CI_USCORESeries_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__CI_USCORESeries_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__CI_USCORESeries_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1783 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREResult_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREResult_USCOREType (546)
/* Type gmd__AbstractDQ_USCOREResult_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:AbstractDQ_Result_Type': */
class SOAP_CMAC gmd__AbstractDQ_USCOREResult_USCOREType : public gco__AbstractObject_USCOREType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREResult_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREResult_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_USCOREResult_USCOREType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_USCOREResult_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREResult_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__AbstractDQ_USCOREResult_USCOREType()
        {
        }
        virtual ~gmd__AbstractDQ_USCOREResult_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_USCOREResult_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_USCOREResult_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_USCOREResult_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1804 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__CodeListValue_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__CodeListValue_USCOREType (553)
/* simple XSD type 'gco:CodeListValue_Type': */
class SOAP_CMAC gco__CodeListValue_USCOREType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// required attribute 'codeList' of XSD type 'xsd:anyURI'
        std::string codeList;
        /// required attribute 'codeListValue' of XSD type 'xsd:anyURI'
        std::string codeListValue;
        /// optional attribute 'codeSpace' of XSD type 'xsd:anyURI'
        std::string *codeSpace;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gco__CodeListValue_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gco__CodeListValue_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gco__CodeListValue_USCOREType, default initialized and not managed by a soap context
        virtual gco__CodeListValue_USCOREType *soap_alloc(void) const { return SOAP_NEW(gco__CodeListValue_USCOREType); }
      public:
        /// Constructor with initializations
        gco__CodeListValue_USCOREType()
        {
          codeSpace = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gco__CodeListValue_USCOREType() { }
        /// Friend allocator used by soap_new_gco__CodeListValue_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gco__CodeListValue_USCOREType * SOAP_FMAC2 soap_instantiate_gco__CodeListValue_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:211 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerArrayFromBooleanMaskArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerArrayFromBooleanMaskArray (22)
/* Type resqml2__IntegerArrayFromBooleanMaskArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:IntegerArrayFromBooleanMaskArray': */
class SOAP_CMAC resqml2__IntegerArrayFromBooleanMaskArray : public resqml2__AbstractIntegerArray {
      public:
        /// Required element 'resqml2:TotalIndexCount' of XSD type 'xsd:positiveInteger'
        ULONG64 TotalIndexCount;
        /// Required element 'resqml2:Mask' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *Mask;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerArrayFromBooleanMaskArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerArrayFromBooleanMaskArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IntegerArrayFromBooleanMaskArray, default initialized and not managed by a soap context
        virtual resqml2__IntegerArrayFromBooleanMaskArray *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerArrayFromBooleanMaskArray); }
      public:
        /// Constructor with initializations
        resqml2__IntegerArrayFromBooleanMaskArray()
        {
          TotalIndexCount = (ULONG64)0;
          Mask = (resqml2__AbstractBooleanArray *)0;
        }
        virtual ~resqml2__IntegerArrayFromBooleanMaskArray() { }
        /// Friend allocator used by soap_new_resqml2__IntegerArrayFromBooleanMaskArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IntegerArrayFromBooleanMaskArray * SOAP_FMAC2 soap_instantiate_resqml2__IntegerArrayFromBooleanMaskArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:214 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromIndexArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromIndexArray (23)
/* Type resqml2__BooleanArrayFromIndexArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:BooleanArrayFromIndexArray': */
class SOAP_CMAC resqml2__BooleanArrayFromIndexArray : public resqml2__AbstractBooleanArray {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:Indices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *Indices;
        /// Required element 'resqml2:IndexIsTrue' of XSD type 'xsd:boolean'
        bool IndexIsTrue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromIndexArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromIndexArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__BooleanArrayFromIndexArray, default initialized and not managed by a soap context
        virtual resqml2__BooleanArrayFromIndexArray *soap_alloc(void) const { return SOAP_NEW(resqml2__BooleanArrayFromIndexArray); }
      public:
        /// Constructor with initializations
        resqml2__BooleanArrayFromIndexArray()
        {
          Count = (ULONG64)0;
          Indices = (resqml2__AbstractIntegerArray *)0;
          IndexIsTrue = (bool)0;
        }
        virtual ~resqml2__BooleanArrayFromIndexArray() { }
        /// Friend allocator used by soap_new_resqml2__BooleanArrayFromIndexArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__BooleanArrayFromIndexArray * SOAP_FMAC2 soap_instantiate_resqml2__BooleanArrayFromIndexArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:217 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanConstantArray (24)
/* Type resqml2__BooleanConstantArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:BooleanConstantArray': */
class SOAP_CMAC resqml2__BooleanConstantArray : public resqml2__AbstractBooleanArray {
      public:
        /// Required element 'resqml2:Value' of XSD type 'xsd:boolean'
        bool Value;
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanConstantArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__BooleanConstantArray, default initialized and not managed by a soap context
        virtual resqml2__BooleanConstantArray *soap_alloc(void) const { return SOAP_NEW(resqml2__BooleanConstantArray); }
      public:
        /// Constructor with initializations
        resqml2__BooleanConstantArray()
        {
          Value = (bool)0;
          Count = (ULONG64)0;
        }
        virtual ~resqml2__BooleanConstantArray() { }
        /// Friend allocator used by soap_new_resqml2__BooleanConstantArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__BooleanConstantArray * SOAP_FMAC2 soap_instantiate_resqml2__BooleanConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:220 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerConstantArray (25)
/* Type resqml2__IntegerConstantArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:IntegerConstantArray': */
class SOAP_CMAC resqml2__IntegerConstantArray : public resqml2__AbstractIntegerArray {
      public:
        /// Required element 'resqml2:Value' of XSD type 'xsd:integer'
        LONG64 Value;
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerConstantArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IntegerConstantArray, default initialized and not managed by a soap context
        virtual resqml2__IntegerConstantArray *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerConstantArray); }
      public:
        /// Constructor with initializations
        resqml2__IntegerConstantArray()
        {
          Value = (LONG64)0;
          Count = (ULONG64)0;
        }
        virtual ~resqml2__IntegerConstantArray() { }
        /// Friend allocator used by soap_new_resqml2__IntegerConstantArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IntegerConstantArray * SOAP_FMAC2 soap_instantiate_resqml2__IntegerConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:229 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerHdf5Array (28)
/* Type resqml2__IntegerHdf5Array is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:IntegerHdf5Array': */
class SOAP_CMAC resqml2__IntegerHdf5Array : public resqml2__AbstractIntegerArray {
      public:
        /// Required element 'resqml2:NullValue' of XSD type 'xsd:integer'
        LONG64 NullValue;
        /// Required element 'resqml2:Values' of XSD type 'eml:Hdf5Dataset'
        eml__Hdf5Dataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerHdf5Array
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerHdf5Array; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IntegerHdf5Array, default initialized and not managed by a soap context
        virtual resqml2__IntegerHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerHdf5Array); }
      public:
        /// Constructor with initializations
        resqml2__IntegerHdf5Array()
        {
          NullValue = (LONG64)0;
          Values = (eml__Hdf5Dataset *)0;
        }
        virtual ~resqml2__IntegerHdf5Array() { }
        /// Friend allocator used by soap_new_resqml2__IntegerHdf5Array(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IntegerHdf5Array * SOAP_FMAC2 soap_instantiate_resqml2__IntegerHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:241 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLatticeArray (32)
/* Type resqml2__DoubleLatticeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:DoubleLatticeArray': */
class SOAP_CMAC resqml2__DoubleLatticeArray : public resqml2__AbstractDoubleArray {
      public:
        /// Required element 'resqml2:StartValue' of XSD type 'xsd:double'
        double StartValue;
        /// Required element 'resqml2:Offset' of XSD type 'resqml2:DoubleConstantArray'
        std::vector<resqml2__DoubleConstantArray *> Offset;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLatticeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__DoubleLatticeArray, default initialized and not managed by a soap context
        virtual resqml2__DoubleLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__DoubleLatticeArray); }
      public:
        /// Constructor with initializations
        resqml2__DoubleLatticeArray()
        {
          StartValue = (double)0;
        }
        virtual ~resqml2__DoubleLatticeArray() { }
        /// Friend allocator used by soap_new_resqml2__DoubleLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__DoubleLatticeArray * SOAP_FMAC2 soap_instantiate_resqml2__DoubleLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:244 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleConstantArray (33)
/* Type resqml2__DoubleConstantArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:DoubleConstantArray': */
class SOAP_CMAC resqml2__DoubleConstantArray : public resqml2__AbstractDoubleArray {
      public:
        /// Required element 'resqml2:Value' of XSD type 'xsd:double'
        double Value;
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleConstantArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleConstantArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__DoubleConstantArray, default initialized and not managed by a soap context
        virtual resqml2__DoubleConstantArray *soap_alloc(void) const { return SOAP_NEW(resqml2__DoubleConstantArray); }
      public:
        /// Constructor with initializations
        resqml2__DoubleConstantArray()
        {
          Value = (double)0;
          Count = (ULONG64)0;
        }
        virtual ~resqml2__DoubleConstantArray() { }
        /// Friend allocator used by soap_new_resqml2__DoubleConstantArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__DoubleConstantArray * SOAP_FMAC2 soap_instantiate_resqml2__DoubleConstantArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:247 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleHdf5Array (34)
/* Type resqml2__DoubleHdf5Array is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:DoubleHdf5Array': */
class SOAP_CMAC resqml2__DoubleHdf5Array : public resqml2__AbstractDoubleArray {
      public:
        /// Required element 'resqml2:Values' of XSD type 'eml:Hdf5Dataset'
        eml__Hdf5Dataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleHdf5Array
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleHdf5Array; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__DoubleHdf5Array, default initialized and not managed by a soap context
        virtual resqml2__DoubleHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__DoubleHdf5Array); }
      public:
        /// Constructor with initializations
        resqml2__DoubleHdf5Array()
        {
          Values = (eml__Hdf5Dataset *)0;
        }
        virtual ~resqml2__DoubleHdf5Array() { }
        /// Friend allocator used by soap_new_resqml2__DoubleHdf5Array(struct soap*, int)
        friend SOAP_FMAC1 resqml2__DoubleHdf5Array * SOAP_FMAC2 soap_instantiate_resqml2__DoubleHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:265 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerLatticeArray (40)
/* Type resqml2__IntegerLatticeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:IntegerLatticeArray': */
class SOAP_CMAC resqml2__IntegerLatticeArray : public resqml2__AbstractIntegerArray {
      public:
        /// Required element 'resqml2:StartValue' of XSD type 'xsd:integer'
        LONG64 StartValue;
        /// Required element 'resqml2:Offset' of XSD type 'resqml2:IntegerConstantArray'
        std::vector<resqml2__IntegerConstantArray *> Offset;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerLatticeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerLatticeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IntegerLatticeArray, default initialized and not managed by a soap context
        virtual resqml2__IntegerLatticeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerLatticeArray); }
      public:
        /// Constructor with initializations
        resqml2__IntegerLatticeArray()
        {
          StartValue = (LONG64)0;
        }
        virtual ~resqml2__IntegerLatticeArray() { }
        /// Friend allocator used by soap_new_resqml2__IntegerLatticeArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IntegerLatticeArray * SOAP_FMAC2 soap_instantiate_resqml2__IntegerLatticeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:277 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanHdf5Array (44)
/* Type resqml2__BooleanHdf5Array is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:BooleanHdf5Array': */
class SOAP_CMAC resqml2__BooleanHdf5Array : public resqml2__AbstractBooleanArray {
      public:
        /// Required element 'resqml2:Values' of XSD type 'eml:Hdf5Dataset'
        eml__Hdf5Dataset *Values;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanHdf5Array
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanHdf5Array; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__BooleanHdf5Array, default initialized and not managed by a soap context
        virtual resqml2__BooleanHdf5Array *soap_alloc(void) const { return SOAP_NEW(resqml2__BooleanHdf5Array); }
      public:
        /// Constructor with initializations
        resqml2__BooleanHdf5Array()
        {
          Values = (eml__Hdf5Dataset *)0;
        }
        virtual ~resqml2__BooleanHdf5Array() { }
        /// Friend allocator used by soap_new_resqml2__BooleanHdf5Array(struct soap*, int)
        friend SOAP_FMAC1 resqml2__BooleanHdf5Array * SOAP_FMAC2 soap_instantiate_resqml2__BooleanHdf5Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:292 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerRangeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerRangeArray (49)
/* Type resqml2__IntegerRangeArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:IntegerRangeArray': */
class SOAP_CMAC resqml2__IntegerRangeArray : public resqml2__AbstractIntegerArray {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:Value' of XSD type 'xsd:integer'
        LONG64 Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerRangeArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerRangeArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IntegerRangeArray, default initialized and not managed by a soap context
        virtual resqml2__IntegerRangeArray *soap_alloc(void) const { return SOAP_NEW(resqml2__IntegerRangeArray); }
      public:
        /// Constructor with initializations
        resqml2__IntegerRangeArray()
        {
          Count = (ULONG64)0;
          Value = (LONG64)0;
        }
        virtual ~resqml2__IntegerRangeArray() { }
        /// Friend allocator used by soap_new_resqml2__IntegerRangeArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IntegerRangeArray * SOAP_FMAC2 soap_instantiate_resqml2__IntegerRangeArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:322 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromDiscretePropertyArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromDiscretePropertyArray (59)
/* Type resqml2__BooleanArrayFromDiscretePropertyArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:BooleanArrayFromDiscretePropertyArray': */
class SOAP_CMAC resqml2__BooleanArrayFromDiscretePropertyArray : public resqml2__AbstractBooleanArray {
      public:
        /// Required element 'resqml2:Value' of XSD type 'xsd:integer'
        LONG64 Value;
        /// Required element 'resqml2:Property' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Property;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromDiscretePropertyArray
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromDiscretePropertyArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__BooleanArrayFromDiscretePropertyArray, default initialized and not managed by a soap context
        virtual resqml2__BooleanArrayFromDiscretePropertyArray *soap_alloc(void) const { return SOAP_NEW(resqml2__BooleanArrayFromDiscretePropertyArray); }
      public:
        /// Constructor with initializations
        resqml2__BooleanArrayFromDiscretePropertyArray()
        {
          Value = (LONG64)0;
          Property = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__BooleanArrayFromDiscretePropertyArray() { }
        /// Friend allocator used by soap_new_resqml2__BooleanArrayFromDiscretePropertyArray(struct soap*, int)
        friend SOAP_FMAC1 resqml2__BooleanArrayFromDiscretePropertyArray * SOAP_FMAC2 soap_instantiate_resqml2__BooleanArrayFromDiscretePropertyArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:331 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineGeometry (62)
/* Type resqml2__ParametricLineGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ParametricLineGeometry': */
class SOAP_CMAC resqml2__ParametricLineGeometry : public resqml2__AbstractParametricLineGeometry {
      public:
        /// Optional element 'resqml2:ControlPointParameters' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *ControlPointParameters;
        /// Required element 'resqml2:ControlPoints' of XSD type 'resqml2:AbstractPoint3dArray'
        resqml2__AbstractPoint3dArray *ControlPoints;
        /// Required element 'resqml2:KnotCount' of XSD type 'xsd:positiveInteger'
        ULONG64 KnotCount;
        /// Required element 'resqml2:LineKindIndex' of XSD type 'xsd:integer'
        LONG64 LineKindIndex;
        /// Optional element 'resqml2:TangentVectors' of XSD type 'resqml2:AbstractPoint3dArray'
        resqml2__AbstractPoint3dArray *TangentVectors;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ParametricLineGeometry, default initialized and not managed by a soap context
        virtual resqml2__ParametricLineGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineGeometry); }
      public:
        /// Constructor with initializations
        resqml2__ParametricLineGeometry()
        {
          ControlPointParameters = (resqml2__AbstractDoubleArray *)0;
          ControlPoints = (resqml2__AbstractPoint3dArray *)0;
          KnotCount = (ULONG64)0;
          LineKindIndex = (LONG64)0;
          TangentVectors = (resqml2__AbstractPoint3dArray *)0;
        }
        virtual ~resqml2__ParametricLineGeometry() { }
        /// Friend allocator used by soap_new_resqml2__ParametricLineGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ParametricLineGeometry * SOAP_FMAC2 soap_instantiate_resqml2__ParametricLineGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:343 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizontalPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizontalPlaneGeometry (66)
/* Type resqml2__HorizontalPlaneGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:HorizontalPlaneGeometry': */
class SOAP_CMAC resqml2__HorizontalPlaneGeometry : public resqml2__AbstractPlaneGeometry {
      public:
        /// Required element 'resqml2:Coordinate' of XSD type 'xsd:double'
        double Coordinate;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizontalPlaneGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizontalPlaneGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__HorizontalPlaneGeometry, default initialized and not managed by a soap context
        virtual resqml2__HorizontalPlaneGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__HorizontalPlaneGeometry); }
      public:
        /// Constructor with initializations
        resqml2__HorizontalPlaneGeometry()
        {
          Coordinate = (double)0;
        }
        virtual ~resqml2__HorizontalPlaneGeometry() { }
        /// Friend allocator used by soap_new_resqml2__HorizontalPlaneGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__HorizontalPlaneGeometry * SOAP_FMAC2 soap_instantiate_resqml2__HorizontalPlaneGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:361 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationGeometry (72)
/* Type resqml2__ParametricLineFromRepresentationGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ParametricLineFromRepresentationGeometry': */
class SOAP_CMAC resqml2__ParametricLineFromRepresentationGeometry : public resqml2__AbstractParametricLineGeometry {
      public:
        /// Required element 'resqml2:LineIndiexOnSupportingRepresentation' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 LineIndiexOnSupportingRepresentation;
        /// Required element 'resqml2:SupportingRepresentation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *SupportingRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ParametricLineFromRepresentationGeometry, default initialized and not managed by a soap context
        virtual resqml2__ParametricLineFromRepresentationGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__ParametricLineFromRepresentationGeometry); }
      public:
        /// Constructor with initializations
        resqml2__ParametricLineFromRepresentationGeometry()
        {
          LineIndiexOnSupportingRepresentation = (ULONG64)0;
          SupportingRepresentation = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__ParametricLineFromRepresentationGeometry() { }
        /// Friend allocator used by soap_new_resqml2__ParametricLineFromRepresentationGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ParametricLineFromRepresentationGeometry * SOAP_FMAC2 soap_instantiate_resqml2__ParametricLineFromRepresentationGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:376 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TiltedPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TiltedPlaneGeometry (77)
/* Type resqml2__TiltedPlaneGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:TiltedPlaneGeometry': */
class SOAP_CMAC resqml2__TiltedPlaneGeometry : public resqml2__AbstractPlaneGeometry {
      public:
        /// Required element 'resqml2:Plane' of XSD type 'resqml2:ThreePoint3d'
        std::vector<resqml2__ThreePoint3d *> Plane;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TiltedPlaneGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TiltedPlaneGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__TiltedPlaneGeometry, default initialized and not managed by a soap context
        virtual resqml2__TiltedPlaneGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__TiltedPlaneGeometry); }
      public:
        /// Constructor with initializations
        resqml2__TiltedPlaneGeometry()
        {
        }
        virtual ~resqml2__TiltedPlaneGeometry() { }
        /// Friend allocator used by soap_new_resqml2__TiltedPlaneGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__TiltedPlaneGeometry * SOAP_FMAC2 soap_instantiate_resqml2__TiltedPlaneGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:406 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubRepresentationPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubRepresentationPatch (87)
/* Type resqml2__SubRepresentationPatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:SubRepresentationPatch': */
class SOAP_CMAC resqml2__SubRepresentationPatch : public resqml2__Patch1d {
      public:
        /// Sequence of 1 to 2 elements 'resqml2:ElementIndices' of XSD type 'resqml2:ElementIndices'
        std::vector<resqml2__ElementIndices *> ElementIndices;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubRepresentationPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubRepresentationPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__SubRepresentationPatch, default initialized and not managed by a soap context
        virtual resqml2__SubRepresentationPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__SubRepresentationPatch); }
      public:
        /// Constructor with initializations
        resqml2__SubRepresentationPatch()
        {
        }
        virtual ~resqml2__SubRepresentationPatch() { }
        /// Friend allocator used by soap_new_resqml2__SubRepresentationPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__SubRepresentationPatch * SOAP_FMAC2 soap_instantiate_resqml2__SubRepresentationPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:448 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnSubnodePatch (101)
/* Type resqml2__ColumnSubnodePatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ColumnSubnodePatch': */
class SOAP_CMAC resqml2__ColumnSubnodePatch : public resqml2__SubnodePatch {
      public:
        /// Required element 'resqml2:SubnodeCountPerObject' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *SubnodeCountPerObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnSubnodePatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnSubnodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ColumnSubnodePatch, default initialized and not managed by a soap context
        virtual resqml2__ColumnSubnodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__ColumnSubnodePatch); }
      public:
        /// Constructor with initializations
        resqml2__ColumnSubnodePatch()
        {
          SubnodeCountPerObject = (resqml2__AbstractIntegerArray *)0;
        }
        virtual ~resqml2__ColumnSubnodePatch() { }
        /// Friend allocator used by soap_new_resqml2__ColumnSubnodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ColumnSubnodePatch * SOAP_FMAC2 soap_instantiate_resqml2__ColumnSubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:490 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UniformSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UniformSubnodePatch (115)
/* Type resqml2__UniformSubnodePatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:UniformSubnodePatch': */
class SOAP_CMAC resqml2__UniformSubnodePatch : public resqml2__SubnodePatch {
      public:
        /// Required element 'resqml2:SubnodeCountPerObject' of XSD type 'xsd:positiveInteger'
        ULONG64 SubnodeCountPerObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UniformSubnodePatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UniformSubnodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__UniformSubnodePatch, default initialized and not managed by a soap context
        virtual resqml2__UniformSubnodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__UniformSubnodePatch); }
      public:
        /// Constructor with initializations
        resqml2__UniformSubnodePatch()
        {
          SubnodeCountPerObject = (ULONG64)0;
        }
        virtual ~resqml2__UniformSubnodePatch() { }
        /// Friend allocator used by soap_new_resqml2__UniformSubnodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__UniformSubnodePatch * SOAP_FMAC2 soap_instantiate_resqml2__UniformSubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:571 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridGeometry (142)
/* Type resqml2__AbstractGridGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractGridGeometry': */
class SOAP_CMAC resqml2__AbstractGridGeometry : public resqml2__PointGeometry {
      public:
        /// Optional element 'resqml2:AdditionalGridPoints' of XSD type 'resqml2:AdditionalGridPoints'
        std::vector<resqml2__AdditionalGridPoints *> AdditionalGridPoints;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractGridGeometry, default initialized and not managed by a soap context
        virtual resqml2__AbstractGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractGridGeometry); }
      public:
        /// Constructor with initializations
        resqml2__AbstractGridGeometry()
        {
        }
        virtual ~resqml2__AbstractGridGeometry() { }
        /// Friend allocator used by soap_new_resqml2__AbstractGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractGridGeometry * SOAP_FMAC2 soap_instantiate_resqml2__AbstractGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:583 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VariableSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VariableSubnodePatch (146)
/* Type resqml2__VariableSubnodePatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:VariableSubnodePatch': */
class SOAP_CMAC resqml2__VariableSubnodePatch : public resqml2__SubnodePatch {
      public:
        /// Required element 'resqml2:ObjectIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *ObjectIndices;
        /// Required element 'resqml2:SubnodeCountPerSelectedObject' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *SubnodeCountPerSelectedObject;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VariableSubnodePatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VariableSubnodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__VariableSubnodePatch, default initialized and not managed by a soap context
        virtual resqml2__VariableSubnodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__VariableSubnodePatch); }
      public:
        /// Constructor with initializations
        resqml2__VariableSubnodePatch()
        {
          ObjectIndices = (resqml2__AbstractIntegerArray *)0;
          SubnodeCountPerSelectedObject = (resqml2__AbstractIntegerArray *)0;
        }
        virtual ~resqml2__VariableSubnodePatch() { }
        /// Friend allocator used by soap_new_resqml2__VariableSubnodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__VariableSubnodePatch * SOAP_FMAC2 soap_instantiate_resqml2__VariableSubnodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:754 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractResqmlDataObject
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractResqmlDataObject (203)
/* Type resqml2__AbstractResqmlDataObject is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractResqmlDataObject': */
class SOAP_CMAC resqml2__AbstractResqmlDataObject : public eml__AbstractCitedDataObject {
      public:
        /// Optional element 'resqml2:ExtraMetadata' of XSD type 'resqml2:NameValuePair'
        std::vector<resqml2__NameValuePair *> ExtraMetadata;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractResqmlDataObject
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractResqmlDataObject; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractResqmlDataObject, default initialized and not managed by a soap context
        virtual resqml2__AbstractResqmlDataObject *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractResqmlDataObject); }
      public:
        /// Constructor with initializations
        resqml2__AbstractResqmlDataObject()
        {
        }
        virtual ~resqml2__AbstractResqmlDataObject() { }
        /// Friend allocator used by soap_new_resqml2__AbstractResqmlDataObject(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractResqmlDataObject * SOAP_FMAC2 soap_instantiate_resqml2__AbstractResqmlDataObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:793 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactPatch (216)
/* Type resqml2__ContactPatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:ContactPatch': */
class SOAP_CMAC resqml2__ContactPatch : public resqml2__Patch1d {
      public:
        /// Required element 'resqml2:RepresentationIndex' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 RepresentationIndex;
        /// Required element 'resqml2:SupportingRepresentationNodes' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *SupportingRepresentationNodes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactPatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactPatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__ContactPatch, default initialized and not managed by a soap context
        virtual resqml2__ContactPatch *soap_alloc(void) const { return SOAP_NEW(resqml2__ContactPatch); }
      public:
        /// Constructor with initializations
        resqml2__ContactPatch()
        {
          RepresentationIndex = (ULONG64)0;
          SupportingRepresentationNodes = (resqml2__AbstractIntegerArray *)0;
        }
        virtual ~resqml2__ContactPatch() { }
        /// Friend allocator used by soap_new_resqml2__ContactPatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__ContactPatch * SOAP_FMAC2 soap_instantiate_resqml2__ContactPatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:811 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__EdgePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__EdgePatch (222)
/* Type resqml2__EdgePatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:EdgePatch': */
class SOAP_CMAC resqml2__EdgePatch : public resqml2__Patch1d {
      public:
        /// Optional element 'resqml2:SplitEdges' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *SplitEdges;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__EdgePatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__EdgePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__EdgePatch, default initialized and not managed by a soap context
        virtual resqml2__EdgePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__EdgePatch); }
      public:
        /// Constructor with initializations
        resqml2__EdgePatch()
        {
          SplitEdges = (resqml2__AbstractIntegerArray *)0;
        }
        virtual ~resqml2__EdgePatch() { }
        /// Friend allocator used by soap_new_resqml2__EdgePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__EdgePatch * SOAP_FMAC2 soap_instantiate_resqml2__EdgePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:823 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodePatch (226)
/* Type resqml2__NodePatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:NodePatch': */
class SOAP_CMAC resqml2__NodePatch : public resqml2__Patch1d {
      public:
        /// Required element 'resqml2:Geometry' of XSD type 'resqml2:PointGeometry'
        resqml2__PointGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodePatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__NodePatch, default initialized and not managed by a soap context
        virtual resqml2__NodePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__NodePatch); }
      public:
        /// Constructor with initializations
        resqml2__NodePatch()
        {
          Geometry = (resqml2__PointGeometry *)0;
        }
        virtual ~resqml2__NodePatch() { }
        /// Friend allocator used by soap_new_resqml2__NodePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__NodePatch * SOAP_FMAC2 soap_instantiate_resqml2__NodePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:829 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TrianglePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TrianglePatch (228)
/* Type resqml2__TrianglePatch is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:TrianglePatch': */
class SOAP_CMAC resqml2__TrianglePatch : public resqml2__Patch1d {
      public:
        /// Required element 'resqml2:NodeCount' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 NodeCount;
        /// Required element 'resqml2:Triangles' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *Triangles;
        /// Required element 'resqml2:Geometry' of XSD type 'resqml2:PointGeometry'
        resqml2__PointGeometry *Geometry;
        /// Optional element 'resqml2:SplitEdgePatch' of XSD type 'resqml2:EdgePatch'
        std::vector<resqml2__EdgePatch *> SplitEdgePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TrianglePatch
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TrianglePatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__TrianglePatch, default initialized and not managed by a soap context
        virtual resqml2__TrianglePatch *soap_alloc(void) const { return SOAP_NEW(resqml2__TrianglePatch); }
      public:
        /// Constructor with initializations
        resqml2__TrianglePatch()
        {
          NodeCount = (ULONG64)0;
          Triangles = (resqml2__AbstractIntegerArray *)0;
          Geometry = (resqml2__PointGeometry *)0;
        }
        virtual ~resqml2__TrianglePatch() { }
        /// Friend allocator used by soap_new_resqml2__TrianglePatch(struct soap*, int)
        friend SOAP_FMAC1 resqml2__TrianglePatch * SOAP_FMAC2 soap_instantiate_resqml2__TrianglePatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:979 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrs (278)
/* Type eml__ProjectedCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:ProjectedCrs': */
class SOAP_CMAC eml__ProjectedCrs : public eml__AbstractCitedDataObject {
      public:
        /// Required element 'eml:AxisOrder' of XSD type 'eml:AxisOrder2d'
        enum eml__AxisOrder2d AxisOrder;
        /// Required element 'eml:AbstractProjectedCrs' of XSD type 'eml:AbstractProjectedCrs'
        eml__AbstractProjectedCrs *AbstractProjectedCrs;
        /// optional attribute 'uom' of XSD type 'eml:LengthUom'
        enum eml__LengthUom *uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ProjectedCrs, default initialized and not managed by a soap context
        virtual eml__ProjectedCrs *soap_alloc(void) const { return SOAP_NEW(eml__ProjectedCrs); }
      public:
        /// Constructor with initializations
        eml__ProjectedCrs()
        {
          AxisOrder = (enum eml__AxisOrder2d)0;
          AbstractProjectedCrs = (eml__AbstractProjectedCrs *)0;
          uom = (enum eml__LengthUom *)0;
        }
        virtual ~eml__ProjectedCrs() { }
        /// Friend allocator used by soap_new_eml__ProjectedCrs(struct soap*, int)
        friend SOAP_FMAC1 eml__ProjectedCrs * SOAP_FMAC2 soap_instantiate_eml__ProjectedCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:982 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrs (279)
/* Type eml__VerticalCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:VerticalCrs': */
class SOAP_CMAC eml__VerticalCrs : public eml__AbstractCitedDataObject {
      public:
        /// Required element 'eml:Direction' of XSD type 'eml:VerticalDirection'
        enum eml__VerticalDirection Direction;
        /// Required element 'eml:AbstractVerticalCrs' of XSD type 'eml:AbstractVerticalCrs'
        eml__AbstractVerticalCrs *AbstractVerticalCrs;
        /// required attribute 'uom' of XSD type 'eml:LengthUom'
        enum eml__LengthUom uom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VerticalCrs, default initialized and not managed by a soap context
        virtual eml__VerticalCrs *soap_alloc(void) const { return SOAP_NEW(eml__VerticalCrs); }
      public:
        /// Constructor with initializations
        eml__VerticalCrs()
        {
          Direction = (enum eml__VerticalDirection)0;
          AbstractVerticalCrs = (eml__AbstractVerticalCrs *)0;
          uom = (enum eml__LengthUom)0;
        }
        virtual ~eml__VerticalCrs() { }
        /// Friend allocator used by soap_new_eml__VerticalCrs(struct soap*, int)
        friend SOAP_FMAC1 eml__VerticalCrs * SOAP_FMAC2 soap_instantiate_eml__VerticalCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1003 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__obj_USCOREEpcExternalPartReference
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__obj_USCOREEpcExternalPartReference (286)
/* Type eml__obj_USCOREEpcExternalPartReference is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'eml:obj_EpcExternalPartReference': */
class SOAP_CMAC eml__obj_USCOREEpcExternalPartReference : public eml__AbstractCitedDataObject {
      public:
        /// Required element 'eml:MimeType' of XSD type 'xsd:string'
        std::string MimeType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__obj_USCOREEpcExternalPartReference
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__obj_USCOREEpcExternalPartReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__obj_USCOREEpcExternalPartReference, default initialized and not managed by a soap context
        virtual eml__obj_USCOREEpcExternalPartReference *soap_alloc(void) const { return SOAP_NEW(eml__obj_USCOREEpcExternalPartReference); }
      public:
        /// Constructor with initializations
        eml__obj_USCOREEpcExternalPartReference()
        {
        }
        virtual ~eml__obj_USCOREEpcExternalPartReference() { }
        /// Friend allocator used by soap_new_eml__obj_USCOREEpcExternalPartReference(struct soap*, int)
        friend SOAP_FMAC1 eml__obj_USCOREEpcExternalPartReference * SOAP_FMAC2 soap_instantiate_eml__obj_USCOREEpcExternalPartReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1009 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredMeasure (288)
/* simple XSD type 'eml:PressureSquaredMeasure': */
class SOAP_CMAC eml__PressureSquaredMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PressureSquaredUom'
        enum eml__PressureSquaredUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PressureSquaredMeasure, default initialized and not managed by a soap context
        virtual eml__PressureSquaredMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressureSquaredMeasure); }
      public:
        /// Constructor with initializations
        eml__PressureSquaredMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PressureSquaredUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PressureSquaredMeasure() { }
        /// Friend allocator used by soap_new_eml__PressureSquaredMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PressureSquaredMeasure * SOAP_FMAC2 soap_instantiate_eml__PressureSquaredMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1012 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthMeasure (289)
/* simple XSD type 'eml:ForceLengthPerLengthMeasure': */
class SOAP_CMAC eml__ForceLengthPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ForceLengthPerLengthUom'
        enum eml__ForceLengthPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ForceLengthPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__ForceLengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForceLengthPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__ForceLengthPerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ForceLengthPerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ForceLengthPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__ForceLengthPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ForceLengthPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__ForceLengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1015 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaMeasure (290)
/* simple XSD type 'eml:AmountOfSubstancePerTimePerAreaMeasure': */
class SOAP_CMAC eml__AmountOfSubstancePerTimePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AmountOfSubstancePerTimePerAreaUom'
        enum eml__AmountOfSubstancePerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AmountOfSubstancePerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__AmountOfSubstancePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerTimePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__AmountOfSubstancePerTimePerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AmountOfSubstancePerTimePerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AmountOfSubstancePerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__AmountOfSubstancePerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AmountOfSubstancePerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__AmountOfSubstancePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1018 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaMeasure (291)
/* simple XSD type 'eml:VolumePerTimePerAreaMeasure': */
class SOAP_CMAC eml__VolumePerTimePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerTimePerAreaUom'
        enum eml__VolumePerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerTimePerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerTimePerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1021 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthMeasure (292)
/* simple XSD type 'eml:LengthPerLengthMeasure': */
class SOAP_CMAC eml__LengthPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LengthPerLengthUom'
        enum eml__LengthPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LengthPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__LengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__LengthPerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LengthPerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LengthPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__LengthPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LengthPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__LengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1024 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalMeasure (293)
/* simple XSD type 'eml:TemperatureIntervalMeasure': */
class SOAP_CMAC eml__TemperatureIntervalMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:TemperatureIntervalUom'
        enum eml__TemperatureIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__TemperatureIntervalMeasure, default initialized and not managed by a soap context
        virtual eml__TemperatureIntervalMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TemperatureIntervalMeasure); }
      public:
        /// Constructor with initializations
        eml__TemperatureIntervalMeasure()
        {
          __item = (double)0;
          uom = (enum eml__TemperatureIntervalUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__TemperatureIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml__TemperatureIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__TemperatureIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml__TemperatureIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1027 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthMeasure (294)
/* simple XSD type 'eml:VolumePerTimePerLengthMeasure': */
class SOAP_CMAC eml__VolumePerTimePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerTimePerLengthUom'
        enum eml__VolumePerTimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerTimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerTimePerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerTimePerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerTimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerTimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerTimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1030 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeMeasure (295)
/* simple XSD type 'eml:VolumePerTimePerTimeMeasure': */
class SOAP_CMAC eml__VolumePerTimePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerTimePerTimeUom'
        enum eml__VolumePerTimePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerTimePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerTimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerTimePerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerTimePerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerTimePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerTimePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerTimePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerTimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1033 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthMeasure (296)
/* simple XSD type 'eml:PermeabilityLengthMeasure': */
class SOAP_CMAC eml__PermeabilityLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PermeabilityLengthUom'
        enum eml__PermeabilityLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PermeabilityLengthMeasure, default initialized and not managed by a soap context
        virtual eml__PermeabilityLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PermeabilityLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__PermeabilityLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PermeabilityLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PermeabilityLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__PermeabilityLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PermeabilityLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__PermeabilityLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1036 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceMeasure (297)
/* simple XSD type 'eml:ThermalInsulanceMeasure': */
class SOAP_CMAC eml__ThermalInsulanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ThermalInsulanceUom'
        enum eml__ThermalInsulanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ThermalInsulanceMeasure, default initialized and not managed by a soap context
        virtual eml__ThermalInsulanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalInsulanceMeasure); }
      public:
        /// Constructor with initializations
        eml__ThermalInsulanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ThermalInsulanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ThermalInsulanceMeasure() { }
        /// Friend allocator used by soap_new_eml__ThermalInsulanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ThermalInsulanceMeasure * SOAP_FMAC2 soap_instantiate_eml__ThermalInsulanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1039 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaMeasure (298)
/* simple XSD type 'eml:ForceAreaMeasure': */
class SOAP_CMAC eml__ForceAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ForceAreaUom'
        enum eml__ForceAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ForceAreaMeasure, default initialized and not managed by a soap context
        virtual eml__ForceAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForceAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__ForceAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ForceAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ForceAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__ForceAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ForceAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__ForceAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1042 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyMeasure (299)
/* simple XSD type 'eml:EnergyMeasure': */
class SOAP_CMAC eml__EnergyMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:EnergyUom'
        enum eml__EnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__EnergyMeasure, default initialized and not managed by a soap context
        virtual eml__EnergyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyMeasure); }
      public:
        /// Constructor with initializations
        eml__EnergyMeasure()
        {
          __item = (double)0;
          uom = (enum eml__EnergyUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__EnergyMeasure() { }
        /// Friend allocator used by soap_new_eml__EnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__EnergyMeasure * SOAP_FMAC2 soap_instantiate_eml__EnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1045 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceMeasure (300)
/* simple XSD type 'eml:IlluminanceMeasure': */
class SOAP_CMAC eml__IlluminanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:IlluminanceUom'
        enum eml__IlluminanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__IlluminanceMeasure, default initialized and not managed by a soap context
        virtual eml__IlluminanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__IlluminanceMeasure); }
      public:
        /// Constructor with initializations
        eml__IlluminanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__IlluminanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__IlluminanceMeasure() { }
        /// Friend allocator used by soap_new_eml__IlluminanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__IlluminanceMeasure * SOAP_FMAC2 soap_instantiate_eml__IlluminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1048 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceMeasure (301)
/* simple XSD type 'eml:ForceMeasure': */
class SOAP_CMAC eml__ForceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ForceUom'
        enum eml__ForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ForceMeasure, default initialized and not managed by a soap context
        virtual eml__ForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForceMeasure); }
      public:
        /// Constructor with initializations
        eml__ForceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ForceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ForceMeasure() { }
        /// Friend allocator used by soap_new_eml__ForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ForceMeasure * SOAP_FMAC2 soap_instantiate_eml__ForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1051 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityMeasure (302)
/* simple XSD type 'eml:RadiantIntensityMeasure': */
class SOAP_CMAC eml__RadiantIntensityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:RadiantIntensityUom'
        enum eml__RadiantIntensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__RadiantIntensityMeasure, default initialized and not managed by a soap context
        virtual eml__RadiantIntensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__RadiantIntensityMeasure); }
      public:
        /// Constructor with initializations
        eml__RadiantIntensityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__RadiantIntensityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__RadiantIntensityMeasure() { }
        /// Friend allocator used by soap_new_eml__RadiantIntensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__RadiantIntensityMeasure * SOAP_FMAC2 soap_instantiate_eml__RadiantIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1054 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerMeasure (303)
/* simple XSD type 'eml:PowerPerPowerMeasure': */
class SOAP_CMAC eml__PowerPerPowerMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PowerPerPowerUom'
        enum eml__PowerPerPowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PowerPerPowerMeasure, default initialized and not managed by a soap context
        virtual eml__PowerPerPowerMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PowerPerPowerMeasure); }
      public:
        /// Constructor with initializations
        eml__PowerPerPowerMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PowerPerPowerUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PowerPerPowerMeasure() { }
        /// Friend allocator used by soap_new_eml__PowerPerPowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PowerPerPowerMeasure * SOAP_FMAC2 soap_instantiate_eml__PowerPerPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1057 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessMeasure (304)
/* simple XSD type 'eml:DimensionlessMeasure': */
class SOAP_CMAC eml__DimensionlessMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:DimensionlessUom'
        enum eml__DimensionlessUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__DimensionlessMeasure, default initialized and not managed by a soap context
        virtual eml__DimensionlessMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DimensionlessMeasure); }
      public:
        /// Constructor with initializations
        eml__DimensionlessMeasure()
        {
          __item = (double)0;
          uom = (enum eml__DimensionlessUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__DimensionlessMeasure() { }
        /// Friend allocator used by soap_new_eml__DimensionlessMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__DimensionlessMeasure * SOAP_FMAC2 soap_instantiate_eml__DimensionlessMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1060 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientMeasure (305)
/* simple XSD type 'eml:HeatTransferCoefficientMeasure': */
class SOAP_CMAC eml__HeatTransferCoefficientMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:HeatTransferCoefficientUom'
        enum eml__HeatTransferCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__HeatTransferCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml__HeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW(eml__HeatTransferCoefficientMeasure); }
      public:
        /// Constructor with initializations
        eml__HeatTransferCoefficientMeasure()
        {
          __item = (double)0;
          uom = (enum eml__HeatTransferCoefficientUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__HeatTransferCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml__HeatTransferCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__HeatTransferCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml__HeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1063 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronMeasure (306)
/* simple XSD type 'eml:APINeutronMeasure': */
class SOAP_CMAC eml__APINeutronMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:APINeutronUom'
        enum eml__APINeutronUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__APINeutronMeasure, default initialized and not managed by a soap context
        virtual eml__APINeutronMeasure *soap_alloc(void) const { return SOAP_NEW(eml__APINeutronMeasure); }
      public:
        /// Constructor with initializations
        eml__APINeutronMeasure()
        {
          __item = (double)0;
          uom = (enum eml__APINeutronUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__APINeutronMeasure() { }
        /// Friend allocator used by soap_new_eml__APINeutronMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__APINeutronMeasure * SOAP_FMAC2 soap_instantiate_eml__APINeutronMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1066 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialMeasure (307)
/* simple XSD type 'eml:MagneticVectorPotentialMeasure': */
class SOAP_CMAC eml__MagneticVectorPotentialMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MagneticVectorPotentialUom'
        enum eml__MagneticVectorPotentialUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MagneticVectorPotentialMeasure, default initialized and not managed by a soap context
        virtual eml__MagneticVectorPotentialMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticVectorPotentialMeasure); }
      public:
        /// Constructor with initializations
        eml__MagneticVectorPotentialMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MagneticVectorPotentialUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MagneticVectorPotentialMeasure() { }
        /// Friend allocator used by soap_new_eml__MagneticVectorPotentialMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MagneticVectorPotentialMeasure * SOAP_FMAC2 soap_instantiate_eml__MagneticVectorPotentialMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1069 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationMeasure (308)
/* simple XSD type 'eml:LinearAccelerationMeasure': */
class SOAP_CMAC eml__LinearAccelerationMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LinearAccelerationUom'
        enum eml__LinearAccelerationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LinearAccelerationMeasure, default initialized and not managed by a soap context
        virtual eml__LinearAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LinearAccelerationMeasure); }
      public:
        /// Constructor with initializations
        eml__LinearAccelerationMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LinearAccelerationUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LinearAccelerationMeasure() { }
        /// Friend allocator used by soap_new_eml__LinearAccelerationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LinearAccelerationMeasure * SOAP_FMAC2 soap_instantiate_eml__LinearAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1072 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeMeasure (309)
/* simple XSD type 'eml:VolumePerTimeMeasure': */
class SOAP_CMAC eml__VolumePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerTimeUom'
        enum eml__VolumePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1075 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxMeasure (310)
/* simple XSD type 'eml:MagneticFluxMeasure': */
class SOAP_CMAC eml__MagneticFluxMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MagneticFluxUom'
        enum eml__MagneticFluxUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MagneticFluxMeasure, default initialized and not managed by a soap context
        virtual eml__MagneticFluxMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticFluxMeasure); }
      public:
        /// Constructor with initializations
        eml__MagneticFluxMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MagneticFluxUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MagneticFluxMeasure() { }
        /// Friend allocator used by soap_new_eml__MagneticFluxMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MagneticFluxMeasure * SOAP_FMAC2 soap_instantiate_eml__MagneticFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1078 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionMeasure (311)
/* simple XSD type 'eml:VolumetricThermalExpansionMeasure': */
class SOAP_CMAC eml__VolumetricThermalExpansionMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumetricThermalExpansionUom'
        enum eml__VolumetricThermalExpansionUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumetricThermalExpansionMeasure, default initialized and not managed by a soap context
        virtual eml__VolumetricThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumetricThermalExpansionMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumetricThermalExpansionMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumetricThermalExpansionUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumetricThermalExpansionMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumetricThermalExpansionMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumetricThermalExpansionMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumetricThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1081 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateMeasure (312)
/* simple XSD type 'eml:HeatFlowRateMeasure': */
class SOAP_CMAC eml__HeatFlowRateMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:HeatFlowRateUom'
        enum eml__HeatFlowRateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__HeatFlowRateMeasure, default initialized and not managed by a soap context
        virtual eml__HeatFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW(eml__HeatFlowRateMeasure); }
      public:
        /// Constructor with initializations
        eml__HeatFlowRateMeasure()
        {
          __item = (double)0;
          uom = (enum eml__HeatFlowRateUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__HeatFlowRateMeasure() { }
        /// Friend allocator used by soap_new_eml__HeatFlowRateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__HeatFlowRateMeasure * SOAP_FMAC2 soap_instantiate_eml__HeatFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1084 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeMeasure (313)
/* simple XSD type 'eml:MassPerTimeMeasure': */
class SOAP_CMAC eml__MassPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassPerTimeUom'
        enum eml__MassPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__MassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__MassPerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassPerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__MassPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__MassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1087 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassMeasure (314)
/* simple XSD type 'eml:VolumePerMassMeasure': */
class SOAP_CMAC eml__VolumePerMassMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerMassUom'
        enum eml__VolumePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerMassMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerMassMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerMassMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerMassUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1090 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeMeasure (315)
/* simple XSD type 'eml:MolarVolumeMeasure': */
class SOAP_CMAC eml__MolarVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MolarVolumeUom'
        enum eml__MolarVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MolarVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__MolarVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MolarVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__MolarVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MolarVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MolarVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__MolarVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MolarVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__MolarVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1093 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceMeasure (316)
/* simple XSD type 'eml:ElectricConductanceMeasure': */
class SOAP_CMAC eml__ElectricConductanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricConductanceUom'
        enum eml__ElectricConductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricConductanceMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricConductanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricConductanceMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricConductanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricConductanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricConductanceMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricConductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricConductanceMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1096 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureMeasure (317)
/* simple XSD type 'eml:ReciprocalPressureMeasure': */
class SOAP_CMAC eml__ReciprocalPressureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReciprocalPressureUom'
        enum eml__ReciprocalPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReciprocalPressureMeasure, default initialized and not managed by a soap context
        virtual eml__ReciprocalPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalPressureMeasure); }
      public:
        /// Constructor with initializations
        eml__ReciprocalPressureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReciprocalPressureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReciprocalPressureMeasure() { }
        /// Friend allocator used by soap_new_eml__ReciprocalPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReciprocalPressureMeasure * SOAP_FMAC2 soap_instantiate_eml__ReciprocalPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1099 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceMeasure (318)
/* simple XSD type 'eml:AreaPerAmountOfSubstanceMeasure': */
class SOAP_CMAC eml__AreaPerAmountOfSubstanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AreaPerAmountOfSubstanceUom'
        enum eml__AreaPerAmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AreaPerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml__AreaPerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerAmountOfSubstanceMeasure); }
      public:
        /// Constructor with initializations
        eml__AreaPerAmountOfSubstanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AreaPerAmountOfSubstanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AreaPerAmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml__AreaPerAmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AreaPerAmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml__AreaPerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1102 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthMeasure (319)
/* simple XSD type 'eml:LengthMeasure': */
class SOAP_CMAC eml__LengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LengthUom'
        enum eml__LengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LengthMeasure, default initialized and not managed by a soap context
        virtual eml__LengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthMeasure); }
      public:
        /// Constructor with initializations
        eml__LengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LengthMeasure() { }
        /// Friend allocator used by soap_new_eml__LengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LengthMeasure * SOAP_FMAC2 soap_instantiate_eml__LengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1105 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeMeasure (320)
/* simple XSD type 'eml:MassPerVolumeMeasure': */
class SOAP_CMAC eml__MassPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassPerVolumeUom'
        enum eml__MassPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__MassPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__MassPerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassPerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__MassPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__MassPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1108 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthMeasure (321)
/* simple XSD type 'eml:TemperatureIntervalPerLengthMeasure': */
class SOAP_CMAC eml__TemperatureIntervalPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:TemperatureIntervalPerLengthUom'
        enum eml__TemperatureIntervalPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__TemperatureIntervalPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__TemperatureIntervalPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TemperatureIntervalPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__TemperatureIntervalPerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__TemperatureIntervalPerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__TemperatureIntervalPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__TemperatureIntervalPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__TemperatureIntervalPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__TemperatureIntervalPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1111 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaMeasure (322)
/* simple XSD type 'eml:AmountOfSubstancePerAreaMeasure': */
class SOAP_CMAC eml__AmountOfSubstancePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AmountOfSubstancePerAreaUom'
        enum eml__AmountOfSubstancePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AmountOfSubstancePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__AmountOfSubstancePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__AmountOfSubstancePerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AmountOfSubstancePerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AmountOfSubstancePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__AmountOfSubstancePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AmountOfSubstancePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__AmountOfSubstancePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1114 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceMeasure (323)
/* simple XSD type 'eml:AmountOfSubstanceMeasure': */
class SOAP_CMAC eml__AmountOfSubstanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AmountOfSubstanceUom'
        enum eml__AmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml__AmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstanceMeasure); }
      public:
        /// Constructor with initializations
        eml__AmountOfSubstanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AmountOfSubstanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml__AmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml__AmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1117 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthMeasure (324)
/* simple XSD type 'eml:TimePerLengthMeasure': */
class SOAP_CMAC eml__TimePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:TimePerLengthUom'
        enum eml__TimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__TimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__TimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__TimePerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__TimePerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__TimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__TimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__TimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__TimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1120 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeMeasure (325)
/* simple XSD type 'eml:ReciprocalMassTimeMeasure': */
class SOAP_CMAC eml__ReciprocalMassTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReciprocalMassTimeUom'
        enum eml__ReciprocalMassTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReciprocalMassTimeMeasure, default initialized and not managed by a soap context
        virtual eml__ReciprocalMassTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalMassTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__ReciprocalMassTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReciprocalMassTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReciprocalMassTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__ReciprocalMassTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReciprocalMassTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__ReciprocalMassTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1123 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeMeasure (326)
/* simple XSD type 'eml:ReciprocalVolumeMeasure': */
class SOAP_CMAC eml__ReciprocalVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReciprocalVolumeUom'
        enum eml__ReciprocalVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReciprocalVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__ReciprocalVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__ReciprocalVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReciprocalVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReciprocalVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__ReciprocalVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReciprocalVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__ReciprocalVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1126 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceMeasure (327)
/* simple XSD type 'eml:ForcePerForceMeasure': */
class SOAP_CMAC eml__ForcePerForceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ForcePerForceUom'
        enum eml__ForcePerForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ForcePerForceMeasure, default initialized and not managed by a soap context
        virtual eml__ForcePerForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForcePerForceMeasure); }
      public:
        /// Constructor with initializations
        eml__ForcePerForceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ForcePerForceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ForcePerForceMeasure() { }
        /// Friend allocator used by soap_new_eml__ForcePerForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ForcePerForceMeasure * SOAP_FMAC2 soap_instantiate_eml__ForcePerForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1129 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionMeasure (328)
/* simple XSD type 'eml:LinearThermalExpansionMeasure': */
class SOAP_CMAC eml__LinearThermalExpansionMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LinearThermalExpansionUom'
        enum eml__LinearThermalExpansionUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LinearThermalExpansionMeasure, default initialized and not managed by a soap context
        virtual eml__LinearThermalExpansionMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LinearThermalExpansionMeasure); }
      public:
        /// Constructor with initializations
        eml__LinearThermalExpansionMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LinearThermalExpansionUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LinearThermalExpansionMeasure() { }
        /// Friend allocator used by soap_new_eml__LinearThermalExpansionMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LinearThermalExpansionMeasure * SOAP_FMAC2 soap_instantiate_eml__LinearThermalExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1132 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthMeasure (329)
/* simple XSD type 'eml:EnergyPerLengthMeasure': */
class SOAP_CMAC eml__EnergyPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:EnergyPerLengthUom'
        enum eml__EnergyPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__EnergyPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__EnergyPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__EnergyPerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__EnergyPerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__EnergyPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__EnergyPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__EnergyPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__EnergyPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1135 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeMeasure (330)
/* simple XSD type 'eml:TemperatureIntervalPerTimeMeasure': */
class SOAP_CMAC eml__TemperatureIntervalPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:TemperatureIntervalPerTimeUom'
        enum eml__TemperatureIntervalPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__TemperatureIntervalPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__TemperatureIntervalPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TemperatureIntervalPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__TemperatureIntervalPerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__TemperatureIntervalPerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__TemperatureIntervalPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__TemperatureIntervalPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__TemperatureIntervalPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__TemperatureIntervalPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1138 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceMeasure (331)
/* simple XSD type 'eml:ThermalConductanceMeasure': */
class SOAP_CMAC eml__ThermalConductanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ThermalConductanceUom'
        enum eml__ThermalConductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ThermalConductanceMeasure, default initialized and not managed by a soap context
        virtual eml__ThermalConductanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalConductanceMeasure); }
      public:
        /// Constructor with initializations
        eml__ThermalConductanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ThermalConductanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ThermalConductanceMeasure() { }
        /// Friend allocator used by soap_new_eml__ThermalConductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ThermalConductanceMeasure * SOAP_FMAC2 soap_instantiate_eml__ThermalConductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1141 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleMeasure (332)
/* simple XSD type 'eml:SolidAngleMeasure': */
class SOAP_CMAC eml__SolidAngleMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:SolidAngleUom'
        enum eml__SolidAngleUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__SolidAngleMeasure, default initialized and not managed by a soap context
        virtual eml__SolidAngleMeasure *soap_alloc(void) const { return SOAP_NEW(eml__SolidAngleMeasure); }
      public:
        /// Constructor with initializations
        eml__SolidAngleMeasure()
        {
          __item = (double)0;
          uom = (enum eml__SolidAngleUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__SolidAngleMeasure() { }
        /// Friend allocator used by soap_new_eml__SolidAngleMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__SolidAngleMeasure * SOAP_FMAC2 soap_instantiate_eml__SolidAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1144 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureMeasure (333)
/* simple XSD type 'eml:EnergyLengthPerTimeAreaTemperatureMeasure': */
class SOAP_CMAC eml__EnergyLengthPerTimeAreaTemperatureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:EnergyLengthPerTimeAreaTemperatureUom'
        enum eml__EnergyLengthPerTimeAreaTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__EnergyLengthPerTimeAreaTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml__EnergyLengthPerTimeAreaTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyLengthPerTimeAreaTemperatureMeasure); }
      public:
        /// Constructor with initializations
        eml__EnergyLengthPerTimeAreaTemperatureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__EnergyLengthPerTimeAreaTemperatureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__EnergyLengthPerTimeAreaTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml__EnergyLengthPerTimeAreaTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__EnergyLengthPerTimeAreaTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml__EnergyLengthPerTimeAreaTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1147 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerMeasure (334)
/* simple XSD type 'eml:PowerMeasure': */
class SOAP_CMAC eml__PowerMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PowerUom'
        enum eml__PowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PowerMeasure, default initialized and not managed by a soap context
        virtual eml__PowerMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PowerMeasure); }
      public:
        /// Constructor with initializations
        eml__PowerMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PowerUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PowerMeasure() { }
        /// Friend allocator used by soap_new_eml__PowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PowerMeasure * SOAP_FMAC2 soap_instantiate_eml__PowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1150 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationMeasure (335)
/* simple XSD type 'eml:VolumePerRotationMeasure': */
class SOAP_CMAC eml__VolumePerRotationMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerRotationUom'
        enum eml__VolumePerRotationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerRotationMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerRotationMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerRotationMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerRotationMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerRotationUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerRotationMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerRotationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerRotationMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerRotationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1153 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaMeasure (336)
/* simple XSD type 'eml:ElectricChargePerAreaMeasure': */
class SOAP_CMAC eml__ElectricChargePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricChargePerAreaUom'
        enum eml__ElectricChargePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricChargePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricChargePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricChargePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricChargePerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricChargePerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricChargePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricChargePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricChargePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricChargePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1156 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureMeasure (337)
/* simple XSD type 'eml:LightExposureMeasure': */
class SOAP_CMAC eml__LightExposureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LightExposureUom'
        enum eml__LightExposureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LightExposureMeasure, default initialized and not managed by a soap context
        virtual eml__LightExposureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LightExposureMeasure); }
      public:
        /// Constructor with initializations
        eml__LightExposureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LightExposureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LightExposureMeasure() { }
        /// Friend allocator used by soap_new_eml__LightExposureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LightExposureMeasure * SOAP_FMAC2 soap_instantiate_eml__LightExposureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1159 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentMeasure (338)
/* simple XSD type 'eml:ElectricCurrentMeasure': */
class SOAP_CMAC eml__ElectricCurrentMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricCurrentUom'
        enum eml__ElectricCurrentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricCurrentMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricCurrentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricCurrentMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricCurrentMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricCurrentUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricCurrentMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricCurrentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricCurrentMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricCurrentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1162 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxMeasure (339)
/* simple XSD type 'eml:LuminousFluxMeasure': */
class SOAP_CMAC eml__LuminousFluxMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LuminousFluxUom'
        enum eml__LuminousFluxUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LuminousFluxMeasure, default initialized and not managed by a soap context
        virtual eml__LuminousFluxMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LuminousFluxMeasure); }
      public:
        /// Constructor with initializations
        eml__LuminousFluxMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LuminousFluxUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LuminousFluxMeasure() { }
        /// Friend allocator used by soap_new_eml__LuminousFluxMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LuminousFluxMeasure * SOAP_FMAC2 soap_instantiate_eml__LuminousFluxMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1165 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityMeasure (340)
/* simple XSD type 'eml:HeatCapacityMeasure': */
class SOAP_CMAC eml__HeatCapacityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:HeatCapacityUom'
        enum eml__HeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__HeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml__HeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__HeatCapacityMeasure); }
      public:
        /// Constructor with initializations
        eml__HeatCapacityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__HeatCapacityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__HeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml__HeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__HeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml__HeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1168 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthMeasure (341)
/* simple XSD type 'eml:ElectricResistancePerLengthMeasure': */
class SOAP_CMAC eml__ElectricResistancePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricResistancePerLengthUom'
        enum eml__ElectricResistancePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricResistancePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricResistancePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricResistancePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricResistancePerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricResistancePerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricResistancePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricResistancePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricResistancePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricResistancePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1171 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseMeasure (342)
/* simple XSD type 'eml:AbsorbedDoseMeasure': */
class SOAP_CMAC eml__AbsorbedDoseMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AbsorbedDoseUom'
        enum eml__AbsorbedDoseUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AbsorbedDoseMeasure, default initialized and not managed by a soap context
        virtual eml__AbsorbedDoseMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AbsorbedDoseMeasure); }
      public:
        /// Constructor with initializations
        eml__AbsorbedDoseMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AbsorbedDoseUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AbsorbedDoseMeasure() { }
        /// Friend allocator used by soap_new_eml__AbsorbedDoseMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AbsorbedDoseMeasure * SOAP_FMAC2 soap_instantiate_eml__AbsorbedDoseMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1174 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureMeasure (343)
/* simple XSD type 'eml:TemperatureIntervalPerPressureMeasure': */
class SOAP_CMAC eml__TemperatureIntervalPerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:TemperatureIntervalPerPressureUom'
        enum eml__TemperatureIntervalPerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__TemperatureIntervalPerPressureMeasure, default initialized and not managed by a soap context
        virtual eml__TemperatureIntervalPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TemperatureIntervalPerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml__TemperatureIntervalPerPressureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__TemperatureIntervalPerPressureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__TemperatureIntervalPerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml__TemperatureIntervalPerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__TemperatureIntervalPerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml__TemperatureIntervalPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1177 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalMeasure (344)
/* simple XSD type 'eml:AttenuationPerFrequencyIntervalMeasure': */
class SOAP_CMAC eml__AttenuationPerFrequencyIntervalMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AttenuationPerFrequencyIntervalUom'
        enum eml__AttenuationPerFrequencyIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AttenuationPerFrequencyIntervalMeasure, default initialized and not managed by a soap context
        virtual eml__AttenuationPerFrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AttenuationPerFrequencyIntervalMeasure); }
      public:
        /// Constructor with initializations
        eml__AttenuationPerFrequencyIntervalMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AttenuationPerFrequencyIntervalUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AttenuationPerFrequencyIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml__AttenuationPerFrequencyIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AttenuationPerFrequencyIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml__AttenuationPerFrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1180 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceMeasure (345)
/* simple XSD type 'eml:ThermalResistanceMeasure': */
class SOAP_CMAC eml__ThermalResistanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ThermalResistanceUom'
        enum eml__ThermalResistanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ThermalResistanceMeasure, default initialized and not managed by a soap context
        virtual eml__ThermalResistanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalResistanceMeasure); }
      public:
        /// Constructor with initializations
        eml__ThermalResistanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ThermalResistanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ThermalResistanceMeasure() { }
        /// Friend allocator used by soap_new_eml__ThermalResistanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ThermalResistanceMeasure * SOAP_FMAC2 soap_instantiate_eml__ThermalResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1183 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthMeasure (346)
/* simple XSD type 'eml:AnglePerLengthMeasure': */
class SOAP_CMAC eml__AnglePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AnglePerLengthUom'
        enum eml__AnglePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AnglePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__AnglePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AnglePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__AnglePerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AnglePerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AnglePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__AnglePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AnglePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__AnglePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1186 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeMeasure (347)
/* simple XSD type 'eml:LengthPerTimeMeasure': */
class SOAP_CMAC eml__LengthPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LengthPerTimeUom'
        enum eml__LengthPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LengthPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__LengthPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__LengthPerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LengthPerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LengthPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__LengthPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LengthPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__LengthPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1189 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthMeasure (348)
/* simple XSD type 'eml:MassPerLengthMeasure': */
class SOAP_CMAC eml__MassPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassPerLengthUom'
        enum eml__MassPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__MassPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__MassPerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassPerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__MassPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__MassPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1192 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaMeasure (349)
/* simple XSD type 'eml:EnergyPerAreaMeasure': */
class SOAP_CMAC eml__EnergyPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:EnergyPerAreaUom'
        enum eml__EnergyPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__EnergyPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__EnergyPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__EnergyPerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__EnergyPerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__EnergyPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__EnergyPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__EnergyPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__EnergyPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1195 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaMeasure (350)
/* simple XSD type 'eml:AreaPerAreaMeasure': */
class SOAP_CMAC eml__AreaPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AreaPerAreaUom'
        enum eml__AreaPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AreaPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__AreaPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__AreaPerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AreaPerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AreaPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__AreaPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AreaPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__AreaPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1198 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceMeasure (351)
/* simple XSD type 'eml:ReluctanceMeasure': */
class SOAP_CMAC eml__ReluctanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReluctanceUom'
        enum eml__ReluctanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReluctanceMeasure, default initialized and not managed by a soap context
        virtual eml__ReluctanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReluctanceMeasure); }
      public:
        /// Constructor with initializations
        eml__ReluctanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReluctanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReluctanceMeasure() { }
        /// Friend allocator used by soap_new_eml__ReluctanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReluctanceMeasure * SOAP_FMAC2 soap_instantiate_eml__ReluctanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1201 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureMeasure (352)
/* simple XSD type 'eml:ThermodynamicTemperatureMeasure': */
class SOAP_CMAC eml__ThermodynamicTemperatureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ThermodynamicTemperatureUom'
        enum eml__ThermodynamicTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ThermodynamicTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml__ThermodynamicTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermodynamicTemperatureMeasure); }
      public:
        /// Constructor with initializations
        eml__ThermodynamicTemperatureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ThermodynamicTemperatureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ThermodynamicTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml__ThermodynamicTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ThermodynamicTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml__ThermodynamicTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1204 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityMeasure (353)
/* simple XSD type 'eml:PermittivityMeasure': */
class SOAP_CMAC eml__PermittivityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PermittivityUom'
        enum eml__PermittivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PermittivityMeasure, default initialized and not managed by a soap context
        virtual eml__PermittivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PermittivityMeasure); }
      public:
        /// Constructor with initializations
        eml__PermittivityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PermittivityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PermittivityMeasure() { }
        /// Friend allocator used by soap_new_eml__PermittivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PermittivityMeasure * SOAP_FMAC2 soap_instantiate_eml__PermittivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1207 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeMeasure (354)
/* simple XSD type 'eml:PressureTimePerVolumeMeasure': */
class SOAP_CMAC eml__PressureTimePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PressureTimePerVolumeUom'
        enum eml__PressureTimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PressureTimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__PressureTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressureTimePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__PressureTimePerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PressureTimePerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PressureTimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__PressureTimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PressureTimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__PressureTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1210 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentMeasure (355)
/* simple XSD type 'eml:DipoleMomentMeasure': */
class SOAP_CMAC eml__DipoleMomentMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:DipoleMomentUom'
        enum eml__DipoleMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__DipoleMomentMeasure, default initialized and not managed by a soap context
        virtual eml__DipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DipoleMomentMeasure); }
      public:
        /// Constructor with initializations
        eml__DipoleMomentMeasure()
        {
          __item = (double)0;
          uom = (enum eml__DipoleMomentUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__DipoleMomentMeasure() { }
        /// Friend allocator used by soap_new_eml__DipoleMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__DipoleMomentMeasure * SOAP_FMAC2 soap_instantiate_eml__DipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1213 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceMeasure (356)
/* simple XSD type 'eml:RadianceMeasure': */
class SOAP_CMAC eml__RadianceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:RadianceUom'
        enum eml__RadianceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__RadianceMeasure, default initialized and not managed by a soap context
        virtual eml__RadianceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__RadianceMeasure); }
      public:
        /// Constructor with initializations
        eml__RadianceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__RadianceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__RadianceMeasure() { }
        /// Friend allocator used by soap_new_eml__RadianceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__RadianceMeasure * SOAP_FMAC2 soap_instantiate_eml__RadianceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1216 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassMeasure (357)
/* simple XSD type 'eml:AreaPerMassMeasure': */
class SOAP_CMAC eml__AreaPerMassMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AreaPerMassUom'
        enum eml__AreaPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AreaPerMassMeasure, default initialized and not managed by a soap context
        virtual eml__AreaPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerMassMeasure); }
      public:
        /// Constructor with initializations
        eml__AreaPerMassMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AreaPerMassUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AreaPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml__AreaPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AreaPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml__AreaPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1219 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeMeasure (358)
/* simple XSD type 'eml:EnergyPerMassPerTimeMeasure': */
class SOAP_CMAC eml__EnergyPerMassPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:EnergyPerMassPerTimeUom'
        enum eml__EnergyPerMassPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__EnergyPerMassPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__EnergyPerMassPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerMassPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__EnergyPerMassPerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__EnergyPerMassPerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__EnergyPerMassPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__EnergyPerMassPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__EnergyPerMassPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__EnergyPerMassPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1222 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityMeasure (359)
/* simple XSD type 'eml:ElectricCurrentDensityMeasure': */
class SOAP_CMAC eml__ElectricCurrentDensityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricCurrentDensityUom'
        enum eml__ElectricCurrentDensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricCurrentDensityMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricCurrentDensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricCurrentDensityMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricCurrentDensityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricCurrentDensityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricCurrentDensityMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricCurrentDensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricCurrentDensityMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricCurrentDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1225 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassMeasure (360)
/* simple XSD type 'eml:MassPerMassMeasure': */
class SOAP_CMAC eml__MassPerMassMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassPerMassUom'
        enum eml__MassPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassPerMassMeasure, default initialized and not managed by a soap context
        virtual eml__MassPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerMassMeasure); }
      public:
        /// Constructor with initializations
        eml__MassPerMassMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassPerMassUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml__MassPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml__MassPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1228 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedMeasure (361)
/* simple XSD type 'eml:DataTransferSpeedMeasure': */
class SOAP_CMAC eml__DataTransferSpeedMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:DataTransferSpeedUom'
        enum eml__DataTransferSpeedUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__DataTransferSpeedMeasure, default initialized and not managed by a soap context
        virtual eml__DataTransferSpeedMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DataTransferSpeedMeasure); }
      public:
        /// Constructor with initializations
        eml__DataTransferSpeedMeasure()
        {
          __item = (double)0;
          uom = (enum eml__DataTransferSpeedUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__DataTransferSpeedMeasure() { }
        /// Friend allocator used by soap_new_eml__DataTransferSpeedMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__DataTransferSpeedMeasure * SOAP_FMAC2 soap_instantiate_eml__DataTransferSpeedMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1231 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentMeasure (362)
/* simple XSD type 'eml:MagneticDipoleMomentMeasure': */
class SOAP_CMAC eml__MagneticDipoleMomentMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MagneticDipoleMomentUom'
        enum eml__MagneticDipoleMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MagneticDipoleMomentMeasure, default initialized and not managed by a soap context
        virtual eml__MagneticDipoleMomentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticDipoleMomentMeasure); }
      public:
        /// Constructor with initializations
        eml__MagneticDipoleMomentMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MagneticDipoleMomentUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MagneticDipoleMomentMeasure() { }
        /// Friend allocator used by soap_new_eml__MagneticDipoleMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MagneticDipoleMomentMeasure * SOAP_FMAC2 soap_instantiate_eml__MagneticDipoleMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1234 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyMeasure (363)
/* simple XSD type 'eml:MassPerEnergyMeasure': */
class SOAP_CMAC eml__MassPerEnergyMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassPerEnergyUom'
        enum eml__MassPerEnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassPerEnergyMeasure, default initialized and not managed by a soap context
        virtual eml__MassPerEnergyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerEnergyMeasure); }
      public:
        /// Constructor with initializations
        eml__MassPerEnergyMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassPerEnergyUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassPerEnergyMeasure() { }
        /// Friend allocator used by soap_new_eml__MassPerEnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassPerEnergyMeasure * SOAP_FMAC2 soap_instantiate_eml__MassPerEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1237 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityMeasure (364)
/* simple XSD type 'eml:MagneticPermeabilityMeasure': */
class SOAP_CMAC eml__MagneticPermeabilityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MagneticPermeabilityUom'
        enum eml__MagneticPermeabilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MagneticPermeabilityMeasure, default initialized and not managed by a soap context
        virtual eml__MagneticPermeabilityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticPermeabilityMeasure); }
      public:
        /// Constructor with initializations
        eml__MagneticPermeabilityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MagneticPermeabilityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MagneticPermeabilityMeasure() { }
        /// Friend allocator used by soap_new_eml__MagneticPermeabilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MagneticPermeabilityMeasure * SOAP_FMAC2 soap_instantiate_eml__MagneticPermeabilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1240 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityMeasure (365)
/* simple XSD type 'eml:APIGravityMeasure': */
class SOAP_CMAC eml__APIGravityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:APIGravityUom'
        enum eml__APIGravityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__APIGravityMeasure, default initialized and not managed by a soap context
        virtual eml__APIGravityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__APIGravityMeasure); }
      public:
        /// Constructor with initializations
        eml__APIGravityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__APIGravityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__APIGravityMeasure() { }
        /// Friend allocator used by soap_new_eml__APIGravityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__APIGravityMeasure * SOAP_FMAC2 soap_instantiate_eml__APIGravityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1243 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthMeasure (366)
/* simple XSD type 'eml:VolumePerLengthMeasure': */
class SOAP_CMAC eml__VolumePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerLengthUom'
        enum eml__VolumePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1246 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeMeasure (367)
/* simple XSD type 'eml:VolumeMeasure': */
class SOAP_CMAC eml__VolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumeUom'
        enum eml__VolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumeMeasure, default initialized and not managed by a soap context
        virtual eml__VolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1249 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeMeasure (368)
/* simple XSD type 'eml:VolumePerTimePerVolumeMeasure': */
class SOAP_CMAC eml__VolumePerTimePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerTimePerVolumeUom'
        enum eml__VolumePerTimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerTimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerTimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerTimePerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerTimePerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerTimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerTimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerTimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerTimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1252 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureMeasure (369)
/* simple XSD type 'eml:VolumePerTimePerPressureMeasure': */
class SOAP_CMAC eml__VolumePerTimePerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerTimePerPressureUom'
        enum eml__VolumePerTimePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerTimePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerTimePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerTimePerPressureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerTimePerPressureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerTimePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerTimePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerTimePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerTimePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1255 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeMeasure (370)
/* simple XSD type 'eml:TimeMeasure': */
class SOAP_CMAC eml__TimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:TimeUom'
        enum eml__TimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__TimeMeasure, default initialized and not managed by a soap context
        virtual eml__TimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimeMeasure); }
      public:
        /// Constructor with initializations
        eml__TimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__TimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__TimeMeasure() { }
        /// Friend allocator used by soap_new_eml__TimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__TimeMeasure * SOAP_FMAC2 soap_instantiate_eml__TimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1258 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceMeasure (371)
/* simple XSD type 'eml:MomentOfForceMeasure': */
class SOAP_CMAC eml__MomentOfForceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MomentOfForceUom'
        enum eml__MomentOfForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MomentOfForceMeasure, default initialized and not managed by a soap context
        virtual eml__MomentOfForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MomentOfForceMeasure); }
      public:
        /// Constructor with initializations
        eml__MomentOfForceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MomentOfForceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MomentOfForceMeasure() { }
        /// Friend allocator used by soap_new_eml__MomentOfForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MomentOfForceMeasure * SOAP_FMAC2 soap_instantiate_eml__MomentOfForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1261 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceMeasure (372)
/* simple XSD type 'eml:LuminanceMeasure': */
class SOAP_CMAC eml__LuminanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LuminanceUom'
        enum eml__LuminanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LuminanceMeasure, default initialized and not managed by a soap context
        virtual eml__LuminanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LuminanceMeasure); }
      public:
        /// Constructor with initializations
        eml__LuminanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LuminanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LuminanceMeasure() { }
        /// Friend allocator used by soap_new_eml__LuminanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LuminanceMeasure * SOAP_FMAC2 soap_instantiate_eml__LuminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1264 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeMeasure (373)
/* simple XSD type 'eml:ForcePerVolumeMeasure': */
class SOAP_CMAC eml__ForcePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ForcePerVolumeUom'
        enum eml__ForcePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ForcePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__ForcePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForcePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__ForcePerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ForcePerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ForcePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__ForcePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ForcePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__ForcePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1267 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityMeasure (374)
/* simple XSD type 'eml:MolarHeatCapacityMeasure': */
class SOAP_CMAC eml__MolarHeatCapacityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MolarHeatCapacityUom'
        enum eml__MolarHeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MolarHeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml__MolarHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MolarHeatCapacityMeasure); }
      public:
        /// Constructor with initializations
        eml__MolarHeatCapacityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MolarHeatCapacityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MolarHeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml__MolarHeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MolarHeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml__MolarHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1270 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageMeasure (375)
/* simple XSD type 'eml:DigitalStorageMeasure': */
class SOAP_CMAC eml__DigitalStorageMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:DigitalStorageUom'
        enum eml__DigitalStorageUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__DigitalStorageMeasure, default initialized and not managed by a soap context
        virtual eml__DigitalStorageMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DigitalStorageMeasure); }
      public:
        /// Constructor with initializations
        eml__DigitalStorageMeasure()
        {
          __item = (double)0;
          uom = (enum eml__DigitalStorageUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__DigitalStorageMeasure() { }
        /// Friend allocator used by soap_new_eml__DigitalStorageMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__DigitalStorageMeasure * SOAP_FMAC2 soap_instantiate_eml__DigitalStorageMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1273 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeMeasure (376)
/* simple XSD type 'eml:ElectricChargeMeasure': */
class SOAP_CMAC eml__ElectricChargeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricChargeUom'
        enum eml__ElectricChargeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricChargeMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricChargeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricChargeMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricChargeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricChargeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricChargeMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricChargeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricChargeMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricChargeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1276 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityMeasure (377)
/* simple XSD type 'eml:LuminousIntensityMeasure': */
class SOAP_CMAC eml__LuminousIntensityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LuminousIntensityUom'
        enum eml__LuminousIntensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LuminousIntensityMeasure, default initialized and not managed by a soap context
        virtual eml__LuminousIntensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LuminousIntensityMeasure); }
      public:
        /// Constructor with initializations
        eml__LuminousIntensityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LuminousIntensityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LuminousIntensityMeasure() { }
        /// Friend allocator used by soap_new_eml__LuminousIntensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LuminousIntensityMeasure * SOAP_FMAC2 soap_instantiate_eml__LuminousIntensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1279 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyMeasure (378)
/* simple XSD type 'eml:MolarEnergyMeasure': */
class SOAP_CMAC eml__MolarEnergyMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MolarEnergyUom'
        enum eml__MolarEnergyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MolarEnergyMeasure, default initialized and not managed by a soap context
        virtual eml__MolarEnergyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MolarEnergyMeasure); }
      public:
        /// Constructor with initializations
        eml__MolarEnergyMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MolarEnergyUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MolarEnergyMeasure() { }
        /// Friend allocator used by soap_new_eml__MolarEnergyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MolarEnergyMeasure * SOAP_FMAC2 soap_instantiate_eml__MolarEnergyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1282 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeMeasure (379)
/* simple XSD type 'eml:LengthPerVolumeMeasure': */
class SOAP_CMAC eml__LengthPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LengthPerVolumeUom'
        enum eml__LengthPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LengthPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__LengthPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__LengthPerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LengthPerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LengthPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__LengthPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LengthPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__LengthPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1285 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaMeasure (380)
/* simple XSD type 'eml:SecondMomentOfAreaMeasure': */
class SOAP_CMAC eml__SecondMomentOfAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:SecondMomentOfAreaUom'
        enum eml__SecondMomentOfAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__SecondMomentOfAreaMeasure, default initialized and not managed by a soap context
        virtual eml__SecondMomentOfAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__SecondMomentOfAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__SecondMomentOfAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__SecondMomentOfAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__SecondMomentOfAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__SecondMomentOfAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__SecondMomentOfAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__SecondMomentOfAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1288 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityMeasure (381)
/* simple XSD type 'eml:MagneticFluxDensityMeasure': */
class SOAP_CMAC eml__MagneticFluxDensityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MagneticFluxDensityUom'
        enum eml__MagneticFluxDensityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MagneticFluxDensityMeasure, default initialized and not managed by a soap context
        virtual eml__MagneticFluxDensityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticFluxDensityMeasure); }
      public:
        /// Constructor with initializations
        eml__MagneticFluxDensityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MagneticFluxDensityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MagneticFluxDensityMeasure() { }
        /// Friend allocator used by soap_new_eml__MagneticFluxDensityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MagneticFluxDensityMeasure * SOAP_FMAC2 soap_instantiate_eml__MagneticFluxDensityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1291 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaMeasure (382)
/* simple XSD type 'eml:VolumePerAreaMeasure': */
class SOAP_CMAC eml__VolumePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerAreaUom'
        enum eml__VolumePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1294 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightMeasure (383)
/* simple XSD type 'eml:QuantityOfLightMeasure': */
class SOAP_CMAC eml__QuantityOfLightMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:QuantityOfLightUom'
        enum eml__QuantityOfLightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__QuantityOfLightMeasure, default initialized and not managed by a soap context
        virtual eml__QuantityOfLightMeasure *soap_alloc(void) const { return SOAP_NEW(eml__QuantityOfLightMeasure); }
      public:
        /// Constructor with initializations
        eml__QuantityOfLightMeasure()
        {
          __item = (double)0;
          uom = (enum eml__QuantityOfLightUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__QuantityOfLightMeasure() { }
        /// Friend allocator used by soap_new_eml__QuantityOfLightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__QuantityOfLightMeasure * SOAP_FMAC2 soap_instantiate_eml__QuantityOfLightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1297 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyMeasure (384)
/* simple XSD type 'eml:LuminousEfficacyMeasure': */
class SOAP_CMAC eml__LuminousEfficacyMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LuminousEfficacyUom'
        enum eml__LuminousEfficacyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LuminousEfficacyMeasure, default initialized and not managed by a soap context
        virtual eml__LuminousEfficacyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LuminousEfficacyMeasure); }
      public:
        /// Constructor with initializations
        eml__LuminousEfficacyMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LuminousEfficacyUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LuminousEfficacyMeasure() { }
        /// Friend allocator used by soap_new_eml__LuminousEfficacyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LuminousEfficacyMeasure * SOAP_FMAC2 soap_instantiate_eml__LuminousEfficacyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1300 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeMeasure (385)
/* simple XSD type 'eml:AreaPerTimeMeasure': */
class SOAP_CMAC eml__AreaPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AreaPerTimeUom'
        enum eml__AreaPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AreaPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__AreaPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__AreaPerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AreaPerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AreaPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__AreaPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AreaPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__AreaPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1303 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateMeasure (386)
/* simple XSD type 'eml:VolumeFlowRatePerVolumeFlowRateMeasure': */
class SOAP_CMAC eml__VolumeFlowRatePerVolumeFlowRateMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumeFlowRatePerVolumeFlowRateUom'
        enum eml__VolumeFlowRatePerVolumeFlowRateUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumeFlowRatePerVolumeFlowRateMeasure, default initialized and not managed by a soap context
        virtual eml__VolumeFlowRatePerVolumeFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumeFlowRatePerVolumeFlowRateMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumeFlowRatePerVolumeFlowRateMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumeFlowRatePerVolumeFlowRateUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumeFlowRatePerVolumeFlowRateMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumeFlowRatePerVolumeFlowRateMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumeFlowRatePerVolumeFlowRateMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumeFlowRatePerVolumeFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1306 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumMeasure (387)
/* simple XSD type 'eml:MomentumMeasure': */
class SOAP_CMAC eml__MomentumMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MomentumUom'
        enum eml__MomentumUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MomentumMeasure, default initialized and not managed by a soap context
        virtual eml__MomentumMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MomentumMeasure); }
      public:
        /// Constructor with initializations
        eml__MomentumMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MomentumUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MomentumMeasure() { }
        /// Friend allocator used by soap_new_eml__MomentumMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MomentumMeasure * SOAP_FMAC2 soap_instantiate_eml__MomentumMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1309 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeMeasure (388)
/* simple XSD type 'eml:PowerPerVolumeMeasure': */
class SOAP_CMAC eml__PowerPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PowerPerVolumeUom'
        enum eml__PowerPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PowerPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__PowerPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PowerPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__PowerPerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PowerPerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PowerPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__PowerPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PowerPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__PowerPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1312 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityMeasure (389)
/* simple XSD type 'eml:ThermalDiffusivityMeasure': */
class SOAP_CMAC eml__ThermalDiffusivityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ThermalDiffusivityUom'
        enum eml__ThermalDiffusivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ThermalDiffusivityMeasure, default initialized and not managed by a soap context
        virtual eml__ThermalDiffusivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalDiffusivityMeasure); }
      public:
        /// Constructor with initializations
        eml__ThermalDiffusivityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ThermalDiffusivityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ThermalDiffusivityMeasure() { }
        /// Friend allocator used by soap_new_eml__ThermalDiffusivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ThermalDiffusivityMeasure * SOAP_FMAC2 soap_instantiate_eml__ThermalDiffusivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1315 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthMeasure (390)
/* simple XSD type 'eml:LogarithmicPowerRatioPerLengthMeasure': */
class SOAP_CMAC eml__LogarithmicPowerRatioPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LogarithmicPowerRatioPerLengthUom'
        enum eml__LogarithmicPowerRatioPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LogarithmicPowerRatioPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__LogarithmicPowerRatioPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LogarithmicPowerRatioPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__LogarithmicPowerRatioPerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LogarithmicPowerRatioPerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LogarithmicPowerRatioPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__LogarithmicPowerRatioPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LogarithmicPowerRatioPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__LogarithmicPowerRatioPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1318 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeMeasure (391)
/* simple XSD type 'eml:ReciprocalTimeMeasure': */
class SOAP_CMAC eml__ReciprocalTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReciprocalTimeUom'
        enum eml__ReciprocalTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReciprocalTimeMeasure, default initialized and not managed by a soap context
        virtual eml__ReciprocalTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__ReciprocalTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReciprocalTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReciprocalTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__ReciprocalTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReciprocalTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__ReciprocalTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1321 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityMeasure (392)
/* simple XSD type 'eml:SpecificHeatCapacityMeasure': */
class SOAP_CMAC eml__SpecificHeatCapacityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:SpecificHeatCapacityUom'
        enum eml__SpecificHeatCapacityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__SpecificHeatCapacityMeasure, default initialized and not managed by a soap context
        virtual eml__SpecificHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__SpecificHeatCapacityMeasure); }
      public:
        /// Constructor with initializations
        eml__SpecificHeatCapacityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__SpecificHeatCapacityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__SpecificHeatCapacityMeasure() { }
        /// Friend allocator used by soap_new_eml__SpecificHeatCapacityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__SpecificHeatCapacityMeasure * SOAP_FMAC2 soap_instantiate_eml__SpecificHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1324 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropMeasure (393)
/* simple XSD type 'eml:PotentialDifferencePerPowerDropMeasure': */
class SOAP_CMAC eml__PotentialDifferencePerPowerDropMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PotentialDifferencePerPowerDropUom'
        enum eml__PotentialDifferencePerPowerDropUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PotentialDifferencePerPowerDropMeasure, default initialized and not managed by a soap context
        virtual eml__PotentialDifferencePerPowerDropMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PotentialDifferencePerPowerDropMeasure); }
      public:
        /// Constructor with initializations
        eml__PotentialDifferencePerPowerDropMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PotentialDifferencePerPowerDropUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PotentialDifferencePerPowerDropMeasure() { }
        /// Friend allocator used by soap_new_eml__PotentialDifferencePerPowerDropMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PotentialDifferencePerPowerDropMeasure * SOAP_FMAC2 soap_instantiate_eml__PotentialDifferencePerPowerDropMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1327 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaMeasure (394)
/* simple XSD type 'eml:MomentOfInertiaMeasure': */
class SOAP_CMAC eml__MomentOfInertiaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MomentOfInertiaUom'
        enum eml__MomentOfInertiaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MomentOfInertiaMeasure, default initialized and not managed by a soap context
        virtual eml__MomentOfInertiaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MomentOfInertiaMeasure); }
      public:
        /// Constructor with initializations
        eml__MomentOfInertiaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MomentOfInertiaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MomentOfInertiaMeasure() { }
        /// Friend allocator used by soap_new_eml__MomentOfInertiaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MomentOfInertiaMeasure * SOAP_FMAC2 soap_instantiate_eml__MomentOfInertiaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1330 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthMeasure (395)
/* simple XSD type 'eml:MassPerTimePerLengthMeasure': */
class SOAP_CMAC eml__MassPerTimePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassPerTimePerLengthUom'
        enum eml__MassPerTimePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassPerTimePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__MassPerTimePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerTimePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__MassPerTimePerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassPerTimePerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassPerTimePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__MassPerTimePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassPerTimePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__MassPerTimePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1333 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightMeasure (396)
/* simple XSD type 'eml:MolecularWeightMeasure': */
class SOAP_CMAC eml__MolecularWeightMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MolecularWeightUom'
        enum eml__MolecularWeightUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MolecularWeightMeasure, default initialized and not managed by a soap context
        virtual eml__MolecularWeightMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MolecularWeightMeasure); }
      public:
        /// Constructor with initializations
        eml__MolecularWeightMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MolecularWeightUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MolecularWeightMeasure() { }
        /// Friend allocator used by soap_new_eml__MolecularWeightMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MolecularWeightMeasure * SOAP_FMAC2 soap_instantiate_eml__MolecularWeightMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1336 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityMeasure (397)
/* simple XSD type 'eml:ActivityOfRadioactivityMeasure': */
class SOAP_CMAC eml__ActivityOfRadioactivityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ActivityOfRadioactivityUom'
        enum eml__ActivityOfRadioactivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ActivityOfRadioactivityMeasure, default initialized and not managed by a soap context
        virtual eml__ActivityOfRadioactivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ActivityOfRadioactivityMeasure); }
      public:
        /// Constructor with initializations
        eml__ActivityOfRadioactivityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ActivityOfRadioactivityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ActivityOfRadioactivityMeasure() { }
        /// Friend allocator used by soap_new_eml__ActivityOfRadioactivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ActivityOfRadioactivityMeasure * SOAP_FMAC2 soap_instantiate_eml__ActivityOfRadioactivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1339 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeMeasure (398)
/* simple XSD type 'eml:SignalingEventPerTimeMeasure': */
class SOAP_CMAC eml__SignalingEventPerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:SignalingEventPerTimeUom'
        enum eml__SignalingEventPerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__SignalingEventPerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__SignalingEventPerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__SignalingEventPerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__SignalingEventPerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__SignalingEventPerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__SignalingEventPerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__SignalingEventPerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__SignalingEventPerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__SignalingEventPerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1342 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyMeasure (399)
/* simple XSD type 'eml:FrequencyMeasure': */
class SOAP_CMAC eml__FrequencyMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:FrequencyUom'
        enum eml__FrequencyUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__FrequencyMeasure, default initialized and not managed by a soap context
        virtual eml__FrequencyMeasure *soap_alloc(void) const { return SOAP_NEW(eml__FrequencyMeasure); }
      public:
        /// Constructor with initializations
        eml__FrequencyMeasure()
        {
          __item = (double)0;
          uom = (enum eml__FrequencyUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__FrequencyMeasure() { }
        /// Friend allocator used by soap_new_eml__FrequencyMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__FrequencyMeasure * SOAP_FMAC2 soap_instantiate_eml__FrequencyMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1345 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalMeasure (400)
/* simple XSD type 'eml:FrequencyIntervalMeasure': */
class SOAP_CMAC eml__FrequencyIntervalMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:FrequencyIntervalUom'
        enum eml__FrequencyIntervalUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__FrequencyIntervalMeasure, default initialized and not managed by a soap context
        virtual eml__FrequencyIntervalMeasure *soap_alloc(void) const { return SOAP_NEW(eml__FrequencyIntervalMeasure); }
      public:
        /// Constructor with initializations
        eml__FrequencyIntervalMeasure()
        {
          __item = (double)0;
          uom = (enum eml__FrequencyIntervalUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__FrequencyIntervalMeasure() { }
        /// Friend allocator used by soap_new_eml__FrequencyIntervalMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__FrequencyIntervalMeasure * SOAP_FMAC2 soap_instantiate_eml__FrequencyIntervalMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1348 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceMeasure (401)
/* simple XSD type 'eml:CapacitanceMeasure': */
class SOAP_CMAC eml__CapacitanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:CapacitanceUom'
        enum eml__CapacitanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__CapacitanceMeasure, default initialized and not managed by a soap context
        virtual eml__CapacitanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__CapacitanceMeasure); }
      public:
        /// Constructor with initializations
        eml__CapacitanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__CapacitanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__CapacitanceMeasure() { }
        /// Friend allocator used by soap_new_eml__CapacitanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__CapacitanceMeasure * SOAP_FMAC2 soap_instantiate_eml__CapacitanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1351 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityMeasure (402)
/* simple XSD type 'eml:ElectricalResistivityMeasure': */
class SOAP_CMAC eml__ElectricalResistivityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricalResistivityUom'
        enum eml__ElectricalResistivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricalResistivityMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricalResistivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricalResistivityMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricalResistivityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricalResistivityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricalResistivityMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricalResistivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricalResistivityMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricalResistivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1354 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthMeasure (403)
/* simple XSD type 'eml:MassLengthMeasure': */
class SOAP_CMAC eml__MassLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassLengthUom'
        enum eml__MassLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassLengthMeasure, default initialized and not managed by a soap context
        virtual eml__MassLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__MassLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__MassLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__MassLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1357 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaMeasure (404)
/* simple XSD type 'eml:ReciprocalAreaMeasure': */
class SOAP_CMAC eml__ReciprocalAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReciprocalAreaUom'
        enum eml__ReciprocalAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReciprocalAreaMeasure, default initialized and not managed by a soap context
        virtual eml__ReciprocalAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__ReciprocalAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReciprocalAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReciprocalAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__ReciprocalAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReciprocalAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__ReciprocalAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1360 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityMeasure (405)
/* simple XSD type 'eml:KinematicViscosityMeasure': */
class SOAP_CMAC eml__KinematicViscosityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:KinematicViscosityUom'
        enum eml__KinematicViscosityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__KinematicViscosityMeasure, default initialized and not managed by a soap context
        virtual eml__KinematicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__KinematicViscosityMeasure); }
      public:
        /// Constructor with initializations
        eml__KinematicViscosityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__KinematicViscosityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__KinematicViscosityMeasure() { }
        /// Friend allocator used by soap_new_eml__KinematicViscosityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__KinematicViscosityMeasure * SOAP_FMAC2 soap_instantiate_eml__KinematicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1363 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceMeasure (406)
/* simple XSD type 'eml:InductanceMeasure': */
class SOAP_CMAC eml__InductanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:InductanceUom'
        enum eml__InductanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__InductanceMeasure, default initialized and not managed by a soap context
        virtual eml__InductanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__InductanceMeasure); }
      public:
        /// Constructor with initializations
        eml__InductanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__InductanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__InductanceMeasure() { }
        /// Friend allocator used by soap_new_eml__InductanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__InductanceMeasure * SOAP_FMAC2 soap_instantiate_eml__InductanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1366 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeMeasure (407)
/* simple XSD type 'eml:TimePerVolumeMeasure': */
class SOAP_CMAC eml__TimePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:TimePerVolumeUom'
        enum eml__TimePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__TimePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__TimePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__TimePerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__TimePerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__TimePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__TimePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__TimePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__TimePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1369 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentMeasure (408)
/* simple XSD type 'eml:ElectromagneticMomentMeasure': */
class SOAP_CMAC eml__ElectromagneticMomentMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectromagneticMomentUom'
        enum eml__ElectromagneticMomentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectromagneticMomentMeasure, default initialized and not managed by a soap context
        virtual eml__ElectromagneticMomentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectromagneticMomentMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectromagneticMomentMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectromagneticMomentUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectromagneticMomentMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectromagneticMomentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectromagneticMomentMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectromagneticMomentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1372 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeMeasure (409)
/* simple XSD type 'eml:EnergyPerVolumeMeasure': */
class SOAP_CMAC eml__EnergyPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:EnergyPerVolumeUom'
        enum eml__EnergyPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__EnergyPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__EnergyPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__EnergyPerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__EnergyPerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__EnergyPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__EnergyPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__EnergyPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__EnergyPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1375 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeMeasure (410)
/* simple XSD type 'eml:ElectricChargePerVolumeMeasure': */
class SOAP_CMAC eml__ElectricChargePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricChargePerVolumeUom'
        enum eml__ElectricChargePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricChargePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricChargePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricChargePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricChargePerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricChargePerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricChargePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricChargePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricChargePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricChargePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1378 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientMeasure (411)
/* simple XSD type 'eml:VolumetricHeatTransferCoefficientMeasure': */
class SOAP_CMAC eml__VolumetricHeatTransferCoefficientMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumetricHeatTransferCoefficientUom'
        enum eml__VolumetricHeatTransferCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumetricHeatTransferCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml__VolumetricHeatTransferCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumetricHeatTransferCoefficientMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumetricHeatTransferCoefficientMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumetricHeatTransferCoefficientUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumetricHeatTransferCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumetricHeatTransferCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumetricHeatTransferCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumetricHeatTransferCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1381 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeMeasure (412)
/* simple XSD type 'eml:PressurePerVolumeMeasure': */
class SOAP_CMAC eml__PressurePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PressurePerVolumeUom'
        enum eml__PressurePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PressurePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__PressurePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressurePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__PressurePerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PressurePerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PressurePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__PressurePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PressurePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__PressurePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1384 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassMeasure (413)
/* simple XSD type 'eml:TimePerMassMeasure': */
class SOAP_CMAC eml__TimePerMassMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:TimePerMassUom'
        enum eml__TimePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__TimePerMassMeasure, default initialized and not managed by a soap context
        virtual eml__TimePerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimePerMassMeasure); }
      public:
        /// Constructor with initializations
        eml__TimePerMassMeasure()
        {
          __item = (double)0;
          uom = (enum eml__TimePerMassUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__TimePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml__TimePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__TimePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml__TimePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1387 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthMeasure (414)
/* simple XSD type 'eml:ReciprocalLengthMeasure': */
class SOAP_CMAC eml__ReciprocalLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReciprocalLengthUom'
        enum eml__ReciprocalLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReciprocalLengthMeasure, default initialized and not managed by a soap context
        virtual eml__ReciprocalLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__ReciprocalLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReciprocalLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReciprocalLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__ReciprocalLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReciprocalLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__ReciprocalLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1390 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityMeasure (415)
/* simple XSD type 'eml:DynamicViscosityMeasure': */
class SOAP_CMAC eml__DynamicViscosityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:DynamicViscosityUom'
        enum eml__DynamicViscosityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__DynamicViscosityMeasure, default initialized and not managed by a soap context
        virtual eml__DynamicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DynamicViscosityMeasure); }
      public:
        /// Constructor with initializations
        eml__DynamicViscosityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__DynamicViscosityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__DynamicViscosityMeasure() { }
        /// Friend allocator used by soap_new_eml__DynamicViscosityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__DynamicViscosityMeasure * SOAP_FMAC2 soap_instantiate_eml__DynamicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1393 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceMeasure (416)
/* simple XSD type 'eml:ReciprocalElectricPotentialDifferenceMeasure': */
class SOAP_CMAC eml__ReciprocalElectricPotentialDifferenceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReciprocalElectricPotentialDifferenceUom'
        enum eml__ReciprocalElectricPotentialDifferenceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReciprocalElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
        virtual eml__ReciprocalElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalElectricPotentialDifferenceMeasure); }
      public:
        /// Constructor with initializations
        eml__ReciprocalElectricPotentialDifferenceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReciprocalElectricPotentialDifferenceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReciprocalElectricPotentialDifferenceMeasure() { }
        /// Friend allocator used by soap_new_eml__ReciprocalElectricPotentialDifferenceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReciprocalElectricPotentialDifferenceMeasure * SOAP_FMAC2 soap_instantiate_eml__ReciprocalElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1396 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassMeasure (417)
/* simple XSD type 'eml:ElectricChargePerMassMeasure': */
class SOAP_CMAC eml__ElectricChargePerMassMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricChargePerMassUom'
        enum eml__ElectricChargePerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricChargePerMassMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricChargePerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricChargePerMassMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricChargePerMassMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricChargePerMassUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricChargePerMassMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricChargePerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricChargePerMassMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricChargePerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1399 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayMeasure (418)
/* simple XSD type 'eml:APIGammaRayMeasure': */
class SOAP_CMAC eml__APIGammaRayMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:APIGammaRayUom'
        enum eml__APIGammaRayUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__APIGammaRayMeasure, default initialized and not managed by a soap context
        virtual eml__APIGammaRayMeasure *soap_alloc(void) const { return SOAP_NEW(eml__APIGammaRayMeasure); }
      public:
        /// Constructor with initializations
        eml__APIGammaRayMeasure()
        {
          __item = (double)0;
          uom = (enum eml__APIGammaRayUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__APIGammaRayMeasure() { }
        /// Friend allocator used by soap_new_eml__APIGammaRayMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__APIGammaRayMeasure * SOAP_FMAC2 soap_instantiate_eml__APIGammaRayMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1402 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientMeasure (419)
/* simple XSD type 'eml:DiffusionCoefficientMeasure': */
class SOAP_CMAC eml__DiffusionCoefficientMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:DiffusionCoefficientUom'
        enum eml__DiffusionCoefficientUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__DiffusionCoefficientMeasure, default initialized and not managed by a soap context
        virtual eml__DiffusionCoefficientMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DiffusionCoefficientMeasure); }
      public:
        /// Constructor with initializations
        eml__DiffusionCoefficientMeasure()
        {
          __item = (double)0;
          uom = (enum eml__DiffusionCoefficientUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__DiffusionCoefficientMeasure() { }
        /// Friend allocator used by soap_new_eml__DiffusionCoefficientMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__DiffusionCoefficientMeasure * SOAP_FMAC2 soap_instantiate_eml__DiffusionCoefficientMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1405 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceMeasure (420)
/* simple XSD type 'eml:ElectricPotentialDifferenceMeasure': */
class SOAP_CMAC eml__ElectricPotentialDifferenceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricPotentialDifferenceUom'
        enum eml__ElectricPotentialDifferenceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricPotentialDifferenceMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricPotentialDifferenceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricPotentialDifferenceMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricPotentialDifferenceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricPotentialDifferenceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricPotentialDifferenceMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricPotentialDifferenceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricPotentialDifferenceMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricPotentialDifferenceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1408 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityMeasure (421)
/* simple XSD type 'eml:IsothermalCompressibilityMeasure': */
class SOAP_CMAC eml__IsothermalCompressibilityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:IsothermalCompressibilityUom'
        enum eml__IsothermalCompressibilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__IsothermalCompressibilityMeasure, default initialized and not managed by a soap context
        virtual eml__IsothermalCompressibilityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__IsothermalCompressibilityMeasure); }
      public:
        /// Constructor with initializations
        eml__IsothermalCompressibilityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__IsothermalCompressibilityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__IsothermalCompressibilityMeasure() { }
        /// Friend allocator used by soap_new_eml__IsothermalCompressibilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__IsothermalCompressibilityMeasure * SOAP_FMAC2 soap_instantiate_eml__IsothermalCompressibilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1411 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthMeasure (422)
/* simple XSD type 'eml:MassPerVolumePerLengthMeasure': */
class SOAP_CMAC eml__MassPerVolumePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassPerVolumePerLengthUom'
        enum eml__MassPerVolumePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassPerVolumePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__MassPerVolumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerVolumePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__MassPerVolumePerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassPerVolumePerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassPerVolumePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__MassPerVolumePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassPerVolumePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__MassPerVolumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1414 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeMeasure (423)
/* simple XSD type 'eml:PressurePerTimeMeasure': */
class SOAP_CMAC eml__PressurePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PressurePerTimeUom'
        enum eml__PressurePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PressurePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__PressurePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressurePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__PressurePerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PressurePerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PressurePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__PressurePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PressurePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__PressurePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1417 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthMeasure (424)
/* simple XSD type 'eml:ForcePerLengthMeasure': */
class SOAP_CMAC eml__ForcePerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ForcePerLengthUom'
        enum eml__ForcePerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ForcePerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__ForcePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ForcePerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__ForcePerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ForcePerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ForcePerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__ForcePerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ForcePerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__ForcePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1420 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeMeasure (425)
/* simple XSD type 'eml:AmountOfSubstancePerTimeMeasure': */
class SOAP_CMAC eml__AmountOfSubstancePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AmountOfSubstancePerTimeUom'
        enum eml__AmountOfSubstancePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AmountOfSubstancePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__AmountOfSubstancePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__AmountOfSubstancePerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AmountOfSubstancePerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AmountOfSubstancePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__AmountOfSubstancePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AmountOfSubstancePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__AmountOfSubstancePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1423 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureMeasure (426)
/* simple XSD type 'eml:LengthPerTemperatureMeasure': */
class SOAP_CMAC eml__LengthPerTemperatureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LengthPerTemperatureUom'
        enum eml__LengthPerTemperatureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LengthPerTemperatureMeasure, default initialized and not managed by a soap context
        virtual eml__LengthPerTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerTemperatureMeasure); }
      public:
        /// Constructor with initializations
        eml__LengthPerTemperatureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LengthPerTemperatureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LengthPerTemperatureMeasure() { }
        /// Friend allocator used by soap_new_eml__LengthPerTemperatureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LengthPerTemperatureMeasure * SOAP_FMAC2 soap_instantiate_eml__LengthPerTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1426 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthMeasure (427)
/* simple XSD type 'eml:VolumePerTimeLengthMeasure': */
class SOAP_CMAC eml__VolumePerTimeLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerTimeLengthUom'
        enum eml__VolumePerTimeLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerTimeLengthMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerTimeLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimeLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerTimeLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerTimeLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerTimeLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerTimeLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerTimeLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerTimeLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1429 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaMeasure (428)
/* simple XSD type 'eml:PressureSquaredPerForceTimePerAreaMeasure': */
class SOAP_CMAC eml__PressureSquaredPerForceTimePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PressureSquaredPerForceTimePerAreaUom'
        enum eml__PressureSquaredPerForceTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PressureSquaredPerForceTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__PressureSquaredPerForceTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressureSquaredPerForceTimePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__PressureSquaredPerForceTimePerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PressureSquaredPerForceTimePerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PressureSquaredPerForceTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__PressureSquaredPerForceTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PressureSquaredPerForceTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__PressureSquaredPerForceTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1432 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeMeasure (429)
/* simple XSD type 'eml:AnglePerVolumeMeasure': */
class SOAP_CMAC eml__AnglePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AnglePerVolumeUom'
        enum eml__AnglePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AnglePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__AnglePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AnglePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__AnglePerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AnglePerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AnglePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__AnglePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AnglePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__AnglePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1435 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureMeasure (430)
/* simple XSD type 'eml:LengthPerPressureMeasure': */
class SOAP_CMAC eml__LengthPerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LengthPerPressureUom'
        enum eml__LengthPerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LengthPerPressureMeasure, default initialized and not managed by a soap context
        virtual eml__LengthPerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml__LengthPerPressureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LengthPerPressureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LengthPerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml__LengthPerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LengthPerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml__LengthPerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1438 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityMeasure (431)
/* simple XSD type 'eml:ThermalConductivityMeasure': */
class SOAP_CMAC eml__ThermalConductivityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ThermalConductivityUom'
        enum eml__ThermalConductivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ThermalConductivityMeasure, default initialized and not managed by a soap context
        virtual eml__ThermalConductivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ThermalConductivityMeasure); }
      public:
        /// Constructor with initializations
        eml__ThermalConductivityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ThermalConductivityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ThermalConductivityMeasure() { }
        /// Friend allocator used by soap_new_eml__ThermalConductivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ThermalConductivityMeasure * SOAP_FMAC2 soap_instantiate_eml__ThermalConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1441 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassMeasure (432)
/* simple XSD type 'eml:MassMeasure': */
class SOAP_CMAC eml__MassMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassUom'
        enum eml__MassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassMeasure, default initialized and not managed by a soap context
        virtual eml__MassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassMeasure); }
      public:
        /// Constructor with initializations
        eml__MassMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassMeasure() { }
        /// Friend allocator used by soap_new_eml__MassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassMeasure * SOAP_FMAC2 soap_instantiate_eml__MassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1444 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerMeasure (433)
/* simple XSD type 'eml:NormalizedPowerMeasure': */
class SOAP_CMAC eml__NormalizedPowerMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:NormalizedPowerUom'
        enum eml__NormalizedPowerUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__NormalizedPowerMeasure, default initialized and not managed by a soap context
        virtual eml__NormalizedPowerMeasure *soap_alloc(void) const { return SOAP_NEW(eml__NormalizedPowerMeasure); }
      public:
        /// Constructor with initializations
        eml__NormalizedPowerMeasure()
        {
          __item = (double)0;
          uom = (enum eml__NormalizedPowerUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__NormalizedPowerMeasure() { }
        /// Friend allocator used by soap_new_eml__NormalizedPowerMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__NormalizedPowerMeasure * SOAP_FMAC2 soap_instantiate_eml__NormalizedPowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1447 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioMeasure (434)
/* simple XSD type 'eml:LogarithmicPowerRatioMeasure': */
class SOAP_CMAC eml__LogarithmicPowerRatioMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LogarithmicPowerRatioUom'
        enum eml__LogarithmicPowerRatioUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LogarithmicPowerRatioMeasure, default initialized and not managed by a soap context
        virtual eml__LogarithmicPowerRatioMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LogarithmicPowerRatioMeasure); }
      public:
        /// Constructor with initializations
        eml__LogarithmicPowerRatioMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LogarithmicPowerRatioUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LogarithmicPowerRatioMeasure() { }
        /// Friend allocator used by soap_new_eml__LogarithmicPowerRatioMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LogarithmicPowerRatioMeasure * SOAP_FMAC2 soap_instantiate_eml__LogarithmicPowerRatioMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1450 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationMeasure (435)
/* simple XSD type 'eml:AngularAccelerationMeasure': */
class SOAP_CMAC eml__AngularAccelerationMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AngularAccelerationUom'
        enum eml__AngularAccelerationUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AngularAccelerationMeasure, default initialized and not managed by a soap context
        virtual eml__AngularAccelerationMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AngularAccelerationMeasure); }
      public:
        /// Constructor with initializations
        eml__AngularAccelerationMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AngularAccelerationUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AngularAccelerationMeasure() { }
        /// Friend allocator used by soap_new_eml__AngularAccelerationMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AngularAccelerationMeasure * SOAP_FMAC2 soap_instantiate_eml__AngularAccelerationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1453 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassMeasure (436)
/* simple XSD type 'eml:ReciprocalMassMeasure': */
class SOAP_CMAC eml__ReciprocalMassMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReciprocalMassUom'
        enum eml__ReciprocalMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReciprocalMassMeasure, default initialized and not managed by a soap context
        virtual eml__ReciprocalMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalMassMeasure); }
      public:
        /// Constructor with initializations
        eml__ReciprocalMassMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReciprocalMassUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReciprocalMassMeasure() { }
        /// Friend allocator used by soap_new_eml__ReciprocalMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReciprocalMassMeasure * SOAP_FMAC2 soap_instantiate_eml__ReciprocalMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1456 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceMeasure (437)
/* simple XSD type 'eml:ReciprocalForceMeasure': */
class SOAP_CMAC eml__ReciprocalForceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ReciprocalForceUom'
        enum eml__ReciprocalForceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ReciprocalForceMeasure, default initialized and not managed by a soap context
        virtual eml__ReciprocalForceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ReciprocalForceMeasure); }
      public:
        /// Constructor with initializations
        eml__ReciprocalForceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ReciprocalForceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ReciprocalForceMeasure() { }
        /// Friend allocator used by soap_new_eml__ReciprocalForceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ReciprocalForceMeasure * SOAP_FMAC2 soap_instantiate_eml__ReciprocalForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1459 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleMeasure (438)
/* simple XSD type 'eml:PlaneAngleMeasure': */
class SOAP_CMAC eml__PlaneAngleMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PlaneAngleUom'
        enum eml__PlaneAngleUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PlaneAngleMeasure, default initialized and not managed by a soap context
        virtual eml__PlaneAngleMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PlaneAngleMeasure); }
      public:
        /// Constructor with initializations
        eml__PlaneAngleMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PlaneAngleUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PlaneAngleMeasure() { }
        /// Friend allocator used by soap_new_eml__PlaneAngleMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PlaneAngleMeasure * SOAP_FMAC2 soap_instantiate_eml__PlaneAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1462 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaMeasure (439)
/* simple XSD type 'eml:EnergyLengthPerAreaMeasure': */
class SOAP_CMAC eml__EnergyLengthPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:EnergyLengthPerAreaUom'
        enum eml__EnergyLengthPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__EnergyLengthPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__EnergyLengthPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyLengthPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__EnergyLengthPerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__EnergyLengthPerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__EnergyLengthPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__EnergyLengthPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__EnergyLengthPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__EnergyLengthPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1465 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassMeasure (440)
/* simple XSD type 'eml:EnergyPerMassMeasure': */
class SOAP_CMAC eml__EnergyPerMassMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:EnergyPerMassUom'
        enum eml__EnergyPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__EnergyPerMassMeasure, default initialized and not managed by a soap context
        virtual eml__EnergyPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__EnergyPerMassMeasure); }
      public:
        /// Constructor with initializations
        eml__EnergyPerMassMeasure()
        {
          __item = (double)0;
          uom = (enum eml__EnergyPerMassUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__EnergyPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml__EnergyPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__EnergyPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml__EnergyPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1468 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityMeasure (441)
/* simple XSD type 'eml:AngularVelocityMeasure': */
class SOAP_CMAC eml__AngularVelocityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AngularVelocityUom'
        enum eml__AngularVelocityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AngularVelocityMeasure, default initialized and not managed by a soap context
        virtual eml__AngularVelocityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AngularVelocityMeasure); }
      public:
        /// Constructor with initializations
        eml__AngularVelocityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AngularVelocityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AngularVelocityMeasure() { }
        /// Friend allocator used by soap_new_eml__AngularVelocityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AngularVelocityMeasure * SOAP_FMAC2 soap_instantiate_eml__AngularVelocityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1471 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityMeasure (442)
/* simple XSD type 'eml:ElectricConductivityMeasure': */
class SOAP_CMAC eml__ElectricConductivityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricConductivityUom'
        enum eml__ElectricConductivityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricConductivityMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricConductivityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricConductivityMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricConductivityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricConductivityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricConductivityMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricConductivityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricConductivityMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1474 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceMeasure (443)
/* simple XSD type 'eml:AmountOfSubstancePerAmountOfSubstanceMeasure': */
class SOAP_CMAC eml__AmountOfSubstancePerAmountOfSubstanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AmountOfSubstancePerAmountOfSubstanceUom'
        enum eml__AmountOfSubstancePerAmountOfSubstanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AmountOfSubstancePerAmountOfSubstanceMeasure, default initialized and not managed by a soap context
        virtual eml__AmountOfSubstancePerAmountOfSubstanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerAmountOfSubstanceMeasure); }
      public:
        /// Constructor with initializations
        eml__AmountOfSubstancePerAmountOfSubstanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AmountOfSubstancePerAmountOfSubstanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AmountOfSubstancePerAmountOfSubstanceMeasure() { }
        /// Friend allocator used by soap_new_eml__AmountOfSubstancePerAmountOfSubstanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AmountOfSubstancePerAmountOfSubstanceMeasure * SOAP_FMAC2 soap_instantiate_eml__AmountOfSubstancePerAmountOfSubstanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1477 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthMeasure (444)
/* simple XSD type 'eml:ElectricFieldStrengthMeasure': */
class SOAP_CMAC eml__ElectricFieldStrengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricFieldStrengthUom'
        enum eml__ElectricFieldStrengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricFieldStrengthMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricFieldStrengthMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricFieldStrengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricFieldStrengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricFieldStrengthMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricFieldStrengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricFieldStrengthMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1480 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaMeasure (445)
/* simple XSD type 'eml:PowerPerAreaMeasure': */
class SOAP_CMAC eml__PowerPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PowerPerAreaUom'
        enum eml__PowerPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PowerPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__PowerPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PowerPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__PowerPerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PowerPerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PowerPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__PowerPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PowerPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__PowerPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1483 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthMeasure (446)
/* simple XSD type 'eml:MagneticFluxDensityPerLengthMeasure': */
class SOAP_CMAC eml__MagneticFluxDensityPerLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MagneticFluxDensityPerLengthUom'
        enum eml__MagneticFluxDensityPerLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MagneticFluxDensityPerLengthMeasure, default initialized and not managed by a soap context
        virtual eml__MagneticFluxDensityPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticFluxDensityPerLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__MagneticFluxDensityPerLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MagneticFluxDensityPerLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MagneticFluxDensityPerLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__MagneticFluxDensityPerLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MagneticFluxDensityPerLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__MagneticFluxDensityPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1486 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureMeasure (447)
/* simple XSD type 'eml:PressureMeasure': */
class SOAP_CMAC eml__PressureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PressureUom'
        enum eml__PressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PressureMeasure, default initialized and not managed by a soap context
        virtual eml__PressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PressureMeasure); }
      public:
        /// Constructor with initializations
        eml__PressureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PressureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PressureMeasure() { }
        /// Friend allocator used by soap_new_eml__PressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PressureMeasure * SOAP_FMAC2 soap_instantiate_eml__PressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1489 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthMeasure (448)
/* simple XSD type 'eml:VolumePerTimePerPressureLengthMeasure': */
class SOAP_CMAC eml__VolumePerTimePerPressureLengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerTimePerPressureLengthUom'
        enum eml__VolumePerTimePerPressureLengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerTimePerPressureLengthMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerTimePerPressureLengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerTimePerPressureLengthMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerTimePerPressureLengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerTimePerPressureLengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerTimePerPressureLengthMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerTimePerPressureLengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerTimePerPressureLengthMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerTimePerPressureLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1492 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthMeasure (449)
/* simple XSD type 'eml:MagneticFieldStrengthMeasure': */
class SOAP_CMAC eml__MagneticFieldStrengthMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MagneticFieldStrengthUom'
        enum eml__MagneticFieldStrengthUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MagneticFieldStrengthMeasure, default initialized and not managed by a soap context
        virtual eml__MagneticFieldStrengthMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MagneticFieldStrengthMeasure); }
      public:
        /// Constructor with initializations
        eml__MagneticFieldStrengthMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MagneticFieldStrengthUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MagneticFieldStrengthMeasure() { }
        /// Friend allocator used by soap_new_eml__MagneticFieldStrengthMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MagneticFieldStrengthMeasure * SOAP_FMAC2 soap_instantiate_eml__MagneticFieldStrengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1495 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockMeasure (450)
/* simple XSD type 'eml:PermeabilityRockMeasure': */
class SOAP_CMAC eml__PermeabilityRockMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:PermeabilityRockUom'
        enum eml__PermeabilityRockUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__PermeabilityRockMeasure, default initialized and not managed by a soap context
        virtual eml__PermeabilityRockMeasure *soap_alloc(void) const { return SOAP_NEW(eml__PermeabilityRockMeasure); }
      public:
        /// Constructor with initializations
        eml__PermeabilityRockMeasure()
        {
          __item = (double)0;
          uom = (enum eml__PermeabilityRockUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__PermeabilityRockMeasure() { }
        /// Friend allocator used by soap_new_eml__PermeabilityRockMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__PermeabilityRockMeasure * SOAP_FMAC2 soap_instantiate_eml__PermeabilityRockMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1498 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentMeasure (451)
/* simple XSD type 'eml:DoseEquivalentMeasure': */
class SOAP_CMAC eml__DoseEquivalentMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:DoseEquivalentUom'
        enum eml__DoseEquivalentUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__DoseEquivalentMeasure, default initialized and not managed by a soap context
        virtual eml__DoseEquivalentMeasure *soap_alloc(void) const { return SOAP_NEW(eml__DoseEquivalentMeasure); }
      public:
        /// Constructor with initializations
        eml__DoseEquivalentMeasure()
        {
          __item = (double)0;
          uom = (enum eml__DoseEquivalentUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__DoseEquivalentMeasure() { }
        /// Friend allocator used by soap_new_eml__DoseEquivalentMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__DoseEquivalentMeasure * SOAP_FMAC2 soap_instantiate_eml__DoseEquivalentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1501 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaMeasure (452)
/* simple XSD type 'eml:MassPerTimePerAreaMeasure': */
class SOAP_CMAC eml__MassPerTimePerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassPerTimePerAreaUom'
        enum eml__MassPerTimePerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassPerTimePerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__MassPerTimePerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerTimePerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__MassPerTimePerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassPerTimePerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassPerTimePerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__MassPerTimePerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassPerTimePerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__MassPerTimePerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1504 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureMeasure (453)
/* simple XSD type 'eml:VolumePerPressureMeasure': */
class SOAP_CMAC eml__VolumePerPressureMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerPressureUom'
        enum eml__VolumePerPressureUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerPressureMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerPressureMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerPressureMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerPressureMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerPressureUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerPressureMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerPressureMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerPressureMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerPressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1507 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaMeasure (454)
/* simple XSD type 'eml:MassPerAreaMeasure': */
class SOAP_CMAC eml__MassPerAreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MassPerAreaUom'
        enum eml__MassPerAreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MassPerAreaMeasure, default initialized and not managed by a soap context
        virtual eml__MassPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MassPerAreaMeasure); }
      public:
        /// Constructor with initializations
        eml__MassPerAreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MassPerAreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MassPerAreaMeasure() { }
        /// Friend allocator used by soap_new_eml__MassPerAreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MassPerAreaMeasure * SOAP_FMAC2 soap_instantiate_eml__MassPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1510 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeMeasure (455)
/* simple XSD type 'eml:AmountOfSubstancePerVolumeMeasure': */
class SOAP_CMAC eml__AmountOfSubstancePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AmountOfSubstancePerVolumeUom'
        enum eml__AmountOfSubstancePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AmountOfSubstancePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__AmountOfSubstancePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AmountOfSubstancePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__AmountOfSubstancePerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AmountOfSubstancePerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AmountOfSubstancePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__AmountOfSubstancePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AmountOfSubstancePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__AmountOfSubstancePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1513 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeMeasure (456)
/* simple XSD type 'eml:TimePerTimeMeasure': */
class SOAP_CMAC eml__TimePerTimeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:TimePerTimeUom'
        enum eml__TimePerTimeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__TimePerTimeMeasure, default initialized and not managed by a soap context
        virtual eml__TimePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__TimePerTimeMeasure); }
      public:
        /// Constructor with initializations
        eml__TimePerTimeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__TimePerTimeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__TimePerTimeMeasure() { }
        /// Friend allocator used by soap_new_eml__TimePerTimeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__TimePerTimeMeasure * SOAP_FMAC2 soap_instantiate_eml__TimePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1516 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeMeasure (457)
/* simple XSD type 'eml:AreaPerVolumeMeasure': */
class SOAP_CMAC eml__AreaPerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AreaPerVolumeUom'
        enum eml__AreaPerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AreaPerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__AreaPerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaPerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__AreaPerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AreaPerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AreaPerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__AreaPerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AreaPerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__AreaPerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1519 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceMeasure (458)
/* simple XSD type 'eml:ElectricResistanceMeasure': */
class SOAP_CMAC eml__ElectricResistanceMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:ElectricResistanceUom'
        enum eml__ElectricResistanceUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__ElectricResistanceMeasure, default initialized and not managed by a soap context
        virtual eml__ElectricResistanceMeasure *soap_alloc(void) const { return SOAP_NEW(eml__ElectricResistanceMeasure); }
      public:
        /// Constructor with initializations
        eml__ElectricResistanceMeasure()
        {
          __item = (double)0;
          uom = (enum eml__ElectricResistanceUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__ElectricResistanceMeasure() { }
        /// Friend allocator used by soap_new_eml__ElectricResistanceMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__ElectricResistanceMeasure * SOAP_FMAC2 soap_instantiate_eml__ElectricResistanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1522 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeMeasure (459)
/* simple XSD type 'eml:VolumePerVolumeMeasure': */
class SOAP_CMAC eml__VolumePerVolumeMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:VolumePerVolumeUom'
        enum eml__VolumePerVolumeUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__VolumePerVolumeMeasure, default initialized and not managed by a soap context
        virtual eml__VolumePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(eml__VolumePerVolumeMeasure); }
      public:
        /// Constructor with initializations
        eml__VolumePerVolumeMeasure()
        {
          __item = (double)0;
          uom = (enum eml__VolumePerVolumeUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__VolumePerVolumeMeasure() { }
        /// Friend allocator used by soap_new_eml__VolumePerVolumeMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__VolumePerVolumeMeasure * SOAP_FMAC2 soap_instantiate_eml__VolumePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1525 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaMeasure (460)
/* simple XSD type 'eml:AreaMeasure': */
class SOAP_CMAC eml__AreaMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:AreaUom'
        enum eml__AreaUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__AreaMeasure, default initialized and not managed by a soap context
        virtual eml__AreaMeasure *soap_alloc(void) const { return SOAP_NEW(eml__AreaMeasure); }
      public:
        /// Constructor with initializations
        eml__AreaMeasure()
        {
          __item = (double)0;
          uom = (enum eml__AreaUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__AreaMeasure() { }
        /// Friend allocator used by soap_new_eml__AreaMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__AreaMeasure * SOAP_FMAC2 soap_instantiate_eml__AreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1528 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassMeasure (461)
/* simple XSD type 'eml:LengthPerMassMeasure': */
class SOAP_CMAC eml__LengthPerMassMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:LengthPerMassUom'
        enum eml__LengthPerMassUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__LengthPerMassMeasure, default initialized and not managed by a soap context
        virtual eml__LengthPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(eml__LengthPerMassMeasure); }
      public:
        /// Constructor with initializations
        eml__LengthPerMassMeasure()
        {
          __item = (double)0;
          uom = (enum eml__LengthPerMassUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__LengthPerMassMeasure() { }
        /// Friend allocator used by soap_new_eml__LengthPerMassMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__LengthPerMassMeasure * SOAP_FMAC2 soap_instantiate_eml__LengthPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1531 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityMeasure (462)
/* simple XSD type 'eml:MobilityMeasure': */
class SOAP_CMAC eml__MobilityMeasure {
      public:
        /// Simple content of XSD type 'eml:Measure' wrapped by this struct
        double __item;
        /// required attribute 'uom' of XSD type 'eml:MobilityUom'
        enum eml__MobilityUom uom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityMeasure
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityMeasure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type eml__MobilityMeasure, default initialized and not managed by a soap context
        virtual eml__MobilityMeasure *soap_alloc(void) const { return SOAP_NEW(eml__MobilityMeasure); }
      public:
        /// Constructor with initializations
        eml__MobilityMeasure()
        {
          __item = (double)0;
          uom = (enum eml__MobilityUom)0;
          soap = (struct soap *)0;
        }
        virtual ~eml__MobilityMeasure() { }
        /// Friend allocator used by soap_new_eml__MobilityMeasure(struct soap*, int)
        friend SOAP_FMAC1 eml__MobilityMeasure * SOAP_FMAC2 soap_instantiate_eml__MobilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1543 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionType (466)
/* Type gml__DefinitionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:DefinitionType': */
class SOAP_CMAC gml__DefinitionType : public gml__DefinitionBaseType {
      public:
        /// Optional element 'gml:remarks' of XSD type 'xsd:string'
        std::string *remarks;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__DefinitionType, default initialized and not managed by a soap context
        virtual gml__DefinitionType *soap_alloc(void) const { return SOAP_NEW(gml__DefinitionType); }
      public:
        /// Constructor with initializations
        gml__DefinitionType()
        {
          remarks = (std::string *)0;
        }
        virtual ~gml__DefinitionType() { }
        /// Friend allocator used by soap_new_gml__DefinitionType(struct soap*, int)
        friend SOAP_FMAC1 gml__DefinitionType * SOAP_FMAC2 soap_instantiate_gml__DefinitionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1558 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeWithAuthorityType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeWithAuthorityType (471)
/* simple XSD type 'gml:CodeWithAuthorityType': */
class SOAP_CMAC gml__CodeWithAuthorityType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// required attribute 'codeSpace' of XSD type 'xsd:anyURI'
        std::string codeSpace;
        /// optional attribute 'codeSpace' of XSD type 'xsd:anyURI'
        std::string *codeSpace_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeWithAuthorityType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeWithAuthorityType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CodeWithAuthorityType, default initialized and not managed by a soap context
        virtual gml__CodeWithAuthorityType *soap_alloc(void) const { return SOAP_NEW(gml__CodeWithAuthorityType); }
      public:
        /// Constructor with initializations
        gml__CodeWithAuthorityType()
        {
          codeSpace_ = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__CodeWithAuthorityType() { }
        /// Friend allocator used by soap_new_gml__CodeWithAuthorityType(struct soap*, int)
        friend SOAP_FMAC1 gml__CodeWithAuthorityType * SOAP_FMAC2 soap_instantiate_gml__CodeWithAuthorityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1564 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimePrimitiveType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimePrimitiveType (473)
/* Type gml__AbstractTimePrimitiveType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractTimePrimitiveType': */
class SOAP_CMAC gml__AbstractTimePrimitiveType : public gml__AbstractTimeObjectType {
      public:
        /// Optional element 'gml:relatedTime' of XSD type 'gml:RelatedTimeType'
        std::vector<gml__RelatedTimeType *> relatedTime;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimePrimitiveType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimePrimitiveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractTimePrimitiveType, default initialized and not managed by a soap context
        virtual gml__AbstractTimePrimitiveType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractTimePrimitiveType); }
      public:
        /// Constructor with initializations
        gml__AbstractTimePrimitiveType()
        {
        }
        virtual ~gml__AbstractTimePrimitiveType() { }
        /// Friend allocator used by soap_new_gml__AbstractTimePrimitiveType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractTimePrimitiveType * SOAP_FMAC2 soap_instantiate_gml__AbstractTimePrimitiveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1618 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AngleType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AngleType (491)
/* Type gml__AngleType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'gml:AngleType': */
class SOAP_CMAC gml__AngleType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AngleType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AngleType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AngleType, default initialized and not managed by a soap context
        virtual gml__AngleType *soap_alloc(void) const { return SOAP_NEW(gml__AngleType); }
      public:
        /// Constructor with initializations
        gml__AngleType()
        {
        }
        virtual ~gml__AngleType() { }
        /// Friend allocator used by soap_new_gml__AngleType(struct soap*, int)
        friend SOAP_FMAC1 gml__AngleType * SOAP_FMAC2 soap_instantiate_gml__AngleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1630 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__LengthType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__LengthType (495)
/* Type gml__LengthType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'gml:LengthType': */
class SOAP_CMAC gml__LengthType : public gml__MeasureType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__LengthType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__LengthType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__LengthType, default initialized and not managed by a soap context
        virtual gml__LengthType *soap_alloc(void) const { return SOAP_NEW(gml__LengthType); }
      public:
        /// Constructor with initializations
        gml__LengthType()
        {
        }
        virtual ~gml__LengthType() { }
        /// Friend allocator used by soap_new_gml__LengthType(struct soap*, int)
        friend SOAP_FMAC1 gml__LengthType * SOAP_FMAC2 soap_instantiate_gml__LengthType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1702 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType (519)
/* Type gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gmd:AbstractDQ_PositionalAccuracy_Type': */
class SOAP_CMAC gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType : public gmd__AbstractDQ_USCOREElement_USCOREType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType, default initialized and not managed by a soap context
        virtual gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType); }
      public:
        /// Constructor with initializations
        gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType()
        {
        }
        virtual ~gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType() { }
        /// Friend allocator used by soap_new_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType(struct soap*, int)
        friend SOAP_FMAC1 gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType * SOAP_FMAC2 soap_instantiate_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:268 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertyKind (41)
/* Type resqml2__obj_USCOREPropertyKind is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_PropertyKind': */
class SOAP_CMAC resqml2__obj_USCOREPropertyKind : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:NamingSystem' of XSD type 'xsd:anyURI'
        std::string NamingSystem;
        /// Required element 'resqml2:IsAbstract' of XSD type 'xsd:boolean'
        bool IsAbstract;
        /// Required element 'resqml2:RepresentativeUom' of XSD type 'resqml2:ResqmlUom'
        enum resqml2__ResqmlUom RepresentativeUom;
        /// Required element 'resqml2:ParentPropertyKind' of XSD type 'resqml2:AbstractPropertyKind'
        resqml2__AbstractPropertyKind *ParentPropertyKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertyKind
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertyKind; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREPropertyKind, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREPropertyKind *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPropertyKind); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREPropertyKind()
        {
          IsAbstract = (bool)0;
          RepresentativeUom = (enum resqml2__ResqmlUom)0;
          ParentPropertyKind = (resqml2__AbstractPropertyKind *)0;
        }
        virtual ~resqml2__obj_USCOREPropertyKind() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREPropertyKind(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREPropertyKind * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREPropertyKind(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:289 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyLookup (48)
/* Type resqml2__AbstractPropertyLookup is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractPropertyLookup': */
class SOAP_CMAC resqml2__AbstractPropertyLookup : public resqml2__AbstractResqmlDataObject {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyLookup
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyLookup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractPropertyLookup, default initialized and not managed by a soap context
        virtual resqml2__AbstractPropertyLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractPropertyLookup); }
      public:
        /// Constructor with initializations
        resqml2__AbstractPropertyLookup()
        {
        }
        virtual ~resqml2__AbstractPropertyLookup() { }
        /// Friend allocator used by soap_new_resqml2__AbstractPropertyLookup(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractPropertyLookup * SOAP_FMAC2 soap_instantiate_resqml2__AbstractPropertyLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:295 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertySet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertySet (50)
/* Type resqml2__obj_USCOREPropertySet is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_PropertySet': */
class SOAP_CMAC resqml2__obj_USCOREPropertySet : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:TimeSetKind' of XSD type 'resqml2:TimeSetKind'
        enum resqml2__TimeSetKind TimeSetKind;
        /// Required element 'resqml2:HasSinglePropertyKind' of XSD type 'xsd:boolean'
        bool HasSinglePropertyKind;
        /// Required element 'resqml2:HasMultipleRealizations' of XSD type 'xsd:boolean'
        bool HasMultipleRealizations;
        /// Optional element 'resqml2:ParentSet' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> ParentSet;
        /// Required element 'resqml2:Properties' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> Properties;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertySet
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertySet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREPropertySet, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREPropertySet *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPropertySet); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREPropertySet()
        {
          TimeSetKind = (enum resqml2__TimeSetKind)0;
          HasSinglePropertyKind = (bool)0;
          HasMultipleRealizations = (bool)0;
        }
        virtual ~resqml2__obj_USCOREPropertySet() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREPropertySet(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREPropertySet * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREPropertySet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:298 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractProperty (51)
/* Type resqml2__AbstractProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractProperty': */
class SOAP_CMAC resqml2__AbstractProperty : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:IndexableElement' of XSD type 'resqml2:IndexableElements'
        enum resqml2__IndexableElements IndexableElement;
        /// Optional element 'resqml2:RealizationIndex' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *RealizationIndex;
        /// Optional element 'resqml2:TimeStep' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 *TimeStep;
        /// Optional element 'resqml2:TimeIndex' of XSD type 'resqml2:TimeIndex'
        resqml2__TimeIndex *TimeIndex;
        /// Required element 'resqml2:SupportingRepresentation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *SupportingRepresentation;
        /// Optional element 'resqml2:LocalCrs' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *LocalCrs;
        /// Required element 'resqml2:PropertyKind' of XSD type 'resqml2:AbstractPropertyKind'
        resqml2__AbstractPropertyKind *PropertyKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractProperty
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractProperty, default initialized and not managed by a soap context
        virtual resqml2__AbstractProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractProperty); }
      public:
        /// Constructor with initializations
        resqml2__AbstractProperty()
        {
          Count = (ULONG64)0;
          IndexableElement = (enum resqml2__IndexableElements)0;
          RealizationIndex = (ULONG64 *)0;
          TimeStep = (ULONG64 *)0;
          TimeIndex = (resqml2__TimeIndex *)0;
          SupportingRepresentation = (eml__DataObjectReference *)0;
          LocalCrs = (eml__DataObjectReference *)0;
          PropertyKind = (resqml2__AbstractPropertyKind *)0;
        }
        virtual ~resqml2__AbstractProperty() { }
        /// Friend allocator used by soap_new_resqml2__AbstractProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractProperty * SOAP_FMAC2 soap_instantiate_resqml2__AbstractProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:418 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationIdentitySet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationIdentitySet (91)
/* Type resqml2__obj_USCORERepresentationIdentitySet is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_RepresentationIdentitySet': */
class SOAP_CMAC resqml2__obj_USCORERepresentationIdentitySet : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:RepresentationIdentity' of XSD type 'resqml2:RepresentationIdentity'
        std::vector<resqml2__RepresentationIdentity *> RepresentationIdentity;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationIdentitySet
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationIdentitySet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORERepresentationIdentitySet, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORERepresentationIdentitySet *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERepresentationIdentitySet); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORERepresentationIdentitySet()
        {
        }
        virtual ~resqml2__obj_USCORERepresentationIdentitySet() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORERepresentationIdentitySet(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORERepresentationIdentitySet * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORERepresentationIdentitySet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:424 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractRepresentation (93)
/* Type resqml2__AbstractRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractRepresentation': */
class SOAP_CMAC resqml2__AbstractRepresentation : public resqml2__AbstractResqmlDataObject {
      public:
        /// Optional element 'resqml2:RepresentedInterpretation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *RepresentedInterpretation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractRepresentation, default initialized and not managed by a soap context
        virtual resqml2__AbstractRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__AbstractRepresentation()
        {
          RepresentedInterpretation = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__AbstractRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__AbstractRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__AbstractRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:454 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalGridSet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalGridSet (103)
/* Type resqml2__obj_USCORELocalGridSet is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_LocalGridSet': */
class SOAP_CMAC resqml2__obj_USCORELocalGridSet : public resqml2__AbstractResqmlDataObject {
      public:
        /// Optional element 'resqml2:Activation' of XSD type 'resqml2:Activation'
        resqml2__Activation *Activation;
        /// Required element 'resqml2:ChildGrid' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> ChildGrid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalGridSet
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalGridSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORELocalGridSet, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORELocalGridSet *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORELocalGridSet); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORELocalGridSet()
        {
          Activation = (resqml2__Activation *)0;
        }
        virtual ~resqml2__obj_USCORELocalGridSet() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORELocalGridSet(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORELocalGridSet * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORELocalGridSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:547 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridGeometry (134)
/* Type resqml2__UnstructuredGridGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:UnstructuredGridGeometry': */
class SOAP_CMAC resqml2__UnstructuredGridGeometry : public resqml2__AbstractGridGeometry {
      public:
        /// Required element 'resqml2:CellShape' of XSD type 'resqml2:CellShape'
        enum resqml2__CellShape CellShape;
        /// Required element 'resqml2:NodeCount' of XSD type 'xsd:positiveInteger'
        ULONG64 NodeCount;
        /// Required element 'resqml2:FaceCount' of XSD type 'xsd:positiveInteger'
        ULONG64 FaceCount;
        /// Required element 'resqml2:NodesPerFace' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *NodesPerFace;
        /// Required element 'resqml2:FacesPerCell' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *FacesPerCell;
        /// Required element 'resqml2:CellFaceIsRightHanded' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *CellFaceIsRightHanded;
        /// Optional element 'resqml2:HingeNodeFaces' of XSD type 'resqml2:UnstructuredGridHingeNodeFaces'
        resqml2__UnstructuredGridHingeNodeFaces *HingeNodeFaces;
        /// Optional element 'resqml2:SubnodeTopology' of XSD type 'resqml2:UnstructuredSubnodeTopology'
        resqml2__UnstructuredSubnodeTopology *SubnodeTopology;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__UnstructuredGridGeometry, default initialized and not managed by a soap context
        virtual resqml2__UnstructuredGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredGridGeometry); }
      public:
        /// Constructor with initializations
        resqml2__UnstructuredGridGeometry()
        {
          CellShape = (enum resqml2__CellShape)0;
          NodeCount = (ULONG64)0;
          FaceCount = (ULONG64)0;
          NodesPerFace = (resqml2__ResqmlJaggedArray *)0;
          FacesPerCell = (resqml2__ResqmlJaggedArray *)0;
          CellFaceIsRightHanded = (resqml2__AbstractBooleanArray *)0;
          HingeNodeFaces = (resqml2__UnstructuredGridHingeNodeFaces *)0;
          SubnodeTopology = (resqml2__UnstructuredSubnodeTopology *)0;
        }
        virtual ~resqml2__UnstructuredGridGeometry() { }
        /// Friend allocator used by soap_new_resqml2__UnstructuredGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__UnstructuredGridGeometry * SOAP_FMAC2 soap_instantiate_resqml2__UnstructuredGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:592 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridGeometry (149)
/* Type resqml2__AbstractColumnLayerGridGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractColumnLayerGridGeometry': */
class SOAP_CMAC resqml2__AbstractColumnLayerGridGeometry : public resqml2__AbstractGridGeometry {
      public:
        /// Required element 'resqml2:KDirection' of XSD type 'resqml2:KDirection'
        enum resqml2__KDirection KDirection;
        /// Required element 'resqml2:PillarGeometryIsDefined' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *PillarGeometryIsDefined;
        /// Required element 'resqml2:PillarShape' of XSD type 'resqml2:PillarShape'
        enum resqml2__PillarShape PillarShape;
        /// Optional element 'resqml2:CellGeometryIsDefined' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *CellGeometryIsDefined;
        /// Optional element 'resqml2:NodeIsColocatedInKDirection' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *NodeIsColocatedInKDirection;
        /// Optional element 'resqml2:NodeIsColocatedOnKEdge' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *NodeIsColocatedOnKEdge;
        /// Optional element 'resqml2:SubnodeTopology' of XSD type 'resqml2:ColumnLayerSubnodeTopology'
        resqml2__ColumnLayerSubnodeTopology *SubnodeTopology;
        /// Optional element 'resqml2:SplitCoordinateLines' of XSD type 'resqml2:ColumnLayerSplitCoordinateLines'
        resqml2__ColumnLayerSplitCoordinateLines *SplitCoordinateLines;
        /// Optional element 'resqml2:SplitNodes' of XSD type 'resqml2:SplitNodePatch'
        resqml2__SplitNodePatch *SplitNodes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractColumnLayerGridGeometry, default initialized and not managed by a soap context
        virtual resqml2__AbstractColumnLayerGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractColumnLayerGridGeometry); }
      public:
        /// Constructor with initializations
        resqml2__AbstractColumnLayerGridGeometry()
        {
          KDirection = (enum resqml2__KDirection)0;
          PillarGeometryIsDefined = (resqml2__AbstractBooleanArray *)0;
          PillarShape = (enum resqml2__PillarShape)0;
          CellGeometryIsDefined = (resqml2__AbstractBooleanArray *)0;
          NodeIsColocatedInKDirection = (resqml2__AbstractBooleanArray *)0;
          NodeIsColocatedOnKEdge = (resqml2__AbstractBooleanArray *)0;
          SubnodeTopology = (resqml2__ColumnLayerSubnodeTopology *)0;
          SplitCoordinateLines = (resqml2__ColumnLayerSplitCoordinateLines *)0;
          SplitNodes = (resqml2__SplitNodePatch *)0;
        }
        virtual ~resqml2__AbstractColumnLayerGridGeometry() { }
        /// Friend allocator used by soap_new_resqml2__AbstractColumnLayerGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractColumnLayerGridGeometry * SOAP_FMAC2 soap_instantiate_resqml2__AbstractColumnLayerGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:598 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeatureInterpretation (151)
/* Type resqml2__AbstractFeatureInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractFeatureInterpretation': */
class SOAP_CMAC resqml2__AbstractFeatureInterpretation : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:Domain' of XSD type 'resqml2:Domain'
        enum resqml2__Domain Domain;
        /// Required element 'resqml2:InterpretedFeature' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *InterpretedFeature;
        /// Optional element 'resqml2:HasOccuredDuring' of XSD type 'resqml2:TimeInterval'
        resqml2__TimeInterval *HasOccuredDuring;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeatureInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeatureInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractFeatureInterpretation, default initialized and not managed by a soap context
        virtual resqml2__AbstractFeatureInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractFeatureInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__AbstractFeatureInterpretation()
        {
          Domain = (enum resqml2__Domain)0;
          InterpretedFeature = (eml__DataObjectReference *)0;
          HasOccuredDuring = (resqml2__TimeInterval *)0;
        }
        virtual ~resqml2__AbstractFeatureInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__AbstractFeatureInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractFeatureInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__AbstractFeatureInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:646 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumn (167)
/* Type resqml2__obj_USCOREStratigraphicColumn is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_StratigraphicColumn': */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicColumn : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:Ranks' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> Ranks;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumn
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREStratigraphicColumn, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREStratigraphicColumn *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicColumn); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREStratigraphicColumn()
        {
        }
        virtual ~resqml2__obj_USCOREStratigraphicColumn() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREStratigraphicColumn(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREStratigraphicColumn * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREStratigraphicColumn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:700 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGlobalChronostratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGlobalChronostratigraphicColumn (185)
/* Type resqml2__obj_USCOREGlobalChronostratigraphicColumn is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GlobalChronostratigraphicColumn': */
class SOAP_CMAC resqml2__obj_USCOREGlobalChronostratigraphicColumn : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:ChronostratigraphicColumnComponent' of XSD type 'resqml2:ChronostratigraphicRank'
        std::vector<resqml2__ChronostratigraphicRank *> ChronostratigraphicColumnComponent;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGlobalChronostratigraphicColumn
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGlobalChronostratigraphicColumn; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGlobalChronostratigraphicColumn, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGlobalChronostratigraphicColumn *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGlobalChronostratigraphicColumn); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGlobalChronostratigraphicColumn()
        {
        }
        virtual ~resqml2__obj_USCOREGlobalChronostratigraphicColumn() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGlobalChronostratigraphicColumn(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGlobalChronostratigraphicColumn * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGlobalChronostratigraphicColumn(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:721 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeature (192)
/* Type resqml2__AbstractFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractFeature': */
class SOAP_CMAC resqml2__AbstractFeature : public resqml2__AbstractResqmlDataObject {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractFeature, default initialized and not managed by a soap context
        virtual resqml2__AbstractFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractFeature); }
      public:
        /// Constructor with initializations
        resqml2__AbstractFeature()
        {
        }
        virtual ~resqml2__AbstractFeature() { }
        /// Friend allocator used by soap_new_resqml2__AbstractFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractFeature * SOAP_FMAC2 soap_instantiate_resqml2__AbstractFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:739 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractLocal3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractLocal3dCrs (198)
/* Type resqml2__AbstractLocal3dCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractLocal3dCrs': */
class SOAP_CMAC resqml2__AbstractLocal3dCrs : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:YOffset' of XSD type 'xsd:double'
        double YOffset;
        /// Required element 'resqml2:ZOffset' of XSD type 'xsd:double'
        double ZOffset;
        /// Required element 'resqml2:ArealRotation' of XSD type 'eml:PlaneAngleMeasure'
        eml__PlaneAngleMeasure *ArealRotation;
        /// Required element 'resqml2:ProjectedAxisOrder' of XSD type 'eml:AxisOrder2d'
        enum eml__AxisOrder2d ProjectedAxisOrder;
        /// Required element 'resqml2:ProjectedUom' of XSD type 'eml:LengthUom'
        enum eml__LengthUom ProjectedUom;
        /// Required element 'resqml2:VerticalUom' of XSD type 'eml:LengthUom'
        enum eml__LengthUom VerticalUom;
        /// Required element 'resqml2:XOffset' of XSD type 'xsd:double'
        double XOffset;
        /// Required element 'resqml2:ZIncreasingDownward' of XSD type 'xsd:boolean'
        bool ZIncreasingDownward;
        /// Required element 'resqml2:VerticalCrs' of XSD type 'eml:AbstractVerticalCrs'
        eml__AbstractVerticalCrs *VerticalCrs;
        /// Required element 'resqml2:ProjectedCrs' of XSD type 'eml:AbstractProjectedCrs'
        eml__AbstractProjectedCrs *ProjectedCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractLocal3dCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractLocal3dCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractLocal3dCrs, default initialized and not managed by a soap context
        virtual resqml2__AbstractLocal3dCrs *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractLocal3dCrs); }
      public:
        /// Constructor with initializations
        resqml2__AbstractLocal3dCrs()
        {
          YOffset = (double)0;
          ZOffset = (double)0;
          ArealRotation = (eml__PlaneAngleMeasure *)0;
          ProjectedAxisOrder = (enum eml__AxisOrder2d)0;
          ProjectedUom = (enum eml__LengthUom)0;
          VerticalUom = (enum eml__LengthUom)0;
          XOffset = (double)0;
          ZIncreasingDownward = (bool)0;
          VerticalCrs = (eml__AbstractVerticalCrs *)0;
          ProjectedCrs = (eml__AbstractProjectedCrs *)0;
        }
        virtual ~resqml2__AbstractLocal3dCrs() { }
        /// Friend allocator used by soap_new_resqml2__AbstractLocal3dCrs(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractLocal3dCrs * SOAP_FMAC2 soap_instantiate_resqml2__AbstractLocal3dCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:751 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETimeSeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETimeSeries (202)
/* Type resqml2__obj_USCORETimeSeries is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_TimeSeries': */
class SOAP_CMAC resqml2__obj_USCORETimeSeries : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:Time' of XSD type 'resqml2:Timestamp'
        std::vector<resqml2__Timestamp *> Time;
        /// Optional element 'resqml2:TimeSeriesParentage' of XSD type 'resqml2:TimeSeriesParentage'
        resqml2__TimeSeriesParentage *TimeSeriesParentage;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETimeSeries
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETimeSeries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORETimeSeries, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORETimeSeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETimeSeries); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORETimeSeries()
        {
          TimeSeriesParentage = (resqml2__TimeSeriesParentage *)0;
        }
        virtual ~resqml2__obj_USCORETimeSeries() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORETimeSeries(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORETimeSeries * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORETimeSeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:772 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREMdDatum
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREMdDatum (209)
/* Type resqml2__obj_USCOREMdDatum is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_MdDatum': */
class SOAP_CMAC resqml2__obj_USCOREMdDatum : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:Location' of XSD type 'resqml2:Point3d'
        resqml2__Point3d *Location;
        /// Required element 'resqml2:MdReference' of XSD type 'resqml2:MdReference'
        enum resqml2__MdReference MdReference;
        /// Required element 'resqml2:LocalCrs' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *LocalCrs;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREMdDatum
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREMdDatum; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREMdDatum, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREMdDatum *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREMdDatum); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREMdDatum()
        {
          Location = (resqml2__Point3d *)0;
          MdReference = (enum resqml2__MdReference)0;
          LocalCrs = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCOREMdDatum() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREMdDatum(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREMdDatum * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREMdDatum(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:775 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreMarker
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreMarker (210)
/* Type resqml2__WellboreMarker is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:WellboreMarker': */
class SOAP_CMAC resqml2__WellboreMarker : public resqml2__AbstractResqmlDataObject {
      public:
        /// Optional element 'resqml2:FluidContact' of XSD type 'resqml2:FluidContact'
        enum resqml2__FluidContact *FluidContact;
        /// Optional element 'resqml2:FluidMarker' of XSD type 'resqml2:FluidMarker'
        enum resqml2__FluidMarker *FluidMarker;
        /// Optional element 'resqml2:GeologicBoundaryKind' of XSD type 'resqml2:GeologicBoundaryKind'
        enum resqml2__GeologicBoundaryKind *GeologicBoundaryKind;
        /// Optional element 'resqml2:WitsmlFormationMarker' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *WitsmlFormationMarker;
        /// Optional element 'resqml2:Interpretation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Interpretation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreMarker
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreMarker; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__WellboreMarker, default initialized and not managed by a soap context
        virtual resqml2__WellboreMarker *soap_alloc(void) const { return SOAP_NEW(resqml2__WellboreMarker); }
      public:
        /// Constructor with initializations
        resqml2__WellboreMarker()
        {
          FluidContact = (enum resqml2__FluidContact *)0;
          FluidMarker = (enum resqml2__FluidMarker *)0;
          GeologicBoundaryKind = (enum resqml2__GeologicBoundaryKind *)0;
          WitsmlFormationMarker = (eml__DataObjectReference *)0;
          Interpretation = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__WellboreMarker() { }
        /// Friend allocator used by soap_new_resqml2__WellboreMarker(struct soap*, int)
        friend SOAP_FMAC1 resqml2__WellboreMarker * SOAP_FMAC2 soap_instantiate_resqml2__WellboreMarker(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:895 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivity (250)
/* Type resqml2__obj_USCOREActivity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_Activity': */
class SOAP_CMAC resqml2__obj_USCOREActivity : public resqml2__AbstractResqmlDataObject {
      public:
        /// Optional element 'resqml2:Parent' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Parent;
        /// Required element 'resqml2:ActivityDescriptor' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *ActivityDescriptor;
        /// Required element 'resqml2:Parameter' of XSD type 'resqml2:AbstractActivityParameter'
        std::vector<resqml2__AbstractActivityParameter *> Parameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivity
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREActivity, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREActivity *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREActivity); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREActivity()
        {
          Parent = (eml__DataObjectReference *)0;
          ActivityDescriptor = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCOREActivity() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREActivity(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREActivity * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREActivity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:922 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivityTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivityTemplate (259)
/* Type resqml2__obj_USCOREActivityTemplate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_ActivityTemplate': */
class SOAP_CMAC resqml2__obj_USCOREActivityTemplate : public resqml2__AbstractResqmlDataObject {
      public:
        /// Required element 'resqml2:Parameter' of XSD type 'resqml2:ParameterTemplate'
        std::vector<resqml2__ParameterTemplate *> Parameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivityTemplate
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivityTemplate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREActivityTemplate, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREActivityTemplate *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREActivityTemplate); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREActivityTemplate()
        {
        }
        virtual ~resqml2__obj_USCOREActivityTemplate() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREActivityTemplate(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREActivityTemplate * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREActivityTemplate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1540 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__IdentifiedObjectType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__IdentifiedObjectType (465)
/* Type gml__IdentifiedObjectType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:IdentifiedObjectType': */
class SOAP_CMAC gml__IdentifiedObjectType : public gml__DefinitionType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__IdentifiedObjectType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__IdentifiedObjectType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__IdentifiedObjectType, default initialized and not managed by a soap context
        virtual gml__IdentifiedObjectType *soap_alloc(void) const { return SOAP_NEW(gml__IdentifiedObjectType); }
      public:
        /// Constructor with initializations
        gml__IdentifiedObjectType()
        {
        }
        virtual ~gml__IdentifiedObjectType() { }
        /// Friend allocator used by soap_new_gml__IdentifiedObjectType(struct soap*, int)
        friend SOAP_FMAC1 gml__IdentifiedObjectType * SOAP_FMAC2 soap_instantiate_gml__IdentifiedObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:223 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDoubleTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDoubleTableLookup (26)
/* Type resqml2__obj_USCOREDoubleTableLookup is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_DoubleTableLookup': */
class SOAP_CMAC resqml2__obj_USCOREDoubleTableLookup : public resqml2__AbstractPropertyLookup {
      public:
        /// Required element 'resqml2:Value' of XSD type 'resqml2:DoubleLookup'
        std::vector<resqml2__DoubleLookup *> Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDoubleTableLookup
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDoubleTableLookup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREDoubleTableLookup, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREDoubleTableLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREDoubleTableLookup); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREDoubleTableLookup()
        {
        }
        virtual ~resqml2__obj_USCOREDoubleTableLookup() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREDoubleTableLookup(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREDoubleTableLookup * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREDoubleTableLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:238 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointsProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointsProperty (31)
/* Type resqml2__obj_USCOREPointsProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_PointsProperty': */
class SOAP_CMAC resqml2__obj_USCOREPointsProperty : public resqml2__AbstractProperty {
      public:
        /// Required element 'resqml2:PatchOfPoints' of XSD type 'resqml2:PatchOfPoints'
        std::vector<resqml2__PatchOfPoints *> PatchOfPoints;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointsProperty
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointsProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREPointsProperty, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREPointsProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPointsProperty); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREPointsProperty()
        {
        }
        virtual ~resqml2__obj_USCOREPointsProperty() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREPointsProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREPointsProperty * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREPointsProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:271 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStringTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStringTableLookup (42)
/* Type resqml2__obj_USCOREStringTableLookup is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_StringTableLookup': */
class SOAP_CMAC resqml2__obj_USCOREStringTableLookup : public resqml2__AbstractPropertyLookup {
      public:
        /// Required element 'resqml2:Value' of XSD type 'resqml2:StringLookup'
        std::vector<resqml2__StringLookup *> Value;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStringTableLookup
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStringTableLookup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREStringTableLookup, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREStringTableLookup *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStringTableLookup); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREStringTableLookup()
        {
        }
        virtual ~resqml2__obj_USCOREStringTableLookup() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREStringTableLookup(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREStringTableLookup * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREStringTableLookup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:313 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValuesProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValuesProperty (56)
/* Type resqml2__AbstractValuesProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractValuesProperty': */
class SOAP_CMAC resqml2__AbstractValuesProperty : public resqml2__AbstractProperty {
      public:
        /// Required element 'resqml2:PatchOfValues' of XSD type 'resqml2:PatchOfValues'
        std::vector<resqml2__PatchOfValues *> PatchOfValues;
        /// Optional element 'resqml2:Facet' of XSD type 'resqml2:PropertyKindFacet'
        std::vector<resqml2__PropertyKindFacet *> Facet;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValuesProperty
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValuesProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractValuesProperty, default initialized and not managed by a soap context
        virtual resqml2__AbstractValuesProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractValuesProperty); }
      public:
        /// Constructor with initializations
        resqml2__AbstractValuesProperty()
        {
        }
        virtual ~resqml2__AbstractValuesProperty() { }
        /// Friend allocator used by soap_new_resqml2__AbstractValuesProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractValuesProperty * SOAP_FMAC2 soap_instantiate_resqml2__AbstractValuesProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:409 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationSetRepresentation (88)
/* Type resqml2__obj_USCORERepresentationSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_RepresentationSetRepresentation': */
class SOAP_CMAC resqml2__obj_USCORERepresentationSetRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Required element 'resqml2:IsHomogeneous' of XSD type 'xsd:boolean'
        bool IsHomogeneous;
        /// Required element 'resqml2:Representation' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> Representation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationSetRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORERepresentationSetRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORERepresentationSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERepresentationSetRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORERepresentationSetRepresentation()
        {
          IsHomogeneous = (bool)0;
        }
        virtual ~resqml2__obj_USCORERepresentationSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORERepresentationSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORERepresentationSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORERepresentationSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:412 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERedefinedGeometryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERedefinedGeometryRepresentation (89)
/* Type resqml2__obj_USCORERedefinedGeometryRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_RedefinedGeometryRepresentation': */
class SOAP_CMAC resqml2__obj_USCORERedefinedGeometryRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Required element 'resqml2:PatchOfGeometry' of XSD type 'resqml2:PatchOfGeometry'
        std::vector<resqml2__PatchOfGeometry *> PatchOfGeometry;
        /// Required element 'resqml2:SupportingRepresentation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *SupportingRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERedefinedGeometryRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERedefinedGeometryRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORERedefinedGeometryRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORERedefinedGeometryRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERedefinedGeometryRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORERedefinedGeometryRepresentation()
        {
          SupportingRepresentation = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCORERedefinedGeometryRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORERedefinedGeometryRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORERedefinedGeometryRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORERedefinedGeometryRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:430 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESubRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESubRepresentation (95)
/* Type resqml2__obj_USCORESubRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_SubRepresentation': */
class SOAP_CMAC resqml2__obj_USCORESubRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Optional element 'resqml2:AdditionalGridTopology' of XSD type 'resqml2:AdditionalGridTopology'
        resqml2__AdditionalGridTopology *AdditionalGridTopology;
        /// Required element 'resqml2:SupportingRepresentation' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *SupportingRepresentation;
        /// Required element 'resqml2:SubRepresentationPatch' of XSD type 'resqml2:SubRepresentationPatch'
        std::vector<resqml2__SubRepresentationPatch *> SubRepresentationPatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESubRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESubRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORESubRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORESubRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESubRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORESubRepresentation()
        {
          AdditionalGridTopology = (resqml2__AdditionalGridTopology *)0;
          SupportingRepresentation = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCORESubRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORESubRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORESubRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORESubRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:457 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridRepresentation (104)
/* Type resqml2__AbstractGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractGridRepresentation': */
class SOAP_CMAC resqml2__AbstractGridRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Optional element 'resqml2:CellFluidPhaseUnits' of XSD type 'resqml2:CellFluidPhaseUnits'
        resqml2__CellFluidPhaseUnits *CellFluidPhaseUnits;
        /// Optional element 'resqml2:ParentWindow' of XSD type 'resqml2:AbstractParentWindow'
        resqml2__AbstractParentWindow *ParentWindow;
        /// Optional element 'resqml2:CellStratigraphicUnits' of XSD type 'resqml2:CellStratigraphicUnits'
        resqml2__CellStratigraphicUnits *CellStratigraphicUnits;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractGridRepresentation, default initialized and not managed by a soap context
        virtual resqml2__AbstractGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractGridRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__AbstractGridRepresentation()
        {
          CellFluidPhaseUnits = (resqml2__CellFluidPhaseUnits *)0;
          ParentWindow = (resqml2__AbstractParentWindow *)0;
          CellStratigraphicUnits = (resqml2__CellStratigraphicUnits *)0;
        }
        virtual ~resqml2__AbstractGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__AbstractGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__AbstractGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:526 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerGridGeometry (127)
/* Type resqml2__UnstructuredColumnLayerGridGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:UnstructuredColumnLayerGridGeometry': */
class SOAP_CMAC resqml2__UnstructuredColumnLayerGridGeometry : public resqml2__AbstractColumnLayerGridGeometry {
      public:
        /// Required element 'resqml2:ColumnShape' of XSD type 'resqml2:ColumnShape'
        enum resqml2__ColumnShape ColumnShape;
        /// Required element 'resqml2:PillarCount' of XSD type 'xsd:positiveInteger'
        ULONG64 PillarCount;
        /// Required element 'resqml2:PillarsPerColumn' of XSD type 'resqml2:ResqmlJaggedArray'
        resqml2__ResqmlJaggedArray *PillarsPerColumn;
        /// Required element 'resqml2:ColumnIsRightHanded' of XSD type 'resqml2:AbstractBooleanArray'
        resqml2__AbstractBooleanArray *ColumnIsRightHanded;
        /// Optional element 'resqml2:ColumnEdges' of XSD type 'resqml2:UnstructuredColumnEdges'
        resqml2__UnstructuredColumnEdges *ColumnEdges;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerGridGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__UnstructuredColumnLayerGridGeometry, default initialized and not managed by a soap context
        virtual resqml2__UnstructuredColumnLayerGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__UnstructuredColumnLayerGridGeometry); }
      public:
        /// Constructor with initializations
        resqml2__UnstructuredColumnLayerGridGeometry()
        {
          ColumnShape = (enum resqml2__ColumnShape)0;
          PillarCount = (ULONG64)0;
          PillarsPerColumn = (resqml2__ResqmlJaggedArray *)0;
          ColumnIsRightHanded = (resqml2__AbstractBooleanArray *)0;
          ColumnEdges = (resqml2__UnstructuredColumnEdges *)0;
        }
        virtual ~resqml2__UnstructuredColumnLayerGridGeometry() { }
        /// Friend allocator used by soap_new_resqml2__UnstructuredColumnLayerGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__UnstructuredColumnLayerGridGeometry * SOAP_FMAC2 soap_instantiate_resqml2__UnstructuredColumnLayerGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:529 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkGridGeometry (128)
/* Type resqml2__IjkGridGeometry is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:IjkGridGeometry': */
class SOAP_CMAC resqml2__IjkGridGeometry : public resqml2__AbstractColumnLayerGridGeometry {
      public:
        /// Required element 'resqml2:GridIsRighthanded' of XSD type 'xsd:boolean'
        bool GridIsRighthanded;
        /// Optional element 'resqml2:IjGaps' of XSD type 'resqml2:IjGaps'
        resqml2__IjGaps *IjGaps;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkGridGeometry
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkGridGeometry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__IjkGridGeometry, default initialized and not managed by a soap context
        virtual resqml2__IjkGridGeometry *soap_alloc(void) const { return SOAP_NEW(resqml2__IjkGridGeometry); }
      public:
        /// Constructor with initializations
        resqml2__IjkGridGeometry()
        {
          GridIsRighthanded = (bool)0;
          IjGaps = (resqml2__IjGaps *)0;
        }
        virtual ~resqml2__IjkGridGeometry() { }
        /// Friend allocator used by soap_new_resqml2__IjkGridGeometry(struct soap*, int)
        friend SOAP_FMAC1 resqml2__IjkGridGeometry * SOAP_FMAC2 soap_instantiate_resqml2__IjkGridGeometry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:568 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGridConnectionSetRepresentation (141)
/* Type resqml2__obj_USCOREGridConnectionSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GridConnectionSetRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREGridConnectionSetRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Required element 'resqml2:Count' of XSD type 'xsd:positiveInteger'
        ULONG64 Count;
        /// Required element 'resqml2:CellIndexPairs' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *CellIndexPairs;
        /// Optional element 'resqml2:GridIndexPairs' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *GridIndexPairs;
        /// Optional element 'resqml2:LocalFacePerCellIndexPairs' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *LocalFacePerCellIndexPairs;
        /// Optional element 'resqml2:ConnectionInterpretations' of XSD type 'resqml2:ConnectionInterpretations'
        resqml2__ConnectionInterpretations *ConnectionInterpretations;
        /// Required element 'resqml2:Grid' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> Grid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGridConnectionSetRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGridConnectionSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGridConnectionSetRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGridConnectionSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGridConnectionSetRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGridConnectionSetRepresentation()
        {
          Count = (ULONG64)0;
          CellIndexPairs = (resqml2__AbstractIntegerArray *)0;
          GridIndexPairs = (resqml2__AbstractIntegerArray *)0;
          LocalFacePerCellIndexPairs = (resqml2__AbstractIntegerArray *)0;
          ConnectionInterpretations = (resqml2__ConnectionInterpretations *)0;
        }
        virtual ~resqml2__obj_USCOREGridConnectionSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGridConnectionSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGridConnectionSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGridConnectionSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:607 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractOrganizationInterpretation (154)
/* Type resqml2__AbstractOrganizationInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractOrganizationInterpretation': */
class SOAP_CMAC resqml2__AbstractOrganizationInterpretation : public resqml2__AbstractFeatureInterpretation {
      public:
        /// Optional element 'resqml2:ContactInterpretation' of XSD type 'resqml2:AbstractContactInterpretationPart'
        std::vector<resqml2__AbstractContactInterpretationPart *> ContactInterpretation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractOrganizationInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractOrganizationInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractOrganizationInterpretation, default initialized and not managed by a soap context
        virtual resqml2__AbstractOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractOrganizationInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__AbstractOrganizationInterpretation()
        {
        }
        virtual ~resqml2__AbstractOrganizationInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__AbstractOrganizationInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractOrganizationInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__AbstractOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:622 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGenericFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGenericFeatureInterpretation (159)
/* Type resqml2__obj_USCOREGenericFeatureInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GenericFeatureInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREGenericFeatureInterpretation : public resqml2__AbstractFeatureInterpretation {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGenericFeatureInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGenericFeatureInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGenericFeatureInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGenericFeatureInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGenericFeatureInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGenericFeatureInterpretation()
        {
        }
        virtual ~resqml2__obj_USCOREGenericFeatureInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGenericFeatureInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGenericFeatureInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGenericFeatureInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:625 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreInterpretation (160)
/* Type resqml2__obj_USCOREWellboreInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_WellboreInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREWellboreInterpretation : public resqml2__AbstractFeatureInterpretation {
      public:
        /// Required element 'resqml2:IsDrilled' of XSD type 'xsd:boolean'
        bool IsDrilled;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREWellboreInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREWellboreInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREWellboreInterpretation()
        {
          IsDrilled = (bool)0;
        }
        virtual ~resqml2__obj_USCOREWellboreInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREWellboreInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREWellboreInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREWellboreInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:652 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeatureInterpretation (169)
/* Type resqml2__obj_USCOREBoundaryFeatureInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_BoundaryFeatureInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREBoundaryFeatureInterpretation : public resqml2__AbstractFeatureInterpretation {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeatureInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeatureInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREBoundaryFeatureInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREBoundaryFeatureInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREBoundaryFeatureInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREBoundaryFeatureInterpretation()
        {
        }
        virtual ~resqml2__obj_USCOREBoundaryFeatureInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREBoundaryFeatureInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREBoundaryFeatureInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREBoundaryFeatureInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:658 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREEarthModelInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREEarthModelInterpretation (171)
/* Type resqml2__obj_USCOREEarthModelInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_EarthModelInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREEarthModelInterpretation : public resqml2__AbstractFeatureInterpretation {
      public:
        /// Optional element 'resqml2:StratigraphicOccurrences' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> StratigraphicOccurrences;
        /// Optional element 'resqml2:StratigraphicColumn' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *StratigraphicColumn;
        /// Optional element 'resqml2:Structure' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Structure;
        /// Optional element 'resqml2:Fluid' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Fluid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREEarthModelInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREEarthModelInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREEarthModelInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREEarthModelInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREEarthModelInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREEarthModelInterpretation()
        {
          StratigraphicColumn = (eml__DataObjectReference *)0;
          Structure = (eml__DataObjectReference *)0;
          Fluid = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCOREEarthModelInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREEarthModelInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREEarthModelInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREEarthModelInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:676 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitInterpretation (177)
/* Type resqml2__obj_USCOREGeologicUnitInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GeologicUnitInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREGeologicUnitInterpretation : public resqml2__AbstractFeatureInterpretation {
      public:
        /// Optional element 'resqml2:GeologicUnitComposition' of XSD type 'resqml2:GeologicUnitComposition'
        enum resqml2__GeologicUnitComposition *GeologicUnitComposition;
        /// Optional element 'resqml2:GeologicUnitMaterialImplacement' of XSD type 'resqml2:GeologicUnitMaterialImplacement'
        enum resqml2__GeologicUnitMaterialImplacement *GeologicUnitMaterialImplacement;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGeologicUnitInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGeologicUnitInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeologicUnitInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGeologicUnitInterpretation()
        {
          GeologicUnitComposition = (enum resqml2__GeologicUnitComposition *)0;
          GeologicUnitMaterialImplacement = (enum resqml2__GeologicUnitMaterialImplacement *)0;
        }
        virtual ~resqml2__obj_USCOREGeologicUnitInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGeologicUnitInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGeologicUnitInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGeologicUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:706 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeologicFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeologicFeature (187)
/* Type resqml2__AbstractGeologicFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractGeologicFeature': */
class SOAP_CMAC resqml2__AbstractGeologicFeature : public resqml2__AbstractFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeologicFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeologicFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractGeologicFeature, default initialized and not managed by a soap context
        virtual resqml2__AbstractGeologicFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractGeologicFeature); }
      public:
        /// Constructor with initializations
        resqml2__AbstractGeologicFeature()
        {
        }
        virtual ~resqml2__AbstractGeologicFeature() { }
        /// Friend allocator used by soap_new_resqml2__AbstractGeologicFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractGeologicFeature * SOAP_FMAC2 soap_instantiate_resqml2__AbstractGeologicFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:730 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalTime3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalTime3dCrs (195)
/* Type resqml2__obj_USCORELocalTime3dCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_LocalTime3dCrs': */
class SOAP_CMAC resqml2__obj_USCORELocalTime3dCrs : public resqml2__AbstractLocal3dCrs {
      public:
        /// Required element 'resqml2:TimeUom' of XSD type 'eml:TimeUom'
        enum eml__TimeUom TimeUom;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalTime3dCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalTime3dCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORELocalTime3dCrs, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORELocalTime3dCrs *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORELocalTime3dCrs); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORELocalTime3dCrs()
        {
          TimeUom = (enum eml__TimeUom)0;
        }
        virtual ~resqml2__obj_USCORELocalTime3dCrs() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORELocalTime3dCrs(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORELocalTime3dCrs * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORELocalTime3dCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:748 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalDepth3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalDepth3dCrs (201)
/* Type resqml2__obj_USCORELocalDepth3dCrs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_LocalDepth3dCrs': */
class SOAP_CMAC resqml2__obj_USCORELocalDepth3dCrs : public resqml2__AbstractLocal3dCrs {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalDepth3dCrs
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalDepth3dCrs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORELocalDepth3dCrs, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORELocalDepth3dCrs *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORELocalDepth3dCrs); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORELocalDepth3dCrs()
        {
        }
        virtual ~resqml2__obj_USCORELocalDepth3dCrs() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORELocalDepth3dCrs(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORELocalDepth3dCrs * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORELocalDepth3dCrs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:763 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDeviationSurveyRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDeviationSurveyRepresentation (206)
/* Type resqml2__obj_USCOREDeviationSurveyRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_DeviationSurveyRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREDeviationSurveyRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Optional element 'resqml2:WitsmlDeviationSurvey' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *WitsmlDeviationSurvey;
        /// Required element 'resqml2:IsFinal' of XSD type 'xsd:boolean'
        bool IsFinal;
        /// Required element 'resqml2:StationCount' of XSD type 'xsd:positiveInteger'
        ULONG64 StationCount;
        /// Required element 'resqml2:MdUom' of XSD type 'eml:LengthUom'
        enum eml__LengthUom MdUom;
        /// Required element 'resqml2:Mds' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *Mds;
        /// Required element 'resqml2:FirstStationLocation' of XSD type 'resqml2:Point3d'
        resqml2__Point3d *FirstStationLocation;
        /// Required element 'resqml2:AngleUom' of XSD type 'eml:PlaneAngleUom'
        enum eml__PlaneAngleUom AngleUom;
        /// Required element 'resqml2:Azimuths' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *Azimuths;
        /// Required element 'resqml2:Inclinations' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *Inclinations;
        /// Required element 'resqml2:MdDatum' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *MdDatum;
        /// Optional element 'resqml2:TimeIndex' of XSD type 'resqml2:TimeIndex'
        resqml2__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDeviationSurveyRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDeviationSurveyRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREDeviationSurveyRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREDeviationSurveyRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREDeviationSurveyRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREDeviationSurveyRepresentation()
        {
          WitsmlDeviationSurvey = (eml__DataObjectReference *)0;
          IsFinal = (bool)0;
          StationCount = (ULONG64)0;
          MdUom = (enum eml__LengthUom)0;
          Mds = (resqml2__AbstractDoubleArray *)0;
          FirstStationLocation = (resqml2__Point3d *)0;
          AngleUom = (enum eml__PlaneAngleUom)0;
          Azimuths = (resqml2__AbstractDoubleArray *)0;
          Inclinations = (resqml2__AbstractDoubleArray *)0;
          MdDatum = (eml__DataObjectReference *)0;
          TimeIndex = (resqml2__TimeIndex *)0;
        }
        virtual ~resqml2__obj_USCOREDeviationSurveyRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREDeviationSurveyRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREDeviationSurveyRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREDeviationSurveyRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:766 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFrameRepresentation (207)
/* Type resqml2__obj_USCOREWellboreFrameRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_WellboreFrameRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREWellboreFrameRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Required element 'resqml2:NodeCount' of XSD type 'xsd:positiveInteger'
        ULONG64 NodeCount;
        /// Required element 'resqml2:NodeMd' of XSD type 'resqml2:AbstractDoubleArray'
        resqml2__AbstractDoubleArray *NodeMd;
        /// Optional element 'resqml2:WitsmlLogReference' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *WitsmlLogReference;
        /// Optional element 'resqml2:IntervalStratigraphiUnits' of XSD type 'resqml2:IntervalStratigraphicUnits'
        resqml2__IntervalStratigraphicUnits *IntervalStratigraphiUnits;
        /// Optional element 'resqml2:CellFluidPhaseUnits' of XSD type 'resqml2:CellFluidPhaseUnits'
        resqml2__CellFluidPhaseUnits *CellFluidPhaseUnits;
        /// Required element 'resqml2:Trajectory' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Trajectory;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFrameRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFrameRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREWellboreFrameRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREWellboreFrameRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreFrameRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREWellboreFrameRepresentation()
        {
          NodeCount = (ULONG64)0;
          NodeMd = (resqml2__AbstractDoubleArray *)0;
          WitsmlLogReference = (eml__DataObjectReference *)0;
          IntervalStratigraphiUnits = (resqml2__IntervalStratigraphicUnits *)0;
          CellFluidPhaseUnits = (resqml2__CellFluidPhaseUnits *)0;
          Trajectory = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCOREWellboreFrameRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREWellboreFrameRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREWellboreFrameRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREWellboreFrameRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:769 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreTrajectoryRepresentation (208)
/* Type resqml2__obj_USCOREWellboreTrajectoryRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_WellboreTrajectoryRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREWellboreTrajectoryRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Required element 'resqml2:StartMd' of XSD type 'xsd:double'
        double StartMd;
        /// Required element 'resqml2:FinishMd' of XSD type 'xsd:double'
        double FinishMd;
        /// Required element 'resqml2:MdUom' of XSD type 'eml:LengthUom'
        enum eml__LengthUom MdUom;
        /// Optional element 'resqml2:MdDomain' of XSD type 'resqml2:MdDomain'
        enum resqml2__MdDomain *MdDomain;
        /// Optional element 'resqml2:WitsmlTrajectory' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *WitsmlTrajectory;
        /// Optional element 'resqml2:Geometry' of XSD type 'resqml2:AbstractParametricLineGeometry'
        resqml2__AbstractParametricLineGeometry *Geometry;
        /// Required element 'resqml2:MdDatum' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *MdDatum;
        /// Optional element 'resqml2:DeviationSurvey' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *DeviationSurvey;
        /// Optional element 'resqml2:ParentIntersection' of XSD type 'resqml2:WellboreTrajectoryParentIntersection'
        resqml2__WellboreTrajectoryParentIntersection *ParentIntersection;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreTrajectoryRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreTrajectoryRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREWellboreTrajectoryRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREWellboreTrajectoryRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreTrajectoryRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREWellboreTrajectoryRepresentation()
        {
          StartMd = (double)0;
          FinishMd = (double)0;
          MdUom = (enum eml__LengthUom)0;
          MdDomain = (enum resqml2__MdDomain *)0;
          WitsmlTrajectory = (eml__DataObjectReference *)0;
          Geometry = (resqml2__AbstractParametricLineGeometry *)0;
          MdDatum = (eml__DataObjectReference *)0;
          DeviationSurvey = (eml__DataObjectReference *)0;
          ParentIntersection = (resqml2__WellboreTrajectoryParentIntersection *)0;
        }
        virtual ~resqml2__obj_USCOREWellboreTrajectoryRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREWellboreTrajectoryRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREWellboreTrajectoryRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREWellboreTrajectoryRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:805 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointSetRepresentation (220)
/* Type resqml2__obj_USCOREPointSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_PointSetRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREPointSetRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Required element 'resqml2:NodePatch' of XSD type 'resqml2:NodePatch'
        std::vector<resqml2__NodePatch *> NodePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointSetRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREPointSetRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREPointSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPointSetRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREPointSetRepresentation()
        {
        }
        virtual ~resqml2__obj_USCOREPointSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREPointSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREPointSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREPointSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:820 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineSetRepresentation (225)
/* Type resqml2__obj_USCOREPolylineSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_PolylineSetRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREPolylineSetRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Optional element 'resqml2:LineRole' of XSD type 'resqml2:LineRole'
        enum resqml2__LineRole *LineRole;
        /// Required element 'resqml2:LinePatch' of XSD type 'resqml2:PolylineSetPatch'
        std::vector<resqml2__PolylineSetPatch *> LinePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineSetRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREPolylineSetRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREPolylineSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPolylineSetRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREPolylineSetRepresentation()
        {
          LineRole = (enum resqml2__LineRole *)0;
        }
        virtual ~resqml2__obj_USCOREPolylineSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREPolylineSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREPolylineSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREPolylineSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:832 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineRepresentation (229)
/* Type resqml2__obj_USCOREPolylineRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_PolylineRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREPolylineRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Optional element 'resqml2:LineRole' of XSD type 'resqml2:LineRole'
        enum resqml2__LineRole *LineRole;
        /// Required element 'resqml2:IsClosed' of XSD type 'xsd:boolean'
        bool IsClosed;
        /// Required element 'resqml2:NodePatch' of XSD type 'resqml2:NodePatch'
        resqml2__NodePatch *NodePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREPolylineRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREPolylineRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPolylineRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREPolylineRepresentation()
        {
          LineRole = (enum resqml2__LineRole *)0;
          IsClosed = (bool)0;
          NodePatch = (resqml2__NodePatch *)0;
        }
        virtual ~resqml2__obj_USCOREPolylineRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREPolylineRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREPolylineRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREPolylineRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:841 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceRepresentation (232)
/* Type resqml2__AbstractSurfaceRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractSurfaceRepresentation': */
class SOAP_CMAC resqml2__AbstractSurfaceRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Required element 'resqml2:SurfaceRole' of XSD type 'resqml2:SurfaceRole'
        enum resqml2__SurfaceRole SurfaceRole;
        /// Optional element 'resqml2:Boundaries' of XSD type 'resqml2:PatchBoundaries'
        std::vector<resqml2__PatchBoundaries *> Boundaries;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractSurfaceRepresentation, default initialized and not managed by a soap context
        virtual resqml2__AbstractSurfaceRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractSurfaceRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__AbstractSurfaceRepresentation()
        {
          SurfaceRole = (enum resqml2__SurfaceRole)0;
        }
        virtual ~resqml2__AbstractSurfaceRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__AbstractSurfaceRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractSurfaceRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__AbstractSurfaceRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:862 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTechnicalFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTechnicalFeature (239)
/* Type resqml2__AbstractTechnicalFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractTechnicalFeature': */
class SOAP_CMAC resqml2__AbstractTechnicalFeature : public resqml2__AbstractFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTechnicalFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTechnicalFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractTechnicalFeature, default initialized and not managed by a soap context
        virtual resqml2__AbstractTechnicalFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractTechnicalFeature); }
      public:
        /// Constructor with initializations
        resqml2__AbstractTechnicalFeature()
        {
        }
        virtual ~resqml2__AbstractTechnicalFeature() { }
        /// Friend allocator used by soap_new_resqml2__AbstractTechnicalFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractTechnicalFeature * SOAP_FMAC2 soap_instantiate_resqml2__AbstractTechnicalFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:931 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesRepresentation (262)
/* Type resqml2__obj_USCOREStreamlinesRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_StreamlinesRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREStreamlinesRepresentation : public resqml2__AbstractRepresentation {
      public:
        /// Required element 'resqml2:LineCount' of XSD type 'xsd:positiveInteger'
        ULONG64 LineCount;
        /// Optional element 'resqml2:StreamlineWellbores' of XSD type 'resqml2:StreamlineWellbores'
        resqml2__StreamlineWellbores *StreamlineWellbores;
        /// Optional element 'resqml2:Geometry' of XSD type 'resqml2:StreamlinePolylineSetPatch'
        resqml2__StreamlinePolylineSetPatch *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREStreamlinesRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREStreamlinesRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStreamlinesRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREStreamlinesRepresentation()
        {
          LineCount = (ULONG64)0;
          StreamlineWellbores = (resqml2__StreamlineWellbores *)0;
          Geometry = (resqml2__StreamlinePolylineSetPatch *)0;
        }
        virtual ~resqml2__obj_USCOREStreamlinesRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREStreamlinesRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREStreamlinesRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREStreamlinesRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1537 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCRSType (464)
/* Type gml__AbstractCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractCRSType': */
class SOAP_CMAC gml__AbstractCRSType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:domainOfValidity' of XSD type 'gml:domainOfValidity'
        std::vector<_gml__domainOfValidity *> domainOfValidity;
        /// Required element 'gml:scope' of XSD type 'xsd:string'
        std::vector<std::string> scope;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCRSType, default initialized and not managed by a soap context
        virtual gml__AbstractCRSType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCRSType); }
      public:
        /// Constructor with initializations
        gml__AbstractCRSType()
        {
        }
        virtual ~gml__AbstractCRSType() { }
        /// Friend allocator used by soap_new_gml__AbstractCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCRSType * SOAP_FMAC2 soap_instantiate_gml__AbstractCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1582 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateSystemType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateSystemType (479)
/* Type gml__AbstractCoordinateSystemType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractCoordinateSystemType': */
class SOAP_CMAC gml__AbstractCoordinateSystemType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:axis' of XSD type 'gml:CoordinateSystemAxisPropertyType'
        std::vector<gml__CoordinateSystemAxisPropertyType *> axis;
        /// optional attribute 'aggregationType' of XSD type 'gml:AggregationType'
        enum gml__AggregationType *aggregationType;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateSystemType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateSystemType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCoordinateSystemType, default initialized and not managed by a soap context
        virtual gml__AbstractCoordinateSystemType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCoordinateSystemType); }
      public:
        /// Constructor with initializations
        gml__AbstractCoordinateSystemType()
        {
          aggregationType = (enum gml__AggregationType *)0;
        }
        virtual ~gml__AbstractCoordinateSystemType() { }
        /// Friend allocator used by soap_new_gml__AbstractCoordinateSystemType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCoordinateSystemType * SOAP_FMAC2 soap_instantiate_gml__AbstractCoordinateSystemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1588 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisType (481)
/* Type gml__CoordinateSystemAxisType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:CoordinateSystemAxisType': */
class SOAP_CMAC gml__CoordinateSystemAxisType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:axisAbbrev' of XSD type 'gml:CodeType'
        gml__CodeType *axisAbbrev;
        /// Required element 'gml:axisDirection' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *axisDirection;
        /// Optional element 'gml:minimumValue' of XSD type 'xsd:double'
        double *minimumValue;
        /// Optional element 'gml:maximumValue' of XSD type 'xsd:double'
        double *maximumValue;
        /// Optional element 'gml:rangeMeaning' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *rangeMeaning;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CoordinateSystemAxisType, default initialized and not managed by a soap context
        virtual gml__CoordinateSystemAxisType *soap_alloc(void) const { return SOAP_NEW(gml__CoordinateSystemAxisType); }
      public:
        /// Constructor with initializations
        gml__CoordinateSystemAxisType()
        {
          axisAbbrev = (gml__CodeType *)0;
          axisDirection = (gml__CodeWithAuthorityType *)0;
          minimumValue = (double *)0;
          maximumValue = (double *)0;
          rangeMeaning = (gml__CodeWithAuthorityType *)0;
        }
        virtual ~gml__CoordinateSystemAxisType() { }
        /// Friend allocator used by soap_new_gml__CoordinateSystemAxisType(struct soap*, int)
        friend SOAP_FMAC1 gml__CoordinateSystemAxisType * SOAP_FMAC2 soap_instantiate_gml__CoordinateSystemAxisType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1609 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractDatumType (488)
/* Type gml__AbstractDatumType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractDatumType': */
class SOAP_CMAC gml__AbstractDatumType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:domainOfValidity' of XSD type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XSD type 'xsd:string'
        std::vector<std::string> scope;
        /// Optional element 'gml:anchorDefinition' of XSD type 'gml:CodeType'
        gml__CodeType *anchorDefinition;
        /// Optional element 'gml:realizationEpoch' of XSD type 'xsd:date'
        std::string *realizationEpoch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractDatumType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractDatumType, default initialized and not managed by a soap context
        virtual gml__AbstractDatumType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractDatumType); }
      public:
        /// Constructor with initializations
        gml__AbstractDatumType()
        {
          domainOfValidity = (_gml__domainOfValidity *)0;
          anchorDefinition = (gml__CodeType *)0;
          realizationEpoch = (std::string *)0;
        }
        virtual ~gml__AbstractDatumType() { }
        /// Friend allocator used by soap_new_gml__AbstractDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractDatumType * SOAP_FMAC2 soap_instantiate_gml__AbstractDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1615 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianType (490)
/* Type gml__PrimeMeridianType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:PrimeMeridianType': */
class SOAP_CMAC gml__PrimeMeridianType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:greenwichLongitude' of XSD type 'gml:AngleType'
        gml__AngleType *greenwichLongitude;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__PrimeMeridianType, default initialized and not managed by a soap context
        virtual gml__PrimeMeridianType *soap_alloc(void) const { return SOAP_NEW(gml__PrimeMeridianType); }
      public:
        /// Constructor with initializations
        gml__PrimeMeridianType()
        {
          greenwichLongitude = (gml__AngleType *)0;
        }
        virtual ~gml__PrimeMeridianType() { }
        /// Friend allocator used by soap_new_gml__PrimeMeridianType(struct soap*, int)
        friend SOAP_FMAC1 gml__PrimeMeridianType * SOAP_FMAC2 soap_instantiate_gml__PrimeMeridianType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1627 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidType (494)
/* Type gml__EllipsoidType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:EllipsoidType': */
class SOAP_CMAC gml__EllipsoidType : public gml__IdentifiedObjectType {
      public:
        /// Required element 'gml:semiMajorAxis' of XSD type 'gml:MeasureType'
        gml__MeasureType *semiMajorAxis;
        /// Required element 'gml:secondDefiningParameter' of XSD type 'gml:secondDefiningParameter'
        _gml__secondDefiningParameter *secondDefiningParameter;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidType, default initialized and not managed by a soap context
        virtual gml__EllipsoidType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidType); }
      public:
        /// Constructor with initializations
        gml__EllipsoidType()
        {
          semiMajorAxis = (gml__MeasureType *)0;
          secondDefiningParameter = (_gml__secondDefiningParameter *)0;
        }
        virtual ~gml__EllipsoidType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1645 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateOperationType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateOperationType (500)
/* Type gml__AbstractCoordinateOperationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractCoordinateOperationType': */
class SOAP_CMAC gml__AbstractCoordinateOperationType : public gml__IdentifiedObjectType {
      public:
        /// Optional element 'gml:domainOfValidity' of XSD type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XSD type 'xsd:string'
        std::vector<std::string> scope;
        /// Optional element 'gml:operationVersion' of XSD type 'xsd:string'
        std::string *operationVersion;
        /// Optional element 'gml:coordinateOperationAccuracy' of XSD type 'gml:coordinateOperationAccuracy'
        std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;
        /// Optional element 'gml:sourceCRS' of XSD type 'gml:CRSPropertyType'
        gml__CRSPropertyType *sourceCRS;
        /// Optional element 'gml:targetCRS' of XSD type 'gml:CRSPropertyType'
        gml__CRSPropertyType *targetCRS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateOperationType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateOperationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractCoordinateOperationType, default initialized and not managed by a soap context
        virtual gml__AbstractCoordinateOperationType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCoordinateOperationType); }
      public:
        /// Constructor with initializations
        gml__AbstractCoordinateOperationType()
        {
          domainOfValidity = (_gml__domainOfValidity *)0;
          operationVersion = (std::string *)0;
          sourceCRS = (gml__CRSPropertyType *)0;
          targetCRS = (gml__CRSPropertyType *)0;
        }
        virtual ~gml__AbstractCoordinateOperationType() { }
        /// Friend allocator used by soap_new_gml__AbstractCoordinateOperationType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractCoordinateOperationType * SOAP_FMAC2 soap_instantiate_gml__AbstractCoordinateOperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:232 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousProperty (29)
/* Type resqml2__obj_USCOREContinuousProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_ContinuousProperty': */
class SOAP_CMAC resqml2__obj_USCOREContinuousProperty : public resqml2__AbstractValuesProperty {
      public:
        /// Optional element 'resqml2:MinimumValue' of XSD type 'xsd:double'
        std::vector<double> MinimumValue;
        /// Optional element 'resqml2:MaximumValue' of XSD type 'xsd:double'
        std::vector<double> MaximumValue;
        /// Required element 'resqml2:UOM' of XSD type 'resqml2:ResqmlUom'
        enum resqml2__ResqmlUom UOM;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousProperty
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREContinuousProperty, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREContinuousProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREContinuousProperty); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREContinuousProperty()
        {
          UOM = (enum resqml2__ResqmlUom)0;
        }
        virtual ~resqml2__obj_USCOREContinuousProperty() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREContinuousProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREContinuousProperty * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREContinuousProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:253 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentProperty (36)
/* Type resqml2__obj_USCORECommentProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_CommentProperty': */
class SOAP_CMAC resqml2__obj_USCORECommentProperty : public resqml2__AbstractValuesProperty {
      public:
        /// Optional element 'resqml2:Language' of XSD type 'xsd:string'
        std::string *Language;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentProperty
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORECommentProperty, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORECommentProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORECommentProperty); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORECommentProperty()
        {
          Language = (std::string *)0;
        }
        virtual ~resqml2__obj_USCORECommentProperty() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORECommentProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORECommentProperty * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORECommentProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:256 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscreteProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscreteProperty (37)
/* Type resqml2__obj_USCOREDiscreteProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_DiscreteProperty': */
class SOAP_CMAC resqml2__obj_USCOREDiscreteProperty : public resqml2__AbstractValuesProperty {
      public:
        /// Optional element 'resqml2:MinimumValue' of XSD type 'xsd:integer'
        std::vector<LONG64> MinimumValue;
        /// Optional element 'resqml2:MaximumValue' of XSD type 'xsd:integer'
        std::vector<LONG64> MaximumValue;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscreteProperty
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscreteProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREDiscreteProperty, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREDiscreteProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREDiscreteProperty); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREDiscreteProperty()
        {
        }
        virtual ~resqml2__obj_USCOREDiscreteProperty() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREDiscreteProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREDiscreteProperty * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREDiscreteProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:259 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalProperty (38)
/* Type resqml2__obj_USCORECategoricalProperty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_CategoricalProperty': */
class SOAP_CMAC resqml2__obj_USCORECategoricalProperty : public resqml2__AbstractValuesProperty {
      public:
        /// Required element 'resqml2:Lookup' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *Lookup;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalProperty
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalProperty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORECategoricalProperty, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORECategoricalProperty *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORECategoricalProperty); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORECategoricalProperty()
        {
          Lookup = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCORECategoricalProperty() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORECategoricalProperty(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORECategoricalProperty * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORECategoricalProperty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:433 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredGridRepresentation (96)
/* Type resqml2__obj_USCOREUnstructuredGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_UnstructuredGridRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREUnstructuredGridRepresentation : public resqml2__AbstractGridRepresentation {
      public:
        /// Required element 'resqml2:CellCount' of XSD type 'xsd:positiveInteger'
        ULONG64 CellCount;
        /// Optional element 'resqml2:Geometry' of XSD type 'resqml2:UnstructuredGridGeometry'
        resqml2__UnstructuredGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredGridRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREUnstructuredGridRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREUnstructuredGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREUnstructuredGridRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREUnstructuredGridRepresentation()
        {
          CellCount = (ULONG64)0;
          Geometry = (resqml2__UnstructuredGridGeometry *)0;
        }
        virtual ~resqml2__obj_USCOREUnstructuredGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREUnstructuredGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREUnstructuredGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREUnstructuredGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:439 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGpGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGpGridRepresentation (98)
/* Type resqml2__obj_USCOREGpGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GpGridRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREGpGridRepresentation : public resqml2__AbstractGridRepresentation {
      public:
        /// Optional element 'resqml2:ColumnLayerGrid' of XSD type 'resqml2:GpGridColumnLayerGrid'
        std::vector<resqml2__GpGridColumnLayerGrid *> ColumnLayerGrid;
        /// Optional element 'resqml2:UnstructuredGridPatch' of XSD type 'resqml2:GpGridUnstructuredGridPatch'
        std::vector<resqml2__GpGridUnstructuredGridPatch *> UnstructuredGridPatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGpGridRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGpGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGpGridRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGpGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGpGridRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGpGridRepresentation()
        {
        }
        virtual ~resqml2__obj_USCOREGpGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGpGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGpGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGpGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:535 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTruncatedColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTruncatedColumnLayerGridRepresentation (130)
/* Type resqml2__AbstractTruncatedColumnLayerGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractTruncatedColumnLayerGridRepresentation': */
class SOAP_CMAC resqml2__AbstractTruncatedColumnLayerGridRepresentation : public resqml2__AbstractGridRepresentation {
      public:
        /// Required element 'resqml2:Nk' of XSD type 'xsd:positiveInteger'
        ULONG64 Nk;
        /// Required element 'resqml2:TruncationCells' of XSD type 'resqml2:TruncationCellPatch'
        resqml2__TruncationCellPatch *TruncationCells;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTruncatedColumnLayerGridRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTruncatedColumnLayerGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractTruncatedColumnLayerGridRepresentation, default initialized and not managed by a soap context
        virtual resqml2__AbstractTruncatedColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractTruncatedColumnLayerGridRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__AbstractTruncatedColumnLayerGridRepresentation()
        {
          Nk = (ULONG64)0;
          TruncationCells = (resqml2__TruncationCellPatch *)0;
        }
        virtual ~resqml2__AbstractTruncatedColumnLayerGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__AbstractTruncatedColumnLayerGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractTruncatedColumnLayerGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__AbstractTruncatedColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:559 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridRepresentation (138)
/* Type resqml2__AbstractColumnLayerGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractColumnLayerGridRepresentation': */
class SOAP_CMAC resqml2__AbstractColumnLayerGridRepresentation : public resqml2__AbstractGridRepresentation {
      public:
        /// Required element 'resqml2:Nk' of XSD type 'xsd:positiveInteger'
        ULONG64 Nk;
        /// Optional element 'resqml2:IntervalStratigraphicUnits' of XSD type 'resqml2:IntervalStratigraphicUnits'
        resqml2__IntervalStratigraphicUnits *IntervalStratigraphicUnits;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractColumnLayerGridRepresentation, default initialized and not managed by a soap context
        virtual resqml2__AbstractColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractColumnLayerGridRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__AbstractColumnLayerGridRepresentation()
        {
          Nk = (ULONG64)0;
          IntervalStratigraphicUnits = (resqml2__IntervalStratigraphicUnits *)0;
        }
        virtual ~resqml2__AbstractColumnLayerGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__AbstractColumnLayerGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractColumnLayerGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__AbstractColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:601 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidOrganizationInterpretation (152)
/* Type resqml2__obj_USCORERockFluidOrganizationInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_RockFluidOrganizationInterpretation': */
class SOAP_CMAC resqml2__obj_USCORERockFluidOrganizationInterpretation : public resqml2__AbstractOrganizationInterpretation {
      public:
        /// Required element 'resqml2:RockFluidUnitIndex' of XSD type 'resqml2:RockFluidUnitInterpretationIndex'
        resqml2__RockFluidUnitInterpretationIndex *RockFluidUnitIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidOrganizationInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidOrganizationInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORERockFluidOrganizationInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORERockFluidOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERockFluidOrganizationInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORERockFluidOrganizationInterpretation()
        {
          RockFluidUnitIndex = (resqml2__RockFluidUnitInterpretationIndex *)0;
        }
        virtual ~resqml2__obj_USCORERockFluidOrganizationInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORERockFluidOrganizationInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORERockFluidOrganizationInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORERockFluidOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:619 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitInterpretation (158)
/* Type resqml2__obj_USCORERockFluidUnitInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_RockFluidUnitInterpretation': */
class SOAP_CMAC resqml2__obj_USCORERockFluidUnitInterpretation : public resqml2__obj_USCOREGeologicUnitInterpretation {
      public:
        /// Optional element 'resqml2:Phase' of XSD type 'resqml2:Phase'
        enum resqml2__Phase *Phase;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORERockFluidUnitInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORERockFluidUnitInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERockFluidUnitInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORERockFluidUnitInterpretation()
        {
          Phase = (enum resqml2__Phase *)0;
        }
        virtual ~resqml2__obj_USCORERockFluidUnitInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORERockFluidUnitInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORERockFluidUnitInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORERockFluidUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:631 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyBoundaryInterpretation (162)
/* Type resqml2__obj_USCOREGeobodyBoundaryInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GeobodyBoundaryInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREGeobodyBoundaryInterpretation : public resqml2__obj_USCOREBoundaryFeatureInterpretation {
      public:
        /// Optional element 'resqml2:BoundaryRelation' of XSD type 'resqml2:BoundaryRelation'
        std::vector<enum resqml2__BoundaryRelation> BoundaryRelation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyBoundaryInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyBoundaryInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGeobodyBoundaryInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGeobodyBoundaryInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeobodyBoundaryInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGeobodyBoundaryInterpretation()
        {
        }
        virtual ~resqml2__obj_USCOREGeobodyBoundaryInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGeobodyBoundaryInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGeobodyBoundaryInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGeobodyBoundaryInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:634 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStructuralOrganizationInterpretation (163)
/* Type resqml2__obj_USCOREStructuralOrganizationInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_StructuralOrganizationInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREStructuralOrganizationInterpretation : public resqml2__AbstractOrganizationInterpretation {
      public:
        /// Required element 'resqml2:OrderingCriteria' of XSD type 'resqml2:OrderingCriteria'
        enum resqml2__OrderingCriteria OrderingCriteria;
        /// Optional element 'resqml2:Faults' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> Faults;
        /// Optional element 'resqml2:Horizons' of XSD type 'resqml2:HorizonInterpretationIndex'
        std::vector<resqml2__HorizonInterpretationIndex *> Horizons;
        /// Optional element 'resqml2:Sides' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> Sides;
        /// Optional element 'resqml2:TopFrontier' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> TopFrontier;
        /// Optional element 'resqml2:BottomFrontier' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> BottomFrontier;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStructuralOrganizationInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStructuralOrganizationInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREStructuralOrganizationInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREStructuralOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStructuralOrganizationInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREStructuralOrganizationInterpretation()
        {
          OrderingCriteria = (enum resqml2__OrderingCriteria)0;
        }
        virtual ~resqml2__obj_USCOREStructuralOrganizationInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREStructuralOrganizationInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREStructuralOrganizationInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREStructuralOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:643 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFaultInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFaultInterpretation (166)
/* Type resqml2__obj_USCOREFaultInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_FaultInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREFaultInterpretation : public resqml2__obj_USCOREBoundaryFeatureInterpretation {
      public:
        /// Optional element 'resqml2:IsListric' of XSD type 'xsd:boolean'
        bool *IsListric;
        /// Optional element 'resqml2:MaximumThrow' of XSD type 'eml:LengthMeasure'
        eml__LengthMeasure *MaximumThrow;
        /// Optional element 'resqml2:MeanAzimuth' of XSD type 'eml:PlaneAngleMeasure'
        eml__PlaneAngleMeasure *MeanAzimuth;
        /// Optional element 'resqml2:MeanDip' of XSD type 'eml:PlaneAngleMeasure'
        eml__PlaneAngleMeasure *MeanDip;
        /// Optional element 'resqml2:ThrowInterpretation' of XSD type 'resqml2:FaultThrow'
        std::vector<resqml2__FaultThrow *> ThrowInterpretation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFaultInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFaultInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREFaultInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREFaultInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREFaultInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREFaultInterpretation()
        {
          IsListric = (bool *)0;
          MaximumThrow = (eml__LengthMeasure *)0;
          MeanAzimuth = (eml__PlaneAngleMeasure *)0;
          MeanDip = (eml__PlaneAngleMeasure *)0;
        }
        virtual ~resqml2__obj_USCOREFaultInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREFaultInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREFaultInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREFaultInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:649 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyInterpretation (168)
/* Type resqml2__obj_USCOREGeobodyInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GeobodyInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREGeobodyInterpretation : public resqml2__obj_USCOREGeologicUnitInterpretation {
      public:
        /// Optional element 'resqml2:Geobody3dShape' of XSD type 'resqml2:Geobody3dShape'
        enum resqml2__Geobody3dShape *Geobody3dShape;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGeobodyInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGeobodyInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeobodyInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGeobodyInterpretation()
        {
          Geobody3dShape = (enum resqml2__Geobody3dShape *)0;
        }
        virtual ~resqml2__obj_USCOREGeobodyInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGeobodyInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGeobodyInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGeobodyInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:667 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractStratigraphicOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractStratigraphicOrganizationInterpretation (174)
/* Type resqml2__AbstractStratigraphicOrganizationInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractStratigraphicOrganizationInterpretation': */
class SOAP_CMAC resqml2__AbstractStratigraphicOrganizationInterpretation : public resqml2__AbstractOrganizationInterpretation {
      public:
        /// Required element 'resqml2:OrderingCriteria' of XSD type 'resqml2:OrderingCriteria'
        enum resqml2__OrderingCriteria OrderingCriteria;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractStratigraphicOrganizationInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractStratigraphicOrganizationInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractStratigraphicOrganizationInterpretation, default initialized and not managed by a soap context
        virtual resqml2__AbstractStratigraphicOrganizationInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractStratigraphicOrganizationInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__AbstractStratigraphicOrganizationInterpretation()
        {
          OrderingCriteria = (enum resqml2__OrderingCriteria)0;
        }
        virtual ~resqml2__AbstractStratigraphicOrganizationInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__AbstractStratigraphicOrganizationInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractStratigraphicOrganizationInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__AbstractStratigraphicOrganizationInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:673 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREHorizonInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREHorizonInterpretation (176)
/* Type resqml2__obj_USCOREHorizonInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_HorizonInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREHorizonInterpretation : public resqml2__obj_USCOREBoundaryFeatureInterpretation {
      public:
        /// Optional element 'resqml2:BoundaryRelation' of XSD type 'resqml2:BoundaryRelation'
        std::vector<enum resqml2__BoundaryRelation> BoundaryRelation;
        /// Optional element 'resqml2:SequenceStratigraphySurface' of XSD type 'resqml2:SequenceStratigraphySurface'
        enum resqml2__SequenceStratigraphySurface *SequenceStratigraphySurface;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREHorizonInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREHorizonInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREHorizonInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREHorizonInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREHorizonInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREHorizonInterpretation()
        {
          SequenceStratigraphySurface = (enum resqml2__SequenceStratigraphySurface *)0;
        }
        virtual ~resqml2__obj_USCOREHorizonInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREHorizonInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREHorizonInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREHorizonInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:679 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitInterpretation (178)
/* Type resqml2__obj_USCOREStratigraphicUnitInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_StratigraphicUnitInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicUnitInterpretation : public resqml2__obj_USCOREGeologicUnitInterpretation {
      public:
        /// Optional element 'resqml2:DepositionMode' of XSD type 'resqml2:DepositionMode'
        enum resqml2__DepositionMode *DepositionMode;
        /// Optional element 'resqml2:MaxThickness' of XSD type 'eml:LengthMeasure'
        eml__LengthMeasure *MaxThickness;
        /// Optional element 'resqml2:MinThickness' of XSD type 'eml:LengthMeasure'
        eml__LengthMeasure *MinThickness;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREStratigraphicUnitInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREStratigraphicUnitInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicUnitInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREStratigraphicUnitInterpretation()
        {
          DepositionMode = (enum resqml2__DepositionMode *)0;
          MaxThickness = (eml__LengthMeasure *)0;
          MinThickness = (eml__LengthMeasure *)0;
        }
        virtual ~resqml2__obj_USCOREStratigraphicUnitInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREStratigraphicUnitInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREStratigraphicUnitInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREStratigraphicUnitInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:688 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitFeature (181)
/* Type resqml2__obj_USCOREGeologicUnitFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GeologicUnitFeature': */
class SOAP_CMAC resqml2__obj_USCOREGeologicUnitFeature : public resqml2__AbstractGeologicFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGeologicUnitFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGeologicUnitFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeologicUnitFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGeologicUnitFeature()
        {
        }
        virtual ~resqml2__obj_USCOREGeologicUnitFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGeologicUnitFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGeologicUnitFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGeologicUnitFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:694 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeature (183)
/* Type resqml2__obj_USCOREBoundaryFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_BoundaryFeature': */
class SOAP_CMAC resqml2__obj_USCOREBoundaryFeature : public resqml2__AbstractGeologicFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREBoundaryFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREBoundaryFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREBoundaryFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREBoundaryFeature()
        {
        }
        virtual ~resqml2__obj_USCOREBoundaryFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREBoundaryFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREBoundaryFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREBoundaryFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:715 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREOrganizationFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREOrganizationFeature (190)
/* Type resqml2__obj_USCOREOrganizationFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_OrganizationFeature': */
class SOAP_CMAC resqml2__obj_USCOREOrganizationFeature : public resqml2__AbstractGeologicFeature {
      public:
        /// Required element 'resqml2:OrganizationKind' of XSD type 'resqml2:OrganizationKind'
        enum resqml2__OrganizationKind OrganizationKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREOrganizationFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREOrganizationFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREOrganizationFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREOrganizationFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREOrganizationFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREOrganizationFeature()
        {
          OrganizationKind = (enum resqml2__OrganizationKind)0;
        }
        virtual ~resqml2__obj_USCOREOrganizationFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREOrganizationFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREOrganizationFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREOrganizationFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:757 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBlockedWellboreRepresentation (204)
/* Type resqml2__obj_USCOREBlockedWellboreRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_BlockedWellboreRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREBlockedWellboreRepresentation : public resqml2__obj_USCOREWellboreFrameRepresentation {
      public:
        /// Required element 'resqml2:CellCount' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 CellCount;
        /// Required element 'resqml2:CellIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *CellIndices;
        /// Required element 'resqml2:GridIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *GridIndices;
        /// Required element 'resqml2:LocalFacePairPerCellIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *LocalFacePairPerCellIndices;
        /// Required element 'resqml2:Grid' of XSD type 'eml:DataObjectReference'
        std::vector<eml__DataObjectReference *> Grid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBlockedWellboreRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBlockedWellboreRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREBlockedWellboreRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREBlockedWellboreRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREBlockedWellboreRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREBlockedWellboreRepresentation()
        {
          CellCount = (ULONG64)0;
          CellIndices = (resqml2__AbstractIntegerArray *)0;
          GridIndices = (resqml2__AbstractIntegerArray *)0;
          LocalFacePairPerCellIndices = (resqml2__AbstractIntegerArray *)0;
        }
        virtual ~resqml2__obj_USCOREBlockedWellboreRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREBlockedWellboreRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREBlockedWellboreRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREBlockedWellboreRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:778 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreMarkerFrameRepresentation (211)
/* Type resqml2__obj_USCOREWellboreMarkerFrameRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_WellboreMarkerFrameRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREWellboreMarkerFrameRepresentation : public resqml2__obj_USCOREWellboreFrameRepresentation {
      public:
        /// Required element 'resqml2:WellboreMarker' of XSD type 'resqml2:WellboreMarker'
        std::vector<resqml2__WellboreMarker *> WellboreMarker;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreMarkerFrameRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreMarkerFrameRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREWellboreMarkerFrameRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREWellboreMarkerFrameRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreMarkerFrameRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREWellboreMarkerFrameRepresentation()
        {
        }
        virtual ~resqml2__obj_USCOREWellboreMarkerFrameRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREWellboreMarkerFrameRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREWellboreMarkerFrameRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREWellboreMarkerFrameRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:784 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETriangulatedSetRepresentation (213)
/* Type resqml2__obj_USCORETriangulatedSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_TriangulatedSetRepresentation': */
class SOAP_CMAC resqml2__obj_USCORETriangulatedSetRepresentation : public resqml2__AbstractSurfaceRepresentation {
      public:
        /// Required element 'resqml2:TrianglePatch' of XSD type 'resqml2:TrianglePatch'
        std::vector<resqml2__TrianglePatch *> TrianglePatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETriangulatedSetRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETriangulatedSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORETriangulatedSetRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORETriangulatedSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETriangulatedSetRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORETriangulatedSetRepresentation()
        {
        }
        virtual ~resqml2__obj_USCORETriangulatedSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORETriangulatedSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORETriangulatedSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORETriangulatedSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:796 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPlaneSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPlaneSetRepresentation (217)
/* Type resqml2__obj_USCOREPlaneSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_PlaneSetRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREPlaneSetRepresentation : public resqml2__AbstractSurfaceRepresentation {
      public:
        /// Required element 'resqml2:Planes' of XSD type 'resqml2:AbstractPlaneGeometry'
        std::vector<resqml2__AbstractPlaneGeometry *> Planes;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPlaneSetRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPlaneSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREPlaneSetRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREPlaneSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREPlaneSetRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREPlaneSetRepresentation()
        {
        }
        virtual ~resqml2__obj_USCOREPlaneSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREPlaneSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREPlaneSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREPlaneSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:802 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceFrameworkRepresentation (219)
/* Type resqml2__AbstractSurfaceFrameworkRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractSurfaceFrameworkRepresentation': */
class SOAP_CMAC resqml2__AbstractSurfaceFrameworkRepresentation : public resqml2__obj_USCORERepresentationSetRepresentation {
      public:
        /// Optional element 'resqml2:ContactIdentity' of XSD type 'resqml2:ContactIdentity'
        std::vector<resqml2__ContactIdentity *> ContactIdentity;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceFrameworkRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceFrameworkRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractSurfaceFrameworkRepresentation, default initialized and not managed by a soap context
        virtual resqml2__AbstractSurfaceFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractSurfaceFrameworkRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__AbstractSurfaceFrameworkRepresentation()
        {
        }
        virtual ~resqml2__AbstractSurfaceFrameworkRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__AbstractSurfaceFrameworkRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractSurfaceFrameworkRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__AbstractSurfaceFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:808 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedVolumeFrameworkRepresentation (221)
/* Type resqml2__obj_USCORESealedVolumeFrameworkRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_SealedVolumeFrameworkRepresentation': */
class SOAP_CMAC resqml2__obj_USCORESealedVolumeFrameworkRepresentation : public resqml2__obj_USCORERepresentationSetRepresentation {
      public:
        /// Required element 'resqml2:BasedOn' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *BasedOn;
        /// Required element 'resqml2:Shells' of XSD type 'resqml2:VolumeShell'
        std::vector<resqml2__VolumeShell *> Shells;
        /// Required element 'resqml2:Regions' of XSD type 'resqml2:VolumeRegion'
        std::vector<resqml2__VolumeRegion *> Regions;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedVolumeFrameworkRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedVolumeFrameworkRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORESealedVolumeFrameworkRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORESealedVolumeFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESealedVolumeFrameworkRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORESealedVolumeFrameworkRepresentation()
        {
          BasedOn = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCORESealedVolumeFrameworkRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORESealedVolumeFrameworkRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORESealedVolumeFrameworkRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORESealedVolumeFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:835 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dRepresentation (230)
/* Type resqml2__obj_USCOREGrid2dRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_Grid2dRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREGrid2dRepresentation : public resqml2__AbstractSurfaceRepresentation {
      public:
        /// Required element 'resqml2:Grid2dPatch' of XSD type 'resqml2:Grid2dPatch'
        resqml2__Grid2dPatch *Grid2dPatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGrid2dRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGrid2dRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGrid2dRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGrid2dRepresentation()
        {
          Grid2dPatch = (resqml2__Grid2dPatch *)0;
        }
        virtual ~resqml2__obj_USCOREGrid2dRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGrid2dRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGrid2dRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGrid2dRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:847 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dSetRepresentation (234)
/* Type resqml2__obj_USCOREGrid2dSetRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_Grid2dSetRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREGrid2dSetRepresentation : public resqml2__AbstractSurfaceRepresentation {
      public:
        /// Required element 'resqml2:Grid2dPatch' of XSD type 'resqml2:Grid2dPatch'
        std::vector<resqml2__Grid2dPatch *> Grid2dPatch;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dSetRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dSetRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGrid2dSetRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGrid2dSetRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGrid2dSetRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGrid2dSetRepresentation()
        {
        }
        virtual ~resqml2__obj_USCOREGrid2dSetRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGrid2dSetRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGrid2dSetRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGrid2dSetRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:865 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFrontierFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFrontierFeature (240)
/* Type resqml2__obj_USCOREFrontierFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_FrontierFeature': */
class SOAP_CMAC resqml2__obj_USCOREFrontierFeature : public resqml2__AbstractTechnicalFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFrontierFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFrontierFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREFrontierFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREFrontierFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREFrontierFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREFrontierFeature()
        {
        }
        virtual ~resqml2__obj_USCOREFrontierFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREFrontierFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREFrontierFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREFrontierFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:874 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFeature (243)
/* Type resqml2__obj_USCOREWellboreFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_WellboreFeature': */
class SOAP_CMAC resqml2__obj_USCOREWellboreFeature : public resqml2__AbstractTechnicalFeature {
      public:
        /// Optional element 'resqml2:WitsmlWellbore' of XSD type 'resqml2:WitsmlWellboreReference'
        resqml2__WitsmlWellboreReference *WitsmlWellbore;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREWellboreFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREWellboreFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREWellboreFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREWellboreFeature()
        {
          WitsmlWellbore = (resqml2__WitsmlWellboreReference *)0;
        }
        virtual ~resqml2__obj_USCOREWellboreFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREWellboreFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREWellboreFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREWellboreFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:883 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicSurveyFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicSurveyFeature (246)
/* Type resqml2__AbstractSeismicSurveyFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:AbstractSeismicSurveyFeature': */
class SOAP_CMAC resqml2__AbstractSeismicSurveyFeature : public resqml2__AbstractTechnicalFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicSurveyFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicSurveyFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__AbstractSeismicSurveyFeature, default initialized and not managed by a soap context
        virtual resqml2__AbstractSeismicSurveyFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__AbstractSeismicSurveyFeature); }
      public:
        /// Constructor with initializations
        resqml2__AbstractSeismicSurveyFeature()
        {
        }
        virtual ~resqml2__AbstractSeismicSurveyFeature() { }
        /// Friend allocator used by soap_new_resqml2__AbstractSeismicSurveyFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__AbstractSeismicSurveyFeature * SOAP_FMAC2 soap_instantiate_resqml2__AbstractSeismicSurveyFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:928 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesFeature (261)
/* Type resqml2__obj_USCOREStreamlinesFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_StreamlinesFeature': */
class SOAP_CMAC resqml2__obj_USCOREStreamlinesFeature : public resqml2__AbstractTechnicalFeature {
      public:
        /// Required element 'resqml2:Flux' of XSD type 'resqml2:StreamlineFlux'
        enum resqml2__StreamlineFlux Flux;
        /// Optional element 'resqml2:OtherFlux' of XSD type 'xsd:string'
        std::string *OtherFlux;
        /// Required element 'resqml2:TimeIndex' of XSD type 'resqml2:TimeIndex'
        resqml2__TimeIndex *TimeIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREStreamlinesFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREStreamlinesFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStreamlinesFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREStreamlinesFeature()
        {
          Flux = (enum resqml2__StreamlineFlux)0;
          OtherFlux = (std::string *)0;
          TimeIndex = (resqml2__TimeIndex *)0;
        }
        virtual ~resqml2__obj_USCOREStreamlinesFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREStreamlinesFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREStreamlinesFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREStreamlinesFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:29533 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_GeodeticCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_GeodeticCRSType (1184)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_GeodeticCRSType
{
        #define SOAP_UNION_gsoap_resqml2_0_1__gml__union_GeodeticCRSType_ellipsoidalCS	(1)	/**< union variant selector value for member ellipsoidalCS */
        gml__EllipsoidalCSPropertyType *ellipsoidalCS;
        #define SOAP_UNION_gsoap_resqml2_0_1__gml__union_GeodeticCRSType_cartesianCS	(2)	/**< union variant selector value for member cartesianCS */
        gml__CartesianCSPropertyType *cartesianCS;
        #define SOAP_UNION_gsoap_resqml2_0_1__gml__union_GeodeticCRSType_sphericalCS	(3)	/**< union variant selector value for member sphericalCS */
        gml__SphericalCSPropertyType *sphericalCS;
};
#endif

/* resqml2_0_1ForGsoap.h:1534 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSType (463)
/* Type gml__GeodeticCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:GeodeticCRSType': */
class SOAP_CMAC gml__GeodeticCRSType : public gml__AbstractCRSType {
      public:
        /// Union with union _gml__union_GeodeticCRSType variant selector __union_GeodeticCRSType set to one of: SOAP_UNION_gsoap_resqml2_0_1__gml__union_GeodeticCRSType_ellipsoidalCS SOAP_UNION_gsoap_resqml2_0_1__gml__union_GeodeticCRSType_cartesianCS SOAP_UNION_gsoap_resqml2_0_1__gml__union_GeodeticCRSType_sphericalCS
        int __union_GeodeticCRSType;
        union _gml__union_GeodeticCRSType union_GeodeticCRSType;
        /// Required element 'gml:geodeticDatum' of XSD type 'gml:GeodeticDatumPropertyType'
        gml__GeodeticDatumPropertyType *geodeticDatum;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticCRSType, default initialized and not managed by a soap context
        virtual gml__GeodeticCRSType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticCRSType); }
      public:
        /// Constructor with initializations
        gml__GeodeticCRSType()
        {
          __union_GeodeticCRSType = -1;
          geodeticDatum = (gml__GeodeticDatumPropertyType *)0;
        }
        virtual ~gml__GeodeticCRSType() { }
        /// Friend allocator used by soap_new_gml__GeodeticCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticCRSType * SOAP_FMAC2 soap_instantiate_gml__GeodeticCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1579 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSType (478)
/* Type gml__EllipsoidalCSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:EllipsoidalCSType': */
class SOAP_CMAC gml__EllipsoidalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__EllipsoidalCSType, default initialized and not managed by a soap context
        virtual gml__EllipsoidalCSType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidalCSType); }
      public:
        /// Constructor with initializations
        gml__EllipsoidalCSType()
        {
        }
        virtual ~gml__EllipsoidalCSType() { }
        /// Friend allocator used by soap_new_gml__EllipsoidalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__EllipsoidalCSType * SOAP_FMAC2 soap_instantiate_gml__EllipsoidalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1594 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSType (483)
/* Type gml__CartesianCSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:CartesianCSType': */
class SOAP_CMAC gml__CartesianCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__CartesianCSType, default initialized and not managed by a soap context
        virtual gml__CartesianCSType *soap_alloc(void) const { return SOAP_NEW(gml__CartesianCSType); }
      public:
        /// Constructor with initializations
        gml__CartesianCSType()
        {
        }
        virtual ~gml__CartesianCSType() { }
        /// Friend allocator used by soap_new_gml__CartesianCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__CartesianCSType * SOAP_FMAC2 soap_instantiate_gml__CartesianCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1600 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSType (485)
/* Type gml__SphericalCSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:SphericalCSType': */
class SOAP_CMAC gml__SphericalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__SphericalCSType, default initialized and not managed by a soap context
        virtual gml__SphericalCSType *soap_alloc(void) const { return SOAP_NEW(gml__SphericalCSType); }
      public:
        /// Constructor with initializations
        gml__SphericalCSType()
        {
        }
        virtual ~gml__SphericalCSType() { }
        /// Friend allocator used by soap_new_gml__SphericalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__SphericalCSType * SOAP_FMAC2 soap_instantiate_gml__SphericalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1606 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumType (487)
/* Type gml__GeodeticDatumType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:GeodeticDatumType': */
class SOAP_CMAC gml__GeodeticDatumType : public gml__AbstractDatumType {
      public:
        /// Required element 'gml:primeMeridian' of XSD type 'gml:PrimeMeridianPropertyType'
        gml__PrimeMeridianPropertyType *primeMeridian;
        /// Required element 'gml:ellipsoid' of XSD type 'gml:EllipsoidPropertyType'
        gml__EllipsoidPropertyType *ellipsoid;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__GeodeticDatumType, default initialized and not managed by a soap context
        virtual gml__GeodeticDatumType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticDatumType); }
      public:
        /// Constructor with initializations
        gml__GeodeticDatumType()
        {
          primeMeridian = (gml__PrimeMeridianPropertyType *)0;
          ellipsoid = (gml__EllipsoidPropertyType *)0;
        }
        virtual ~gml__GeodeticDatumType() { }
        /// Friend allocator used by soap_new_gml__GeodeticDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__GeodeticDatumType * SOAP_FMAC2 soap_instantiate_gml__GeodeticDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1636 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralDerivedCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralDerivedCRSType (497)
/* Type gml__AbstractGeneralDerivedCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:AbstractGeneralDerivedCRSType': */
class SOAP_CMAC gml__AbstractGeneralDerivedCRSType : public gml__AbstractCRSType {
      public:
        /// Required element 'gml:conversion' of XSD type 'gml:GeneralConversionPropertyType'
        gml__GeneralConversionPropertyType *conversion;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralDerivedCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralDerivedCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralDerivedCRSType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralDerivedCRSType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGeneralDerivedCRSType); }
      public:
        /// Constructor with initializations
        gml__AbstractGeneralDerivedCRSType()
        {
          conversion = (gml__GeneralConversionPropertyType *)0;
        }
        virtual ~gml__AbstractGeneralDerivedCRSType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralDerivedCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralDerivedCRSType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralDerivedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1642 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralConversionType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralConversionType (499)
/* complex XSD type 'gml:AbstractGeneralConversionType': */
class SOAP_CMAC gml__AbstractGeneralConversionType {
      public:
        /// Optional element 'gml:description' of XSD type 'gml:StringOrRefType'
        gml__StringOrRefType *description;
        /// Optional element 'gml:descriptionReference' of XSD type 'gml:ReferenceType'
        gml__ReferenceType *descriptionReference;
        /// Required element 'gml:identifier' of XSD type 'gml:CodeWithAuthorityType'
        gml__CodeWithAuthorityType *identifier;
        /// Optional element 'gml:name' of XSD type 'gml:CodeType'
        std::vector<gml__CodeType *> name;
        /// Optional element 'gml:remarks' of XSD type 'xsd:string'
        std::string *remarks;
        /// Optional element 'gml:domainOfValidity' of XSD type 'gml:domainOfValidity'
        _gml__domainOfValidity *domainOfValidity;
        /// Required element 'gml:scope' of XSD type 'xsd:string'
        std::vector<std::string> scope;
        /// Optional element 'gml:coordinateOperationAccuracy' of XSD type 'gml:coordinateOperationAccuracy'
        std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;
        /// required attribute 'gml:id' of XSD type 'xsd:ID'
        std::string gml__id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralConversionType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralConversionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__AbstractGeneralConversionType, default initialized and not managed by a soap context
        virtual gml__AbstractGeneralConversionType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGeneralConversionType); }
      public:
        /// Constructor with initializations
        gml__AbstractGeneralConversionType()
        {
          description = (gml__StringOrRefType *)0;
          descriptionReference = (gml__ReferenceType *)0;
          identifier = (gml__CodeWithAuthorityType *)0;
          remarks = (std::string *)0;
          domainOfValidity = (_gml__domainOfValidity *)0;
          soap = (struct soap *)0;
        }
        virtual ~gml__AbstractGeneralConversionType() { }
        /// Friend allocator used by soap_new_gml__AbstractGeneralConversionType(struct soap*, int)
        friend SOAP_FMAC1 gml__AbstractGeneralConversionType * SOAP_FMAC2 soap_instantiate_gml__AbstractGeneralConversionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1654 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCRSType (503)
/* Type gml__VerticalCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:VerticalCRSType': */
class SOAP_CMAC gml__VerticalCRSType : public gml__AbstractCRSType {
      public:
        /// Required element 'gml:verticalCS' of XSD type 'gml:VerticalCSPropertyType'
        gml__VerticalCSPropertyType *verticalCS;
        /// Required element 'gml:verticalDatum' of XSD type 'gml:VerticalDatumPropertyType'
        gml__VerticalDatumPropertyType *verticalDatum;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCRSType, default initialized and not managed by a soap context
        virtual gml__VerticalCRSType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCRSType); }
      public:
        /// Constructor with initializations
        gml__VerticalCRSType()
        {
          verticalCS = (gml__VerticalCSPropertyType *)0;
          verticalDatum = (gml__VerticalDatumPropertyType *)0;
        }
        virtual ~gml__VerticalCRSType() { }
        /// Friend allocator used by soap_new_gml__VerticalCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCRSType * SOAP_FMAC2 soap_instantiate_gml__VerticalCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1660 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSType (505)
/* Type gml__VerticalCSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:VerticalCSType': */
class SOAP_CMAC gml__VerticalCSType : public gml__AbstractCoordinateSystemType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalCSType, default initialized and not managed by a soap context
        virtual gml__VerticalCSType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCSType); }
      public:
        /// Constructor with initializations
        gml__VerticalCSType()
        {
        }
        virtual ~gml__VerticalCSType() { }
        /// Friend allocator used by soap_new_gml__VerticalCSType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalCSType * SOAP_FMAC2 soap_instantiate_gml__VerticalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:1666 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumType (507)
/* Type gml__VerticalDatumType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:VerticalDatumType': */
class SOAP_CMAC gml__VerticalDatumType : public gml__AbstractDatumType {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__VerticalDatumType, default initialized and not managed by a soap context
        virtual gml__VerticalDatumType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalDatumType); }
      public:
        /// Constructor with initializations
        gml__VerticalDatumType()
        {
        }
        virtual ~gml__VerticalDatumType() { }
        /// Friend allocator used by soap_new_gml__VerticalDatumType(struct soap*, int)
        friend SOAP_FMAC1 gml__VerticalDatumType * SOAP_FMAC2 soap_instantiate_gml__VerticalDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:466 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation (107)
/* Type resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_UnstructuredColumnLayerGridRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation : public resqml2__AbstractColumnLayerGridRepresentation {
      public:
        /// Required element 'resqml2:ColumnCount' of XSD type 'xsd:positiveInteger'
        ULONG64 ColumnCount;
        /// Optional element 'resqml2:Geometry' of XSD type 'resqml2:UnstructuredColumnLayerGridGeometry'
        resqml2__UnstructuredColumnLayerGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation()
        {
          ColumnCount = (ULONG64)0;
          Geometry = (resqml2__UnstructuredColumnLayerGridGeometry *)0;
        }
        virtual ~resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:472 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREIjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREIjkGridRepresentation (109)
/* Type resqml2__obj_USCOREIjkGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_IjkGridRepresentation': */
class SOAP_CMAC resqml2__obj_USCOREIjkGridRepresentation : public resqml2__AbstractColumnLayerGridRepresentation {
      public:
        /// Required element 'resqml2:Ni' of XSD type 'xsd:positiveInteger'
        ULONG64 Ni;
        /// Required element 'resqml2:Nj' of XSD type 'xsd:positiveInteger'
        ULONG64 Nj;
        /// Optional element 'resqml2:RadialGridIsComplete' of XSD type 'xsd:boolean'
        bool *RadialGridIsComplete;
        /// Optional element 'resqml2:KGaps' of XSD type 'resqml2:KGaps'
        resqml2__KGaps *KGaps;
        /// Optional element 'resqml2:Geometry' of XSD type 'resqml2:IjkGridGeometry'
        resqml2__IjkGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREIjkGridRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREIjkGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREIjkGridRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREIjkGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREIjkGridRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREIjkGridRepresentation()
        {
          Ni = (ULONG64)0;
          Nj = (ULONG64)0;
          RadialGridIsComplete = (bool *)0;
          KGaps = (resqml2__KGaps *)0;
          Geometry = (resqml2__IjkGridGeometry *)0;
        }
        virtual ~resqml2__obj_USCOREIjkGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREIjkGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREIjkGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREIjkGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:553 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation (136)
/* Type resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_TruncatedUnstructuredColumnLayerGridRepresentation': */
class SOAP_CMAC resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation : public resqml2__AbstractTruncatedColumnLayerGridRepresentation {
      public:
        /// Required element 'resqml2:ColumnCount' of XSD type 'xsd:positiveInteger'
        ULONG64 ColumnCount;
        /// Required element 'resqml2:Geometry' of XSD type 'resqml2:UnstructuredColumnLayerGridGeometry'
        resqml2__UnstructuredColumnLayerGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation()
        {
          ColumnCount = (ULONG64)0;
          Geometry = (resqml2__UnstructuredColumnLayerGridGeometry *)0;
        }
        virtual ~resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:565 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedIjkGridRepresentation (140)
/* Type resqml2__obj_USCORETruncatedIjkGridRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_TruncatedIjkGridRepresentation': */
class SOAP_CMAC resqml2__obj_USCORETruncatedIjkGridRepresentation : public resqml2__AbstractTruncatedColumnLayerGridRepresentation {
      public:
        /// Required element 'resqml2:Ni' of XSD type 'xsd:positiveInteger'
        ULONG64 Ni;
        /// Required element 'resqml2:Nj' of XSD type 'xsd:positiveInteger'
        ULONG64 Nj;
        /// Required element 'resqml2:Geometry' of XSD type 'resqml2:IjkGridGeometry'
        resqml2__IjkGridGeometry *Geometry;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedIjkGridRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedIjkGridRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORETruncatedIjkGridRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORETruncatedIjkGridRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETruncatedIjkGridRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORETruncatedIjkGridRepresentation()
        {
          Ni = (ULONG64)0;
          Nj = (ULONG64)0;
          Geometry = (resqml2__IjkGridGeometry *)0;
        }
        virtual ~resqml2__obj_USCORETruncatedIjkGridRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORETruncatedIjkGridRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORETruncatedIjkGridRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORETruncatedIjkGridRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:664 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumnRankInterpretation (173)
/* Type resqml2__obj_USCOREStratigraphicColumnRankInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_StratigraphicColumnRankInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicColumnRankInterpretation : public resqml2__AbstractStratigraphicOrganizationInterpretation {
      public:
        /// Required element 'resqml2:Index' of XSD type 'xsd:nonNegativeInteger'
        ULONG64 Index;
        /// Required element 'resqml2:StratigraphicUnits' of XSD type 'resqml2:StratigraphicUnitInterpretationIndex'
        std::vector<resqml2__StratigraphicUnitInterpretationIndex *> StratigraphicUnits;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumnRankInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumnRankInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREStratigraphicColumnRankInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREStratigraphicColumnRankInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicColumnRankInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREStratigraphicColumnRankInterpretation()
        {
          Index = (ULONG64)0;
        }
        virtual ~resqml2__obj_USCOREStratigraphicColumnRankInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREStratigraphicColumnRankInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREStratigraphicColumnRankInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREStratigraphicColumnRankInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:682 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation (179)
/* Type resqml2__obj_USCOREStratigraphicOccurrenceInterpretation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_StratigraphicOccurrenceInterpretation': */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicOccurrenceInterpretation : public resqml2__AbstractStratigraphicOrganizationInterpretation {
      public:
        /// Optional element 'resqml2:IsOccurrenceOf' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *IsOccurrenceOf;
        /// Optional element 'resqml2:GeologicUnitIndex' of XSD type 'resqml2:GeologicUnitInterpretationIndex'
        std::vector<resqml2__GeologicUnitInterpretationIndex *> GeologicUnitIndex;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREStratigraphicOccurrenceInterpretation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREStratigraphicOccurrenceInterpretation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicOccurrenceInterpretation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREStratigraphicOccurrenceInterpretation()
        {
          IsOccurrenceOf = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCOREStratigraphicOccurrenceInterpretation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREStratigraphicOccurrenceInterpretation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:685 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFluidBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFluidBoundaryFeature (180)
/* Type resqml2__obj_USCOREFluidBoundaryFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_FluidBoundaryFeature': */
class SOAP_CMAC resqml2__obj_USCOREFluidBoundaryFeature : public resqml2__obj_USCOREBoundaryFeature {
      public:
        /// Required element 'resqml2:FluidContact' of XSD type 'resqml2:FluidContact'
        enum resqml2__FluidContact FluidContact;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFluidBoundaryFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFluidBoundaryFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREFluidBoundaryFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREFluidBoundaryFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREFluidBoundaryFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREFluidBoundaryFeature()
        {
          FluidContact = (enum resqml2__FluidContact)0;
        }
        virtual ~resqml2__obj_USCOREFluidBoundaryFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREFluidBoundaryFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREFluidBoundaryFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREFluidBoundaryFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:691 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitFeature (182)
/* Type resqml2__obj_USCORERockFluidUnitFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_RockFluidUnitFeature': */
class SOAP_CMAC resqml2__obj_USCORERockFluidUnitFeature : public resqml2__obj_USCOREGeologicUnitFeature {
      public:
        /// Required element 'resqml2:Phase' of XSD type 'resqml2:Phase'
        enum resqml2__Phase Phase;
        /// Required element 'resqml2:FluidBoundaryBottom' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *FluidBoundaryBottom;
        /// Required element 'resqml2:FluidBoundaryTop' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *FluidBoundaryTop;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORERockFluidUnitFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORERockFluidUnitFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORERockFluidUnitFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORERockFluidUnitFeature()
        {
          Phase = (enum resqml2__Phase)0;
          FluidBoundaryBottom = (eml__DataObjectReference *)0;
          FluidBoundaryTop = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCORERockFluidUnitFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORERockFluidUnitFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORERockFluidUnitFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORERockFluidUnitFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:703 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitFeature (186)
/* Type resqml2__obj_USCOREStratigraphicUnitFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_StratigraphicUnitFeature': */
class SOAP_CMAC resqml2__obj_USCOREStratigraphicUnitFeature : public resqml2__obj_USCOREGeologicUnitFeature {
      public:
        /// Optional element 'resqml2:ChronostratigraphicBottom' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *ChronostratigraphicBottom;
        /// Optional element 'resqml2:ChronostratigraphicTop' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *ChronostratigraphicTop;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREStratigraphicUnitFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREStratigraphicUnitFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREStratigraphicUnitFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREStratigraphicUnitFeature()
        {
          ChronostratigraphicBottom = (eml__DataObjectReference *)0;
          ChronostratigraphicTop = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCOREStratigraphicUnitFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREStratigraphicUnitFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREStratigraphicUnitFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREStratigraphicUnitFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:709 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeneticBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeneticBoundaryFeature (188)
/* Type resqml2__obj_USCOREGeneticBoundaryFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GeneticBoundaryFeature': */
class SOAP_CMAC resqml2__obj_USCOREGeneticBoundaryFeature : public resqml2__obj_USCOREBoundaryFeature {
      public:
        /// Required element 'resqml2:GeneticBoundaryKind' of XSD type 'resqml2:GeneticBoundaryKind'
        enum resqml2__GeneticBoundaryKind GeneticBoundaryKind;
        /// Optional element 'resqml2:AbsoluteAge' of XSD type 'resqml2:Timestamp'
        resqml2__Timestamp *AbsoluteAge;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeneticBoundaryFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeneticBoundaryFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGeneticBoundaryFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGeneticBoundaryFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeneticBoundaryFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGeneticBoundaryFeature()
        {
          GeneticBoundaryKind = (enum resqml2__GeneticBoundaryKind)0;
          AbsoluteAge = (resqml2__Timestamp *)0;
        }
        virtual ~resqml2__obj_USCOREGeneticBoundaryFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGeneticBoundaryFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGeneticBoundaryFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGeneticBoundaryFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:712 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyFeature (189)
/* Type resqml2__obj_USCOREGeobodyFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_GeobodyFeature': */
class SOAP_CMAC resqml2__obj_USCOREGeobodyFeature : public resqml2__obj_USCOREGeologicUnitFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREGeobodyFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREGeobodyFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREGeobodyFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREGeobodyFeature()
        {
        }
        virtual ~resqml2__obj_USCOREGeobodyFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREGeobodyFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREGeobodyFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREGeobodyFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:718 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETectonicBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETectonicBoundaryFeature (191)
/* Type resqml2__obj_USCORETectonicBoundaryFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_TectonicBoundaryFeature': */
class SOAP_CMAC resqml2__obj_USCORETectonicBoundaryFeature : public resqml2__obj_USCOREBoundaryFeature {
      public:
        /// Required element 'resqml2:TectonicBoundaryKind' of XSD type 'resqml2:TectonicBoundaryKind'
        enum resqml2__TectonicBoundaryKind TectonicBoundaryKind;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETectonicBoundaryFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETectonicBoundaryFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORETectonicBoundaryFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORETectonicBoundaryFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORETectonicBoundaryFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORETectonicBoundaryFeature()
        {
          TectonicBoundaryKind = (enum resqml2__TectonicBoundaryKind)0;
        }
        virtual ~resqml2__obj_USCORETectonicBoundaryFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORETectonicBoundaryFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORETectonicBoundaryFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORETectonicBoundaryFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:781 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation (212)
/* Type resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_NonSealedSurfaceFrameworkRepresentation': */
class SOAP_CMAC resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation : public resqml2__AbstractSurfaceFrameworkRepresentation {
      public:
        /// Optional element 'resqml2:NonSealedContactRepresentation' of XSD type 'resqml2:AbstractContactRepresentationPart'
        std::vector<resqml2__AbstractContactRepresentationPart *> NonSealedContactRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation()
        {
        }
        virtual ~resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:826 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation (227)
/* Type resqml2__obj_USCORESealedSurfaceFrameworkRepresentation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_SealedSurfaceFrameworkRepresentation': */
class SOAP_CMAC resqml2__obj_USCORESealedSurfaceFrameworkRepresentation : public resqml2__AbstractSurfaceFrameworkRepresentation {
      public:
        /// Optional element 'resqml2:SealedContactRepresentation' of XSD type 'resqml2:SealedContactRepresentationPart'
        std::vector<resqml2__SealedContactRepresentationPart *> SealedContactRepresentation;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORESealedSurfaceFrameworkRepresentation, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORESealedSurfaceFrameworkRepresentation *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESealedSurfaceFrameworkRepresentation); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORESealedSurfaceFrameworkRepresentation()
        {
        }
        virtual ~resqml2__obj_USCORESealedSurfaceFrameworkRepresentation() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORESealedSurfaceFrameworkRepresentation * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:868 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SeismicLatticeSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SeismicLatticeSetFeature (241)
/* Type resqml2__SeismicLatticeSetFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:SeismicLatticeSetFeature': */
class SOAP_CMAC resqml2__SeismicLatticeSetFeature : public resqml2__AbstractSeismicSurveyFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SeismicLatticeSetFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SeismicLatticeSetFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__SeismicLatticeSetFeature, default initialized and not managed by a soap context
        virtual resqml2__SeismicLatticeSetFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__SeismicLatticeSetFeature); }
      public:
        /// Constructor with initializations
        resqml2__SeismicLatticeSetFeature()
        {
        }
        virtual ~resqml2__SeismicLatticeSetFeature() { }
        /// Friend allocator used by soap_new_resqml2__SeismicLatticeSetFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__SeismicLatticeSetFeature * SOAP_FMAC2 soap_instantiate_resqml2__SeismicLatticeSetFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:871 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineSetFeature (242)
/* Type resqml2__obj_USCORESeismicLineSetFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_SeismicLineSetFeature': */
class SOAP_CMAC resqml2__obj_USCORESeismicLineSetFeature : public resqml2__AbstractSeismicSurveyFeature {
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineSetFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineSetFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORESeismicLineSetFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORESeismicLineSetFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESeismicLineSetFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORESeismicLineSetFeature()
        {
        }
        virtual ~resqml2__obj_USCORESeismicLineSetFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORESeismicLineSetFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORESeismicLineSetFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORESeismicLineSetFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:877 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineFeature (244)
/* Type resqml2__obj_USCORESeismicLineFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_SeismicLineFeature': */
class SOAP_CMAC resqml2__obj_USCORESeismicLineFeature : public resqml2__AbstractSeismicSurveyFeature {
      public:
        /// Required element 'resqml2:FirstTraceIndex' of XSD type 'xsd:integer'
        LONG64 FirstTraceIndex;
        /// Required element 'resqml2:TraceCount' of XSD type 'xsd:positiveInteger'
        ULONG64 TraceCount;
        /// Required element 'resqml2:TraceIndexIncrement' of XSD type 'xsd:integer'
        LONG64 TraceIndexIncrement;
        /// Optional element 'resqml2:IsPartOf' of XSD type 'eml:DataObjectReference'
        eml__DataObjectReference *IsPartOf;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORESeismicLineFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORESeismicLineFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESeismicLineFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORESeismicLineFeature()
        {
          FirstTraceIndex = (LONG64)0;
          TraceCount = (ULONG64)0;
          TraceIndexIncrement = (LONG64)0;
          IsPartOf = (eml__DataObjectReference *)0;
        }
        virtual ~resqml2__obj_USCORESeismicLineFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORESeismicLineFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORESeismicLineFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORESeismicLineFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:880 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLatticeFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLatticeFeature (245)
/* Type resqml2__obj_USCORESeismicLatticeFeature is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_SeismicLatticeFeature': */
class SOAP_CMAC resqml2__obj_USCORESeismicLatticeFeature : public resqml2__AbstractSeismicSurveyFeature {
      public:
        /// Required element 'resqml2:CrosslineCount' of XSD type 'xsd:positiveInteger'
        ULONG64 CrosslineCount;
        /// Required element 'resqml2:CrosslineIndexIncrement' of XSD type 'xsd:integer'
        LONG64 CrosslineIndexIncrement;
        /// Required element 'resqml2:FirstCrosslineIndex' of XSD type 'xsd:integer'
        LONG64 FirstCrosslineIndex;
        /// Required element 'resqml2:FirstInlineIndex' of XSD type 'xsd:integer'
        LONG64 FirstInlineIndex;
        /// Required element 'resqml2:InlineCount' of XSD type 'xsd:positiveInteger'
        ULONG64 InlineCount;
        /// Required element 'resqml2:InlineIndexIncrement' of XSD type 'xsd:integer'
        LONG64 InlineIndexIncrement;
        /// Optional element 'resqml2:IsPartOf' of XSD type 'resqml2:SeismicLatticeSetFeature'
        resqml2__SeismicLatticeSetFeature *IsPartOf;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLatticeFeature
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLatticeFeature; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORESeismicLatticeFeature, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORESeismicLatticeFeature *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORESeismicLatticeFeature); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORESeismicLatticeFeature()
        {
          CrosslineCount = (ULONG64)0;
          CrosslineIndexIncrement = (LONG64)0;
          FirstCrosslineIndex = (LONG64)0;
          FirstInlineIndex = (LONG64)0;
          InlineCount = (ULONG64)0;
          InlineIndexIncrement = (LONG64)0;
          IsPartOf = (resqml2__SeismicLatticeSetFeature *)0;
        }
        virtual ~resqml2__obj_USCORESeismicLatticeFeature() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORESeismicLatticeFeature(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORESeismicLatticeFeature * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORESeismicLatticeFeature(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:943 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousPropertySeries (266)
/* Type resqml2__obj_USCOREContinuousPropertySeries is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_ContinuousPropertySeries': */
class SOAP_CMAC resqml2__obj_USCOREContinuousPropertySeries : public resqml2__obj_USCOREContinuousProperty {
      public:
        /// Optional element 'resqml2:RealizationIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *RealizationIndices;
        /// Optional element 'resqml2:SeriesTimeIndices' of XSD type 'resqml2:TimeIndices'
        resqml2__TimeIndices *SeriesTimeIndices;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousPropertySeries
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousPropertySeries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREContinuousPropertySeries, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREContinuousPropertySeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREContinuousPropertySeries); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREContinuousPropertySeries()
        {
          RealizationIndices = (resqml2__AbstractIntegerArray *)0;
          SeriesTimeIndices = (resqml2__TimeIndices *)0;
        }
        virtual ~resqml2__obj_USCOREContinuousPropertySeries() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREContinuousPropertySeries(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREContinuousPropertySeries * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREContinuousPropertySeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:946 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalPropertySeries (267)
/* Type resqml2__obj_USCORECategoricalPropertySeries is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_CategoricalPropertySeries': */
class SOAP_CMAC resqml2__obj_USCORECategoricalPropertySeries : public resqml2__obj_USCORECategoricalProperty {
      public:
        /// Optional element 'resqml2:RealizationIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *RealizationIndices;
        /// Optional element 'resqml2:SeriesTimeIndices' of XSD type 'resqml2:TimeIndices'
        resqml2__TimeIndices *SeriesTimeIndices;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalPropertySeries
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalPropertySeries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORECategoricalPropertySeries, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORECategoricalPropertySeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORECategoricalPropertySeries); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORECategoricalPropertySeries()
        {
          RealizationIndices = (resqml2__AbstractIntegerArray *)0;
          SeriesTimeIndices = (resqml2__TimeIndices *)0;
        }
        virtual ~resqml2__obj_USCORECategoricalPropertySeries() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORECategoricalPropertySeries(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORECategoricalPropertySeries * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORECategoricalPropertySeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:949 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentPropertySeries (268)
/* Type resqml2__obj_USCORECommentPropertySeries is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_CommentPropertySeries': */
class SOAP_CMAC resqml2__obj_USCORECommentPropertySeries : public resqml2__obj_USCORECommentProperty {
      public:
        /// Optional element 'resqml2:RealizationIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *RealizationIndices;
        /// Optional element 'resqml2:SeriesTimeIndices' of XSD type 'resqml2:TimeIndices'
        resqml2__TimeIndices *SeriesTimeIndices;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentPropertySeries
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentPropertySeries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCORECommentPropertySeries, default initialized and not managed by a soap context
        virtual resqml2__obj_USCORECommentPropertySeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCORECommentPropertySeries); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCORECommentPropertySeries()
        {
          RealizationIndices = (resqml2__AbstractIntegerArray *)0;
          SeriesTimeIndices = (resqml2__TimeIndices *)0;
        }
        virtual ~resqml2__obj_USCORECommentPropertySeries() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCORECommentPropertySeries(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCORECommentPropertySeries * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCORECommentPropertySeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:952 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscretePropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscretePropertySeries (269)
/* Type resqml2__obj_USCOREDiscretePropertySeries is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'resqml2:obj_DiscretePropertySeries': */
class SOAP_CMAC resqml2__obj_USCOREDiscretePropertySeries : public resqml2__obj_USCOREDiscreteProperty {
      public:
        /// Optional element 'resqml2:RealizationIndices' of XSD type 'resqml2:AbstractIntegerArray'
        resqml2__AbstractIntegerArray *RealizationIndices;
        /// Optional element 'resqml2:SeriesTimeIndices' of XSD type 'resqml2:TimeIndices'
        resqml2__TimeIndices *SeriesTimeIndices;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscretePropertySeries
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscretePropertySeries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type resqml2__obj_USCOREDiscretePropertySeries, default initialized and not managed by a soap context
        virtual resqml2__obj_USCOREDiscretePropertySeries *soap_alloc(void) const { return SOAP_NEW(resqml2__obj_USCOREDiscretePropertySeries); }
      public:
        /// Constructor with initializations
        resqml2__obj_USCOREDiscretePropertySeries()
        {
          RealizationIndices = (resqml2__AbstractIntegerArray *)0;
          SeriesTimeIndices = (resqml2__TimeIndices *)0;
        }
        virtual ~resqml2__obj_USCOREDiscretePropertySeries() { }
        /// Friend allocator used by soap_new_resqml2__obj_USCOREDiscretePropertySeries(struct soap*, int)
        friend SOAP_FMAC1 resqml2__obj_USCOREDiscretePropertySeries * SOAP_FMAC2 soap_instantiate_resqml2__obj_USCOREDiscretePropertySeries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:31113 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__union_ProjectedCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__union_ProjectedCRSType (1202)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _gml__union_ProjectedCRSType
{
        #define SOAP_UNION_gsoap_resqml2_0_1__gml__union_ProjectedCRSType_baseGeodeticCRS	(1)	/**< union variant selector value for member baseGeodeticCRS */
        gml__GeodeticCRSPropertyType *baseGeodeticCRS;
};
#endif

/* resqml2_0_1ForGsoap.h:1633 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__ProjectedCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__ProjectedCRSType (496)
/* Type gml__ProjectedCRSType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'gml:ProjectedCRSType': */
class SOAP_CMAC gml__ProjectedCRSType : public gml__AbstractGeneralDerivedCRSType {
      public:
        /// Union with union _gml__union_ProjectedCRSType variant selector __union_ProjectedCRSType set to one of: SOAP_UNION_gsoap_resqml2_0_1__gml__union_ProjectedCRSType_baseGeodeticCRS
        int __union_ProjectedCRSType;
        union _gml__union_ProjectedCRSType union_ProjectedCRSType;
        /// Required element 'gml:cartesianCS' of XSD type 'gml:CartesianCSPropertyType'
        gml__CartesianCSPropertyType *cartesianCS;
      public:
        /// Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_gml__ProjectedCRSType
        virtual int soap_type(void) const { return SOAP_TYPE_gsoap_resqml2_0_1_gml__ProjectedCRSType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type gml__ProjectedCRSType, default initialized and not managed by a soap context
        virtual gml__ProjectedCRSType *soap_alloc(void) const { return SOAP_NEW(gml__ProjectedCRSType); }
      public:
        /// Constructor with initializations
        gml__ProjectedCRSType()
        {
          __union_ProjectedCRSType = -1;
          cartesianCS = (gml__CartesianCSPropertyType *)0;
        }
        virtual ~gml__ProjectedCRSType() { }
        /// Friend allocator used by soap_new_gml__ProjectedCRSType(struct soap*, int)
        friend SOAP_FMAC1 gml__ProjectedCRSType * SOAP_FMAC2 soap_instantiate_gml__ProjectedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* resqml2_0_1ForGsoap.h:33183 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Header (1357)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* resqml2_0_1ForGsoap.h:33183 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Code (1358)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* resqml2_0_1ForGsoap.h:33183 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Detail (1360)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* resqml2_0_1ForGsoap.h:33183 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Reason (1363)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* resqml2_0_1ForGsoap.h:33183 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Fault (1364)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* resqml2_0_1ForGsoap.h:1 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__QName
#define SOAP_TYPE_gsoap_resqml2_0_1__QName (5)
typedef char *_QName;
#endif

/* resqml2_0_1ForGsoap.h:1 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__XML
#define SOAP_TYPE_gsoap_resqml2_0_1__XML (6)
typedef char *_XML;
#endif

/* resqml2_0_1ForGsoap.h:185 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__integer
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__integer (13)
typedef LONG64 xsd__integer;
#endif

/* resqml2_0_1ForGsoap.h:188 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__nonNegativeInteger (16)
typedef ULONG64 xsd__nonNegativeInteger;
#endif

/* resqml2_0_1ForGsoap.h:191 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__positiveInteger
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__positiveInteger (17)
typedef ULONG64 xsd__positiveInteger;
#endif

/* resqml2_0_1ForGsoap.h:194 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__ID
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__ID (19)
typedef std::string xsd__ID;
#endif

/* resqml2_0_1ForGsoap.h:197 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__anyURI
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__anyURI (20)
typedef std::string xsd__anyURI;
#endif

/* resqml2_0_1ForGsoap.h:200 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__date
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__date (21)
typedef std::string xsd__date;
#endif

/* resqml2_0_1ForGsoap.h:1846 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonType (559)
typedef std::string gml__NilReasonType;
#endif

/* resqml2_0_1ForGsoap.h:1850 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonEnumeration
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonEnumeration (560)
typedef std::string gml__NilReasonEnumeration;
#endif

/* resqml2_0_1ForGsoap.h:1853 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__UomIdentifier
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__UomIdentifier (561)
typedef std::string gml__UomIdentifier;
#endif

/* resqml2_0_1ForGsoap.h:1888 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREType (562)
typedef std::string gco__Date_USCOREType;
#endif

/* resqml2_0_1ForGsoap.h:4549 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__UuidString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__UuidString (603)
typedef std::string eml__UuidString;
#endif

/* resqml2_0_1ForGsoap.h:4556 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__Measure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__Measure (605)
typedef double eml__Measure;
#endif

/* resqml2_0_1ForGsoap.h:4564 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__String
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__String (606)
typedef std::string eml__String;
#endif

/* resqml2_0_1ForGsoap.h:4580 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__UomSymbol
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__UomSymbol (607)
typedef std::string gml__UomSymbol;
#endif

/* resqml2_0_1ForGsoap.h:4590 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__UomURI
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__UomURI (608)
typedef std::string gml__UomURI;
#endif

/* resqml2_0_1ForGsoap.h:4700 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DescriptionString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DescriptionString (612)
typedef std::string eml__DescriptionString;
#endif

/* resqml2_0_1ForGsoap.h:4708 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TypeEnum
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TypeEnum (613)
typedef std::string eml__TypeEnum;
#endif

/* resqml2_0_1ForGsoap.h:4717 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__NameString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__NameString (614)
typedef std::string eml__NameString;
#endif

/* resqml2_0_1ForGsoap.h:4727 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__UidString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__UidString (615)
typedef std::string eml__UidString;
#endif

/* resqml2_0_1ForGsoap.h:4736 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MaximumLengthString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MaximumLengthString (616)
typedef std::string eml__MaximumLengthString;
#endif

/* resqml2_0_1ForGsoap.h:4745 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__UomEnum
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__UomEnum (617)
typedef std::string eml__UomEnum;
#endif

/* resqml2_0_1ForGsoap.h:5242 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CommentString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CommentString (620)
typedef eml__MaximumLengthString eml__CommentString;
#endif

/* resqml2_0_1ForGsoap.h:31131 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Activity
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Activity (1203)
typedef resqml2__obj_USCOREActivity _resqml2__Activity;
#endif

/* resqml2_0_1ForGsoap.h:31134 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ActivityTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ActivityTemplate (1204)
typedef resqml2__obj_USCOREActivityTemplate _resqml2__ActivityTemplate;
#endif

/* resqml2_0_1ForGsoap.h:31137 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalPropertySeries (1205)
typedef resqml2__obj_USCORECategoricalPropertySeries _resqml2__CategoricalPropertySeries;
#endif

/* resqml2_0_1ForGsoap.h:31140 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentPropertySeries (1206)
typedef resqml2__obj_USCORECommentPropertySeries _resqml2__CommentPropertySeries;
#endif

/* resqml2_0_1ForGsoap.h:31143 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousPropertySeries (1207)
typedef resqml2__obj_USCOREContinuousPropertySeries _resqml2__ContinuousPropertySeries;
#endif

/* resqml2_0_1ForGsoap.h:31146 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscretePropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscretePropertySeries (1208)
typedef resqml2__obj_USCOREDiscretePropertySeries _resqml2__DiscretePropertySeries;
#endif

/* resqml2_0_1ForGsoap.h:31149 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesFeature (1209)
typedef resqml2__obj_USCOREStreamlinesFeature _resqml2__StreamlinesFeature;
#endif

/* resqml2_0_1ForGsoap.h:31152 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesRepresentation (1210)
typedef resqml2__obj_USCOREStreamlinesRepresentation _resqml2__StreamlinesRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31155 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalDepth3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalDepth3dCrs (1211)
typedef resqml2__obj_USCORELocalDepth3dCrs _resqml2__LocalDepth3dCrs;
#endif

/* resqml2_0_1ForGsoap.h:31158 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalTime3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalTime3dCrs (1212)
typedef resqml2__obj_USCORELocalTime3dCrs _resqml2__LocalTime3dCrs;
#endif

/* resqml2_0_1ForGsoap.h:31161 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TimeSeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TimeSeries (1213)
typedef resqml2__obj_USCORETimeSeries _resqml2__TimeSeries;
#endif

/* resqml2_0_1ForGsoap.h:31164 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FluidBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FluidBoundaryFeature (1214)
typedef resqml2__obj_USCOREFluidBoundaryFeature _resqml2__FluidBoundaryFeature;
#endif

/* resqml2_0_1ForGsoap.h:31167 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeneticBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeneticBoundaryFeature (1215)
typedef resqml2__obj_USCOREGeneticBoundaryFeature _resqml2__GeneticBoundaryFeature;
#endif

/* resqml2_0_1ForGsoap.h:31170 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyFeature (1216)
typedef resqml2__obj_USCOREGeobodyFeature _resqml2__GeobodyFeature;
#endif

/* resqml2_0_1ForGsoap.h:31173 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GlobalChronostratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GlobalChronostratigraphicColumn (1217)
typedef resqml2__obj_USCOREGlobalChronostratigraphicColumn _resqml2__GlobalChronostratigraphicColumn;
#endif

/* resqml2_0_1ForGsoap.h:31176 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitFeature (1218)
typedef resqml2__obj_USCORERockFluidUnitFeature _resqml2__RockFluidUnitFeature;
#endif

/* resqml2_0_1ForGsoap.h:31179 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitFeature (1219)
typedef resqml2__obj_USCOREStratigraphicUnitFeature _resqml2__StratigraphicUnitFeature;
#endif

/* resqml2_0_1ForGsoap.h:31182 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TectonicBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TectonicBoundaryFeature (1220)
typedef resqml2__obj_USCORETectonicBoundaryFeature _resqml2__TectonicBoundaryFeature;
#endif

/* resqml2_0_1ForGsoap.h:31185 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeature (1221)
typedef resqml2__obj_USCOREBoundaryFeature _resqml2__BoundaryFeature;
#endif

/* resqml2_0_1ForGsoap.h:31188 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitFeature (1222)
typedef resqml2__obj_USCOREGeologicUnitFeature _resqml2__GeologicUnitFeature;
#endif

/* resqml2_0_1ForGsoap.h:31191 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__OrganizationFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__OrganizationFeature (1223)
typedef resqml2__obj_USCOREOrganizationFeature _resqml2__OrganizationFeature;
#endif

/* resqml2_0_1ForGsoap.h:31194 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FrontierFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FrontierFeature (1224)
typedef resqml2__obj_USCOREFrontierFeature _resqml2__FrontierFeature;
#endif

/* resqml2_0_1ForGsoap.h:31197 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLatticeFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLatticeFeature (1225)
typedef resqml2__obj_USCORESeismicLatticeFeature _resqml2__SeismicLatticeFeature;
#endif

/* resqml2_0_1ForGsoap.h:31200 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineFeature (1226)
typedef resqml2__obj_USCORESeismicLineFeature _resqml2__SeismicLineFeature;
#endif

/* resqml2_0_1ForGsoap.h:31203 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineSetFeature (1227)
typedef resqml2__obj_USCORESeismicLineSetFeature _resqml2__SeismicLineSetFeature;
#endif

/* resqml2_0_1ForGsoap.h:31206 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFeature (1228)
typedef resqml2__obj_USCOREWellboreFeature _resqml2__WellboreFeature;
#endif

/* resqml2_0_1ForGsoap.h:31209 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeatureInterpretation (1229)
typedef resqml2__obj_USCOREBoundaryFeatureInterpretation _resqml2__BoundaryFeatureInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31212 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GenericFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GenericFeatureInterpretation (1230)
typedef resqml2__obj_USCOREGenericFeatureInterpretation _resqml2__GenericFeatureInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31215 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitInterpretation (1231)
typedef resqml2__obj_USCOREGeologicUnitInterpretation _resqml2__GeologicUnitInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31218 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumn (1232)
typedef resqml2__obj_USCOREStratigraphicColumn _resqml2__StratigraphicColumn;
#endif

/* resqml2_0_1ForGsoap.h:31221 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumnRankInterpretation (1233)
typedef resqml2__obj_USCOREStratigraphicColumnRankInterpretation _resqml2__StratigraphicColumnRankInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31224 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicOccurrenceInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicOccurrenceInterpretation (1234)
typedef resqml2__obj_USCOREStratigraphicOccurrenceInterpretation _resqml2__StratigraphicOccurrenceInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31227 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StructuralOrganizationInterpretation (1235)
typedef resqml2__obj_USCOREStructuralOrganizationInterpretation _resqml2__StructuralOrganizationInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31230 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreInterpretation (1236)
typedef resqml2__obj_USCOREWellboreInterpretation _resqml2__WellboreInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31233 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__EarthModelInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__EarthModelInterpretation (1237)
typedef resqml2__obj_USCOREEarthModelInterpretation _resqml2__EarthModelInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31236 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FaultInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FaultInterpretation (1238)
typedef resqml2__obj_USCOREFaultInterpretation _resqml2__FaultInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31239 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyBoundaryInterpretation (1239)
typedef resqml2__obj_USCOREGeobodyBoundaryInterpretation _resqml2__GeobodyBoundaryInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31242 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyInterpretation (1240)
typedef resqml2__obj_USCOREGeobodyInterpretation _resqml2__GeobodyInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31245 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitInterpretation (1241)
typedef resqml2__obj_USCORERockFluidUnitInterpretation _resqml2__RockFluidUnitInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31248 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__HorizonInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__HorizonInterpretation (1242)
typedef resqml2__obj_USCOREHorizonInterpretation _resqml2__HorizonInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31251 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidOrganizationInterpretation (1243)
typedef resqml2__obj_USCORERockFluidOrganizationInterpretation _resqml2__RockFluidOrganizationInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31254 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitInterpretation (1244)
typedef resqml2__obj_USCOREStratigraphicUnitInterpretation _resqml2__StratigraphicUnitInterpretation;
#endif

/* resqml2_0_1ForGsoap.h:31257 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RedefinedGeometryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RedefinedGeometryRepresentation (1245)
typedef resqml2__obj_USCORERedefinedGeometryRepresentation _resqml2__RedefinedGeometryRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31260 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationIdentitySet
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationIdentitySet (1246)
typedef resqml2__obj_USCORERepresentationIdentitySet _resqml2__RepresentationIdentitySet;
#endif

/* resqml2_0_1ForGsoap.h:31263 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationSetRepresentation (1247)
typedef resqml2__obj_USCORERepresentationSetRepresentation _resqml2__RepresentationSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31266 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SubRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SubRepresentation (1248)
typedef resqml2__obj_USCORESubRepresentation _resqml2__SubRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31269 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GpGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GpGridRepresentation (1249)
typedef resqml2__obj_USCOREGpGridRepresentation _resqml2__GpGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31272 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GridConnectionSetRepresentation (1250)
typedef resqml2__obj_USCOREGridConnectionSetRepresentation _resqml2__GridConnectionSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31275 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__IjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__IjkGridRepresentation (1251)
typedef resqml2__obj_USCOREIjkGridRepresentation _resqml2__IjkGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31278 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalGridSet
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalGridSet (1252)
typedef resqml2__obj_USCORELocalGridSet _resqml2__LocalGridSet;
#endif

/* resqml2_0_1ForGsoap.h:31281 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedIjkGridRepresentation (1253)
typedef resqml2__obj_USCORETruncatedIjkGridRepresentation _resqml2__TruncatedIjkGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31284 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedUnstructuredColumnLayerGridRepresentation (1254)
typedef resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation _resqml2__TruncatedUnstructuredColumnLayerGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31287 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredColumnLayerGridRepresentation (1255)
typedef resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation _resqml2__UnstructuredColumnLayerGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31290 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredGridRepresentation (1256)
typedef resqml2__obj_USCOREUnstructuredGridRepresentation _resqml2__UnstructuredGridRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31293 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dRepresentation (1257)
typedef resqml2__obj_USCOREGrid2dRepresentation _resqml2__Grid2dRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31296 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dSetRepresentation (1258)
typedef resqml2__obj_USCOREGrid2dSetRepresentation _resqml2__Grid2dSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31299 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__NonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__NonSealedSurfaceFrameworkRepresentation (1259)
typedef resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation _resqml2__NonSealedSurfaceFrameworkRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31302 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PlaneSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PlaneSetRepresentation (1260)
typedef resqml2__obj_USCOREPlaneSetRepresentation _resqml2__PlaneSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31305 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointSetRepresentation (1261)
typedef resqml2__obj_USCOREPointSetRepresentation _resqml2__PointSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31308 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineRepresentation (1262)
typedef resqml2__obj_USCOREPolylineRepresentation _resqml2__PolylineRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31311 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineSetRepresentation (1263)
typedef resqml2__obj_USCOREPolylineSetRepresentation _resqml2__PolylineSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31314 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedSurfaceFrameworkRepresentation (1264)
typedef resqml2__obj_USCORESealedSurfaceFrameworkRepresentation _resqml2__SealedSurfaceFrameworkRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31317 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedVolumeFrameworkRepresentation (1265)
typedef resqml2__obj_USCORESealedVolumeFrameworkRepresentation _resqml2__SealedVolumeFrameworkRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31320 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TriangulatedSetRepresentation (1266)
typedef resqml2__obj_USCORETriangulatedSetRepresentation _resqml2__TriangulatedSetRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31323 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BlockedWellboreRepresentation (1267)
typedef resqml2__obj_USCOREBlockedWellboreRepresentation _resqml2__BlockedWellboreRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31326 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DeviationSurveyRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DeviationSurveyRepresentation (1268)
typedef resqml2__obj_USCOREDeviationSurveyRepresentation _resqml2__DeviationSurveyRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31329 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__MdDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__MdDatum (1269)
typedef resqml2__obj_USCOREMdDatum _resqml2__MdDatum;
#endif

/* resqml2_0_1ForGsoap.h:31332 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFrameRepresentation (1270)
typedef resqml2__obj_USCOREWellboreFrameRepresentation _resqml2__WellboreFrameRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31335 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreMarkerFrameRepresentation (1271)
typedef resqml2__obj_USCOREWellboreMarkerFrameRepresentation _resqml2__WellboreMarkerFrameRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31338 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreTrajectoryRepresentation (1272)
typedef resqml2__obj_USCOREWellboreTrajectoryRepresentation _resqml2__WellboreTrajectoryRepresentation;
#endif

/* resqml2_0_1ForGsoap.h:31341 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalProperty (1273)
typedef resqml2__obj_USCORECategoricalProperty _resqml2__CategoricalProperty;
#endif

/* resqml2_0_1ForGsoap.h:31344 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentProperty (1274)
typedef resqml2__obj_USCORECommentProperty _resqml2__CommentProperty;
#endif

/* resqml2_0_1ForGsoap.h:31347 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousProperty (1275)
typedef resqml2__obj_USCOREContinuousProperty _resqml2__ContinuousProperty;
#endif

/* resqml2_0_1ForGsoap.h:31350 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscreteProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscreteProperty (1276)
typedef resqml2__obj_USCOREDiscreteProperty _resqml2__DiscreteProperty;
#endif

/* resqml2_0_1ForGsoap.h:31353 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DoubleTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DoubleTableLookup (1277)
typedef resqml2__obj_USCOREDoubleTableLookup _resqml2__DoubleTableLookup;
#endif

/* resqml2_0_1ForGsoap.h:31356 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointsProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointsProperty (1278)
typedef resqml2__obj_USCOREPointsProperty _resqml2__PointsProperty;
#endif

/* resqml2_0_1ForGsoap.h:31359 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertyKind (1279)
typedef resqml2__obj_USCOREPropertyKind _resqml2__PropertyKind;
#endif

/* resqml2_0_1ForGsoap.h:31362 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertySet
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertySet (1280)
typedef resqml2__obj_USCOREPropertySet _resqml2__PropertySet;
#endif

/* resqml2_0_1ForGsoap.h:31365 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StringTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StringTableLookup (1281)
typedef resqml2__obj_USCOREStringTableLookup _resqml2__StringTableLookup;
#endif

/* resqml2_0_1ForGsoap.h:31384 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__eml__EpcExternalPartReference
#define SOAP_TYPE_gsoap_resqml2_0_1__eml__EpcExternalPartReference (1282)
typedef eml__obj_USCOREEpcExternalPartReference _eml__EpcExternalPartReference;
#endif

/* resqml2_0_1ForGsoap.h:31390 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractDataObject
#define SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractDataObject (1283)
typedef eml__AbstractObject _eml__AbstractDataObject;
#endif

/* resqml2_0_1ForGsoap.h:31396 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractContextualObject
#define SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractContextualObject (1284)
typedef eml__AbstractObject _eml__AbstractContextualObject;
#endif

/* resqml2_0_1ForGsoap.h:31415 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticCRS (1285)
typedef gml__GeodeticCRSType _gml__GeodeticCRS;
#endif

/* resqml2_0_1ForGsoap.h:31421 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__description
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__description (1286)
typedef gml__StringOrRefType _gml__description;
#endif

/* resqml2_0_1ForGsoap.h:31427 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__descriptionReference
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__descriptionReference (1287)
typedef gml__ReferenceType _gml__descriptionReference;
#endif

/* resqml2_0_1ForGsoap.h:31433 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__identifier
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__identifier (1288)
typedef gml__CodeWithAuthorityType _gml__identifier;
#endif

/* resqml2_0_1ForGsoap.h:31439 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__name
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__name (1289)
typedef gml__CodeType _gml__name;
#endif

/* resqml2_0_1ForGsoap.h:31442 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__remarks
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__remarks (1290)
typedef std::string _gml__remarks;
#endif

/* resqml2_0_1ForGsoap.h:31450 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__Definition
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__Definition (1291)
typedef gml__DefinitionType _gml__Definition;
#endif

/* resqml2_0_1ForGsoap.h:31456 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__scope
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__scope (1292)
typedef std::string _gml__scope;
#endif

/* resqml2_0_1ForGsoap.h:31462 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoidalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoidalCS (1293)
typedef gml__EllipsoidalCSPropertyType _gml__ellipsoidalCS;
#endif

/* resqml2_0_1ForGsoap.h:31468 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__EllipsoidalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__EllipsoidalCS (1294)
typedef gml__EllipsoidalCSType _gml__EllipsoidalCS;
#endif

/* resqml2_0_1ForGsoap.h:31474 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__axis
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__axis (1295)
typedef gml__CoordinateSystemAxisPropertyType _gml__axis;
#endif

/* resqml2_0_1ForGsoap.h:31480 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__CoordinateSystemAxis
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__CoordinateSystemAxis (1296)
typedef gml__CoordinateSystemAxisType _gml__CoordinateSystemAxis;
#endif

/* resqml2_0_1ForGsoap.h:31486 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__axisAbbrev
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__axisAbbrev (1297)
typedef gml__CodeType _gml__axisAbbrev;
#endif

/* resqml2_0_1ForGsoap.h:31494 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__axisDirection
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__axisDirection (1298)
typedef gml__CodeWithAuthorityType _gml__axisDirection;
#endif

/* resqml2_0_1ForGsoap.h:31500 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__minimumValue
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__minimumValue (1299)
typedef double _gml__minimumValue;
#endif

/* resqml2_0_1ForGsoap.h:31506 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__maximumValue
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__maximumValue (1300)
typedef double _gml__maximumValue;
#endif

/* resqml2_0_1ForGsoap.h:31512 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__rangeMeaning
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__rangeMeaning (1301)
typedef gml__CodeWithAuthorityType _gml__rangeMeaning;
#endif

/* resqml2_0_1ForGsoap.h:31518 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__cartesianCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__cartesianCS (1302)
typedef gml__CartesianCSPropertyType _gml__cartesianCS;
#endif

/* resqml2_0_1ForGsoap.h:31524 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__CartesianCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__CartesianCS (1303)
typedef gml__CartesianCSType _gml__CartesianCS;
#endif

/* resqml2_0_1ForGsoap.h:31530 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__sphericalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__sphericalCS (1304)
typedef gml__SphericalCSPropertyType _gml__sphericalCS;
#endif

/* resqml2_0_1ForGsoap.h:31536 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__SphericalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__SphericalCS (1305)
typedef gml__SphericalCSType _gml__SphericalCS;
#endif

/* resqml2_0_1ForGsoap.h:31542 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__geodeticDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__geodeticDatum (1306)
typedef gml__GeodeticDatumPropertyType _gml__geodeticDatum;
#endif

/* resqml2_0_1ForGsoap.h:31548 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticDatum (1307)
typedef gml__GeodeticDatumType _gml__GeodeticDatum;
#endif

/* resqml2_0_1ForGsoap.h:31558 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__anchorDefinition
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__anchorDefinition (1308)
typedef gml__CodeType _gml__anchorDefinition;
#endif

/* resqml2_0_1ForGsoap.h:31564 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__realizationEpoch
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__realizationEpoch (1309)
typedef xsd__date _gml__realizationEpoch;
#endif

/* resqml2_0_1ForGsoap.h:31570 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__primeMeridian
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__primeMeridian (1310)
typedef gml__PrimeMeridianPropertyType _gml__primeMeridian;
#endif

/* resqml2_0_1ForGsoap.h:31576 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__PrimeMeridian
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__PrimeMeridian (1311)
typedef gml__PrimeMeridianType _gml__PrimeMeridian;
#endif

/* resqml2_0_1ForGsoap.h:31582 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__greenwichLongitude
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__greenwichLongitude (1312)
typedef gml__AngleType _gml__greenwichLongitude;
#endif

/* resqml2_0_1ForGsoap.h:31588 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoid
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoid (1313)
typedef gml__EllipsoidPropertyType _gml__ellipsoid;
#endif

/* resqml2_0_1ForGsoap.h:31594 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__Ellipsoid
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__Ellipsoid (1314)
typedef gml__EllipsoidType _gml__Ellipsoid;
#endif

/* resqml2_0_1ForGsoap.h:31600 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__semiMajorAxis
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__semiMajorAxis (1315)
typedef gml__MeasureType _gml__semiMajorAxis;
#endif

/* resqml2_0_1ForGsoap.h:31606 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__ProjectedCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__ProjectedCRS (1316)
typedef gml__ProjectedCRSType _gml__ProjectedCRS;
#endif

/* resqml2_0_1ForGsoap.h:31612 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__conversion
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__conversion (1317)
typedef gml__GeneralConversionPropertyType _gml__conversion;
#endif

/* resqml2_0_1ForGsoap.h:31618 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__operationVersion
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__operationVersion (1318)
typedef std::string _gml__operationVersion;
#endif

/* resqml2_0_1ForGsoap.h:31624 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__sourceCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__sourceCRS (1319)
typedef gml__CRSPropertyType _gml__sourceCRS;
#endif

/* resqml2_0_1ForGsoap.h:31630 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__targetCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__targetCRS (1320)
typedef gml__CRSPropertyType _gml__targetCRS;
#endif

/* resqml2_0_1ForGsoap.h:31636 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__baseGeodeticCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__baseGeodeticCRS (1321)
typedef gml__GeodeticCRSPropertyType _gml__baseGeodeticCRS;
#endif

/* resqml2_0_1ForGsoap.h:31642 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCRS (1322)
typedef gml__VerticalCRSType _gml__VerticalCRS;
#endif

/* resqml2_0_1ForGsoap.h:31648 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalCS (1323)
typedef gml__VerticalCSPropertyType _gml__verticalCS;
#endif

/* resqml2_0_1ForGsoap.h:31654 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCS (1324)
typedef gml__VerticalCSType _gml__VerticalCS;
#endif

/* resqml2_0_1ForGsoap.h:31660 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalDatum (1325)
typedef gml__VerticalDatumPropertyType _gml__verticalDatum;
#endif

/* resqml2_0_1ForGsoap.h:31666 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalDatum (1326)
typedef gml__VerticalDatumType _gml__VerticalDatum;
#endif

/* resqml2_0_1ForGsoap.h:31680 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__id
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__id (1327)
typedef xsd__ID _gml__id;
#endif

/* resqml2_0_1ForGsoap.h:31699 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__href
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__href (1328)
typedef xsd__anyURI _xlink__href;
#endif

/* resqml2_0_1ForGsoap.h:31702 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__role
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__role (1329)
typedef xsd__anyURI _xlink__role;
#endif

/* resqml2_0_1ForGsoap.h:31705 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__arcrole
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__arcrole (1330)
typedef xsd__anyURI _xlink__arcrole;
#endif

/* resqml2_0_1ForGsoap.h:31708 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__title
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__title (1331)
typedef std::string _xlink__title;
#endif

/* resqml2_0_1ForGsoap.h:31719 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREExtent
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREExtent (1332)
typedef gmd__EX_USCOREExtent_USCOREType _gmd__EX_USCOREExtent;
#endif

/* resqml2_0_1ForGsoap.h:31722 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCORETemporalExtent
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCORETemporalExtent (1333)
typedef gmd__EX_USCORETemporalExtent_USCOREType _gmd__EX_USCORETemporalExtent;
#endif

/* resqml2_0_1ForGsoap.h:31725 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREVerticalExtent
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREVerticalExtent (1334)
typedef gmd__EX_USCOREVerticalExtent_USCOREType _gmd__EX_USCOREVerticalExtent;
#endif

/* resqml2_0_1ForGsoap.h:31728 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__MD_USCOREIdentifier
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__MD_USCOREIdentifier (1335)
typedef gmd__MD_USCOREIdentifier_USCOREType _gmd__MD_USCOREIdentifier;
#endif

/* resqml2_0_1ForGsoap.h:31731 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORECitation
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORECitation (1336)
typedef gmd__CI_USCORECitation_USCOREType _gmd__CI_USCORECitation;
#endif

/* resqml2_0_1ForGsoap.h:31734 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDate
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDate (1337)
typedef gmd__CI_USCOREDate_USCOREType _gmd__CI_USCOREDate;
#endif

/* resqml2_0_1ForGsoap.h:31737 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDateTypeCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDateTypeCode (1338)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREDateTypeCode;
#endif

/* resqml2_0_1ForGsoap.h:31740 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREResponsibleParty
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREResponsibleParty (1339)
typedef gmd__CI_USCOREResponsibleParty_USCOREType _gmd__CI_USCOREResponsibleParty;
#endif

/* resqml2_0_1ForGsoap.h:31743 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREContact
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREContact (1340)
typedef gmd__CI_USCOREContact_USCOREType _gmd__CI_USCOREContact;
#endif

/* resqml2_0_1ForGsoap.h:31746 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORETelephone
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORETelephone (1341)
typedef gmd__CI_USCORETelephone_USCOREType _gmd__CI_USCORETelephone;
#endif

/* resqml2_0_1ForGsoap.h:31749 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREAddress
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREAddress (1342)
typedef gmd__CI_USCOREAddress_USCOREType _gmd__CI_USCOREAddress;
#endif

/* resqml2_0_1ForGsoap.h:31752 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnlineResource
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnlineResource (1343)
typedef gmd__CI_USCOREOnlineResource_USCOREType _gmd__CI_USCOREOnlineResource;
#endif

/* resqml2_0_1ForGsoap.h:31755 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__URL
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__URL (1344)
typedef xsd__anyURI _gmd__URL;
#endif

/* resqml2_0_1ForGsoap.h:31758 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnLineFunctionCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnLineFunctionCode (1345)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREOnLineFunctionCode;
#endif

/* resqml2_0_1ForGsoap.h:31761 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORERoleCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORERoleCode (1346)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCORERoleCode;
#endif

/* resqml2_0_1ForGsoap.h:31764 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREPresentationFormCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREPresentationFormCode (1347)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREPresentationFormCode;
#endif

/* resqml2_0_1ForGsoap.h:31767 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORESeries
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORESeries (1348)
typedef gmd__CI_USCORESeries_USCOREType _gmd__CI_USCORESeries;
#endif

/* resqml2_0_1ForGsoap.h:31770 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__DQ_USCOREEvaluationMethodTypeCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__DQ_USCOREEvaluationMethodTypeCode (1349)
typedef gco__CodeListValue_USCOREType _gmd__DQ_USCOREEvaluationMethodTypeCode;
#endif

/* resqml2_0_1ForGsoap.h:31805 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__CharacterString
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__CharacterString (1350)
typedef std::string _gco__CharacterString;
#endif

/* resqml2_0_1ForGsoap.h:31808 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__Boolean
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__Boolean (1351)
typedef bool _gco__Boolean;
#endif

/* resqml2_0_1ForGsoap.h:31811 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__Real
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__Real (1352)
typedef double _gco__Real;
#endif

/* resqml2_0_1ForGsoap.h:31814 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__Date
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__Date (1353)
typedef gco__Date_USCOREType _gco__Date;
#endif

/* resqml2_0_1ForGsoap.h:31817 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__DateTime
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__DateTime (1354)
typedef time_t _gco__DateTime;
#endif

/* resqml2_0_1ForGsoap.h:31828 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__nilReason
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__nilReason (1355)
typedef gml__NilReasonType _gco__nilReason;
#endif

/* resqml2_0_1ForGsoap.h:31858 */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__ptm__standardEnergisticsPropertyTypeSet
#define SOAP_TYPE_gsoap_resqml2_0_1__ptm__standardEnergisticsPropertyTypeSet (1356)
typedef ptm__standardEnergisticsPropertyTypeSet _ptm__standardEnergisticsPropertyTypeSet;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_byte
#define SOAP_TYPE_gsoap_resqml2_0_1_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_int
#define SOAP_TYPE_gsoap_resqml2_0_1_int (1)
#endif

/* long has binding name 'long' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_long
#define SOAP_TYPE_gsoap_resqml2_0_1_long (11)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__integer
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__integer (13)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_LONG64
#define SOAP_TYPE_gsoap_resqml2_0_1_LONG64 (12)
#endif

/* _gco__Real has binding name '_gco__Real' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__Real
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__Real (1352)
#endif

/* _gml__maximumValue has binding name '_gml__maximumValue' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__maximumValue
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__maximumValue (1300)
#endif

/* _gml__minimumValue has binding name '_gml__minimumValue' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__minimumValue
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__minimumValue (1299)
#endif

/* eml__Measure has binding name 'eml__Measure' for type 'eml:Measure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__Measure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__Measure (605)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_double
#define SOAP_TYPE_gsoap_resqml2_0_1_double (604)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_unsignedInt
#define SOAP_TYPE_gsoap_resqml2_0_1_unsignedInt (14)
#endif

/* xsd__positiveInteger has binding name 'xsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__positiveInteger
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__positiveInteger (17)
#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__nonNegativeInteger (16)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ULONG64
#define SOAP_TYPE_gsoap_resqml2_0_1_ULONG64 (15)
#endif

/* _gco__DateTime has binding name '_gco__DateTime' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__DateTime
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__DateTime (1354)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_dateTime
#define SOAP_TYPE_gsoap_resqml2_0_1_dateTime (847)
#endif

/* _gco__Boolean has binding name '_gco__Boolean' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__Boolean
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__Boolean (1351)
#endif

/* enum _gml__RelatedTimeType_relativePosition has binding name '_gml__RelatedTimeType_relativePosition' for type 'gml:RelatedTimeType-relativePosition' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__RelatedTimeType_relativePosition (1029)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_bool
#define SOAP_TYPE_gsoap_resqml2_0_1_bool (846)
#endif

/* enum eml__DigitalStorageUom has binding name 'eml__DigitalStorageUom' for type 'eml:DigitalStorageUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageUom (798)
#endif

/* enum eml__MagneticDipoleMomentUom has binding name 'eml__MagneticDipoleMomentUom' for type 'eml:MagneticDipoleMomentUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentUom (797)
#endif

/* enum eml__EnergyPerAreaUom has binding name 'eml__EnergyPerAreaUom' for type 'eml:EnergyPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaUom (796)
#endif

/* enum eml__LightExposureUom has binding name 'eml__LightExposureUom' for type 'eml:LightExposureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureUom (795)
#endif

/* enum eml__ReciprocalPressureUom has binding name 'eml__ReciprocalPressureUom' for type 'eml:ReciprocalPressureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureUom (794)
#endif

/* enum eml__ForcePerLengthUom has binding name 'eml__ForcePerLengthUom' for type 'eml:ForcePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthUom (793)
#endif

/* enum eml__ElectricResistancePerLengthUom has binding name 'eml__ElectricResistancePerLengthUom' for type 'eml:ElectricResistancePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthUom (792)
#endif

/* enum eml__EnergyLengthPerAreaUom has binding name 'eml__EnergyLengthPerAreaUom' for type 'eml:EnergyLengthPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaUom (791)
#endif

/* enum eml__TimePerVolumeUom has binding name 'eml__TimePerVolumeUom' for type 'eml:TimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeUom (790)
#endif

/* enum eml__AngularVelocityUom has binding name 'eml__AngularVelocityUom' for type 'eml:AngularVelocityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityUom (789)
#endif

/* enum eml__AreaPerAreaUom has binding name 'eml__AreaPerAreaUom' for type 'eml:AreaPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaUom (788)
#endif

/* enum eml__PressureUom has binding name 'eml__PressureUom' for type 'eml:PressureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureUom (787)
#endif

/* enum eml__ReciprocalVolumeUom has binding name 'eml__ReciprocalVolumeUom' for type 'eml:ReciprocalVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeUom (786)
#endif

/* enum eml__ElectricResistanceUom has binding name 'eml__ElectricResistanceUom' for type 'eml:ElectricResistanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceUom (785)
#endif

/* enum eml__IsothermalCompressibilityUom has binding name 'eml__IsothermalCompressibilityUom' for type 'eml:IsothermalCompressibilityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityUom (784)
#endif

/* enum eml__AttenuationPerFrequencyIntervalUom has binding name 'eml__AttenuationPerFrequencyIntervalUom' for type 'eml:AttenuationPerFrequencyIntervalUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalUom (783)
#endif

/* enum eml__TemperatureIntervalPerLengthUom has binding name 'eml__TemperatureIntervalPerLengthUom' for type 'eml:TemperatureIntervalPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthUom (782)
#endif

/* enum eml__VolumePerMassUom has binding name 'eml__VolumePerMassUom' for type 'eml:VolumePerMassUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassUom (781)
#endif

/* enum eml__EnergyPerMassPerTimeUom has binding name 'eml__EnergyPerMassPerTimeUom' for type 'eml:EnergyPerMassPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeUom (780)
#endif

/* enum eml__TimePerTimeUom has binding name 'eml__TimePerTimeUom' for type 'eml:TimePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeUom (779)
#endif

/* enum eml__DiffusionCoefficientUom has binding name 'eml__DiffusionCoefficientUom' for type 'eml:DiffusionCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientUom (778)
#endif

/* enum eml__AnglePerVolumeUom has binding name 'eml__AnglePerVolumeUom' for type 'eml:AnglePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeUom (777)
#endif

/* enum eml__VolumePerVolumeUom has binding name 'eml__VolumePerVolumeUom' for type 'eml:VolumePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeUom (776)
#endif

/* enum eml__PressureTimePerVolumeUom has binding name 'eml__PressureTimePerVolumeUom' for type 'eml:PressureTimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeUom (775)
#endif

/* enum eml__EnergyLengthPerTimeAreaTemperatureUom has binding name 'eml__EnergyLengthPerTimeAreaTemperatureUom' for type 'eml:EnergyLengthPerTimeAreaTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureUom (774)
#endif

/* enum eml__NormalizedPowerUom has binding name 'eml__NormalizedPowerUom' for type 'eml:NormalizedPowerUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerUom (773)
#endif

/* enum eml__VolumetricHeatTransferCoefficientUom has binding name 'eml__VolumetricHeatTransferCoefficientUom' for type 'eml:VolumetricHeatTransferCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientUom (772)
#endif

/* enum eml__TimePerMassUom has binding name 'eml__TimePerMassUom' for type 'eml:TimePerMassUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassUom (771)
#endif

/* enum eml__AbsorbedDoseUom has binding name 'eml__AbsorbedDoseUom' for type 'eml:AbsorbedDoseUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseUom (770)
#endif

/* enum eml__LuminousIntensityUom has binding name 'eml__LuminousIntensityUom' for type 'eml:LuminousIntensityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityUom (769)
#endif

/* enum eml__FrequencyUom has binding name 'eml__FrequencyUom' for type 'eml:FrequencyUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyUom (768)
#endif

/* enum eml__PowerPerVolumeUom has binding name 'eml__PowerPerVolumeUom' for type 'eml:PowerPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeUom (767)
#endif

/* enum eml__MassPerTimePerAreaUom has binding name 'eml__MassPerTimePerAreaUom' for type 'eml:MassPerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaUom (766)
#endif

/* enum eml__MomentumUom has binding name 'eml__MomentumUom' for type 'eml:MomentumUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumUom (765)
#endif

/* enum eml__ElectricConductanceUom has binding name 'eml__ElectricConductanceUom' for type 'eml:ElectricConductanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceUom (764)
#endif

/* enum eml__MolarEnergyUom has binding name 'eml__MolarEnergyUom' for type 'eml:MolarEnergyUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyUom (763)
#endif

/* enum eml__HeatCapacityUom has binding name 'eml__HeatCapacityUom' for type 'eml:HeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityUom (762)
#endif

/* enum eml__AreaPerTimeUom has binding name 'eml__AreaPerTimeUom' for type 'eml:AreaPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeUom (761)
#endif

/* enum eml__PotentialDifferencePerPowerDropUom has binding name 'eml__PotentialDifferencePerPowerDropUom' for type 'eml:PotentialDifferencePerPowerDropUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropUom (760)
#endif

/* enum eml__DynamicViscosityUom has binding name 'eml__DynamicViscosityUom' for type 'eml:DynamicViscosityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityUom (759)
#endif

/* enum eml__ReciprocalMassUom has binding name 'eml__ReciprocalMassUom' for type 'eml:ReciprocalMassUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassUom (758)
#endif

/* enum eml__MagneticPermeabilityUom has binding name 'eml__MagneticPermeabilityUom' for type 'eml:MagneticPermeabilityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityUom (757)
#endif

/* enum eml__EnergyPerVolumeUom has binding name 'eml__EnergyPerVolumeUom' for type 'eml:EnergyPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeUom (756)
#endif

/* enum eml__VolumePerLengthUom has binding name 'eml__VolumePerLengthUom' for type 'eml:VolumePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthUom (755)
#endif

/* enum eml__VerticalCoordinateUom has binding name 'eml__VerticalCoordinateUom' for type 'eml:VerticalCoordinateUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCoordinateUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCoordinateUom (754)
#endif

/* enum eml__AnglePerLengthUom has binding name 'eml__AnglePerLengthUom' for type 'eml:AnglePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthUom (753)
#endif

/* enum eml__EnergyUom has binding name 'eml__EnergyUom' for type 'eml:EnergyUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyUom (752)
#endif

/* enum eml__DimensionlessUom has binding name 'eml__DimensionlessUom' for type 'eml:DimensionlessUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessUom (751)
#endif

/* enum eml__LinearAccelerationUom has binding name 'eml__LinearAccelerationUom' for type 'eml:LinearAccelerationUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationUom (750)
#endif

/* enum eml__VolumePerTimePerLengthUom has binding name 'eml__VolumePerTimePerLengthUom' for type 'eml:VolumePerTimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthUom (749)
#endif

/* enum eml__LengthPerTemperatureUom has binding name 'eml__LengthPerTemperatureUom' for type 'eml:LengthPerTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureUom (748)
#endif

/* enum eml__ReluctanceUom has binding name 'eml__ReluctanceUom' for type 'eml:ReluctanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceUom (747)
#endif

/* enum eml__APIGravityUom has binding name 'eml__APIGravityUom' for type 'eml:APIGravityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityUom (746)
#endif

/* enum eml__ElectricChargePerVolumeUom has binding name 'eml__ElectricChargePerVolumeUom' for type 'eml:ElectricChargePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeUom (745)
#endif

/* enum eml__ForcePerVolumeUom has binding name 'eml__ForcePerVolumeUom' for type 'eml:ForcePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeUom (744)
#endif

/* enum eml__MassLengthUom has binding name 'eml__MassLengthUom' for type 'eml:MassLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthUom (743)
#endif

/* enum eml__MassPerVolumePerLengthUom has binding name 'eml__MassPerVolumePerLengthUom' for type 'eml:MassPerVolumePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthUom (742)
#endif

/* enum eml__ElectricChargePerMassUom has binding name 'eml__ElectricChargePerMassUom' for type 'eml:ElectricChargePerMassUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassUom (741)
#endif

/* enum eml__PowerPerPowerUom has binding name 'eml__PowerPerPowerUom' for type 'eml:PowerPerPowerUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerUom (740)
#endif

/* enum eml__DoseEquivalentUom has binding name 'eml__DoseEquivalentUom' for type 'eml:DoseEquivalentUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentUom (739)
#endif

/* enum eml__HeatFlowRateUom has binding name 'eml__HeatFlowRateUom' for type 'eml:HeatFlowRateUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateUom (738)
#endif

/* enum eml__RadianceUom has binding name 'eml__RadianceUom' for type 'eml:RadianceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceUom (737)
#endif

/* enum eml__AmountOfSubstancePerAmountOfSubstanceUom has binding name 'eml__AmountOfSubstancePerAmountOfSubstanceUom' for type 'eml:AmountOfSubstancePerAmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceUom (736)
#endif

/* enum eml__TemperatureIntervalPerTimeUom has binding name 'eml__TemperatureIntervalPerTimeUom' for type 'eml:TemperatureIntervalPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeUom (735)
#endif

/* enum eml__AreaPerVolumeUom has binding name 'eml__AreaPerVolumeUom' for type 'eml:AreaPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeUom (734)
#endif

/* enum eml__IlluminanceUom has binding name 'eml__IlluminanceUom' for type 'eml:IlluminanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceUom (733)
#endif

/* enum eml__MassPerAreaUom has binding name 'eml__MassPerAreaUom' for type 'eml:MassPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaUom (732)
#endif

/* enum eml__PowerPerAreaUom has binding name 'eml__PowerPerAreaUom' for type 'eml:PowerPerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaUom (731)
#endif

/* enum eml__ThermalInsulanceUom has binding name 'eml__ThermalInsulanceUom' for type 'eml:ThermalInsulanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceUom (730)
#endif

/* enum eml__ElectromagneticMomentUom has binding name 'eml__ElectromagneticMomentUom' for type 'eml:ElectromagneticMomentUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentUom (729)
#endif

/* enum eml__PermittivityUom has binding name 'eml__PermittivityUom' for type 'eml:PermittivityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityUom (728)
#endif

/* enum eml__EnergyPerMassUom has binding name 'eml__EnergyPerMassUom' for type 'eml:EnergyPerMassUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassUom (727)
#endif

/* enum eml__AmountOfSubstancePerVolumeUom has binding name 'eml__AmountOfSubstancePerVolumeUom' for type 'eml:AmountOfSubstancePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeUom (726)
#endif

/* enum eml__VolumePerTimePerPressureUom has binding name 'eml__VolumePerTimePerPressureUom' for type 'eml:VolumePerTimePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureUom (725)
#endif

/* enum eml__LuminousFluxUom has binding name 'eml__LuminousFluxUom' for type 'eml:LuminousFluxUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxUom (724)
#endif

/* enum eml__PressureSquaredPerForceTimePerAreaUom has binding name 'eml__PressureSquaredPerForceTimePerAreaUom' for type 'eml:PressureSquaredPerForceTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaUom (723)
#endif

/* enum eml__MassPerMassUom has binding name 'eml__MassPerMassUom' for type 'eml:MassPerMassUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassUom (722)
#endif

/* enum eml__ElectricalResistivityUom has binding name 'eml__ElectricalResistivityUom' for type 'eml:ElectricalResistivityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityUom (721)
#endif

/* enum eml__MassPerLengthUom has binding name 'eml__MassPerLengthUom' for type 'eml:MassPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthUom (720)
#endif

/* enum eml__LinearThermalExpansionUom has binding name 'eml__LinearThermalExpansionUom' for type 'eml:LinearThermalExpansionUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionUom (719)
#endif

/* enum eml__ThermodynamicTemperatureUom has binding name 'eml__ThermodynamicTemperatureUom' for type 'eml:ThermodynamicTemperatureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureUom (718)
#endif

/* enum eml__AmountOfSubstancePerTimePerAreaUom has binding name 'eml__AmountOfSubstancePerTimePerAreaUom' for type 'eml:AmountOfSubstancePerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaUom (717)
#endif

/* enum eml__LengthPerMassUom has binding name 'eml__LengthPerMassUom' for type 'eml:LengthPerMassUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassUom (716)
#endif

/* enum eml__SpecificHeatCapacityUom has binding name 'eml__SpecificHeatCapacityUom' for type 'eml:SpecificHeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityUom (715)
#endif

/* enum eml__MassUom has binding name 'eml__MassUom' for type 'eml:MassUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassUom (714)
#endif

/* enum eml__ForcePerForceUom has binding name 'eml__ForcePerForceUom' for type 'eml:ForcePerForceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceUom (713)
#endif

/* enum eml__ThermalResistanceUom has binding name 'eml__ThermalResistanceUom' for type 'eml:ThermalResistanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceUom (712)
#endif

/* enum eml__AreaPerMassUom has binding name 'eml__AreaPerMassUom' for type 'eml:AreaPerMassUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassUom (711)
#endif

/* enum eml__LengthUom has binding name 'eml__LengthUom' for type 'eml:LengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthUom (710)
#endif

/* enum eml__VolumePerTimeUom has binding name 'eml__VolumePerTimeUom' for type 'eml:VolumePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeUom (709)
#endif

/* enum eml__MagneticFieldStrengthUom has binding name 'eml__MagneticFieldStrengthUom' for type 'eml:MagneticFieldStrengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthUom (708)
#endif

/* enum eml__MagneticVectorPotentialUom has binding name 'eml__MagneticVectorPotentialUom' for type 'eml:MagneticVectorPotentialUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialUom (707)
#endif

/* enum eml__LengthPerPressureUom has binding name 'eml__LengthPerPressureUom' for type 'eml:LengthPerPressureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureUom (706)
#endif

/* enum eml__ElectricPotentialDifferenceUom has binding name 'eml__ElectricPotentialDifferenceUom' for type 'eml:ElectricPotentialDifferenceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceUom (705)
#endif

/* enum eml__ActivityOfRadioactivityUom has binding name 'eml__ActivityOfRadioactivityUom' for type 'eml:ActivityOfRadioactivityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityUom (704)
#endif

/* enum eml__PressurePerVolumeUom has binding name 'eml__PressurePerVolumeUom' for type 'eml:PressurePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeUom (703)
#endif

/* enum eml__PowerUom has binding name 'eml__PowerUom' for type 'eml:PowerUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerUom (702)
#endif

/* enum eml__LuminousEfficacyUom has binding name 'eml__LuminousEfficacyUom' for type 'eml:LuminousEfficacyUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyUom (701)
#endif

/* enum eml__ElectricChargeUom has binding name 'eml__ElectricChargeUom' for type 'eml:ElectricChargeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeUom (700)
#endif

/* enum eml__PressurePerTimeUom has binding name 'eml__PressurePerTimeUom' for type 'eml:PressurePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeUom (699)
#endif

/* enum eml__ReciprocalAreaUom has binding name 'eml__ReciprocalAreaUom' for type 'eml:ReciprocalAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaUom (698)
#endif

/* enum eml__ReciprocalForceUom has binding name 'eml__ReciprocalForceUom' for type 'eml:ReciprocalForceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceUom (697)
#endif

/* enum eml__VolumePerTimePerPressureLengthUom has binding name 'eml__VolumePerTimePerPressureLengthUom' for type 'eml:VolumePerTimePerPressureLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthUom (696)
#endif

/* enum eml__KinematicViscosityUom has binding name 'eml__KinematicViscosityUom' for type 'eml:KinematicViscosityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityUom (695)
#endif

/* enum eml__InductanceUom has binding name 'eml__InductanceUom' for type 'eml:InductanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceUom (694)
#endif

/* enum eml__DataTransferSpeedUom has binding name 'eml__DataTransferSpeedUom' for type 'eml:DataTransferSpeedUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedUom (693)
#endif

/* enum eml__PermeabilityLengthUom has binding name 'eml__PermeabilityLengthUom' for type 'eml:PermeabilityLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthUom (692)
#endif

/* enum eml__RadiantIntensityUom has binding name 'eml__RadiantIntensityUom' for type 'eml:RadiantIntensityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityUom (691)
#endif

/* enum eml__TemperatureIntervalUom has binding name 'eml__TemperatureIntervalUom' for type 'eml:TemperatureIntervalUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalUom (690)
#endif

/* enum eml__FrequencyIntervalUom has binding name 'eml__FrequencyIntervalUom' for type 'eml:FrequencyIntervalUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalUom (689)
#endif

/* enum eml__VolumeFlowRatePerVolumeFlowRateUom has binding name 'eml__VolumeFlowRatePerVolumeFlowRateUom' for type 'eml:VolumeFlowRatePerVolumeFlowRateUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateUom (688)
#endif

/* enum eml__MolarHeatCapacityUom has binding name 'eml__MolarHeatCapacityUom' for type 'eml:MolarHeatCapacityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityUom (687)
#endif

/* enum eml__VolumePerTimePerTimeUom has binding name 'eml__VolumePerTimePerTimeUom' for type 'eml:VolumePerTimePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeUom (686)
#endif

/* enum eml__LuminanceUom has binding name 'eml__LuminanceUom' for type 'eml:LuminanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceUom (685)
#endif

/* enum eml__ReciprocalLengthUom has binding name 'eml__ReciprocalLengthUom' for type 'eml:ReciprocalLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthUom (684)
#endif

/* enum eml__LogarithmicPowerRatioPerLengthUom has binding name 'eml__LogarithmicPowerRatioPerLengthUom' for type 'eml:LogarithmicPowerRatioPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthUom (683)
#endif

/* enum eml__AreaPerAmountOfSubstanceUom has binding name 'eml__AreaPerAmountOfSubstanceUom' for type 'eml:AreaPerAmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceUom (682)
#endif

/* enum eml__ThermalConductivityUom has binding name 'eml__ThermalConductivityUom' for type 'eml:ThermalConductivityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityUom (681)
#endif

/* enum eml__TimeUom has binding name 'eml__TimeUom' for type 'eml:TimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeUom (680)
#endif

/* enum eml__AmountOfSubstancePerAreaUom has binding name 'eml__AmountOfSubstancePerAreaUom' for type 'eml:AmountOfSubstancePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaUom (679)
#endif

/* enum eml__ElectricFieldStrengthUom has binding name 'eml__ElectricFieldStrengthUom' for type 'eml:ElectricFieldStrengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthUom (678)
#endif

/* enum eml__ForceAreaUom has binding name 'eml__ForceAreaUom' for type 'eml:ForceAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaUom (677)
#endif

/* enum eml__SecondMomentOfAreaUom has binding name 'eml__SecondMomentOfAreaUom' for type 'eml:SecondMomentOfAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaUom (676)
#endif

/* enum eml__PermeabilityRockUom has binding name 'eml__PermeabilityRockUom' for type 'eml:PermeabilityRockUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockUom (675)
#endif

/* enum eml__VolumePerTimeLengthUom has binding name 'eml__VolumePerTimeLengthUom' for type 'eml:VolumePerTimeLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthUom (674)
#endif

/* enum eml__ThermalDiffusivityUom has binding name 'eml__ThermalDiffusivityUom' for type 'eml:ThermalDiffusivityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityUom (673)
#endif

/* enum eml__ReciprocalMassTimeUom has binding name 'eml__ReciprocalMassTimeUom' for type 'eml:ReciprocalMassTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeUom (672)
#endif

/* enum eml__AngularAccelerationUom has binding name 'eml__AngularAccelerationUom' for type 'eml:AngularAccelerationUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationUom (671)
#endif

/* enum eml__PressureSquaredUom has binding name 'eml__PressureSquaredUom' for type 'eml:PressureSquaredUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredUom (670)
#endif

/* enum eml__ElectricCurrentUom has binding name 'eml__ElectricCurrentUom' for type 'eml:ElectricCurrentUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentUom (669)
#endif

/* enum eml__EnergyPerLengthUom has binding name 'eml__EnergyPerLengthUom' for type 'eml:EnergyPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthUom (668)
#endif

/* enum eml__SignalingEventPerTimeUom has binding name 'eml__SignalingEventPerTimeUom' for type 'eml:SignalingEventPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeUom (667)
#endif

/* enum eml__PlaneAngleUom has binding name 'eml__PlaneAngleUom' for type 'eml:PlaneAngleUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleUom (666)
#endif

/* enum eml__MagneticFluxDensityUom has binding name 'eml__MagneticFluxDensityUom' for type 'eml:MagneticFluxDensityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityUom (665)
#endif

/* enum eml__MassPerTimePerLengthUom has binding name 'eml__MassPerTimePerLengthUom' for type 'eml:MassPerTimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthUom (664)
#endif

/* enum eml__ElectricChargePerAreaUom has binding name 'eml__ElectricChargePerAreaUom' for type 'eml:ElectricChargePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaUom (663)
#endif

/* enum eml__VolumePerPressureUom has binding name 'eml__VolumePerPressureUom' for type 'eml:VolumePerPressureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureUom (662)
#endif

/* enum eml__TimePerLengthUom has binding name 'eml__TimePerLengthUom' for type 'eml:TimePerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthUom (661)
#endif

/* enum eml__ReciprocalElectricPotentialDifferenceUom has binding name 'eml__ReciprocalElectricPotentialDifferenceUom' for type 'eml:ReciprocalElectricPotentialDifferenceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceUom (660)
#endif

/* enum eml__VolumePerAreaUom has binding name 'eml__VolumePerAreaUom' for type 'eml:VolumePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaUom (659)
#endif

/* enum eml__ForceUom has binding name 'eml__ForceUom' for type 'eml:ForceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceUom (658)
#endif

/* enum eml__ElectricCurrentDensityUom has binding name 'eml__ElectricCurrentDensityUom' for type 'eml:ElectricCurrentDensityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityUom (657)
#endif

/* enum eml__VolumetricThermalExpansionUom has binding name 'eml__VolumetricThermalExpansionUom' for type 'eml:VolumetricThermalExpansionUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionUom (656)
#endif

/* enum eml__APIGammaRayUom has binding name 'eml__APIGammaRayUom' for type 'eml:APIGammaRayUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayUom (655)
#endif

/* enum eml__AreaUom has binding name 'eml__AreaUom' for type 'eml:AreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaUom (654)
#endif

/* enum eml__LengthPerLengthUom has binding name 'eml__LengthPerLengthUom' for type 'eml:LengthPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthUom (653)
#endif

/* enum eml__TemperatureIntervalPerPressureUom has binding name 'eml__TemperatureIntervalPerPressureUom' for type 'eml:TemperatureIntervalPerPressureUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureUom (652)
#endif

/* enum eml__ReciprocalTimeUom has binding name 'eml__ReciprocalTimeUom' for type 'eml:ReciprocalTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeUom (651)
#endif

/* enum eml__APINeutronUom has binding name 'eml__APINeutronUom' for type 'eml:APINeutronUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronUom (650)
#endif

/* enum eml__DipoleMomentUom has binding name 'eml__DipoleMomentUom' for type 'eml:DipoleMomentUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentUom (649)
#endif

/* enum eml__AmountOfSubstanceUom has binding name 'eml__AmountOfSubstanceUom' for type 'eml:AmountOfSubstanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceUom (648)
#endif

/* enum eml__MolarVolumeUom has binding name 'eml__MolarVolumeUom' for type 'eml:MolarVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeUom (647)
#endif

/* enum eml__MassPerVolumeUom has binding name 'eml__MassPerVolumeUom' for type 'eml:MassPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeUom (646)
#endif

/* enum eml__MomentOfForceUom has binding name 'eml__MomentOfForceUom' for type 'eml:MomentOfForceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceUom (645)
#endif

/* enum eml__VolumePerTimePerVolumeUom has binding name 'eml__VolumePerTimePerVolumeUom' for type 'eml:VolumePerTimePerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeUom (644)
#endif

/* enum eml__SolidAngleUom has binding name 'eml__SolidAngleUom' for type 'eml:SolidAngleUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleUom (643)
#endif

/* enum eml__ForceLengthPerLengthUom has binding name 'eml__ForceLengthPerLengthUom' for type 'eml:ForceLengthPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthUom (642)
#endif

/* enum eml__LengthPerTimeUom has binding name 'eml__LengthPerTimeUom' for type 'eml:LengthPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeUom (641)
#endif

/* enum eml__QuantityOfLightUom has binding name 'eml__QuantityOfLightUom' for type 'eml:QuantityOfLightUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightUom (640)
#endif

/* enum eml__ThermalConductanceUom has binding name 'eml__ThermalConductanceUom' for type 'eml:ThermalConductanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceUom (639)
#endif

/* enum eml__VolumeUom has binding name 'eml__VolumeUom' for type 'eml:VolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeUom (638)
#endif

/* enum eml__MagneticFluxUom has binding name 'eml__MagneticFluxUom' for type 'eml:MagneticFluxUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxUom (637)
#endif

/* enum eml__MolecularWeightUom has binding name 'eml__MolecularWeightUom' for type 'eml:MolecularWeightUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightUom (636)
#endif

/* enum eml__MassPerTimeUom has binding name 'eml__MassPerTimeUom' for type 'eml:MassPerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeUom (635)
#endif

/* enum eml__LengthPerVolumeUom has binding name 'eml__LengthPerVolumeUom' for type 'eml:LengthPerVolumeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeUom (634)
#endif

/* enum eml__MagneticFluxDensityPerLengthUom has binding name 'eml__MagneticFluxDensityPerLengthUom' for type 'eml:MagneticFluxDensityPerLengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthUom (633)
#endif

/* enum eml__CapacitanceUom has binding name 'eml__CapacitanceUom' for type 'eml:CapacitanceUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceUom (632)
#endif

/* enum eml__MomentOfInertiaUom has binding name 'eml__MomentOfInertiaUom' for type 'eml:MomentOfInertiaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaUom (631)
#endif

/* enum eml__MassPerEnergyUom has binding name 'eml__MassPerEnergyUom' for type 'eml:MassPerEnergyUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyUom (630)
#endif

/* enum eml__HeatTransferCoefficientUom has binding name 'eml__HeatTransferCoefficientUom' for type 'eml:HeatTransferCoefficientUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientUom (629)
#endif

/* enum eml__MobilityUom has binding name 'eml__MobilityUom' for type 'eml:MobilityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityUom (628)
#endif

/* enum eml__VolumePerTimePerAreaUom has binding name 'eml__VolumePerTimePerAreaUom' for type 'eml:VolumePerTimePerAreaUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaUom (627)
#endif

/* enum eml__VolumePerRotationUom has binding name 'eml__VolumePerRotationUom' for type 'eml:VolumePerRotationUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationUom (626)
#endif

/* enum eml__ElectricConductivityUom has binding name 'eml__ElectricConductivityUom' for type 'eml:ElectricConductivityUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityUom (625)
#endif

/* enum eml__AmountOfSubstancePerTimeUom has binding name 'eml__AmountOfSubstancePerTimeUom' for type 'eml:AmountOfSubstancePerTimeUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeUom (624)
#endif

/* enum eml__LogarithmicPowerRatioUom has binding name 'eml__LogarithmicPowerRatioUom' for type 'eml:LogarithmicPowerRatioUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioUom
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioUom (623)
#endif

/* enum eml__VerticalDirection has binding name 'eml__VerticalDirection' for type 'eml:VerticalDirection' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalDirection
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalDirection (622)
#endif

/* enum eml__AxisOrder2d has binding name 'eml__AxisOrder2d' for type 'eml:AxisOrder2d' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AxisOrder2d
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AxisOrder2d (621)
#endif

/* enum resqml2__OrganizationKind has binding name 'resqml2__OrganizationKind' for type 'resqml2:OrganizationKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrganizationKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrganizationKind (619)
#endif

/* enum resqml2__ResqmlPropertyKind has binding name 'resqml2__ResqmlPropertyKind' for type 'resqml2:ResqmlPropertyKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlPropertyKind (618)
#endif

/* enum _xlink__actuate has binding name '_xlink__actuate' for type 'xlink:actuate' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__actuate
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__actuate (611)
#endif

/* enum _xlink__show has binding name '_xlink__show' for type 'xlink:show' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__show
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__show (610)
#endif

/* enum gml__AggregationType has binding name 'gml__AggregationType' for type 'gml:AggregationType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AggregationType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AggregationType (609)
#endif

/* enum resqml2__StreamlineFlux has binding name 'resqml2__StreamlineFlux' for type 'resqml2:StreamlineFlux' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineFlux
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineFlux (602)
#endif

/* enum resqml2__ParameterKind has binding name 'resqml2__ParameterKind' for type 'resqml2:ParameterKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterKind (601)
#endif

/* enum resqml2__LineRole has binding name 'resqml2__LineRole' for type 'resqml2:LineRole' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LineRole
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LineRole (600)
#endif

/* enum resqml2__SurfaceRole has binding name 'resqml2__SurfaceRole' for type 'resqml2:SurfaceRole' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SurfaceRole
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SurfaceRole (599)
#endif

/* enum resqml2__FluidMarker has binding name 'resqml2__FluidMarker' for type 'resqml2:FluidMarker' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidMarker
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidMarker (598)
#endif

/* enum resqml2__MdReference has binding name 'resqml2__MdReference' for type 'resqml2:MdReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdReference (597)
#endif

/* enum resqml2__MdDomain has binding name 'resqml2__MdDomain' for type 'resqml2:MdDomain' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdDomain
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MdDomain (596)
#endif

/* enum resqml2__WellboreFrameIndexableElements has binding name 'resqml2__WellboreFrameIndexableElements' for type 'resqml2:WellboreFrameIndexableElements' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreFrameIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreFrameIndexableElements (595)
#endif

/* enum resqml2__GeologicBoundaryKind has binding name 'resqml2__GeologicBoundaryKind' for type 'resqml2:GeologicBoundaryKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicBoundaryKind (594)
#endif

/* enum resqml2__TectonicBoundaryKind has binding name 'resqml2__TectonicBoundaryKind' for type 'resqml2:TectonicBoundaryKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TectonicBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TectonicBoundaryKind (593)
#endif

/* enum resqml2__FluidContact has binding name 'resqml2__FluidContact' for type 'resqml2:FluidContact' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidContact
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FluidContact (592)
#endif

/* enum resqml2__GeneticBoundaryKind has binding name 'resqml2__GeneticBoundaryKind' for type 'resqml2:GeneticBoundaryKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeneticBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeneticBoundaryKind (591)
#endif

/* enum resqml2__Phase has binding name 'resqml2__Phase' for type 'resqml2:Phase' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Phase
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Phase (590)
#endif

/* enum resqml2__GeologicUnitMaterialImplacement has binding name 'resqml2__GeologicUnitMaterialImplacement' for type 'resqml2:GeologicUnitMaterialImplacement' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitMaterialImplacement
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitMaterialImplacement (589)
#endif

/* enum resqml2__ContactSide has binding name 'resqml2__ContactSide' for type 'resqml2:ContactSide' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactSide
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactSide (588)
#endif

/* enum resqml2__ContactVerb has binding name 'resqml2__ContactVerb' for type 'resqml2:ContactVerb' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactVerb
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactVerb (587)
#endif

/* enum resqml2__Geobody3dShape has binding name 'resqml2__Geobody3dShape' for type 'resqml2:Geobody3dShape' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Geobody3dShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Geobody3dShape (586)
#endif

/* enum resqml2__OrderingCriteria has binding name 'resqml2__OrderingCriteria' for type 'resqml2:OrderingCriteria' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrderingCriteria
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrderingCriteria (585)
#endif

/* enum resqml2__ContactMode has binding name 'resqml2__ContactMode' for type 'resqml2:ContactMode' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactMode
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactMode (584)
#endif

/* enum resqml2__BoundaryRelation has binding name 'resqml2__BoundaryRelation' for type 'resqml2:BoundaryRelation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BoundaryRelation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BoundaryRelation (583)
#endif

/* enum resqml2__Domain has binding name 'resqml2__Domain' for type 'resqml2:Domain' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Domain
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Domain (582)
#endif

/* enum resqml2__GeologicUnitComposition has binding name 'resqml2__GeologicUnitComposition' for type 'resqml2:GeologicUnitComposition' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitComposition
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitComposition (581)
#endif

/* enum resqml2__DepositionMode has binding name 'resqml2__DepositionMode' for type 'resqml2:DepositionMode' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DepositionMode
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DepositionMode (580)
#endif

/* enum resqml2__ContactRelationship has binding name 'resqml2__ContactRelationship' for type 'resqml2:ContactRelationship' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRelationship
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRelationship (579)
#endif

/* enum resqml2__SequenceStratigraphySurface has binding name 'resqml2__SequenceStratigraphySurface' for type 'resqml2:SequenceStratigraphySurface' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SequenceStratigraphySurface
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SequenceStratigraphySurface (578)
#endif

/* enum resqml2__ThrowKind has binding name 'resqml2__ThrowKind' for type 'resqml2:ThrowKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThrowKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThrowKind (577)
#endif

/* enum resqml2__PillarShape has binding name 'resqml2__PillarShape' for type 'resqml2:PillarShape' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PillarShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PillarShape (576)
#endif

/* enum resqml2__UnstructuredCellIndexableElements has binding name 'resqml2__UnstructuredCellIndexableElements' for type 'resqml2:UnstructuredCellIndexableElements' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredCellIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredCellIndexableElements (575)
#endif

/* enum resqml2__CellShape has binding name 'resqml2__CellShape' for type 'resqml2:CellShape' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellShape (574)
#endif

/* enum resqml2__GridGeometryAttachment has binding name 'resqml2__GridGeometryAttachment' for type 'resqml2:GridGeometryAttachment' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GridGeometryAttachment
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GridGeometryAttachment (573)
#endif

/* enum resqml2__IjkIndexableElements has binding name 'resqml2__IjkIndexableElements' for type 'resqml2:IjkIndexableElements' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkIndexableElements (572)
#endif

/* enum resqml2__KDirection has binding name 'resqml2__KDirection' for type 'resqml2:KDirection' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KDirection
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KDirection (571)
#endif

/* enum resqml2__ColumnShape has binding name 'resqml2__ColumnShape' for type 'resqml2:ColumnShape' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnShape
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnShape (570)
#endif

/* enum resqml2__SubnodeNodeObject has binding name 'resqml2__SubnodeNodeObject' for type 'resqml2:SubnodeNodeObject' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeNodeObject
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeNodeObject (569)
#endif

/* enum resqml2__UnstructuredColumnLayerIndexableElements has binding name 'resqml2__UnstructuredColumnLayerIndexableElements' for type 'resqml2:UnstructuredColumnLayerIndexableElements' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerIndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerIndexableElements (568)
#endif

/* enum resqml2__IndexableElements has binding name 'resqml2__IndexableElements' for type 'resqml2:IndexableElements' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IndexableElements
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IndexableElements (567)
#endif

/* enum resqml2__IdentityKind has binding name 'resqml2__IdentityKind' for type 'resqml2:IdentityKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IdentityKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IdentityKind (566)
#endif

/* enum resqml2__ResqmlUom has binding name 'resqml2__ResqmlUom' for type 'resqml2:ResqmlUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlUom
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlUom (565)
#endif

/* enum resqml2__Facet has binding name 'resqml2__Facet' for type 'resqml2:Facet' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Facet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Facet (564)
#endif

/* enum resqml2__TimeSetKind has binding name 'resqml2__TimeSetKind' for type 'resqml2:TimeSetKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSetKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSetKind (563)
#endif

/* _ptm__standardEnergisticsPropertyTypeSet has binding name '_ptm__standardEnergisticsPropertyTypeSet' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__ptm__standardEnergisticsPropertyTypeSet
#define SOAP_TYPE_gsoap_resqml2_0_1__ptm__standardEnergisticsPropertyTypeSet (1356)
#endif

/* _gco__nilReason has binding name '_gco__nilReason' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__nilReason
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__nilReason (1355)
#endif

/* _gco__Date has binding name '_gco__Date' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__Date
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__Date (1353)
#endif

/* _gco__CharacterString has binding name '_gco__CharacterString' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gco__CharacterString
#define SOAP_TYPE_gsoap_resqml2_0_1__gco__CharacterString (1350)
#endif

/* _gmd__DQ_USCOREEvaluationMethodTypeCode has binding name '_gmd__DQ_USCOREEvaluationMethodTypeCode' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__DQ_USCOREEvaluationMethodTypeCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__DQ_USCOREEvaluationMethodTypeCode (1349)
#endif

/* _gmd__CI_USCORESeries has binding name '_gmd__CI_USCORESeries' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORESeries
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORESeries (1348)
#endif

/* _gmd__CI_USCOREPresentationFormCode has binding name '_gmd__CI_USCOREPresentationFormCode' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREPresentationFormCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREPresentationFormCode (1347)
#endif

/* _gmd__CI_USCORERoleCode has binding name '_gmd__CI_USCORERoleCode' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORERoleCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORERoleCode (1346)
#endif

/* _gmd__CI_USCOREOnLineFunctionCode has binding name '_gmd__CI_USCOREOnLineFunctionCode' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnLineFunctionCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnLineFunctionCode (1345)
#endif

/* _gmd__URL has binding name '_gmd__URL' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__URL
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__URL (1344)
#endif

/* _gmd__CI_USCOREOnlineResource has binding name '_gmd__CI_USCOREOnlineResource' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnlineResource
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREOnlineResource (1343)
#endif

/* _gmd__CI_USCOREAddress has binding name '_gmd__CI_USCOREAddress' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREAddress
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREAddress (1342)
#endif

/* _gmd__CI_USCORETelephone has binding name '_gmd__CI_USCORETelephone' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORETelephone
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORETelephone (1341)
#endif

/* _gmd__CI_USCOREContact has binding name '_gmd__CI_USCOREContact' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREContact
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREContact (1340)
#endif

/* _gmd__CI_USCOREResponsibleParty has binding name '_gmd__CI_USCOREResponsibleParty' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREResponsibleParty
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREResponsibleParty (1339)
#endif

/* _gmd__CI_USCOREDateTypeCode has binding name '_gmd__CI_USCOREDateTypeCode' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDateTypeCode
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDateTypeCode (1338)
#endif

/* _gmd__CI_USCOREDate has binding name '_gmd__CI_USCOREDate' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDate
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCOREDate (1337)
#endif

/* _gmd__CI_USCORECitation has binding name '_gmd__CI_USCORECitation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORECitation
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__CI_USCORECitation (1336)
#endif

/* _gmd__MD_USCOREIdentifier has binding name '_gmd__MD_USCOREIdentifier' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__MD_USCOREIdentifier
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__MD_USCOREIdentifier (1335)
#endif

/* _gmd__EX_USCOREVerticalExtent has binding name '_gmd__EX_USCOREVerticalExtent' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREVerticalExtent
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREVerticalExtent (1334)
#endif

/* _gmd__EX_USCORETemporalExtent has binding name '_gmd__EX_USCORETemporalExtent' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCORETemporalExtent
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCORETemporalExtent (1333)
#endif

/* _gmd__EX_USCOREExtent has binding name '_gmd__EX_USCOREExtent' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREExtent
#define SOAP_TYPE_gsoap_resqml2_0_1__gmd__EX_USCOREExtent (1332)
#endif

/* _xlink__title has binding name '_xlink__title' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__title
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__title (1331)
#endif

/* _xlink__arcrole has binding name '_xlink__arcrole' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__arcrole
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__arcrole (1330)
#endif

/* _xlink__role has binding name '_xlink__role' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__role
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__role (1329)
#endif

/* _xlink__href has binding name '_xlink__href' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__xlink__href
#define SOAP_TYPE_gsoap_resqml2_0_1__xlink__href (1328)
#endif

/* _gml__id has binding name '_gml__id' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__id
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__id (1327)
#endif

/* _gml__VerticalDatum has binding name '_gml__VerticalDatum' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalDatum (1326)
#endif

/* _gml__verticalDatum has binding name '_gml__verticalDatum' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalDatum (1325)
#endif

/* _gml__VerticalCS has binding name '_gml__VerticalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCS (1324)
#endif

/* _gml__verticalCS has binding name '_gml__verticalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__verticalCS (1323)
#endif

/* _gml__VerticalCRS has binding name '_gml__VerticalCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__VerticalCRS (1322)
#endif

/* _gml__baseGeodeticCRS has binding name '_gml__baseGeodeticCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__baseGeodeticCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__baseGeodeticCRS (1321)
#endif

/* _gml__targetCRS has binding name '_gml__targetCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__targetCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__targetCRS (1320)
#endif

/* _gml__sourceCRS has binding name '_gml__sourceCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__sourceCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__sourceCRS (1319)
#endif

/* _gml__operationVersion has binding name '_gml__operationVersion' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__operationVersion
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__operationVersion (1318)
#endif

/* _gml__conversion has binding name '_gml__conversion' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__conversion
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__conversion (1317)
#endif

/* _gml__ProjectedCRS has binding name '_gml__ProjectedCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__ProjectedCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__ProjectedCRS (1316)
#endif

/* _gml__semiMajorAxis has binding name '_gml__semiMajorAxis' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__semiMajorAxis
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__semiMajorAxis (1315)
#endif

/* _gml__Ellipsoid has binding name '_gml__Ellipsoid' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__Ellipsoid
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__Ellipsoid (1314)
#endif

/* _gml__ellipsoid has binding name '_gml__ellipsoid' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoid
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoid (1313)
#endif

/* _gml__greenwichLongitude has binding name '_gml__greenwichLongitude' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__greenwichLongitude
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__greenwichLongitude (1312)
#endif

/* _gml__PrimeMeridian has binding name '_gml__PrimeMeridian' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__PrimeMeridian
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__PrimeMeridian (1311)
#endif

/* _gml__primeMeridian has binding name '_gml__primeMeridian' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__primeMeridian
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__primeMeridian (1310)
#endif

/* _gml__realizationEpoch has binding name '_gml__realizationEpoch' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__realizationEpoch
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__realizationEpoch (1309)
#endif

/* _gml__anchorDefinition has binding name '_gml__anchorDefinition' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__anchorDefinition
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__anchorDefinition (1308)
#endif

/* _gml__GeodeticDatum has binding name '_gml__GeodeticDatum' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticDatum (1307)
#endif

/* _gml__geodeticDatum has binding name '_gml__geodeticDatum' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__geodeticDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__geodeticDatum (1306)
#endif

/* _gml__SphericalCS has binding name '_gml__SphericalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__SphericalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__SphericalCS (1305)
#endif

/* _gml__sphericalCS has binding name '_gml__sphericalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__sphericalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__sphericalCS (1304)
#endif

/* _gml__CartesianCS has binding name '_gml__CartesianCS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__CartesianCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__CartesianCS (1303)
#endif

/* _gml__cartesianCS has binding name '_gml__cartesianCS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__cartesianCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__cartesianCS (1302)
#endif

/* _gml__rangeMeaning has binding name '_gml__rangeMeaning' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__rangeMeaning
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__rangeMeaning (1301)
#endif

/* _gml__axisDirection has binding name '_gml__axisDirection' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__axisDirection
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__axisDirection (1298)
#endif

/* _gml__axisAbbrev has binding name '_gml__axisAbbrev' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__axisAbbrev
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__axisAbbrev (1297)
#endif

/* _gml__CoordinateSystemAxis has binding name '_gml__CoordinateSystemAxis' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__CoordinateSystemAxis
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__CoordinateSystemAxis (1296)
#endif

/* _gml__axis has binding name '_gml__axis' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__axis
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__axis (1295)
#endif

/* _gml__EllipsoidalCS has binding name '_gml__EllipsoidalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__EllipsoidalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__EllipsoidalCS (1294)
#endif

/* _gml__ellipsoidalCS has binding name '_gml__ellipsoidalCS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoidalCS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__ellipsoidalCS (1293)
#endif

/* _gml__scope has binding name '_gml__scope' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__scope
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__scope (1292)
#endif

/* _gml__Definition has binding name '_gml__Definition' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__Definition
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__Definition (1291)
#endif

/* _gml__remarks has binding name '_gml__remarks' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__remarks
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__remarks (1290)
#endif

/* _gml__name has binding name '_gml__name' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__name
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__name (1289)
#endif

/* _gml__identifier has binding name '_gml__identifier' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__identifier
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__identifier (1288)
#endif

/* _gml__descriptionReference has binding name '_gml__descriptionReference' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__descriptionReference
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__descriptionReference (1287)
#endif

/* _gml__description has binding name '_gml__description' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__description
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__description (1286)
#endif

/* _gml__GeodeticCRS has binding name '_gml__GeodeticCRS' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticCRS
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__GeodeticCRS (1285)
#endif

/* _eml__AbstractContextualObject has binding name '_eml__AbstractContextualObject' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractContextualObject
#define SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractContextualObject (1284)
#endif

/* _eml__AbstractDataObject has binding name '_eml__AbstractDataObject' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractDataObject
#define SOAP_TYPE_gsoap_resqml2_0_1__eml__AbstractDataObject (1283)
#endif

/* _eml__EpcExternalPartReference has binding name '_eml__EpcExternalPartReference' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__eml__EpcExternalPartReference
#define SOAP_TYPE_gsoap_resqml2_0_1__eml__EpcExternalPartReference (1282)
#endif

/* _resqml2__StringTableLookup has binding name '_resqml2__StringTableLookup' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StringTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StringTableLookup (1281)
#endif

/* _resqml2__PropertySet has binding name '_resqml2__PropertySet' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertySet
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertySet (1280)
#endif

/* _resqml2__PropertyKind has binding name '_resqml2__PropertyKind' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PropertyKind (1279)
#endif

/* _resqml2__PointsProperty has binding name '_resqml2__PointsProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointsProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointsProperty (1278)
#endif

/* _resqml2__DoubleTableLookup has binding name '_resqml2__DoubleTableLookup' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DoubleTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DoubleTableLookup (1277)
#endif

/* _resqml2__DiscreteProperty has binding name '_resqml2__DiscreteProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscreteProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscreteProperty (1276)
#endif

/* _resqml2__ContinuousProperty has binding name '_resqml2__ContinuousProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousProperty (1275)
#endif

/* _resqml2__CommentProperty has binding name '_resqml2__CommentProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentProperty (1274)
#endif

/* _resqml2__CategoricalProperty has binding name '_resqml2__CategoricalProperty' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalProperty
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalProperty (1273)
#endif

/* _resqml2__WellboreTrajectoryRepresentation has binding name '_resqml2__WellboreTrajectoryRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreTrajectoryRepresentation (1272)
#endif

/* _resqml2__WellboreMarkerFrameRepresentation has binding name '_resqml2__WellboreMarkerFrameRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreMarkerFrameRepresentation (1271)
#endif

/* _resqml2__WellboreFrameRepresentation has binding name '_resqml2__WellboreFrameRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFrameRepresentation (1270)
#endif

/* _resqml2__MdDatum has binding name '_resqml2__MdDatum' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__MdDatum
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__MdDatum (1269)
#endif

/* _resqml2__DeviationSurveyRepresentation has binding name '_resqml2__DeviationSurveyRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DeviationSurveyRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DeviationSurveyRepresentation (1268)
#endif

/* _resqml2__BlockedWellboreRepresentation has binding name '_resqml2__BlockedWellboreRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BlockedWellboreRepresentation (1267)
#endif

/* _resqml2__TriangulatedSetRepresentation has binding name '_resqml2__TriangulatedSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TriangulatedSetRepresentation (1266)
#endif

/* _resqml2__SealedVolumeFrameworkRepresentation has binding name '_resqml2__SealedVolumeFrameworkRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedVolumeFrameworkRepresentation (1265)
#endif

/* _resqml2__SealedSurfaceFrameworkRepresentation has binding name '_resqml2__SealedSurfaceFrameworkRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SealedSurfaceFrameworkRepresentation (1264)
#endif

/* _resqml2__PolylineSetRepresentation has binding name '_resqml2__PolylineSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineSetRepresentation (1263)
#endif

/* _resqml2__PolylineRepresentation has binding name '_resqml2__PolylineRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PolylineRepresentation (1262)
#endif

/* _resqml2__PointSetRepresentation has binding name '_resqml2__PointSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PointSetRepresentation (1261)
#endif

/* _resqml2__PlaneSetRepresentation has binding name '_resqml2__PlaneSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PlaneSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__PlaneSetRepresentation (1260)
#endif

/* _resqml2__NonSealedSurfaceFrameworkRepresentation has binding name '_resqml2__NonSealedSurfaceFrameworkRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__NonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__NonSealedSurfaceFrameworkRepresentation (1259)
#endif

/* _resqml2__Grid2dSetRepresentation has binding name '_resqml2__Grid2dSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dSetRepresentation (1258)
#endif

/* _resqml2__Grid2dRepresentation has binding name '_resqml2__Grid2dRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Grid2dRepresentation (1257)
#endif

/* _resqml2__UnstructuredGridRepresentation has binding name '_resqml2__UnstructuredGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredGridRepresentation (1256)
#endif

/* _resqml2__UnstructuredColumnLayerGridRepresentation has binding name '_resqml2__UnstructuredColumnLayerGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__UnstructuredColumnLayerGridRepresentation (1255)
#endif

/* _resqml2__TruncatedUnstructuredColumnLayerGridRepresentation has binding name '_resqml2__TruncatedUnstructuredColumnLayerGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedUnstructuredColumnLayerGridRepresentation (1254)
#endif

/* _resqml2__TruncatedIjkGridRepresentation has binding name '_resqml2__TruncatedIjkGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TruncatedIjkGridRepresentation (1253)
#endif

/* _resqml2__LocalGridSet has binding name '_resqml2__LocalGridSet' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalGridSet
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalGridSet (1252)
#endif

/* _resqml2__IjkGridRepresentation has binding name '_resqml2__IjkGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__IjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__IjkGridRepresentation (1251)
#endif

/* _resqml2__GridConnectionSetRepresentation has binding name '_resqml2__GridConnectionSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GridConnectionSetRepresentation (1250)
#endif

/* _resqml2__GpGridRepresentation has binding name '_resqml2__GpGridRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GpGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GpGridRepresentation (1249)
#endif

/* _resqml2__SubRepresentation has binding name '_resqml2__SubRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SubRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SubRepresentation (1248)
#endif

/* _resqml2__RepresentationSetRepresentation has binding name '_resqml2__RepresentationSetRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationSetRepresentation (1247)
#endif

/* _resqml2__RepresentationIdentitySet has binding name '_resqml2__RepresentationIdentitySet' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationIdentitySet
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RepresentationIdentitySet (1246)
#endif

/* _resqml2__RedefinedGeometryRepresentation has binding name '_resqml2__RedefinedGeometryRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RedefinedGeometryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RedefinedGeometryRepresentation (1245)
#endif

/* _resqml2__StratigraphicUnitInterpretation has binding name '_resqml2__StratigraphicUnitInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitInterpretation (1244)
#endif

/* _resqml2__RockFluidOrganizationInterpretation has binding name '_resqml2__RockFluidOrganizationInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidOrganizationInterpretation (1243)
#endif

/* _resqml2__HorizonInterpretation has binding name '_resqml2__HorizonInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__HorizonInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__HorizonInterpretation (1242)
#endif

/* _resqml2__RockFluidUnitInterpretation has binding name '_resqml2__RockFluidUnitInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitInterpretation (1241)
#endif

/* _resqml2__GeobodyInterpretation has binding name '_resqml2__GeobodyInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyInterpretation (1240)
#endif

/* _resqml2__GeobodyBoundaryInterpretation has binding name '_resqml2__GeobodyBoundaryInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyBoundaryInterpretation (1239)
#endif

/* _resqml2__FaultInterpretation has binding name '_resqml2__FaultInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FaultInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FaultInterpretation (1238)
#endif

/* _resqml2__EarthModelInterpretation has binding name '_resqml2__EarthModelInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__EarthModelInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__EarthModelInterpretation (1237)
#endif

/* _resqml2__WellboreInterpretation has binding name '_resqml2__WellboreInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreInterpretation (1236)
#endif

/* _resqml2__StructuralOrganizationInterpretation has binding name '_resqml2__StructuralOrganizationInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StructuralOrganizationInterpretation (1235)
#endif

/* _resqml2__StratigraphicOccurrenceInterpretation has binding name '_resqml2__StratigraphicOccurrenceInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicOccurrenceInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicOccurrenceInterpretation (1234)
#endif

/* _resqml2__StratigraphicColumnRankInterpretation has binding name '_resqml2__StratigraphicColumnRankInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumnRankInterpretation (1233)
#endif

/* _resqml2__StratigraphicColumn has binding name '_resqml2__StratigraphicColumn' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicColumn (1232)
#endif

/* _resqml2__GeologicUnitInterpretation has binding name '_resqml2__GeologicUnitInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitInterpretation (1231)
#endif

/* _resqml2__GenericFeatureInterpretation has binding name '_resqml2__GenericFeatureInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GenericFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GenericFeatureInterpretation (1230)
#endif

/* _resqml2__BoundaryFeatureInterpretation has binding name '_resqml2__BoundaryFeatureInterpretation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeatureInterpretation (1229)
#endif

/* _resqml2__WellboreFeature has binding name '_resqml2__WellboreFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__WellboreFeature (1228)
#endif

/* _resqml2__SeismicLineSetFeature has binding name '_resqml2__SeismicLineSetFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineSetFeature (1227)
#endif

/* _resqml2__SeismicLineFeature has binding name '_resqml2__SeismicLineFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLineFeature (1226)
#endif

/* _resqml2__SeismicLatticeFeature has binding name '_resqml2__SeismicLatticeFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLatticeFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__SeismicLatticeFeature (1225)
#endif

/* _resqml2__FrontierFeature has binding name '_resqml2__FrontierFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FrontierFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FrontierFeature (1224)
#endif

/* _resqml2__OrganizationFeature has binding name '_resqml2__OrganizationFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__OrganizationFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__OrganizationFeature (1223)
#endif

/* _resqml2__GeologicUnitFeature has binding name '_resqml2__GeologicUnitFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeologicUnitFeature (1222)
#endif

/* _resqml2__BoundaryFeature has binding name '_resqml2__BoundaryFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__BoundaryFeature (1221)
#endif

/* _resqml2__TectonicBoundaryFeature has binding name '_resqml2__TectonicBoundaryFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TectonicBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TectonicBoundaryFeature (1220)
#endif

/* _resqml2__StratigraphicUnitFeature has binding name '_resqml2__StratigraphicUnitFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StratigraphicUnitFeature (1219)
#endif

/* _resqml2__RockFluidUnitFeature has binding name '_resqml2__RockFluidUnitFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__RockFluidUnitFeature (1218)
#endif

/* _resqml2__GlobalChronostratigraphicColumn has binding name '_resqml2__GlobalChronostratigraphicColumn' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GlobalChronostratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GlobalChronostratigraphicColumn (1217)
#endif

/* _resqml2__GeobodyFeature has binding name '_resqml2__GeobodyFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeobodyFeature (1216)
#endif

/* _resqml2__GeneticBoundaryFeature has binding name '_resqml2__GeneticBoundaryFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeneticBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__GeneticBoundaryFeature (1215)
#endif

/* _resqml2__FluidBoundaryFeature has binding name '_resqml2__FluidBoundaryFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FluidBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__FluidBoundaryFeature (1214)
#endif

/* _resqml2__TimeSeries has binding name '_resqml2__TimeSeries' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TimeSeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__TimeSeries (1213)
#endif

/* _resqml2__LocalTime3dCrs has binding name '_resqml2__LocalTime3dCrs' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalTime3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalTime3dCrs (1212)
#endif

/* _resqml2__LocalDepth3dCrs has binding name '_resqml2__LocalDepth3dCrs' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalDepth3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__LocalDepth3dCrs (1211)
#endif

/* _resqml2__StreamlinesRepresentation has binding name '_resqml2__StreamlinesRepresentation' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesRepresentation (1210)
#endif

/* _resqml2__StreamlinesFeature has binding name '_resqml2__StreamlinesFeature' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesFeature
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__StreamlinesFeature (1209)
#endif

/* _resqml2__DiscretePropertySeries has binding name '_resqml2__DiscretePropertySeries' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscretePropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__DiscretePropertySeries (1208)
#endif

/* _resqml2__ContinuousPropertySeries has binding name '_resqml2__ContinuousPropertySeries' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ContinuousPropertySeries (1207)
#endif

/* _resqml2__CommentPropertySeries has binding name '_resqml2__CommentPropertySeries' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CommentPropertySeries (1206)
#endif

/* _resqml2__CategoricalPropertySeries has binding name '_resqml2__CategoricalPropertySeries' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__CategoricalPropertySeries (1205)
#endif

/* _resqml2__ActivityTemplate has binding name '_resqml2__ActivityTemplate' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ActivityTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__ActivityTemplate (1204)
#endif

/* _resqml2__Activity has binding name '_resqml2__Activity' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Activity
#define SOAP_TYPE_gsoap_resqml2_0_1__resqml2__Activity (1203)
#endif

/* eml__CommentString has binding name 'eml__CommentString' for type 'eml:CommentString' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CommentString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CommentString (620)
#endif

/* eml__UomEnum has binding name 'eml__UomEnum' for type 'eml:UomEnum' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__UomEnum
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__UomEnum (617)
#endif

/* eml__MaximumLengthString has binding name 'eml__MaximumLengthString' for type 'eml:MaximumLengthString' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MaximumLengthString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MaximumLengthString (616)
#endif

/* eml__UidString has binding name 'eml__UidString' for type 'eml:UidString' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__UidString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__UidString (615)
#endif

/* eml__NameString has binding name 'eml__NameString' for type 'eml:NameString' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__NameString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__NameString (614)
#endif

/* eml__TypeEnum has binding name 'eml__TypeEnum' for type 'eml:TypeEnum' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TypeEnum
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TypeEnum (613)
#endif

/* eml__DescriptionString has binding name 'eml__DescriptionString' for type 'eml:DescriptionString' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DescriptionString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DescriptionString (612)
#endif

/* gml__UomURI has binding name 'gml__UomURI' for type 'gml:UomURI' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__UomURI
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__UomURI (608)
#endif

/* gml__UomSymbol has binding name 'gml__UomSymbol' for type 'gml:UomSymbol' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__UomSymbol
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__UomSymbol (607)
#endif

/* eml__String has binding name 'eml__String' for type 'eml:String' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__String
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__String (606)
#endif

/* eml__UuidString has binding name 'eml__UuidString' for type 'eml:UuidString' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__UuidString
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__UuidString (603)
#endif

/* gco__Date_USCOREType has binding name 'gco__Date_USCOREType' for type 'gco:Date_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREType (562)
#endif

/* gml__UomIdentifier has binding name 'gml__UomIdentifier' for type 'gml:UomIdentifier' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__UomIdentifier
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__UomIdentifier (561)
#endif

/* gml__NilReasonEnumeration has binding name 'gml__NilReasonEnumeration' for type 'gml:NilReasonEnumeration' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonEnumeration
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonEnumeration (560)
#endif

/* gml__NilReasonType has binding name 'gml__NilReasonType' for type 'gml:NilReasonType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__NilReasonType (559)
#endif

/* ptm__equivalentPropertyType has binding name 'ptm__equivalentPropertyType' for type 'ptm:equivalentPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ptm__equivalentPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_ptm__equivalentPropertyType (558)
#endif

/* ptm__standardEnergisticsPropertyType has binding name 'ptm__standardEnergisticsPropertyType' for type 'ptm:standardEnergisticsPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyType (557)
#endif

/* ptm__standardEnergisticsPropertyTypeSet has binding name 'ptm__standardEnergisticsPropertyTypeSet' for type 'ptm:standardEnergisticsPropertyTypeSet' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyTypeSet
#define SOAP_TYPE_gsoap_resqml2_0_1_ptm__standardEnergisticsPropertyTypeSet (556)
#endif

/* gsr__SC_USCORECRS_USCOREPropertyType has binding name 'gsr__SC_USCORECRS_USCOREPropertyType' for type 'gsr:SC_CRS_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gsr__SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gsr__SC_USCORECRS_USCOREPropertyType (555)
#endif

/* gco__DateTime_USCOREPropertyType has binding name 'gco__DateTime_USCOREPropertyType' for type 'gco:DateTime_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__DateTime_USCOREPropertyType (554)
#endif

/* gco__CodeListValue_USCOREType has binding name 'gco__CodeListValue_USCOREType' for type 'gco:CodeListValue_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__CodeListValue_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__CodeListValue_USCOREType (553)
#endif

/* gco__Date_USCOREPropertyType has binding name 'gco__Date_USCOREPropertyType' for type 'gco:Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Date_USCOREPropertyType (552)
#endif

/* gco__Real_USCOREPropertyType has binding name 'gco__Real_USCOREPropertyType' for type 'gco:Real_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Real_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Real_USCOREPropertyType (551)
#endif

/* gco__Boolean_USCOREPropertyType has binding name 'gco__Boolean_USCOREPropertyType' for type 'gco:Boolean_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__Boolean_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__Boolean_USCOREPropertyType (550)
#endif

/* gco__CharacterString_USCOREPropertyType has binding name 'gco__CharacterString_USCOREPropertyType' for type 'gco:CharacterString_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__CharacterString_USCOREPropertyType (549)
#endif

/* gco__AbstractObject_USCOREType has binding name 'gco__AbstractObject_USCOREType' for type 'gco:AbstractObject_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gco__AbstractObject_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gco__AbstractObject_USCOREType (548)
#endif

/* gts__TM_USCOREPrimitive_USCOREPropertyType has binding name 'gts__TM_USCOREPrimitive_USCOREPropertyType' for type 'gts:TM_Primitive_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gts__TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gts__TM_USCOREPrimitive_USCOREPropertyType (547)
#endif

/* gmd__AbstractDQ_USCOREResult_USCOREType has binding name 'gmd__AbstractDQ_USCOREResult_USCOREType' for type 'gmd:AbstractDQ_Result_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREResult_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREResult_USCOREType (546)
#endif

/* gmd__DQ_USCOREResult_USCOREPropertyType has binding name 'gmd__DQ_USCOREResult_USCOREPropertyType' for type 'gmd:DQ_Result_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREResult_USCOREPropertyType (545)
#endif

/* gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType has binding name 'gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType' for type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (544)
#endif

/* gmd__CI_USCORESeries_USCOREType has binding name 'gmd__CI_USCORESeries_USCOREType' for type 'gmd:CI_Series_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREType (543)
#endif

/* gmd__CI_USCORESeries_USCOREPropertyType has binding name 'gmd__CI_USCORESeries_USCOREPropertyType' for type 'gmd:CI_Series_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORESeries_USCOREPropertyType (542)
#endif

/* gmd__CI_USCOREPresentationFormCode_USCOREPropertyType has binding name 'gmd__CI_USCOREPresentationFormCode_USCOREPropertyType' for type 'gmd:CI_PresentationFormCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType (541)
#endif

/* gmd__CI_USCORERoleCode_USCOREPropertyType has binding name 'gmd__CI_USCORERoleCode_USCOREPropertyType' for type 'gmd:CI_RoleCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORERoleCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORERoleCode_USCOREPropertyType (540)
#endif

/* gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType has binding name 'gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType' for type 'gmd:CI_OnLineFunctionCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (539)
#endif

/* gmd__URL_USCOREPropertyType has binding name 'gmd__URL_USCOREPropertyType' for type 'gmd:URL_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__URL_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__URL_USCOREPropertyType (538)
#endif

/* gmd__CI_USCOREOnlineResource_USCOREType has binding name 'gmd__CI_USCOREOnlineResource_USCOREType' for type 'gmd:CI_OnlineResource_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREType (537)
#endif

/* gmd__CI_USCOREOnlineResource_USCOREPropertyType has binding name 'gmd__CI_USCOREOnlineResource_USCOREPropertyType' for type 'gmd:CI_OnlineResource_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType (536)
#endif

/* gmd__CI_USCOREAddress_USCOREType has binding name 'gmd__CI_USCOREAddress_USCOREType' for type 'gmd:CI_Address_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREType (535)
#endif

/* gmd__CI_USCOREAddress_USCOREPropertyType has binding name 'gmd__CI_USCOREAddress_USCOREPropertyType' for type 'gmd:CI_Address_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREAddress_USCOREPropertyType (534)
#endif

/* gmd__CI_USCORETelephone_USCOREType has binding name 'gmd__CI_USCORETelephone_USCOREType' for type 'gmd:CI_Telephone_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREType (533)
#endif

/* gmd__CI_USCORETelephone_USCOREPropertyType has binding name 'gmd__CI_USCORETelephone_USCOREPropertyType' for type 'gmd:CI_Telephone_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORETelephone_USCOREPropertyType (532)
#endif

/* gmd__CI_USCOREContact_USCOREType has binding name 'gmd__CI_USCOREContact_USCOREType' for type 'gmd:CI_Contact_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREType (531)
#endif

/* gmd__CI_USCOREContact_USCOREPropertyType has binding name 'gmd__CI_USCOREContact_USCOREPropertyType' for type 'gmd:CI_Contact_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREContact_USCOREPropertyType (530)
#endif

/* gmd__CI_USCOREResponsibleParty_USCOREType has binding name 'gmd__CI_USCOREResponsibleParty_USCOREType' for type 'gmd:CI_ResponsibleParty_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREType (529)
#endif

/* gmd__CI_USCOREResponsibleParty_USCOREPropertyType has binding name 'gmd__CI_USCOREResponsibleParty_USCOREPropertyType' for type 'gmd:CI_ResponsibleParty_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType (528)
#endif

/* gmd__CI_USCOREDateTypeCode_USCOREPropertyType has binding name 'gmd__CI_USCOREDateTypeCode_USCOREPropertyType' for type 'gmd:CI_DateTypeCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType (527)
#endif

/* gmd__CI_USCOREDate_USCOREType has binding name 'gmd__CI_USCOREDate_USCOREType' for type 'gmd:CI_Date_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREType (526)
#endif

/* gmd__CI_USCOREDate_USCOREPropertyType has binding name 'gmd__CI_USCOREDate_USCOREPropertyType' for type 'gmd:CI_Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCOREDate_USCOREPropertyType (525)
#endif

/* gmd__CI_USCORECitation_USCOREType has binding name 'gmd__CI_USCORECitation_USCOREType' for type 'gmd:CI_Citation_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREType (524)
#endif

/* gmd__CI_USCORECitation_USCOREPropertyType has binding name 'gmd__CI_USCORECitation_USCOREPropertyType' for type 'gmd:CI_Citation_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__CI_USCORECitation_USCOREPropertyType (523)
#endif

/* gmd__MD_USCOREIdentifier_USCOREType has binding name 'gmd__MD_USCOREIdentifier_USCOREType' for type 'gmd:MD_Identifier_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREType (522)
#endif

/* gmd__MD_USCOREIdentifier_USCOREPropertyType has binding name 'gmd__MD_USCOREIdentifier_USCOREPropertyType' for type 'gmd:MD_Identifier_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__MD_USCOREIdentifier_USCOREPropertyType (521)
#endif

/* gmd__AbstractDQ_USCOREElement_USCOREType has binding name 'gmd__AbstractDQ_USCOREElement_USCOREType' for type 'gmd:AbstractDQ_Element_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREElement_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREElement_USCOREType (520)
#endif

/* gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType has binding name 'gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType' for type 'gmd:AbstractDQ_PositionalAccuracy_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType (519)
#endif

/* gmd__EX_USCOREVerticalExtent_USCOREType has binding name 'gmd__EX_USCOREVerticalExtent_USCOREType' for type 'gmd:EX_VerticalExtent_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREType (518)
#endif

/* gmd__EX_USCOREVerticalExtent_USCOREPropertyType has binding name 'gmd__EX_USCOREVerticalExtent_USCOREPropertyType' for type 'gmd:EX_VerticalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType (517)
#endif

/* gmd__EX_USCORETemporalExtent_USCOREType has binding name 'gmd__EX_USCORETemporalExtent_USCOREType' for type 'gmd:EX_TemporalExtent_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREType (516)
#endif

/* gmd__EX_USCORETemporalExtent_USCOREPropertyType has binding name 'gmd__EX_USCORETemporalExtent_USCOREPropertyType' for type 'gmd:EX_TemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType (515)
#endif

/* gmd__AbstractEX_USCOREGeographicExtent_USCOREType has binding name 'gmd__AbstractEX_USCOREGeographicExtent_USCOREType' for type 'gmd:AbstractEX_GeographicExtent_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType (514)
#endif

/* gmd__EX_USCOREGeographicExtent_USCOREPropertyType has binding name 'gmd__EX_USCOREGeographicExtent_USCOREPropertyType' for type 'gmd:EX_GeographicExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType (513)
#endif

/* gmd__EX_USCOREExtent_USCOREType has binding name 'gmd__EX_USCOREExtent_USCOREType' for type 'gmd:EX_Extent_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_gmd__EX_USCOREExtent_USCOREType (512)
#endif

/* _gml__coordinateOperationAccuracy has binding name '_gml__coordinateOperationAccuracy' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__coordinateOperationAccuracy (511)
#endif

/* _gml__SecondDefiningParameter has binding name '_gml__SecondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__SecondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__SecondDefiningParameter (510)
#endif

/* _gml__secondDefiningParameter has binding name '_gml__secondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__secondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__secondDefiningParameter (509)
#endif

/* _gml__domainOfValidity has binding name '_gml__domainOfValidity' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__gml__domainOfValidity
#define SOAP_TYPE_gsoap_resqml2_0_1__gml__domainOfValidity (508)
#endif

/* gml__VerticalDatumType has binding name 'gml__VerticalDatumType' for type 'gml:VerticalDatumType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumType (507)
#endif

/* gml__VerticalDatumPropertyType has binding name 'gml__VerticalDatumPropertyType' for type 'gml:VerticalDatumPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalDatumPropertyType (506)
#endif

/* gml__VerticalCSType has binding name 'gml__VerticalCSType' for type 'gml:VerticalCSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSType (505)
#endif

/* gml__VerticalCSPropertyType has binding name 'gml__VerticalCSPropertyType' for type 'gml:VerticalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCSPropertyType (504)
#endif

/* gml__VerticalCRSType has binding name 'gml__VerticalCRSType' for type 'gml:VerticalCRSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__VerticalCRSType (503)
#endif

/* gml__GeodeticCRSPropertyType has binding name 'gml__GeodeticCRSPropertyType' for type 'gml:GeodeticCRSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSPropertyType (502)
#endif

/* gml__CRSPropertyType has binding name 'gml__CRSPropertyType' for type 'gml:CRSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CRSPropertyType (501)
#endif

/* gml__AbstractCoordinateOperationType has binding name 'gml__AbstractCoordinateOperationType' for type 'gml:AbstractCoordinateOperationType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateOperationType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateOperationType (500)
#endif

/* gml__AbstractGeneralConversionType has binding name 'gml__AbstractGeneralConversionType' for type 'gml:AbstractGeneralConversionType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralConversionType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralConversionType (499)
#endif

/* gml__GeneralConversionPropertyType has binding name 'gml__GeneralConversionPropertyType' for type 'gml:GeneralConversionPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeneralConversionPropertyType (498)
#endif

/* gml__AbstractGeneralDerivedCRSType has binding name 'gml__AbstractGeneralDerivedCRSType' for type 'gml:AbstractGeneralDerivedCRSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralDerivedCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGeneralDerivedCRSType (497)
#endif

/* gml__ProjectedCRSType has binding name 'gml__ProjectedCRSType' for type 'gml:ProjectedCRSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__ProjectedCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__ProjectedCRSType (496)
#endif

/* gml__LengthType has binding name 'gml__LengthType' for type 'gml:LengthType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__LengthType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__LengthType (495)
#endif

/* gml__EllipsoidType has binding name 'gml__EllipsoidType' for type 'gml:EllipsoidType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidType (494)
#endif

/* gml__EllipsoidPropertyType has binding name 'gml__EllipsoidPropertyType' for type 'gml:EllipsoidPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidPropertyType (493)
#endif

/* gml__MeasureType has binding name 'gml__MeasureType' for type 'gml:MeasureType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__MeasureType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__MeasureType (492)
#endif

/* gml__AngleType has binding name 'gml__AngleType' for type 'gml:AngleType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AngleType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AngleType (491)
#endif

/* gml__PrimeMeridianType has binding name 'gml__PrimeMeridianType' for type 'gml:PrimeMeridianType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianType (490)
#endif

/* gml__PrimeMeridianPropertyType has binding name 'gml__PrimeMeridianPropertyType' for type 'gml:PrimeMeridianPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__PrimeMeridianPropertyType (489)
#endif

/* gml__AbstractDatumType has binding name 'gml__AbstractDatumType' for type 'gml:AbstractDatumType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractDatumType (488)
#endif

/* gml__GeodeticDatumType has binding name 'gml__GeodeticDatumType' for type 'gml:GeodeticDatumType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumType (487)
#endif

/* gml__GeodeticDatumPropertyType has binding name 'gml__GeodeticDatumPropertyType' for type 'gml:GeodeticDatumPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticDatumPropertyType (486)
#endif

/* gml__SphericalCSType has binding name 'gml__SphericalCSType' for type 'gml:SphericalCSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSType (485)
#endif

/* gml__SphericalCSPropertyType has binding name 'gml__SphericalCSPropertyType' for type 'gml:SphericalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__SphericalCSPropertyType (484)
#endif

/* gml__CartesianCSType has binding name 'gml__CartesianCSType' for type 'gml:CartesianCSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSType (483)
#endif

/* gml__CartesianCSPropertyType has binding name 'gml__CartesianCSPropertyType' for type 'gml:CartesianCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CartesianCSPropertyType (482)
#endif

/* gml__CoordinateSystemAxisType has binding name 'gml__CoordinateSystemAxisType' for type 'gml:CoordinateSystemAxisType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisType (481)
#endif

/* gml__CoordinateSystemAxisPropertyType has binding name 'gml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CoordinateSystemAxisPropertyType (480)
#endif

/* gml__AbstractCoordinateSystemType has binding name 'gml__AbstractCoordinateSystemType' for type 'gml:AbstractCoordinateSystemType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateSystemType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCoordinateSystemType (479)
#endif

/* gml__EllipsoidalCSType has binding name 'gml__EllipsoidalCSType' for type 'gml:EllipsoidalCSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSType (478)
#endif

/* gml__EllipsoidalCSPropertyType has binding name 'gml__EllipsoidalCSPropertyType' for type 'gml:EllipsoidalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__EllipsoidalCSPropertyType (477)
#endif

/* gml__TimePrimitivePropertyType has binding name 'gml__TimePrimitivePropertyType' for type 'gml:TimePrimitivePropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__TimePrimitivePropertyType (476)
#endif

/* gml__RelatedTimeType has binding name 'gml__RelatedTimeType' for type 'gml:RelatedTimeType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__RelatedTimeType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__RelatedTimeType (475)
#endif

/* gml__AbstractTimeObjectType has binding name 'gml__AbstractTimeObjectType' for type 'gml:AbstractTimeObjectType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimeObjectType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimeObjectType (474)
#endif

/* gml__AbstractTimePrimitiveType has binding name 'gml__AbstractTimePrimitiveType' for type 'gml:AbstractTimePrimitiveType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimePrimitiveType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractTimePrimitiveType (473)
#endif

/* gml__CodeType has binding name 'gml__CodeType' for type 'gml:CodeType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeType (472)
#endif

/* gml__CodeWithAuthorityType has binding name 'gml__CodeWithAuthorityType' for type 'gml:CodeWithAuthorityType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeWithAuthorityType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__CodeWithAuthorityType (471)
#endif

/* gml__ReferenceType has binding name 'gml__ReferenceType' for type 'gml:ReferenceType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__ReferenceType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__ReferenceType (470)
#endif

/* gml__StringOrRefType has binding name 'gml__StringOrRefType' for type 'gml:StringOrRefType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__StringOrRefType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__StringOrRefType (469)
#endif

/* gml__AbstractGMLType has binding name 'gml__AbstractGMLType' for type 'gml:AbstractGMLType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGMLType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractGMLType (468)
#endif

/* gml__DefinitionBaseType has binding name 'gml__DefinitionBaseType' for type 'gml:DefinitionBaseType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionBaseType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionBaseType (467)
#endif

/* gml__DefinitionType has binding name 'gml__DefinitionType' for type 'gml:DefinitionType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__DefinitionType (466)
#endif

/* gml__IdentifiedObjectType has binding name 'gml__IdentifiedObjectType' for type 'gml:IdentifiedObjectType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__IdentifiedObjectType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__IdentifiedObjectType (465)
#endif

/* gml__AbstractCRSType has binding name 'gml__AbstractCRSType' for type 'gml:AbstractCRSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__AbstractCRSType (464)
#endif

/* gml__GeodeticCRSType has binding name 'gml__GeodeticCRSType' for type 'gml:GeodeticCRSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_gml__GeodeticCRSType (463)
#endif

/* eml__MobilityMeasure has binding name 'eml__MobilityMeasure' for type 'eml:MobilityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MobilityMeasure (462)
#endif

/* eml__LengthPerMassMeasure has binding name 'eml__LengthPerMassMeasure' for type 'eml:LengthPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerMassMeasure (461)
#endif

/* eml__AreaMeasure has binding name 'eml__AreaMeasure' for type 'eml:AreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaMeasure (460)
#endif

/* eml__VolumePerVolumeMeasure has binding name 'eml__VolumePerVolumeMeasure' for type 'eml:VolumePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerVolumeMeasure (459)
#endif

/* eml__ElectricResistanceMeasure has binding name 'eml__ElectricResistanceMeasure' for type 'eml:ElectricResistanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistanceMeasure (458)
#endif

/* eml__AreaPerVolumeMeasure has binding name 'eml__AreaPerVolumeMeasure' for type 'eml:AreaPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerVolumeMeasure (457)
#endif

/* eml__TimePerTimeMeasure has binding name 'eml__TimePerTimeMeasure' for type 'eml:TimePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerTimeMeasure (456)
#endif

/* eml__AmountOfSubstancePerVolumeMeasure has binding name 'eml__AmountOfSubstancePerVolumeMeasure' for type 'eml:AmountOfSubstancePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerVolumeMeasure (455)
#endif

/* eml__MassPerAreaMeasure has binding name 'eml__MassPerAreaMeasure' for type 'eml:MassPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerAreaMeasure (454)
#endif

/* eml__VolumePerPressureMeasure has binding name 'eml__VolumePerPressureMeasure' for type 'eml:VolumePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerPressureMeasure (453)
#endif

/* eml__MassPerTimePerAreaMeasure has binding name 'eml__MassPerTimePerAreaMeasure' for type 'eml:MassPerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerAreaMeasure (452)
#endif

/* eml__DoseEquivalentMeasure has binding name 'eml__DoseEquivalentMeasure' for type 'eml:DoseEquivalentMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DoseEquivalentMeasure (451)
#endif

/* eml__PermeabilityRockMeasure has binding name 'eml__PermeabilityRockMeasure' for type 'eml:PermeabilityRockMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityRockMeasure (450)
#endif

/* eml__MagneticFieldStrengthMeasure has binding name 'eml__MagneticFieldStrengthMeasure' for type 'eml:MagneticFieldStrengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFieldStrengthMeasure (449)
#endif

/* eml__VolumePerTimePerPressureLengthMeasure has binding name 'eml__VolumePerTimePerPressureLengthMeasure' for type 'eml:VolumePerTimePerPressureLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureLengthMeasure (448)
#endif

/* eml__PressureMeasure has binding name 'eml__PressureMeasure' for type 'eml:PressureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureMeasure (447)
#endif

/* eml__MagneticFluxDensityPerLengthMeasure has binding name 'eml__MagneticFluxDensityPerLengthMeasure' for type 'eml:MagneticFluxDensityPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityPerLengthMeasure (446)
#endif

/* eml__PowerPerAreaMeasure has binding name 'eml__PowerPerAreaMeasure' for type 'eml:PowerPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerAreaMeasure (445)
#endif

/* eml__ElectricFieldStrengthMeasure has binding name 'eml__ElectricFieldStrengthMeasure' for type 'eml:ElectricFieldStrengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricFieldStrengthMeasure (444)
#endif

/* eml__AmountOfSubstancePerAmountOfSubstanceMeasure has binding name 'eml__AmountOfSubstancePerAmountOfSubstanceMeasure' for type 'eml:AmountOfSubstancePerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAmountOfSubstanceMeasure (443)
#endif

/* eml__ElectricConductivityMeasure has binding name 'eml__ElectricConductivityMeasure' for type 'eml:ElectricConductivityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductivityMeasure (442)
#endif

/* eml__AngularVelocityMeasure has binding name 'eml__AngularVelocityMeasure' for type 'eml:AngularVelocityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularVelocityMeasure (441)
#endif

/* eml__EnergyPerMassMeasure has binding name 'eml__EnergyPerMassMeasure' for type 'eml:EnergyPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassMeasure (440)
#endif

/* eml__EnergyLengthPerAreaMeasure has binding name 'eml__EnergyLengthPerAreaMeasure' for type 'eml:EnergyLengthPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerAreaMeasure (439)
#endif

/* eml__PlaneAngleMeasure has binding name 'eml__PlaneAngleMeasure' for type 'eml:PlaneAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PlaneAngleMeasure (438)
#endif

/* eml__ReciprocalForceMeasure has binding name 'eml__ReciprocalForceMeasure' for type 'eml:ReciprocalForceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalForceMeasure (437)
#endif

/* eml__ReciprocalMassMeasure has binding name 'eml__ReciprocalMassMeasure' for type 'eml:ReciprocalMassMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassMeasure (436)
#endif

/* eml__AngularAccelerationMeasure has binding name 'eml__AngularAccelerationMeasure' for type 'eml:AngularAccelerationMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AngularAccelerationMeasure (435)
#endif

/* eml__LogarithmicPowerRatioMeasure has binding name 'eml__LogarithmicPowerRatioMeasure' for type 'eml:LogarithmicPowerRatioMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioMeasure (434)
#endif

/* eml__NormalizedPowerMeasure has binding name 'eml__NormalizedPowerMeasure' for type 'eml:NormalizedPowerMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__NormalizedPowerMeasure (433)
#endif

/* eml__MassMeasure has binding name 'eml__MassMeasure' for type 'eml:MassMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassMeasure (432)
#endif

/* eml__ThermalConductivityMeasure has binding name 'eml__ThermalConductivityMeasure' for type 'eml:ThermalConductivityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductivityMeasure (431)
#endif

/* eml__LengthPerPressureMeasure has binding name 'eml__LengthPerPressureMeasure' for type 'eml:LengthPerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerPressureMeasure (430)
#endif

/* eml__AnglePerVolumeMeasure has binding name 'eml__AnglePerVolumeMeasure' for type 'eml:AnglePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerVolumeMeasure (429)
#endif

/* eml__PressureSquaredPerForceTimePerAreaMeasure has binding name 'eml__PressureSquaredPerForceTimePerAreaMeasure' for type 'eml:PressureSquaredPerForceTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredPerForceTimePerAreaMeasure (428)
#endif

/* eml__VolumePerTimeLengthMeasure has binding name 'eml__VolumePerTimeLengthMeasure' for type 'eml:VolumePerTimeLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeLengthMeasure (427)
#endif

/* eml__LengthPerTemperatureMeasure has binding name 'eml__LengthPerTemperatureMeasure' for type 'eml:LengthPerTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTemperatureMeasure (426)
#endif

/* eml__AmountOfSubstancePerTimeMeasure has binding name 'eml__AmountOfSubstancePerTimeMeasure' for type 'eml:AmountOfSubstancePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimeMeasure (425)
#endif

/* eml__ForcePerLengthMeasure has binding name 'eml__ForcePerLengthMeasure' for type 'eml:ForcePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerLengthMeasure (424)
#endif

/* eml__PressurePerTimeMeasure has binding name 'eml__PressurePerTimeMeasure' for type 'eml:PressurePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerTimeMeasure (423)
#endif

/* eml__MassPerVolumePerLengthMeasure has binding name 'eml__MassPerVolumePerLengthMeasure' for type 'eml:MassPerVolumePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumePerLengthMeasure (422)
#endif

/* eml__IsothermalCompressibilityMeasure has binding name 'eml__IsothermalCompressibilityMeasure' for type 'eml:IsothermalCompressibilityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IsothermalCompressibilityMeasure (421)
#endif

/* eml__ElectricPotentialDifferenceMeasure has binding name 'eml__ElectricPotentialDifferenceMeasure' for type 'eml:ElectricPotentialDifferenceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricPotentialDifferenceMeasure (420)
#endif

/* eml__DiffusionCoefficientMeasure has binding name 'eml__DiffusionCoefficientMeasure' for type 'eml:DiffusionCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DiffusionCoefficientMeasure (419)
#endif

/* eml__APIGammaRayMeasure has binding name 'eml__APIGammaRayMeasure' for type 'eml:APIGammaRayMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGammaRayMeasure (418)
#endif

/* eml__ElectricChargePerMassMeasure has binding name 'eml__ElectricChargePerMassMeasure' for type 'eml:ElectricChargePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerMassMeasure (417)
#endif

/* eml__ReciprocalElectricPotentialDifferenceMeasure has binding name 'eml__ReciprocalElectricPotentialDifferenceMeasure' for type 'eml:ReciprocalElectricPotentialDifferenceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalElectricPotentialDifferenceMeasure (416)
#endif

/* eml__DynamicViscosityMeasure has binding name 'eml__DynamicViscosityMeasure' for type 'eml:DynamicViscosityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DynamicViscosityMeasure (415)
#endif

/* eml__ReciprocalLengthMeasure has binding name 'eml__ReciprocalLengthMeasure' for type 'eml:ReciprocalLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalLengthMeasure (414)
#endif

/* eml__TimePerMassMeasure has binding name 'eml__TimePerMassMeasure' for type 'eml:TimePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerMassMeasure (413)
#endif

/* eml__PressurePerVolumeMeasure has binding name 'eml__PressurePerVolumeMeasure' for type 'eml:PressurePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressurePerVolumeMeasure (412)
#endif

/* eml__VolumetricHeatTransferCoefficientMeasure has binding name 'eml__VolumetricHeatTransferCoefficientMeasure' for type 'eml:VolumetricHeatTransferCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricHeatTransferCoefficientMeasure (411)
#endif

/* eml__ElectricChargePerVolumeMeasure has binding name 'eml__ElectricChargePerVolumeMeasure' for type 'eml:ElectricChargePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerVolumeMeasure (410)
#endif

/* eml__EnergyPerVolumeMeasure has binding name 'eml__EnergyPerVolumeMeasure' for type 'eml:EnergyPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerVolumeMeasure (409)
#endif

/* eml__ElectromagneticMomentMeasure has binding name 'eml__ElectromagneticMomentMeasure' for type 'eml:ElectromagneticMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectromagneticMomentMeasure (408)
#endif

/* eml__TimePerVolumeMeasure has binding name 'eml__TimePerVolumeMeasure' for type 'eml:TimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerVolumeMeasure (407)
#endif

/* eml__InductanceMeasure has binding name 'eml__InductanceMeasure' for type 'eml:InductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__InductanceMeasure (406)
#endif

/* eml__KinematicViscosityMeasure has binding name 'eml__KinematicViscosityMeasure' for type 'eml:KinematicViscosityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__KinematicViscosityMeasure (405)
#endif

/* eml__ReciprocalAreaMeasure has binding name 'eml__ReciprocalAreaMeasure' for type 'eml:ReciprocalAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalAreaMeasure (404)
#endif

/* eml__MassLengthMeasure has binding name 'eml__MassLengthMeasure' for type 'eml:MassLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassLengthMeasure (403)
#endif

/* eml__ElectricalResistivityMeasure has binding name 'eml__ElectricalResistivityMeasure' for type 'eml:ElectricalResistivityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricalResistivityMeasure (402)
#endif

/* eml__CapacitanceMeasure has binding name 'eml__CapacitanceMeasure' for type 'eml:CapacitanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CapacitanceMeasure (401)
#endif

/* eml__FrequencyIntervalMeasure has binding name 'eml__FrequencyIntervalMeasure' for type 'eml:FrequencyIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyIntervalMeasure (400)
#endif

/* eml__FrequencyMeasure has binding name 'eml__FrequencyMeasure' for type 'eml:FrequencyMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__FrequencyMeasure (399)
#endif

/* eml__SignalingEventPerTimeMeasure has binding name 'eml__SignalingEventPerTimeMeasure' for type 'eml:SignalingEventPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SignalingEventPerTimeMeasure (398)
#endif

/* eml__ActivityOfRadioactivityMeasure has binding name 'eml__ActivityOfRadioactivityMeasure' for type 'eml:ActivityOfRadioactivityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ActivityOfRadioactivityMeasure (397)
#endif

/* eml__MolecularWeightMeasure has binding name 'eml__MolecularWeightMeasure' for type 'eml:MolecularWeightMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolecularWeightMeasure (396)
#endif

/* eml__MassPerTimePerLengthMeasure has binding name 'eml__MassPerTimePerLengthMeasure' for type 'eml:MassPerTimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimePerLengthMeasure (395)
#endif

/* eml__MomentOfInertiaMeasure has binding name 'eml__MomentOfInertiaMeasure' for type 'eml:MomentOfInertiaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfInertiaMeasure (394)
#endif

/* eml__PotentialDifferencePerPowerDropMeasure has binding name 'eml__PotentialDifferencePerPowerDropMeasure' for type 'eml:PotentialDifferencePerPowerDropMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PotentialDifferencePerPowerDropMeasure (393)
#endif

/* eml__SpecificHeatCapacityMeasure has binding name 'eml__SpecificHeatCapacityMeasure' for type 'eml:SpecificHeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SpecificHeatCapacityMeasure (392)
#endif

/* eml__ReciprocalTimeMeasure has binding name 'eml__ReciprocalTimeMeasure' for type 'eml:ReciprocalTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalTimeMeasure (391)
#endif

/* eml__LogarithmicPowerRatioPerLengthMeasure has binding name 'eml__LogarithmicPowerRatioPerLengthMeasure' for type 'eml:LogarithmicPowerRatioPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LogarithmicPowerRatioPerLengthMeasure (390)
#endif

/* eml__ThermalDiffusivityMeasure has binding name 'eml__ThermalDiffusivityMeasure' for type 'eml:ThermalDiffusivityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalDiffusivityMeasure (389)
#endif

/* eml__PowerPerVolumeMeasure has binding name 'eml__PowerPerVolumeMeasure' for type 'eml:PowerPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerVolumeMeasure (388)
#endif

/* eml__MomentumMeasure has binding name 'eml__MomentumMeasure' for type 'eml:MomentumMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentumMeasure (387)
#endif

/* eml__VolumeFlowRatePerVolumeFlowRateMeasure has binding name 'eml__VolumeFlowRatePerVolumeFlowRateMeasure' for type 'eml:VolumeFlowRatePerVolumeFlowRateMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeFlowRatePerVolumeFlowRateMeasure (386)
#endif

/* eml__AreaPerTimeMeasure has binding name 'eml__AreaPerTimeMeasure' for type 'eml:AreaPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerTimeMeasure (385)
#endif

/* eml__LuminousEfficacyMeasure has binding name 'eml__LuminousEfficacyMeasure' for type 'eml:LuminousEfficacyMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousEfficacyMeasure (384)
#endif

/* eml__QuantityOfLightMeasure has binding name 'eml__QuantityOfLightMeasure' for type 'eml:QuantityOfLightMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__QuantityOfLightMeasure (383)
#endif

/* eml__VolumePerAreaMeasure has binding name 'eml__VolumePerAreaMeasure' for type 'eml:VolumePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerAreaMeasure (382)
#endif

/* eml__MagneticFluxDensityMeasure has binding name 'eml__MagneticFluxDensityMeasure' for type 'eml:MagneticFluxDensityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxDensityMeasure (381)
#endif

/* eml__SecondMomentOfAreaMeasure has binding name 'eml__SecondMomentOfAreaMeasure' for type 'eml:SecondMomentOfAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SecondMomentOfAreaMeasure (380)
#endif

/* eml__LengthPerVolumeMeasure has binding name 'eml__LengthPerVolumeMeasure' for type 'eml:LengthPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerVolumeMeasure (379)
#endif

/* eml__MolarEnergyMeasure has binding name 'eml__MolarEnergyMeasure' for type 'eml:MolarEnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarEnergyMeasure (378)
#endif

/* eml__LuminousIntensityMeasure has binding name 'eml__LuminousIntensityMeasure' for type 'eml:LuminousIntensityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousIntensityMeasure (377)
#endif

/* eml__ElectricChargeMeasure has binding name 'eml__ElectricChargeMeasure' for type 'eml:ElectricChargeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargeMeasure (376)
#endif

/* eml__DigitalStorageMeasure has binding name 'eml__DigitalStorageMeasure' for type 'eml:DigitalStorageMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DigitalStorageMeasure (375)
#endif

/* eml__MolarHeatCapacityMeasure has binding name 'eml__MolarHeatCapacityMeasure' for type 'eml:MolarHeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarHeatCapacityMeasure (374)
#endif

/* eml__ForcePerVolumeMeasure has binding name 'eml__ForcePerVolumeMeasure' for type 'eml:ForcePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerVolumeMeasure (373)
#endif

/* eml__LuminanceMeasure has binding name 'eml__LuminanceMeasure' for type 'eml:LuminanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminanceMeasure (372)
#endif

/* eml__MomentOfForceMeasure has binding name 'eml__MomentOfForceMeasure' for type 'eml:MomentOfForceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MomentOfForceMeasure (371)
#endif

/* eml__TimeMeasure has binding name 'eml__TimeMeasure' for type 'eml:TimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimeMeasure (370)
#endif

/* eml__VolumePerTimePerPressureMeasure has binding name 'eml__VolumePerTimePerPressureMeasure' for type 'eml:VolumePerTimePerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerPressureMeasure (369)
#endif

/* eml__VolumePerTimePerVolumeMeasure has binding name 'eml__VolumePerTimePerVolumeMeasure' for type 'eml:VolumePerTimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerVolumeMeasure (368)
#endif

/* eml__VolumeMeasure has binding name 'eml__VolumeMeasure' for type 'eml:VolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumeMeasure (367)
#endif

/* eml__VolumePerLengthMeasure has binding name 'eml__VolumePerLengthMeasure' for type 'eml:VolumePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerLengthMeasure (366)
#endif

/* eml__APIGravityMeasure has binding name 'eml__APIGravityMeasure' for type 'eml:APIGravityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APIGravityMeasure (365)
#endif

/* eml__MagneticPermeabilityMeasure has binding name 'eml__MagneticPermeabilityMeasure' for type 'eml:MagneticPermeabilityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticPermeabilityMeasure (364)
#endif

/* eml__MassPerEnergyMeasure has binding name 'eml__MassPerEnergyMeasure' for type 'eml:MassPerEnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerEnergyMeasure (363)
#endif

/* eml__MagneticDipoleMomentMeasure has binding name 'eml__MagneticDipoleMomentMeasure' for type 'eml:MagneticDipoleMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticDipoleMomentMeasure (362)
#endif

/* eml__DataTransferSpeedMeasure has binding name 'eml__DataTransferSpeedMeasure' for type 'eml:DataTransferSpeedMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DataTransferSpeedMeasure (361)
#endif

/* eml__MassPerMassMeasure has binding name 'eml__MassPerMassMeasure' for type 'eml:MassPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerMassMeasure (360)
#endif

/* eml__ElectricCurrentDensityMeasure has binding name 'eml__ElectricCurrentDensityMeasure' for type 'eml:ElectricCurrentDensityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentDensityMeasure (359)
#endif

/* eml__EnergyPerMassPerTimeMeasure has binding name 'eml__EnergyPerMassPerTimeMeasure' for type 'eml:EnergyPerMassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerMassPerTimeMeasure (358)
#endif

/* eml__AreaPerMassMeasure has binding name 'eml__AreaPerMassMeasure' for type 'eml:AreaPerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerMassMeasure (357)
#endif

/* eml__RadianceMeasure has binding name 'eml__RadianceMeasure' for type 'eml:RadianceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadianceMeasure (356)
#endif

/* eml__DipoleMomentMeasure has binding name 'eml__DipoleMomentMeasure' for type 'eml:DipoleMomentMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DipoleMomentMeasure (355)
#endif

/* eml__PressureTimePerVolumeMeasure has binding name 'eml__PressureTimePerVolumeMeasure' for type 'eml:PressureTimePerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureTimePerVolumeMeasure (354)
#endif

/* eml__PermittivityMeasure has binding name 'eml__PermittivityMeasure' for type 'eml:PermittivityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermittivityMeasure (353)
#endif

/* eml__ThermodynamicTemperatureMeasure has binding name 'eml__ThermodynamicTemperatureMeasure' for type 'eml:ThermodynamicTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermodynamicTemperatureMeasure (352)
#endif

/* eml__ReluctanceMeasure has binding name 'eml__ReluctanceMeasure' for type 'eml:ReluctanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReluctanceMeasure (351)
#endif

/* eml__AreaPerAreaMeasure has binding name 'eml__AreaPerAreaMeasure' for type 'eml:AreaPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAreaMeasure (350)
#endif

/* eml__EnergyPerAreaMeasure has binding name 'eml__EnergyPerAreaMeasure' for type 'eml:EnergyPerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerAreaMeasure (349)
#endif

/* eml__MassPerLengthMeasure has binding name 'eml__MassPerLengthMeasure' for type 'eml:MassPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerLengthMeasure (348)
#endif

/* eml__LengthPerTimeMeasure has binding name 'eml__LengthPerTimeMeasure' for type 'eml:LengthPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerTimeMeasure (347)
#endif

/* eml__AnglePerLengthMeasure has binding name 'eml__AnglePerLengthMeasure' for type 'eml:AnglePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AnglePerLengthMeasure (346)
#endif

/* eml__ThermalResistanceMeasure has binding name 'eml__ThermalResistanceMeasure' for type 'eml:ThermalResistanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalResistanceMeasure (345)
#endif

/* eml__AttenuationPerFrequencyIntervalMeasure has binding name 'eml__AttenuationPerFrequencyIntervalMeasure' for type 'eml:AttenuationPerFrequencyIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AttenuationPerFrequencyIntervalMeasure (344)
#endif

/* eml__TemperatureIntervalPerPressureMeasure has binding name 'eml__TemperatureIntervalPerPressureMeasure' for type 'eml:TemperatureIntervalPerPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerPressureMeasure (343)
#endif

/* eml__AbsorbedDoseMeasure has binding name 'eml__AbsorbedDoseMeasure' for type 'eml:AbsorbedDoseMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbsorbedDoseMeasure (342)
#endif

/* eml__ElectricResistancePerLengthMeasure has binding name 'eml__ElectricResistancePerLengthMeasure' for type 'eml:ElectricResistancePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricResistancePerLengthMeasure (341)
#endif

/* eml__HeatCapacityMeasure has binding name 'eml__HeatCapacityMeasure' for type 'eml:HeatCapacityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatCapacityMeasure (340)
#endif

/* eml__LuminousFluxMeasure has binding name 'eml__LuminousFluxMeasure' for type 'eml:LuminousFluxMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LuminousFluxMeasure (339)
#endif

/* eml__ElectricCurrentMeasure has binding name 'eml__ElectricCurrentMeasure' for type 'eml:ElectricCurrentMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricCurrentMeasure (338)
#endif

/* eml__LightExposureMeasure has binding name 'eml__LightExposureMeasure' for type 'eml:LightExposureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LightExposureMeasure (337)
#endif

/* eml__ElectricChargePerAreaMeasure has binding name 'eml__ElectricChargePerAreaMeasure' for type 'eml:ElectricChargePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricChargePerAreaMeasure (336)
#endif

/* eml__VolumePerRotationMeasure has binding name 'eml__VolumePerRotationMeasure' for type 'eml:VolumePerRotationMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerRotationMeasure (335)
#endif

/* eml__PowerMeasure has binding name 'eml__PowerMeasure' for type 'eml:PowerMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerMeasure (334)
#endif

/* eml__EnergyLengthPerTimeAreaTemperatureMeasure has binding name 'eml__EnergyLengthPerTimeAreaTemperatureMeasure' for type 'eml:EnergyLengthPerTimeAreaTemperatureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyLengthPerTimeAreaTemperatureMeasure (333)
#endif

/* eml__SolidAngleMeasure has binding name 'eml__SolidAngleMeasure' for type 'eml:SolidAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__SolidAngleMeasure (332)
#endif

/* eml__ThermalConductanceMeasure has binding name 'eml__ThermalConductanceMeasure' for type 'eml:ThermalConductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalConductanceMeasure (331)
#endif

/* eml__TemperatureIntervalPerTimeMeasure has binding name 'eml__TemperatureIntervalPerTimeMeasure' for type 'eml:TemperatureIntervalPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerTimeMeasure (330)
#endif

/* eml__EnergyPerLengthMeasure has binding name 'eml__EnergyPerLengthMeasure' for type 'eml:EnergyPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyPerLengthMeasure (329)
#endif

/* eml__LinearThermalExpansionMeasure has binding name 'eml__LinearThermalExpansionMeasure' for type 'eml:LinearThermalExpansionMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearThermalExpansionMeasure (328)
#endif

/* eml__ForcePerForceMeasure has binding name 'eml__ForcePerForceMeasure' for type 'eml:ForcePerForceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForcePerForceMeasure (327)
#endif

/* eml__ReciprocalVolumeMeasure has binding name 'eml__ReciprocalVolumeMeasure' for type 'eml:ReciprocalVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalVolumeMeasure (326)
#endif

/* eml__ReciprocalMassTimeMeasure has binding name 'eml__ReciprocalMassTimeMeasure' for type 'eml:ReciprocalMassTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalMassTimeMeasure (325)
#endif

/* eml__TimePerLengthMeasure has binding name 'eml__TimePerLengthMeasure' for type 'eml:TimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TimePerLengthMeasure (324)
#endif

/* eml__AmountOfSubstanceMeasure has binding name 'eml__AmountOfSubstanceMeasure' for type 'eml:AmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstanceMeasure (323)
#endif

/* eml__AmountOfSubstancePerAreaMeasure has binding name 'eml__AmountOfSubstancePerAreaMeasure' for type 'eml:AmountOfSubstancePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerAreaMeasure (322)
#endif

/* eml__TemperatureIntervalPerLengthMeasure has binding name 'eml__TemperatureIntervalPerLengthMeasure' for type 'eml:TemperatureIntervalPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalPerLengthMeasure (321)
#endif

/* eml__MassPerVolumeMeasure has binding name 'eml__MassPerVolumeMeasure' for type 'eml:MassPerVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerVolumeMeasure (320)
#endif

/* eml__LengthMeasure has binding name 'eml__LengthMeasure' for type 'eml:LengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthMeasure (319)
#endif

/* eml__AreaPerAmountOfSubstanceMeasure has binding name 'eml__AreaPerAmountOfSubstanceMeasure' for type 'eml:AreaPerAmountOfSubstanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AreaPerAmountOfSubstanceMeasure (318)
#endif

/* eml__ReciprocalPressureMeasure has binding name 'eml__ReciprocalPressureMeasure' for type 'eml:ReciprocalPressureMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ReciprocalPressureMeasure (317)
#endif

/* eml__ElectricConductanceMeasure has binding name 'eml__ElectricConductanceMeasure' for type 'eml:ElectricConductanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ElectricConductanceMeasure (316)
#endif

/* eml__MolarVolumeMeasure has binding name 'eml__MolarVolumeMeasure' for type 'eml:MolarVolumeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MolarVolumeMeasure (315)
#endif

/* eml__VolumePerMassMeasure has binding name 'eml__VolumePerMassMeasure' for type 'eml:VolumePerMassMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerMassMeasure (314)
#endif

/* eml__MassPerTimeMeasure has binding name 'eml__MassPerTimeMeasure' for type 'eml:MassPerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MassPerTimeMeasure (313)
#endif

/* eml__HeatFlowRateMeasure has binding name 'eml__HeatFlowRateMeasure' for type 'eml:HeatFlowRateMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatFlowRateMeasure (312)
#endif

/* eml__VolumetricThermalExpansionMeasure has binding name 'eml__VolumetricThermalExpansionMeasure' for type 'eml:VolumetricThermalExpansionMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumetricThermalExpansionMeasure (311)
#endif

/* eml__MagneticFluxMeasure has binding name 'eml__MagneticFluxMeasure' for type 'eml:MagneticFluxMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticFluxMeasure (310)
#endif

/* eml__VolumePerTimeMeasure has binding name 'eml__VolumePerTimeMeasure' for type 'eml:VolumePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimeMeasure (309)
#endif

/* eml__LinearAccelerationMeasure has binding name 'eml__LinearAccelerationMeasure' for type 'eml:LinearAccelerationMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LinearAccelerationMeasure (308)
#endif

/* eml__MagneticVectorPotentialMeasure has binding name 'eml__MagneticVectorPotentialMeasure' for type 'eml:MagneticVectorPotentialMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__MagneticVectorPotentialMeasure (307)
#endif

/* eml__APINeutronMeasure has binding name 'eml__APINeutronMeasure' for type 'eml:APINeutronMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__APINeutronMeasure (306)
#endif

/* eml__HeatTransferCoefficientMeasure has binding name 'eml__HeatTransferCoefficientMeasure' for type 'eml:HeatTransferCoefficientMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__HeatTransferCoefficientMeasure (305)
#endif

/* eml__DimensionlessMeasure has binding name 'eml__DimensionlessMeasure' for type 'eml:DimensionlessMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DimensionlessMeasure (304)
#endif

/* eml__PowerPerPowerMeasure has binding name 'eml__PowerPerPowerMeasure' for type 'eml:PowerPerPowerMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PowerPerPowerMeasure (303)
#endif

/* eml__RadiantIntensityMeasure has binding name 'eml__RadiantIntensityMeasure' for type 'eml:RadiantIntensityMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__RadiantIntensityMeasure (302)
#endif

/* eml__ForceMeasure has binding name 'eml__ForceMeasure' for type 'eml:ForceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceMeasure (301)
#endif

/* eml__IlluminanceMeasure has binding name 'eml__IlluminanceMeasure' for type 'eml:IlluminanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__IlluminanceMeasure (300)
#endif

/* eml__EnergyMeasure has binding name 'eml__EnergyMeasure' for type 'eml:EnergyMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__EnergyMeasure (299)
#endif

/* eml__ForceAreaMeasure has binding name 'eml__ForceAreaMeasure' for type 'eml:ForceAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceAreaMeasure (298)
#endif

/* eml__ThermalInsulanceMeasure has binding name 'eml__ThermalInsulanceMeasure' for type 'eml:ThermalInsulanceMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ThermalInsulanceMeasure (297)
#endif

/* eml__PermeabilityLengthMeasure has binding name 'eml__PermeabilityLengthMeasure' for type 'eml:PermeabilityLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PermeabilityLengthMeasure (296)
#endif

/* eml__VolumePerTimePerTimeMeasure has binding name 'eml__VolumePerTimePerTimeMeasure' for type 'eml:VolumePerTimePerTimeMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerTimeMeasure (295)
#endif

/* eml__VolumePerTimePerLengthMeasure has binding name 'eml__VolumePerTimePerLengthMeasure' for type 'eml:VolumePerTimePerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerLengthMeasure (294)
#endif

/* eml__TemperatureIntervalMeasure has binding name 'eml__TemperatureIntervalMeasure' for type 'eml:TemperatureIntervalMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__TemperatureIntervalMeasure (293)
#endif

/* eml__LengthPerLengthMeasure has binding name 'eml__LengthPerLengthMeasure' for type 'eml:LengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__LengthPerLengthMeasure (292)
#endif

/* eml__VolumePerTimePerAreaMeasure has binding name 'eml__VolumePerTimePerAreaMeasure' for type 'eml:VolumePerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VolumePerTimePerAreaMeasure (291)
#endif

/* eml__AmountOfSubstancePerTimePerAreaMeasure has binding name 'eml__AmountOfSubstancePerTimePerAreaMeasure' for type 'eml:AmountOfSubstancePerTimePerAreaMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AmountOfSubstancePerTimePerAreaMeasure (290)
#endif

/* eml__ForceLengthPerLengthMeasure has binding name 'eml__ForceLengthPerLengthMeasure' for type 'eml:ForceLengthPerLengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ForceLengthPerLengthMeasure (289)
#endif

/* eml__PressureSquaredMeasure has binding name 'eml__PressureSquaredMeasure' for type 'eml:PressureSquaredMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__PressureSquaredMeasure (288)
#endif

/* eml__DataObjectReference has binding name 'eml__DataObjectReference' for type 'eml:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__DataObjectReference
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__DataObjectReference (287)
#endif

/* eml__obj_USCOREEpcExternalPartReference has binding name 'eml__obj_USCOREEpcExternalPartReference' for type 'eml:obj_EpcExternalPartReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__obj_USCOREEpcExternalPartReference
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__obj_USCOREEpcExternalPartReference (286)
#endif

/* eml__Hdf5Dataset has binding name 'eml__Hdf5Dataset' for type 'eml:Hdf5Dataset' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__Hdf5Dataset
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__Hdf5Dataset (285)
#endif

/* eml__ProjectedUnknownCrs has binding name 'eml__ProjectedUnknownCrs' for type 'eml:ProjectedUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedUnknownCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedUnknownCrs (284)
#endif

/* eml__GmlProjectedCrsDefinition has binding name 'eml__GmlProjectedCrsDefinition' for type 'eml:GmlProjectedCrsDefinition' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlProjectedCrsDefinition
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlProjectedCrsDefinition (283)
#endif

/* eml__ProjectedCrsEpsgCode has binding name 'eml__ProjectedCrsEpsgCode' for type 'eml:ProjectedCrsEpsgCode' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrsEpsgCode
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrsEpsgCode (282)
#endif

/* eml__AbstractProjectedCrs has binding name 'eml__AbstractProjectedCrs' for type 'eml:AbstractProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractProjectedCrs (281)
#endif

/* eml__AbstractVerticalCrs has binding name 'eml__AbstractVerticalCrs' for type 'eml:AbstractVerticalCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractVerticalCrs (280)
#endif

/* eml__VerticalCrs has binding name 'eml__VerticalCrs' for type 'eml:VerticalCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrs (279)
#endif

/* eml__ProjectedCrs has binding name 'eml__ProjectedCrs' for type 'eml:ProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ProjectedCrs (278)
#endif

/* eml__VerticalUnknownCrs has binding name 'eml__VerticalUnknownCrs' for type 'eml:VerticalUnknownCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalUnknownCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalUnknownCrs (277)
#endif

/* eml__GmlVerticalCrsDefinition has binding name 'eml__GmlVerticalCrsDefinition' for type 'eml:GmlVerticalCrsDefinition' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlVerticalCrsDefinition
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__GmlVerticalCrsDefinition (276)
#endif

/* eml__VerticalCrsEpsgCode has binding name 'eml__VerticalCrsEpsgCode' for type 'eml:VerticalCrsEpsgCode' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrsEpsgCode
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__VerticalCrsEpsgCode (275)
#endif

/* eml__ObjectAlias has binding name 'eml__ObjectAlias' for type 'eml:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__ObjectAlias
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__ObjectAlias (274)
#endif

/* eml__AbstractObject has binding name 'eml__AbstractObject' for type 'eml:AbstractObject' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractObject
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractObject (273)
#endif

/* eml__Citation has binding name 'eml__Citation' for type 'eml:Citation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__Citation
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__Citation (272)
#endif

/* eml__CustomData has binding name 'eml__CustomData' for type 'eml:CustomData' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__CustomData
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__CustomData (271)
#endif

/* eml__AbstractCitedDataObject has binding name 'eml__AbstractCitedDataObject' for type 'eml:AbstractCitedDataObject' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractCitedDataObject
#define SOAP_TYPE_gsoap_resqml2_0_1_eml__AbstractCitedDataObject (270)
#endif

/* resqml2__obj_USCOREDiscretePropertySeries has binding name 'resqml2__obj_USCOREDiscretePropertySeries' for type 'resqml2:obj_DiscretePropertySeries' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscretePropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscretePropertySeries (269)
#endif

/* resqml2__obj_USCORECommentPropertySeries has binding name 'resqml2__obj_USCORECommentPropertySeries' for type 'resqml2:obj_CommentPropertySeries' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentPropertySeries (268)
#endif

/* resqml2__obj_USCORECategoricalPropertySeries has binding name 'resqml2__obj_USCORECategoricalPropertySeries' for type 'resqml2:obj_CategoricalPropertySeries' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalPropertySeries (267)
#endif

/* resqml2__obj_USCOREContinuousPropertySeries has binding name 'resqml2__obj_USCOREContinuousPropertySeries' for type 'resqml2:obj_ContinuousPropertySeries' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousPropertySeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousPropertySeries (266)
#endif

/* resqml2__TimeIndices has binding name 'resqml2__TimeIndices' for type 'resqml2:TimeIndices' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndices
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndices (265)
#endif

/* resqml2__IntervalGridCells has binding name 'resqml2__IntervalGridCells' for type 'resqml2:IntervalGridCells' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalGridCells
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalGridCells (264)
#endif

/* resqml2__StreamlineWellbores has binding name 'resqml2__StreamlineWellbores' for type 'resqml2:StreamlineWellbores' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineWellbores
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlineWellbores (263)
#endif

/* resqml2__obj_USCOREStreamlinesRepresentation has binding name 'resqml2__obj_USCOREStreamlinesRepresentation' for type 'resqml2:obj_StreamlinesRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesRepresentation (262)
#endif

/* resqml2__obj_USCOREStreamlinesFeature has binding name 'resqml2__obj_USCOREStreamlinesFeature' for type 'resqml2:obj_StreamlinesFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStreamlinesFeature (261)
#endif

/* resqml2__StreamlinePolylineSetPatch has binding name 'resqml2__StreamlinePolylineSetPatch' for type 'resqml2:StreamlinePolylineSetPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlinePolylineSetPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StreamlinePolylineSetPatch (260)
#endif

/* resqml2__obj_USCOREActivityTemplate has binding name 'resqml2__obj_USCOREActivityTemplate' for type 'resqml2:obj_ActivityTemplate' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivityTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivityTemplate (259)
#endif

/* resqml2__AbstractActivityParameter has binding name 'resqml2__AbstractActivityParameter' for type 'resqml2:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractActivityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractActivityParameter (258)
#endif

/* resqml2__TimeIndexParameter has binding name 'resqml2__TimeIndexParameter' for type 'resqml2:TimeIndexParameter' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameter (257)
#endif

/* resqml2__AbstractParameterKey has binding name 'resqml2__AbstractParameterKey' for type 'resqml2:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParameterKey (256)
#endif

/* resqml2__FloatingPointQuantityParameter has binding name 'resqml2__FloatingPointQuantityParameter' for type 'resqml2:FloatingPointQuantityParameter' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FloatingPointQuantityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FloatingPointQuantityParameter (255)
#endif

/* resqml2__TimeIndexParameterKey has binding name 'resqml2__TimeIndexParameterKey' for type 'resqml2:TimeIndexParameterKey' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndexParameterKey (254)
#endif

/* resqml2__IntegerQuantityParameter has binding name 'resqml2__IntegerQuantityParameter' for type 'resqml2:IntegerQuantityParameter' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerQuantityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerQuantityParameter (253)
#endif

/* resqml2__ParameterTemplate has binding name 'resqml2__ParameterTemplate' for type 'resqml2:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParameterTemplate (252)
#endif

/* resqml2__StringParameter has binding name 'resqml2__StringParameter' for type 'resqml2:StringParameter' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringParameter (251)
#endif

/* resqml2__obj_USCOREActivity has binding name 'resqml2__obj_USCOREActivity' for type 'resqml2:obj_Activity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREActivity (250)
#endif

/* resqml2__ObjectParameterKey has binding name 'resqml2__ObjectParameterKey' for type 'resqml2:ObjectParameterKey' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ObjectParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ObjectParameterKey (249)
#endif

/* resqml2__DataObjectParameter has binding name 'resqml2__DataObjectParameter' for type 'resqml2:DataObjectParameter' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DataObjectParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DataObjectParameter (248)
#endif

/* resqml2__WitsmlWellboreReference has binding name 'resqml2__WitsmlWellboreReference' for type 'resqml2:WitsmlWellboreReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WitsmlWellboreReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WitsmlWellboreReference (247)
#endif

/* resqml2__AbstractSeismicSurveyFeature has binding name 'resqml2__AbstractSeismicSurveyFeature' for type 'resqml2:AbstractSeismicSurveyFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicSurveyFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicSurveyFeature (246)
#endif

/* resqml2__obj_USCORESeismicLatticeFeature has binding name 'resqml2__obj_USCORESeismicLatticeFeature' for type 'resqml2:obj_SeismicLatticeFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLatticeFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLatticeFeature (245)
#endif

/* resqml2__obj_USCORESeismicLineFeature has binding name 'resqml2__obj_USCORESeismicLineFeature' for type 'resqml2:obj_SeismicLineFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineFeature (244)
#endif

/* resqml2__obj_USCOREWellboreFeature has binding name 'resqml2__obj_USCOREWellboreFeature' for type 'resqml2:obj_WellboreFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFeature (243)
#endif

/* resqml2__obj_USCORESeismicLineSetFeature has binding name 'resqml2__obj_USCORESeismicLineSetFeature' for type 'resqml2:obj_SeismicLineSetFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESeismicLineSetFeature (242)
#endif

/* resqml2__SeismicLatticeSetFeature has binding name 'resqml2__SeismicLatticeSetFeature' for type 'resqml2:SeismicLatticeSetFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SeismicLatticeSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SeismicLatticeSetFeature (241)
#endif

/* resqml2__obj_USCOREFrontierFeature has binding name 'resqml2__obj_USCOREFrontierFeature' for type 'resqml2:obj_FrontierFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFrontierFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFrontierFeature (240)
#endif

/* resqml2__AbstractTechnicalFeature has binding name 'resqml2__AbstractTechnicalFeature' for type 'resqml2:AbstractTechnicalFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTechnicalFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTechnicalFeature (239)
#endif

/* resqml2__ContactRepresentationReference has binding name 'resqml2__ContactRepresentationReference' for type 'resqml2:ContactRepresentationReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRepresentationReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactRepresentationReference (238)
#endif

/* resqml2__ContactIdentity has binding name 'resqml2__ContactIdentity' for type 'resqml2:ContactIdentity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactIdentity (237)
#endif

/* resqml2__OrientedMacroFace has binding name 'resqml2__OrientedMacroFace' for type 'resqml2:OrientedMacroFace' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrientedMacroFace
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OrientedMacroFace (236)
#endif

/* resqml2__PolylineSetPatch has binding name 'resqml2__PolylineSetPatch' for type 'resqml2:PolylineSetPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PolylineSetPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PolylineSetPatch (235)
#endif

/* resqml2__obj_USCOREGrid2dSetRepresentation has binding name 'resqml2__obj_USCOREGrid2dSetRepresentation' for type 'resqml2:obj_Grid2dSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dSetRepresentation (234)
#endif

/* resqml2__Grid2dPatch has binding name 'resqml2__Grid2dPatch' for type 'resqml2:Grid2dPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Grid2dPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Grid2dPatch (233)
#endif

/* resqml2__AbstractSurfaceRepresentation has binding name 'resqml2__AbstractSurfaceRepresentation' for type 'resqml2:AbstractSurfaceRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceRepresentation (232)
#endif

/* resqml2__PatchBoundaries has binding name 'resqml2__PatchBoundaries' for type 'resqml2:PatchBoundaries' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchBoundaries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchBoundaries (231)
#endif

/* resqml2__obj_USCOREGrid2dRepresentation has binding name 'resqml2__obj_USCOREGrid2dRepresentation' for type 'resqml2:obj_Grid2dRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGrid2dRepresentation (230)
#endif

/* resqml2__obj_USCOREPolylineRepresentation has binding name 'resqml2__obj_USCOREPolylineRepresentation' for type 'resqml2:obj_PolylineRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineRepresentation (229)
#endif

/* resqml2__TrianglePatch has binding name 'resqml2__TrianglePatch' for type 'resqml2:TrianglePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TrianglePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TrianglePatch (228)
#endif

/* resqml2__obj_USCORESealedSurfaceFrameworkRepresentation has binding name 'resqml2__obj_USCORESealedSurfaceFrameworkRepresentation' for type 'resqml2:obj_SealedSurfaceFrameworkRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedSurfaceFrameworkRepresentation (227)
#endif

/* resqml2__NodePatch has binding name 'resqml2__NodePatch' for type 'resqml2:NodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodePatch (226)
#endif

/* resqml2__obj_USCOREPolylineSetRepresentation has binding name 'resqml2__obj_USCOREPolylineSetRepresentation' for type 'resqml2:obj_PolylineSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPolylineSetRepresentation (225)
#endif

/* resqml2__VolumeShell has binding name 'resqml2__VolumeShell' for type 'resqml2:VolumeShell' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeShell
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeShell (224)
#endif

/* resqml2__VolumeRegion has binding name 'resqml2__VolumeRegion' for type 'resqml2:VolumeRegion' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeRegion
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VolumeRegion (223)
#endif

/* resqml2__EdgePatch has binding name 'resqml2__EdgePatch' for type 'resqml2:EdgePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__EdgePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__EdgePatch (222)
#endif

/* resqml2__obj_USCORESealedVolumeFrameworkRepresentation has binding name 'resqml2__obj_USCORESealedVolumeFrameworkRepresentation' for type 'resqml2:obj_SealedVolumeFrameworkRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedVolumeFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESealedVolumeFrameworkRepresentation (221)
#endif

/* resqml2__obj_USCOREPointSetRepresentation has binding name 'resqml2__obj_USCOREPointSetRepresentation' for type 'resqml2:obj_PointSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointSetRepresentation (220)
#endif

/* resqml2__AbstractSurfaceFrameworkRepresentation has binding name 'resqml2__AbstractSurfaceFrameworkRepresentation' for type 'resqml2:AbstractSurfaceFrameworkRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSurfaceFrameworkRepresentation (219)
#endif

/* resqml2__AbstractContactRepresentationPart has binding name 'resqml2__AbstractContactRepresentationPart' for type 'resqml2:AbstractContactRepresentationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactRepresentationPart (218)
#endif

/* resqml2__obj_USCOREPlaneSetRepresentation has binding name 'resqml2__obj_USCOREPlaneSetRepresentation' for type 'resqml2:obj_PlaneSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPlaneSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPlaneSetRepresentation (217)
#endif

/* resqml2__ContactPatch has binding name 'resqml2__ContactPatch' for type 'resqml2:ContactPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactPatch (216)
#endif

/* resqml2__SealedContactRepresentationPart has binding name 'resqml2__SealedContactRepresentationPart' for type 'resqml2:SealedContactRepresentationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SealedContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SealedContactRepresentationPart (215)
#endif

/* resqml2__NonSealedContactRepresentationPart has binding name 'resqml2__NonSealedContactRepresentationPart' for type 'resqml2:NonSealedContactRepresentationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NonSealedContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NonSealedContactRepresentationPart (214)
#endif

/* resqml2__obj_USCORETriangulatedSetRepresentation has binding name 'resqml2__obj_USCORETriangulatedSetRepresentation' for type 'resqml2:obj_TriangulatedSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETriangulatedSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETriangulatedSetRepresentation (213)
#endif

/* resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation has binding name 'resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation' for type 'resqml2:obj_NonSealedSurfaceFrameworkRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORENonSealedSurfaceFrameworkRepresentation (212)
#endif

/* resqml2__obj_USCOREWellboreMarkerFrameRepresentation has binding name 'resqml2__obj_USCOREWellboreMarkerFrameRepresentation' for type 'resqml2:obj_WellboreMarkerFrameRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreMarkerFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreMarkerFrameRepresentation (211)
#endif

/* resqml2__WellboreMarker has binding name 'resqml2__WellboreMarker' for type 'resqml2:WellboreMarker' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreMarker
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreMarker (210)
#endif

/* resqml2__obj_USCOREMdDatum has binding name 'resqml2__obj_USCOREMdDatum' for type 'resqml2:obj_MdDatum' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREMdDatum
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREMdDatum (209)
#endif

/* resqml2__obj_USCOREWellboreTrajectoryRepresentation has binding name 'resqml2__obj_USCOREWellboreTrajectoryRepresentation' for type 'resqml2:obj_WellboreTrajectoryRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreTrajectoryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreTrajectoryRepresentation (208)
#endif

/* resqml2__obj_USCOREWellboreFrameRepresentation has binding name 'resqml2__obj_USCOREWellboreFrameRepresentation' for type 'resqml2:obj_WellboreFrameRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFrameRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreFrameRepresentation (207)
#endif

/* resqml2__obj_USCOREDeviationSurveyRepresentation has binding name 'resqml2__obj_USCOREDeviationSurveyRepresentation' for type 'resqml2:obj_DeviationSurveyRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDeviationSurveyRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDeviationSurveyRepresentation (206)
#endif

/* resqml2__WellboreTrajectoryParentIntersection has binding name 'resqml2__WellboreTrajectoryParentIntersection' for type 'resqml2:WellboreTrajectoryParentIntersection' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreTrajectoryParentIntersection
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__WellboreTrajectoryParentIntersection (205)
#endif

/* resqml2__obj_USCOREBlockedWellboreRepresentation has binding name 'resqml2__obj_USCOREBlockedWellboreRepresentation' for type 'resqml2:obj_BlockedWellboreRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBlockedWellboreRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBlockedWellboreRepresentation (204)
#endif

/* resqml2__AbstractResqmlDataObject has binding name 'resqml2__AbstractResqmlDataObject' for type 'resqml2:AbstractResqmlDataObject' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractResqmlDataObject
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractResqmlDataObject (203)
#endif

/* resqml2__obj_USCORETimeSeries has binding name 'resqml2__obj_USCORETimeSeries' for type 'resqml2:obj_TimeSeries' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETimeSeries
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETimeSeries (202)
#endif

/* resqml2__obj_USCORELocalDepth3dCrs has binding name 'resqml2__obj_USCORELocalDepth3dCrs' for type 'resqml2:obj_LocalDepth3dCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalDepth3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalDepth3dCrs (201)
#endif

/* resqml2__NameValuePair has binding name 'resqml2__NameValuePair' for type 'resqml2:NameValuePair' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NameValuePair
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NameValuePair (200)
#endif

/* resqml2__ResqmlJaggedArray has binding name 'resqml2__ResqmlJaggedArray' for type 'resqml2:ResqmlJaggedArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlJaggedArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ResqmlJaggedArray (199)
#endif

/* resqml2__AbstractLocal3dCrs has binding name 'resqml2__AbstractLocal3dCrs' for type 'resqml2:AbstractLocal3dCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractLocal3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractLocal3dCrs (198)
#endif

/* resqml2__Timestamp has binding name 'resqml2__Timestamp' for type 'resqml2:Timestamp' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Timestamp
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Timestamp (197)
#endif

/* resqml2__TimeIndex has binding name 'resqml2__TimeIndex' for type 'resqml2:TimeIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeIndex (196)
#endif

/* resqml2__obj_USCORELocalTime3dCrs has binding name 'resqml2__obj_USCORELocalTime3dCrs' for type 'resqml2:obj_LocalTime3dCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalTime3dCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalTime3dCrs (195)
#endif

/* resqml2__TimeSeriesParentage has binding name 'resqml2__TimeSeriesParentage' for type 'resqml2:TimeSeriesParentage' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSeriesParentage
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeSeriesParentage (194)
#endif

/* resqml2__Point3d has binding name 'resqml2__Point3d' for type 'resqml2:Point3d' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3d
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3d (193)
#endif

/* resqml2__AbstractFeature has binding name 'resqml2__AbstractFeature' for type 'resqml2:AbstractFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeature (192)
#endif

/* resqml2__obj_USCORETectonicBoundaryFeature has binding name 'resqml2__obj_USCORETectonicBoundaryFeature' for type 'resqml2:obj_TectonicBoundaryFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETectonicBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETectonicBoundaryFeature (191)
#endif

/* resqml2__obj_USCOREOrganizationFeature has binding name 'resqml2__obj_USCOREOrganizationFeature' for type 'resqml2:obj_OrganizationFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREOrganizationFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREOrganizationFeature (190)
#endif

/* resqml2__obj_USCOREGeobodyFeature has binding name 'resqml2__obj_USCOREGeobodyFeature' for type 'resqml2:obj_GeobodyFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyFeature (189)
#endif

/* resqml2__obj_USCOREGeneticBoundaryFeature has binding name 'resqml2__obj_USCOREGeneticBoundaryFeature' for type 'resqml2:obj_GeneticBoundaryFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeneticBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeneticBoundaryFeature (188)
#endif

/* resqml2__AbstractGeologicFeature has binding name 'resqml2__AbstractGeologicFeature' for type 'resqml2:AbstractGeologicFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeologicFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeologicFeature (187)
#endif

/* resqml2__obj_USCOREStratigraphicUnitFeature has binding name 'resqml2__obj_USCOREStratigraphicUnitFeature' for type 'resqml2:obj_StratigraphicUnitFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitFeature (186)
#endif

/* resqml2__obj_USCOREGlobalChronostratigraphicColumn has binding name 'resqml2__obj_USCOREGlobalChronostratigraphicColumn' for type 'resqml2:obj_GlobalChronostratigraphicColumn' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGlobalChronostratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGlobalChronostratigraphicColumn (185)
#endif

/* resqml2__ChronostratigraphicRank has binding name 'resqml2__ChronostratigraphicRank' for type 'resqml2:ChronostratigraphicRank' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ChronostratigraphicRank
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ChronostratigraphicRank (184)
#endif

/* resqml2__obj_USCOREBoundaryFeature has binding name 'resqml2__obj_USCOREBoundaryFeature' for type 'resqml2:obj_BoundaryFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeature (183)
#endif

/* resqml2__obj_USCORERockFluidUnitFeature has binding name 'resqml2__obj_USCORERockFluidUnitFeature' for type 'resqml2:obj_RockFluidUnitFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitFeature (182)
#endif

/* resqml2__obj_USCOREGeologicUnitFeature has binding name 'resqml2__obj_USCOREGeologicUnitFeature' for type 'resqml2:obj_GeologicUnitFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitFeature (181)
#endif

/* resqml2__obj_USCOREFluidBoundaryFeature has binding name 'resqml2__obj_USCOREFluidBoundaryFeature' for type 'resqml2:obj_FluidBoundaryFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFluidBoundaryFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFluidBoundaryFeature (180)
#endif

/* resqml2__obj_USCOREStratigraphicOccurrenceInterpretation has binding name 'resqml2__obj_USCOREStratigraphicOccurrenceInterpretation' for type 'resqml2:obj_StratigraphicOccurrenceInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicOccurrenceInterpretation (179)
#endif

/* resqml2__obj_USCOREStratigraphicUnitInterpretation has binding name 'resqml2__obj_USCOREStratigraphicUnitInterpretation' for type 'resqml2:obj_StratigraphicUnitInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicUnitInterpretation (178)
#endif

/* resqml2__obj_USCOREGeologicUnitInterpretation has binding name 'resqml2__obj_USCOREGeologicUnitInterpretation' for type 'resqml2:obj_GeologicUnitInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeologicUnitInterpretation (177)
#endif

/* resqml2__obj_USCOREHorizonInterpretation has binding name 'resqml2__obj_USCOREHorizonInterpretation' for type 'resqml2:obj_HorizonInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREHorizonInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREHorizonInterpretation (176)
#endif

/* resqml2__RockFluidUnitInterpretationIndex has binding name 'resqml2__RockFluidUnitInterpretationIndex' for type 'resqml2:RockFluidUnitInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RockFluidUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RockFluidUnitInterpretationIndex (175)
#endif

/* resqml2__AbstractStratigraphicOrganizationInterpretation has binding name 'resqml2__AbstractStratigraphicOrganizationInterpretation' for type 'resqml2:AbstractStratigraphicOrganizationInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractStratigraphicOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractStratigraphicOrganizationInterpretation (174)
#endif

/* resqml2__obj_USCOREStratigraphicColumnRankInterpretation has binding name 'resqml2__obj_USCOREStratigraphicColumnRankInterpretation' for type 'resqml2:obj_StratigraphicColumnRankInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumnRankInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumnRankInterpretation (173)
#endif

/* resqml2__FaultThrow has binding name 'resqml2__FaultThrow' for type 'resqml2:FaultThrow' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FaultThrow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__FaultThrow (172)
#endif

/* resqml2__obj_USCOREEarthModelInterpretation has binding name 'resqml2__obj_USCOREEarthModelInterpretation' for type 'resqml2:obj_EarthModelInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREEarthModelInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREEarthModelInterpretation (171)
#endif

/* resqml2__AbstractContactInterpretationPart has binding name 'resqml2__AbstractContactInterpretationPart' for type 'resqml2:AbstractContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractContactInterpretationPart (170)
#endif

/* resqml2__obj_USCOREBoundaryFeatureInterpretation has binding name 'resqml2__obj_USCOREBoundaryFeatureInterpretation' for type 'resqml2:obj_BoundaryFeatureInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREBoundaryFeatureInterpretation (169)
#endif

/* resqml2__obj_USCOREGeobodyInterpretation has binding name 'resqml2__obj_USCOREGeobodyInterpretation' for type 'resqml2:obj_GeobodyInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyInterpretation (168)
#endif

/* resqml2__obj_USCOREStratigraphicColumn has binding name 'resqml2__obj_USCOREStratigraphicColumn' for type 'resqml2:obj_StratigraphicColumn' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumn
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStratigraphicColumn (167)
#endif

/* resqml2__obj_USCOREFaultInterpretation has binding name 'resqml2__obj_USCOREFaultInterpretation' for type 'resqml2:obj_FaultInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFaultInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREFaultInterpretation (166)
#endif

/* resqml2__HorizonInterpretationIndex has binding name 'resqml2__HorizonInterpretationIndex' for type 'resqml2:HorizonInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizonInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizonInterpretationIndex (165)
#endif

/* resqml2__MultipleContactInterpretationPart has binding name 'resqml2__MultipleContactInterpretationPart' for type 'resqml2:MultipleContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MultipleContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__MultipleContactInterpretationPart (164)
#endif

/* resqml2__obj_USCOREStructuralOrganizationInterpretation has binding name 'resqml2__obj_USCOREStructuralOrganizationInterpretation' for type 'resqml2:obj_StructuralOrganizationInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStructuralOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStructuralOrganizationInterpretation (163)
#endif

/* resqml2__obj_USCOREGeobodyBoundaryInterpretation has binding name 'resqml2__obj_USCOREGeobodyBoundaryInterpretation' for type 'resqml2:obj_GeobodyBoundaryInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyBoundaryInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGeobodyBoundaryInterpretation (162)
#endif

/* resqml2__GeologicUnitInterpretationIndex has binding name 'resqml2__GeologicUnitInterpretationIndex' for type 'resqml2:GeologicUnitInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GeologicUnitInterpretationIndex (161)
#endif

/* resqml2__obj_USCOREWellboreInterpretation has binding name 'resqml2__obj_USCOREWellboreInterpretation' for type 'resqml2:obj_WellboreInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREWellboreInterpretation (160)
#endif

/* resqml2__obj_USCOREGenericFeatureInterpretation has binding name 'resqml2__obj_USCOREGenericFeatureInterpretation' for type 'resqml2:obj_GenericFeatureInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGenericFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGenericFeatureInterpretation (159)
#endif

/* resqml2__obj_USCORERockFluidUnitInterpretation has binding name 'resqml2__obj_USCORERockFluidUnitInterpretation' for type 'resqml2:obj_RockFluidUnitInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidUnitInterpretation (158)
#endif

/* resqml2__ContactElementReference has binding name 'resqml2__ContactElementReference' for type 'resqml2:ContactElementReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactElementReference
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ContactElementReference (157)
#endif

/* resqml2__StratigraphicUnitInterpretationIndex has binding name 'resqml2__StratigraphicUnitInterpretationIndex' for type 'resqml2:StratigraphicUnitInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StratigraphicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StratigraphicUnitInterpretationIndex (156)
#endif

/* resqml2__BinaryContactInterpretationPart has binding name 'resqml2__BinaryContactInterpretationPart' for type 'resqml2:BinaryContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BinaryContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BinaryContactInterpretationPart (155)
#endif

/* resqml2__AbstractOrganizationInterpretation has binding name 'resqml2__AbstractOrganizationInterpretation' for type 'resqml2:AbstractOrganizationInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractOrganizationInterpretation (154)
#endif

/* resqml2__TimeInterval has binding name 'resqml2__TimeInterval' for type 'resqml2:TimeInterval' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeInterval
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TimeInterval (153)
#endif

/* resqml2__obj_USCORERockFluidOrganizationInterpretation has binding name 'resqml2__obj_USCORERockFluidOrganizationInterpretation' for type 'resqml2:obj_RockFluidOrganizationInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidOrganizationInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERockFluidOrganizationInterpretation (152)
#endif

/* resqml2__AbstractFeatureInterpretation has binding name 'resqml2__AbstractFeatureInterpretation' for type 'resqml2:AbstractFeatureInterpretation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeatureInterpretation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractFeatureInterpretation (151)
#endif

/* resqml2__AbstractParentWindow has binding name 'resqml2__AbstractParentWindow' for type 'resqml2:AbstractParentWindow' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParentWindow (150)
#endif

/* resqml2__AbstractColumnLayerGridGeometry has binding name 'resqml2__AbstractColumnLayerGridGeometry' for type 'resqml2:AbstractColumnLayerGridGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridGeometry (149)
#endif

/* resqml2__Intervals has binding name 'resqml2__Intervals' for type 'resqml2:Intervals' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Intervals
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Intervals (148)
#endif

/* resqml2__OverlapVolume has binding name 'resqml2__OverlapVolume' for type 'resqml2:OverlapVolume' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OverlapVolume
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__OverlapVolume (147)
#endif

/* resqml2__VariableSubnodePatch has binding name 'resqml2__VariableSubnodePatch' for type 'resqml2:VariableSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VariableSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__VariableSubnodePatch (146)
#endif

/* resqml2__ColumnLayerSplitColumnEdges has binding name 'resqml2__ColumnLayerSplitColumnEdges' for type 'resqml2:ColumnLayerSplitColumnEdges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitColumnEdges (145)
#endif

/* resqml2__CellOverlap has binding name 'resqml2__CellOverlap' for type 'resqml2:CellOverlap' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellOverlap
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellOverlap (144)
#endif

/* resqml2__UnstructuredGridHingeNodeFaces has binding name 'resqml2__UnstructuredGridHingeNodeFaces' for type 'resqml2:UnstructuredGridHingeNodeFaces' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridHingeNodeFaces
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridHingeNodeFaces (143)
#endif

/* resqml2__AbstractGridGeometry has binding name 'resqml2__AbstractGridGeometry' for type 'resqml2:AbstractGridGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridGeometry (142)
#endif

/* resqml2__obj_USCOREGridConnectionSetRepresentation has binding name 'resqml2__obj_USCOREGridConnectionSetRepresentation' for type 'resqml2:obj_GridConnectionSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGridConnectionSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGridConnectionSetRepresentation (141)
#endif

/* resqml2__obj_USCORETruncatedIjkGridRepresentation has binding name 'resqml2__obj_USCORETruncatedIjkGridRepresentation' for type 'resqml2:obj_TruncatedIjkGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedIjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedIjkGridRepresentation (140)
#endif

/* resqml2__GpGridIjkGridPatch has binding name 'resqml2__GpGridIjkGridPatch' for type 'resqml2:GpGridIjkGridPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridIjkGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridIjkGridPatch (139)
#endif

/* resqml2__AbstractColumnLayerGridRepresentation has binding name 'resqml2__AbstractColumnLayerGridRepresentation' for type 'resqml2:AbstractColumnLayerGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractColumnLayerGridRepresentation (138)
#endif

/* resqml2__CellParentWindow has binding name 'resqml2__CellParentWindow' for type 'resqml2:CellParentWindow' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellParentWindow (137)
#endif

/* resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation has binding name 'resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation' for type 'resqml2:obj_TruncatedUnstructuredColumnLayerGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORETruncatedUnstructuredColumnLayerGridRepresentation (136)
#endif

/* resqml2__Edges has binding name 'resqml2__Edges' for type 'resqml2:Edges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Edges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Edges (135)
#endif

/* resqml2__UnstructuredGridGeometry has binding name 'resqml2__UnstructuredGridGeometry' for type 'resqml2:UnstructuredGridGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredGridGeometry (134)
#endif

/* resqml2__NodesPerCell has binding name 'resqml2__NodesPerCell' for type 'resqml2:NodesPerCell' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodesPerCell
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__NodesPerCell (133)
#endif

/* resqml2__CellFluidPhaseUnits has binding name 'resqml2__CellFluidPhaseUnits' for type 'resqml2:CellFluidPhaseUnits' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellFluidPhaseUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellFluidPhaseUnits (132)
#endif

/* resqml2__SplitEdges has binding name 'resqml2__SplitEdges' for type 'resqml2:SplitEdges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitEdges (131)
#endif

/* resqml2__AbstractTruncatedColumnLayerGridRepresentation has binding name 'resqml2__AbstractTruncatedColumnLayerGridRepresentation' for type 'resqml2:AbstractTruncatedColumnLayerGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTruncatedColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractTruncatedColumnLayerGridRepresentation (130)
#endif

/* resqml2__ConnectionInterpretations has binding name 'resqml2__ConnectionInterpretations' for type 'resqml2:ConnectionInterpretations' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ConnectionInterpretations
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ConnectionInterpretations (129)
#endif

/* resqml2__IjkGridGeometry has binding name 'resqml2__IjkGridGeometry' for type 'resqml2:IjkGridGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkGridGeometry (128)
#endif

/* resqml2__UnstructuredColumnLayerGridGeometry has binding name 'resqml2__UnstructuredColumnLayerGridGeometry' for type 'resqml2:UnstructuredColumnLayerGridGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnLayerGridGeometry (127)
#endif

/* resqml2__Activation has binding name 'resqml2__Activation' for type 'resqml2:Activation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Activation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Activation (126)
#endif

/* resqml2__Regrid has binding name 'resqml2__Regrid' for type 'resqml2:Regrid' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Regrid
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Regrid (125)
#endif

/* resqml2__IntervalStratigraphicUnits has binding name 'resqml2__IntervalStratigraphicUnits' for type 'resqml2:IntervalStratigraphicUnits' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalStratigraphicUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntervalStratigraphicUnits (124)
#endif

/* resqml2__GpGridUnstructuredGridPatch has binding name 'resqml2__GpGridUnstructuredGridPatch' for type 'resqml2:GpGridUnstructuredGridPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredGridPatch (123)
#endif

/* resqml2__TruncationCellPatch has binding name 'resqml2__TruncationCellPatch' for type 'resqml2:TruncationCellPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TruncationCellPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TruncationCellPatch (122)
#endif

/* resqml2__IjSplitColumnEdges has binding name 'resqml2__IjSplitColumnEdges' for type 'resqml2:IjSplitColumnEdges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjSplitColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjSplitColumnEdges (121)
#endif

/* resqml2__AdditionalGridPoints has binding name 'resqml2__AdditionalGridPoints' for type 'resqml2:AdditionalGridPoints' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridPoints (120)
#endif

/* resqml2__UnstructuredColumnEdges has binding name 'resqml2__UnstructuredColumnEdges' for type 'resqml2:UnstructuredColumnEdges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredColumnEdges (119)
#endif

/* resqml2__ColumnLayerSubnodeTopology has binding name 'resqml2__ColumnLayerSubnodeTopology' for type 'resqml2:ColumnLayerSubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSubnodeTopology (118)
#endif

/* resqml2__SubnodePatch has binding name 'resqml2__SubnodePatch' for type 'resqml2:SubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodePatch (117)
#endif

/* resqml2__KGaps has binding name 'resqml2__KGaps' for type 'resqml2:KGaps' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KGaps
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__KGaps (116)
#endif

/* resqml2__UniformSubnodePatch has binding name 'resqml2__UniformSubnodePatch' for type 'resqml2:UniformSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UniformSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UniformSubnodePatch (115)
#endif

/* resqml2__ColumnLayerSplitCoordinateLines has binding name 'resqml2__ColumnLayerSplitCoordinateLines' for type 'resqml2:ColumnLayerSplitCoordinateLines' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitCoordinateLines
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerSplitCoordinateLines (114)
#endif

/* resqml2__GpGridColumnLayerGrid has binding name 'resqml2__GpGridColumnLayerGrid' for type 'resqml2:GpGridColumnLayerGrid' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridColumnLayerGrid
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridColumnLayerGrid (113)
#endif

/* resqml2__GpGridUnstructuredColumnLayerGridPatch has binding name 'resqml2__GpGridUnstructuredColumnLayerGridPatch' for type 'resqml2:GpGridUnstructuredColumnLayerGridPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredColumnLayerGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__GpGridUnstructuredColumnLayerGridPatch (112)
#endif

/* resqml2__UnstructuredSubnodeTopology has binding name 'resqml2__UnstructuredSubnodeTopology' for type 'resqml2:UnstructuredSubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredSubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__UnstructuredSubnodeTopology (111)
#endif

/* resqml2__ColumnLayerParentWindow has binding name 'resqml2__ColumnLayerParentWindow' for type 'resqml2:ColumnLayerParentWindow' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnLayerParentWindow (110)
#endif

/* resqml2__obj_USCOREIjkGridRepresentation has binding name 'resqml2__obj_USCOREIjkGridRepresentation' for type 'resqml2:obj_IjkGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREIjkGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREIjkGridRepresentation (109)
#endif

/* resqml2__IjGaps has binding name 'resqml2__IjGaps' for type 'resqml2:IjGaps' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjGaps
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjGaps (108)
#endif

/* resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation has binding name 'resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation' for type 'resqml2:obj_UnstructuredColumnLayerGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredColumnLayerGridRepresentation (107)
#endif

/* resqml2__SplitFaces has binding name 'resqml2__SplitFaces' for type 'resqml2:SplitFaces' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitFaces
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitFaces (106)
#endif

/* resqml2__SubnodeTopology has binding name 'resqml2__SubnodeTopology' for type 'resqml2:SubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubnodeTopology (105)
#endif

/* resqml2__AbstractGridRepresentation has binding name 'resqml2__AbstractGridRepresentation' for type 'resqml2:AbstractGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGridRepresentation (104)
#endif

/* resqml2__obj_USCORELocalGridSet has binding name 'resqml2__obj_USCORELocalGridSet' for type 'resqml2:obj_LocalGridSet' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalGridSet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORELocalGridSet (103)
#endif

/* resqml2__CellStratigraphicUnits has binding name 'resqml2__CellStratigraphicUnits' for type 'resqml2:CellStratigraphicUnits' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellStratigraphicUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__CellStratigraphicUnits (102)
#endif

/* resqml2__ColumnSubnodePatch has binding name 'resqml2__ColumnSubnodePatch' for type 'resqml2:ColumnSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ColumnSubnodePatch (101)
#endif

/* resqml2__IjkParentWindow has binding name 'resqml2__IjkParentWindow' for type 'resqml2:IjkParentWindow' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IjkParentWindow (100)
#endif

/* resqml2__SplitNodePatch has binding name 'resqml2__SplitNodePatch' for type 'resqml2:SplitNodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitNodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SplitNodePatch (99)
#endif

/* resqml2__obj_USCOREGpGridRepresentation has binding name 'resqml2__obj_USCOREGpGridRepresentation' for type 'resqml2:obj_GpGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGpGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREGpGridRepresentation (98)
#endif

/* resqml2__AdditionalGridTopology has binding name 'resqml2__AdditionalGridTopology' for type 'resqml2:AdditionalGridTopology' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AdditionalGridTopology (97)
#endif

/* resqml2__obj_USCOREUnstructuredGridRepresentation has binding name 'resqml2__obj_USCOREUnstructuredGridRepresentation' for type 'resqml2:obj_UnstructuredGridRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredGridRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREUnstructuredGridRepresentation (96)
#endif

/* resqml2__obj_USCORESubRepresentation has binding name 'resqml2__obj_USCORESubRepresentation' for type 'resqml2:obj_SubRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESubRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORESubRepresentation (95)
#endif

/* resqml2__PatchOfGeometry has binding name 'resqml2__PatchOfGeometry' for type 'resqml2:PatchOfGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfGeometry (94)
#endif

/* resqml2__AbstractRepresentation has binding name 'resqml2__AbstractRepresentation' for type 'resqml2:AbstractRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractRepresentation (93)
#endif

/* resqml2__ElementIdentity has binding name 'resqml2__ElementIdentity' for type 'resqml2:ElementIdentity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIdentity (92)
#endif

/* resqml2__obj_USCORERepresentationIdentitySet has binding name 'resqml2__obj_USCORERepresentationIdentitySet' for type 'resqml2:obj_RepresentationIdentitySet' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationIdentitySet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationIdentitySet (91)
#endif

/* resqml2__RepresentationIdentity has binding name 'resqml2__RepresentationIdentity' for type 'resqml2:RepresentationIdentity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RepresentationIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__RepresentationIdentity (90)
#endif

/* resqml2__obj_USCORERedefinedGeometryRepresentation has binding name 'resqml2__obj_USCORERedefinedGeometryRepresentation' for type 'resqml2:obj_RedefinedGeometryRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERedefinedGeometryRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERedefinedGeometryRepresentation (89)
#endif

/* resqml2__obj_USCORERepresentationSetRepresentation has binding name 'resqml2__obj_USCORERepresentationSetRepresentation' for type 'resqml2:obj_RepresentationSetRepresentation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationSetRepresentation
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORERepresentationSetRepresentation (88)
#endif

/* resqml2__SubRepresentationPatch has binding name 'resqml2__SubRepresentationPatch' for type 'resqml2:SubRepresentationPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubRepresentationPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__SubRepresentationPatch (87)
#endif

/* resqml2__ElementIndices has binding name 'resqml2__ElementIndices' for type 'resqml2:ElementIndices' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIndices
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ElementIndices (86)
#endif

/* resqml2__Patch has binding name 'resqml2__Patch' for type 'resqml2:Patch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch (85)
#endif

/* resqml2__Patch1d has binding name 'resqml2__Patch1d' for type 'resqml2:Patch1d' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch1d
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Patch1d (84)
#endif

/* resqml2__Seismic2dCoordinates has binding name 'resqml2__Seismic2dCoordinates' for type 'resqml2:Seismic2dCoordinates' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic2dCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic2dCoordinates (83)
#endif

/* resqml2__AbstractSeismicCoordinates has binding name 'resqml2__AbstractSeismicCoordinates' for type 'resqml2:AbstractSeismicCoordinates' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractSeismicCoordinates (82)
#endif

/* resqml2__Seismic3dCoordinates has binding name 'resqml2__Seismic3dCoordinates' for type 'resqml2:Seismic3dCoordinates' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic3dCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Seismic3dCoordinates (81)
#endif

/* resqml2__Point3dFromRepresentationLatticeArray has binding name 'resqml2__Point3dFromRepresentationLatticeArray' for type 'resqml2:Point3dFromRepresentationLatticeArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dFromRepresentationLatticeArray (80)
#endif

/* resqml2__AbstractParametricLineGeometry has binding name 'resqml2__AbstractParametricLineGeometry' for type 'resqml2:AbstractParametricLineGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineGeometry (79)
#endif

/* resqml2__AbstractPlaneGeometry has binding name 'resqml2__AbstractPlaneGeometry' for type 'resqml2:AbstractPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPlaneGeometry (78)
#endif

/* resqml2__TiltedPlaneGeometry has binding name 'resqml2__TiltedPlaneGeometry' for type 'resqml2:TiltedPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TiltedPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__TiltedPlaneGeometry (77)
#endif

/* resqml2__ParametricLineIntersections has binding name 'resqml2__ParametricLineIntersections' for type 'resqml2:ParametricLineIntersections' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineIntersections
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineIntersections (76)
#endif

/* resqml2__AbstractParametricLineArray has binding name 'resqml2__AbstractParametricLineArray' for type 'resqml2:AbstractParametricLineArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractParametricLineArray (75)
#endif

/* resqml2__Point3dParametricArray has binding name 'resqml2__Point3dParametricArray' for type 'resqml2:Point3dParametricArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dParametricArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dParametricArray (74)
#endif

/* resqml2__ParametricLineArray has binding name 'resqml2__ParametricLineArray' for type 'resqml2:ParametricLineArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineArray (73)
#endif

/* resqml2__ParametricLineFromRepresentationGeometry has binding name 'resqml2__ParametricLineFromRepresentationGeometry' for type 'resqml2:ParametricLineFromRepresentationGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationGeometry (72)
#endif

/* resqml2__ThreePoint3d has binding name 'resqml2__ThreePoint3d' for type 'resqml2:ThreePoint3d' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThreePoint3d
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ThreePoint3d (71)
#endif

/* resqml2__Point3dHdf5Array has binding name 'resqml2__Point3dHdf5Array' for type 'resqml2:Point3dHdf5Array' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dHdf5Array (70)
#endif

/* resqml2__AbstractGeometry has binding name 'resqml2__AbstractGeometry' for type 'resqml2:AbstractGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractGeometry (69)
#endif

/* resqml2__AbstractPoint3dArray has binding name 'resqml2__AbstractPoint3dArray' for type 'resqml2:AbstractPoint3dArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPoint3dArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPoint3dArray (68)
#endif

/* resqml2__PointGeometry has binding name 'resqml2__PointGeometry' for type 'resqml2:PointGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PointGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PointGeometry (67)
#endif

/* resqml2__HorizontalPlaneGeometry has binding name 'resqml2__HorizontalPlaneGeometry' for type 'resqml2:HorizontalPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizontalPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__HorizontalPlaneGeometry (66)
#endif

/* resqml2__Point3dZValueArray has binding name 'resqml2__Point3dZValueArray' for type 'resqml2:Point3dZValueArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dZValueArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dZValueArray (65)
#endif

/* resqml2__Point3dLatticeArray has binding name 'resqml2__Point3dLatticeArray' for type 'resqml2:Point3dLatticeArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dLatticeArray (64)
#endif

/* resqml2__ParametricLineFromRepresentationLatticeArray has binding name 'resqml2__ParametricLineFromRepresentationLatticeArray' for type 'resqml2:ParametricLineFromRepresentationLatticeArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineFromRepresentationLatticeArray (63)
#endif

/* resqml2__ParametricLineGeometry has binding name 'resqml2__ParametricLineGeometry' for type 'resqml2:ParametricLineGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__ParametricLineGeometry (62)
#endif

/* resqml2__Point2dHdf5Array has binding name 'resqml2__Point2dHdf5Array' for type 'resqml2:Point2dHdf5Array' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point2dHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point2dHdf5Array (61)
#endif

/* resqml2__Point3dOffset has binding name 'resqml2__Point3dOffset' for type 'resqml2:Point3dOffset' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dOffset
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__Point3dOffset (60)
#endif

/* resqml2__BooleanArrayFromDiscretePropertyArray has binding name 'resqml2__BooleanArrayFromDiscretePropertyArray' for type 'resqml2:BooleanArrayFromDiscretePropertyArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromDiscretePropertyArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromDiscretePropertyArray (59)
#endif

/* resqml2__DoubleLookup has binding name 'resqml2__DoubleLookup' for type 'resqml2:DoubleLookup' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLookup (58)
#endif

/* resqml2__LocalPropertyKind has binding name 'resqml2__LocalPropertyKind' for type 'resqml2:LocalPropertyKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LocalPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__LocalPropertyKind (57)
#endif

/* resqml2__AbstractValuesProperty has binding name 'resqml2__AbstractValuesProperty' for type 'resqml2:AbstractValuesProperty' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValuesProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValuesProperty (56)
#endif

/* resqml2__StandardPropertyKind has binding name 'resqml2__StandardPropertyKind' for type 'resqml2:StandardPropertyKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StandardPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StandardPropertyKind (55)
#endif

/* resqml2__PropertyValuesPatch has binding name 'resqml2__PropertyValuesPatch' for type 'resqml2:PropertyValuesPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyValuesPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyValuesPatch (54)
#endif

/* resqml2__AbstractBooleanArray has binding name 'resqml2__AbstractBooleanArray' for type 'resqml2:AbstractBooleanArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractBooleanArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractBooleanArray (53)
#endif

/* resqml2__AbstractIntegerArray has binding name 'resqml2__AbstractIntegerArray' for type 'resqml2:AbstractIntegerArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractIntegerArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractIntegerArray (52)
#endif

/* resqml2__AbstractProperty has binding name 'resqml2__AbstractProperty' for type 'resqml2:AbstractProperty' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractProperty (51)
#endif

/* resqml2__obj_USCOREPropertySet has binding name 'resqml2__obj_USCOREPropertySet' for type 'resqml2:obj_PropertySet' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertySet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertySet (50)
#endif

/* resqml2__IntegerRangeArray has binding name 'resqml2__IntegerRangeArray' for type 'resqml2:IntegerRangeArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerRangeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerRangeArray (49)
#endif

/* resqml2__AbstractPropertyLookup has binding name 'resqml2__AbstractPropertyLookup' for type 'resqml2:AbstractPropertyLookup' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyLookup (48)
#endif

/* resqml2__AbstractValueArray has binding name 'resqml2__AbstractValueArray' for type 'resqml2:AbstractValueArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValueArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractValueArray (47)
#endif

/* resqml2__PatchOfValues has binding name 'resqml2__PatchOfValues' for type 'resqml2:PatchOfValues' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfValues
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfValues (46)
#endif

/* resqml2__AbstractPropertyKind has binding name 'resqml2__AbstractPropertyKind' for type 'resqml2:AbstractPropertyKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractPropertyKind (45)
#endif

/* resqml2__BooleanHdf5Array has binding name 'resqml2__BooleanHdf5Array' for type 'resqml2:BooleanHdf5Array' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanHdf5Array (44)
#endif

/* resqml2__StringHdf5Array has binding name 'resqml2__StringHdf5Array' for type 'resqml2:StringHdf5Array' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringHdf5Array (43)
#endif

/* resqml2__obj_USCOREStringTableLookup has binding name 'resqml2__obj_USCOREStringTableLookup' for type 'resqml2:obj_StringTableLookup' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStringTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREStringTableLookup (42)
#endif

/* resqml2__obj_USCOREPropertyKind has binding name 'resqml2__obj_USCOREPropertyKind' for type 'resqml2:obj_PropertyKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPropertyKind (41)
#endif

/* resqml2__IntegerLatticeArray has binding name 'resqml2__IntegerLatticeArray' for type 'resqml2:IntegerLatticeArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerLatticeArray (40)
#endif

/* resqml2__AbstractDoubleArray has binding name 'resqml2__AbstractDoubleArray' for type 'resqml2:AbstractDoubleArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractDoubleArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__AbstractDoubleArray (39)
#endif

/* resqml2__obj_USCORECategoricalProperty has binding name 'resqml2__obj_USCORECategoricalProperty' for type 'resqml2:obj_CategoricalProperty' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECategoricalProperty (38)
#endif

/* resqml2__obj_USCOREDiscreteProperty has binding name 'resqml2__obj_USCOREDiscreteProperty' for type 'resqml2:obj_DiscreteProperty' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscreteProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDiscreteProperty (37)
#endif

/* resqml2__obj_USCORECommentProperty has binding name 'resqml2__obj_USCORECommentProperty' for type 'resqml2:obj_CommentProperty' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCORECommentProperty (36)
#endif

/* resqml2__PatchOfPoints has binding name 'resqml2__PatchOfPoints' for type 'resqml2:PatchOfPoints' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PatchOfPoints (35)
#endif

/* resqml2__DoubleHdf5Array has binding name 'resqml2__DoubleHdf5Array' for type 'resqml2:DoubleHdf5Array' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleHdf5Array (34)
#endif

/* resqml2__DoubleConstantArray has binding name 'resqml2__DoubleConstantArray' for type 'resqml2:DoubleConstantArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleConstantArray (33)
#endif

/* resqml2__DoubleLatticeArray has binding name 'resqml2__DoubleLatticeArray' for type 'resqml2:DoubleLatticeArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__DoubleLatticeArray (32)
#endif

/* resqml2__obj_USCOREPointsProperty has binding name 'resqml2__obj_USCOREPointsProperty' for type 'resqml2:obj_PointsProperty' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointsProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREPointsProperty (31)
#endif

/* resqml2__StringLookup has binding name 'resqml2__StringLookup' for type 'resqml2:StringLookup' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__StringLookup (30)
#endif

/* resqml2__obj_USCOREContinuousProperty has binding name 'resqml2__obj_USCOREContinuousProperty' for type 'resqml2:obj_ContinuousProperty' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousProperty
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREContinuousProperty (29)
#endif

/* resqml2__IntegerHdf5Array has binding name 'resqml2__IntegerHdf5Array' for type 'resqml2:IntegerHdf5Array' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerHdf5Array
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerHdf5Array (28)
#endif

/* resqml2__PropertyKindFacet has binding name 'resqml2__PropertyKindFacet' for type 'resqml2:PropertyKindFacet' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyKindFacet
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__PropertyKindFacet (27)
#endif

/* resqml2__obj_USCOREDoubleTableLookup has binding name 'resqml2__obj_USCOREDoubleTableLookup' for type 'resqml2:obj_DoubleTableLookup' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDoubleTableLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__obj_USCOREDoubleTableLookup (26)
#endif

/* resqml2__IntegerConstantArray has binding name 'resqml2__IntegerConstantArray' for type 'resqml2:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerConstantArray (25)
#endif

/* resqml2__BooleanConstantArray has binding name 'resqml2__BooleanConstantArray' for type 'resqml2:BooleanConstantArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanConstantArray (24)
#endif

/* resqml2__BooleanArrayFromIndexArray has binding name 'resqml2__BooleanArrayFromIndexArray' for type 'resqml2:BooleanArrayFromIndexArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromIndexArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__BooleanArrayFromIndexArray (23)
#endif

/* resqml2__IntegerArrayFromBooleanMaskArray has binding name 'resqml2__IntegerArrayFromBooleanMaskArray' for type 'resqml2:IntegerArrayFromBooleanMaskArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerArrayFromBooleanMaskArray
#define SOAP_TYPE_gsoap_resqml2_0_1_resqml2__IntegerArrayFromBooleanMaskArray (22)
#endif

/* xsd__date has binding name 'xsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__date
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__date (21)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__anyURI
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__anyURI (20)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_xsd__ID
#define SOAP_TYPE_gsoap_resqml2_0_1_xsd__ID (19)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__string
#define SOAP_TYPE_gsoap_resqml2_0_1_std__string (18)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Fault (1364)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Reason (1363)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Detail (1360)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Code (1358)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_resqml2_0_1_SOAP_ENV__Header (1357)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToSOAP_ENV__Reason (1366)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToSOAP_ENV__Detail (1365)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToSOAP_ENV__Code
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToSOAP_ENV__Code (1359)
#endif

/* gml__GeodeticCRSPropertyType * has binding name 'PointerTogml__GeodeticCRSPropertyType' for type 'gml:GeodeticCRSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeodeticCRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeodeticCRSPropertyType (1201)
#endif

/* resqml2__TimeIndices * has binding name 'PointerToresqml2__TimeIndices' for type 'resqml2:TimeIndices' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TimeIndices
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TimeIndices (1200)
#endif

/* resqml2__SeismicLatticeSetFeature * has binding name 'PointerToresqml2__SeismicLatticeSetFeature' for type 'resqml2:SeismicLatticeSetFeature' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SeismicLatticeSetFeature
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SeismicLatticeSetFeature (1199)
#endif

/* resqml2__SealedContactRepresentationPart * has binding name 'PointerToresqml2__SealedContactRepresentationPart' for type 'resqml2:SealedContactRepresentationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SealedContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SealedContactRepresentationPart (1197)
#endif

/* resqml2__AbstractContactRepresentationPart * has binding name 'PointerToresqml2__AbstractContactRepresentationPart' for type 'resqml2:AbstractContactRepresentationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractContactRepresentationPart (1195)
#endif

/* resqml2__GeologicUnitInterpretationIndex * has binding name 'PointerToresqml2__GeologicUnitInterpretationIndex' for type 'resqml2:GeologicUnitInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GeologicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GeologicUnitInterpretationIndex (1193)
#endif

/* resqml2__StratigraphicUnitInterpretationIndex * has binding name 'PointerToresqml2__StratigraphicUnitInterpretationIndex' for type 'resqml2:StratigraphicUnitInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__StratigraphicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__StratigraphicUnitInterpretationIndex (1191)
#endif

/* gml__VerticalDatumPropertyType * has binding name 'PointerTogml__VerticalDatumPropertyType' for type 'gml:VerticalDatumPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalDatumPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalDatumPropertyType (1190)
#endif

/* gml__VerticalCSPropertyType * has binding name 'PointerTogml__VerticalCSPropertyType' for type 'gml:VerticalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalCSPropertyType (1189)
#endif

/* gml__GeneralConversionPropertyType * has binding name 'PointerTogml__GeneralConversionPropertyType' for type 'gml:GeneralConversionPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeneralConversionPropertyType (1188)
#endif

/* gml__EllipsoidPropertyType * has binding name 'PointerTogml__EllipsoidPropertyType' for type 'gml:EllipsoidPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__EllipsoidPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__EllipsoidPropertyType (1187)
#endif

/* gml__PrimeMeridianPropertyType * has binding name 'PointerTogml__PrimeMeridianPropertyType' for type 'gml:PrimeMeridianPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__PrimeMeridianPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__PrimeMeridianPropertyType (1186)
#endif

/* gml__GeodeticDatumPropertyType * has binding name 'PointerTogml__GeodeticDatumPropertyType' for type 'gml:GeodeticDatumPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeodeticDatumPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeodeticDatumPropertyType (1185)
#endif

/* gml__SphericalCSPropertyType * has binding name 'PointerTogml__SphericalCSPropertyType' for type 'gml:SphericalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__SphericalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__SphericalCSPropertyType (1183)
#endif

/* gml__CartesianCSPropertyType * has binding name 'PointerTogml__CartesianCSPropertyType' for type 'gml:CartesianCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CartesianCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CartesianCSPropertyType (1182)
#endif

/* gml__EllipsoidalCSPropertyType * has binding name 'PointerTogml__EllipsoidalCSPropertyType' for type 'gml:EllipsoidalCSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__EllipsoidalCSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__EllipsoidalCSPropertyType (1181)
#endif

/* resqml2__WitsmlWellboreReference * has binding name 'PointerToresqml2__WitsmlWellboreReference' for type 'resqml2:WitsmlWellboreReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__WitsmlWellboreReference
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__WitsmlWellboreReference (1180)
#endif

/* resqml2__Grid2dPatch * has binding name 'PointerToresqml2__Grid2dPatch' for type 'resqml2:Grid2dPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Grid2dPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Grid2dPatch (1178)
#endif

/* resqml2__VolumeRegion * has binding name 'PointerToresqml2__VolumeRegion' for type 'resqml2:VolumeRegion' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__VolumeRegion
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__VolumeRegion (1176)
#endif

/* resqml2__ContactIdentity * has binding name 'PointerToresqml2__ContactIdentity' for type 'resqml2:ContactIdentity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactIdentity (1174)
#endif

/* resqml2__AbstractPlaneGeometry * has binding name 'PointerToresqml2__AbstractPlaneGeometry' for type 'resqml2:AbstractPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractPlaneGeometry (1172)
#endif

/* resqml2__TrianglePatch * has binding name 'PointerToresqml2__TrianglePatch' for type 'resqml2:TrianglePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TrianglePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TrianglePatch (1170)
#endif

/* resqml2__WellboreMarker * has binding name 'PointerToresqml2__WellboreMarker' for type 'resqml2:WellboreMarker' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__WellboreMarker
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__WellboreMarker (1168)
#endif

/* enum resqml2__DepositionMode * has binding name 'PointerToresqml2__DepositionMode' for type 'resqml2:DepositionMode' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__DepositionMode
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__DepositionMode (1167)
#endif

/* enum resqml2__SequenceStratigraphySurface * has binding name 'PointerToresqml2__SequenceStratigraphySurface' for type 'resqml2:SequenceStratigraphySurface' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SequenceStratigraphySurface
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SequenceStratigraphySurface (1166)
#endif

/* enum resqml2__Geobody3dShape * has binding name 'PointerToresqml2__Geobody3dShape' for type 'resqml2:Geobody3dShape' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Geobody3dShape
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Geobody3dShape (1165)
#endif

/* resqml2__FaultThrow * has binding name 'PointerToresqml2__FaultThrow' for type 'resqml2:FaultThrow' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__FaultThrow
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__FaultThrow (1163)
#endif

/* eml__LengthMeasure * has binding name 'PointerToeml__LengthMeasure' for type 'eml:LengthMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__LengthMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__LengthMeasure (1162)
#endif

/* resqml2__HorizonInterpretationIndex * has binding name 'PointerToresqml2__HorizonInterpretationIndex' for type 'resqml2:HorizonInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__HorizonInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__HorizonInterpretationIndex (1160)
#endif

/* enum resqml2__Phase * has binding name 'PointerToresqml2__Phase' for type 'resqml2:Phase' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Phase
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Phase (1158)
#endif

/* resqml2__RockFluidUnitInterpretationIndex * has binding name 'PointerToresqml2__RockFluidUnitInterpretationIndex' for type 'resqml2:RockFluidUnitInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__RockFluidUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__RockFluidUnitInterpretationIndex (1157)
#endif

/* resqml2__GpGridUnstructuredGridPatch * has binding name 'PointerToresqml2__GpGridUnstructuredGridPatch' for type 'resqml2:GpGridUnstructuredGridPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GpGridUnstructuredGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GpGridUnstructuredGridPatch (1155)
#endif

/* resqml2__GpGridColumnLayerGrid * has binding name 'PointerToresqml2__GpGridColumnLayerGrid' for type 'resqml2:GpGridColumnLayerGrid' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GpGridColumnLayerGrid
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GpGridColumnLayerGrid (1153)
#endif

/* gml__CRSPropertyType * has binding name 'PointerTogml__CRSPropertyType' for type 'gml:CRSPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CRSPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CRSPropertyType (1150)
#endif

/* _gml__coordinateOperationAccuracy * has binding name 'PointerTo_gml__coordinateOperationAccuracy' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__coordinateOperationAccuracy (1148)
#endif

/* _gml__secondDefiningParameter * has binding name 'PointerTo_gml__secondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__secondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__secondDefiningParameter (1147)
#endif

/* gml__AngleType * has binding name 'PointerTogml__AngleType' for type 'gml:AngleType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__AngleType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__AngleType (1146)
#endif

/* std::string * has binding name 'PointerToxsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToxsd__date
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToxsd__date (1145)
#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTodouble
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTodouble (1144)
#endif

/* enum gml__AggregationType * has binding name 'PointerTogml__AggregationType' for type 'gml:AggregationType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__AggregationType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__AggregationType (1143)
#endif

/* gml__CoordinateSystemAxisPropertyType * has binding name 'PointerTogml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CoordinateSystemAxisPropertyType (1141)
#endif

/* _gml__domainOfValidity * has binding name 'PointerTo_gml__domainOfValidity' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__domainOfValidity
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__domainOfValidity (1139)
#endif

/* resqml2__StreamlinePolylineSetPatch * has binding name 'PointerToresqml2__StreamlinePolylineSetPatch' for type 'resqml2:StreamlinePolylineSetPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__StreamlinePolylineSetPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__StreamlinePolylineSetPatch (1138)
#endif

/* resqml2__StreamlineWellbores * has binding name 'PointerToresqml2__StreamlineWellbores' for type 'resqml2:StreamlineWellbores' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__StreamlineWellbores
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__StreamlineWellbores (1137)
#endif

/* resqml2__PatchBoundaries * has binding name 'PointerToresqml2__PatchBoundaries' for type 'resqml2:PatchBoundaries' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PatchBoundaries
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PatchBoundaries (1135)
#endif

/* resqml2__PolylineSetPatch * has binding name 'PointerToresqml2__PolylineSetPatch' for type 'resqml2:PolylineSetPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PolylineSetPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PolylineSetPatch (1133)
#endif

/* enum resqml2__LineRole * has binding name 'PointerToresqml2__LineRole' for type 'resqml2:LineRole' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__LineRole
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__LineRole (1132)
#endif

/* resqml2__NodePatch * has binding name 'PointerToresqml2__NodePatch' for type 'resqml2:NodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__NodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__NodePatch (1130)
#endif

/* resqml2__WellboreTrajectoryParentIntersection * has binding name 'PointerToresqml2__WellboreTrajectoryParentIntersection' for type 'resqml2:WellboreTrajectoryParentIntersection' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__WellboreTrajectoryParentIntersection
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__WellboreTrajectoryParentIntersection (1129)
#endif

/* resqml2__AbstractParametricLineGeometry * has binding name 'PointerToresqml2__AbstractParametricLineGeometry' for type 'resqml2:AbstractParametricLineGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractParametricLineGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractParametricLineGeometry (1128)
#endif

/* enum resqml2__MdDomain * has binding name 'PointerToresqml2__MdDomain' for type 'resqml2:MdDomain' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__MdDomain
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__MdDomain (1127)
#endif

/* resqml2__IntervalStratigraphicUnits * has binding name 'PointerToresqml2__IntervalStratigraphicUnits' for type 'resqml2:IntervalStratigraphicUnits' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IntervalStratigraphicUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IntervalStratigraphicUnits (1126)
#endif

/* enum resqml2__GeologicUnitMaterialImplacement * has binding name 'PointerToresqml2__GeologicUnitMaterialImplacement' for type 'resqml2:GeologicUnitMaterialImplacement' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GeologicUnitMaterialImplacement
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GeologicUnitMaterialImplacement (1125)
#endif

/* enum resqml2__GeologicUnitComposition * has binding name 'PointerToresqml2__GeologicUnitComposition' for type 'resqml2:GeologicUnitComposition' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GeologicUnitComposition
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GeologicUnitComposition (1124)
#endif

/* resqml2__AbstractContactInterpretationPart * has binding name 'PointerToresqml2__AbstractContactInterpretationPart' for type 'resqml2:AbstractContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractContactInterpretationPart (1122)
#endif

/* resqml2__ConnectionInterpretations * has binding name 'PointerToresqml2__ConnectionInterpretations' for type 'resqml2:ConnectionInterpretations' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ConnectionInterpretations
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ConnectionInterpretations (1121)
#endif

/* resqml2__IjGaps * has binding name 'PointerToresqml2__IjGaps' for type 'resqml2:IjGaps' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IjGaps
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IjGaps (1120)
#endif

/* resqml2__CellStratigraphicUnits * has binding name 'PointerToresqml2__CellStratigraphicUnits' for type 'resqml2:CellStratigraphicUnits' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__CellStratigraphicUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__CellStratigraphicUnits (1119)
#endif

/* resqml2__AbstractParentWindow * has binding name 'PointerToresqml2__AbstractParentWindow' for type 'resqml2:AbstractParentWindow' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractParentWindow
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractParentWindow (1118)
#endif

/* resqml2__CellFluidPhaseUnits * has binding name 'PointerToresqml2__CellFluidPhaseUnits' for type 'resqml2:CellFluidPhaseUnits' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__CellFluidPhaseUnits
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__CellFluidPhaseUnits (1117)
#endif

/* resqml2__SubRepresentationPatch * has binding name 'PointerToresqml2__SubRepresentationPatch' for type 'resqml2:SubRepresentationPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SubRepresentationPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SubRepresentationPatch (1115)
#endif

/* resqml2__PatchOfGeometry * has binding name 'PointerToresqml2__PatchOfGeometry' for type 'resqml2:PatchOfGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PatchOfGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PatchOfGeometry (1113)
#endif

/* resqml2__PropertyKindFacet * has binding name 'PointerToresqml2__PropertyKindFacet' for type 'resqml2:PropertyKindFacet' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PropertyKindFacet
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PropertyKindFacet (1111)
#endif

/* resqml2__PatchOfValues * has binding name 'PointerToresqml2__PatchOfValues' for type 'resqml2:PatchOfValues' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PatchOfValues
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PatchOfValues (1109)
#endif

/* resqml2__StringLookup * has binding name 'PointerToresqml2__StringLookup' for type 'resqml2:StringLookup' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__StringLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__StringLookup (1107)
#endif

/* resqml2__PatchOfPoints * has binding name 'PointerToresqml2__PatchOfPoints' for type 'resqml2:PatchOfPoints' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PatchOfPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PatchOfPoints (1105)
#endif

/* resqml2__DoubleLookup * has binding name 'PointerToresqml2__DoubleLookup' for type 'resqml2:DoubleLookup' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__DoubleLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__DoubleLookup (1103)
#endif

/* resqml2__ParameterTemplate * has binding name 'PointerToresqml2__ParameterTemplate' for type 'resqml2:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ParameterTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ParameterTemplate (1101)
#endif

/* enum resqml2__GeologicBoundaryKind * has binding name 'PointerToresqml2__GeologicBoundaryKind' for type 'resqml2:GeologicBoundaryKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GeologicBoundaryKind
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GeologicBoundaryKind (1100)
#endif

/* enum resqml2__FluidMarker * has binding name 'PointerToresqml2__FluidMarker' for type 'resqml2:FluidMarker' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__FluidMarker
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__FluidMarker (1099)
#endif

/* enum resqml2__FluidContact * has binding name 'PointerToresqml2__FluidContact' for type 'resqml2:FluidContact' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__FluidContact
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__FluidContact (1098)
#endif

/* resqml2__TimeSeriesParentage * has binding name 'PointerToresqml2__TimeSeriesParentage' for type 'resqml2:TimeSeriesParentage' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TimeSeriesParentage
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TimeSeriesParentage (1097)
#endif

/* resqml2__Timestamp * has binding name 'PointerToresqml2__Timestamp' for type 'resqml2:Timestamp' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Timestamp
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Timestamp (1095)
#endif

/* eml__PlaneAngleMeasure * has binding name 'PointerToeml__PlaneAngleMeasure' for type 'eml:PlaneAngleMeasure' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__PlaneAngleMeasure
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__PlaneAngleMeasure (1094)
#endif

/* resqml2__ChronostratigraphicRank * has binding name 'PointerToresqml2__ChronostratigraphicRank' for type 'resqml2:ChronostratigraphicRank' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ChronostratigraphicRank
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ChronostratigraphicRank (1092)
#endif

/* resqml2__ColumnLayerSplitCoordinateLines * has binding name 'PointerToresqml2__ColumnLayerSplitCoordinateLines' for type 'resqml2:ColumnLayerSplitCoordinateLines' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ColumnLayerSplitCoordinateLines
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ColumnLayerSplitCoordinateLines (1091)
#endif

/* resqml2__UnstructuredGridHingeNodeFaces * has binding name 'PointerToresqml2__UnstructuredGridHingeNodeFaces' for type 'resqml2:UnstructuredGridHingeNodeFaces' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredGridHingeNodeFaces
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredGridHingeNodeFaces (1090)
#endif

/* resqml2__Activation * has binding name 'PointerToresqml2__Activation' for type 'resqml2:Activation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Activation
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Activation (1089)
#endif

/* resqml2__RepresentationIdentity * has binding name 'PointerToresqml2__RepresentationIdentity' for type 'resqml2:RepresentationIdentity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__RepresentationIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__RepresentationIdentity (1087)
#endif

/* resqml2__AbstractPropertyKind * has binding name 'PointerToresqml2__AbstractPropertyKind' for type 'resqml2:AbstractPropertyKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractPropertyKind (1086)
#endif

/* gml__RelatedTimeType * has binding name 'PointerTogml__RelatedTimeType' for type 'gml:RelatedTimeType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__RelatedTimeType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__RelatedTimeType (1084)
#endif

/* eml__AbstractVerticalCrs * has binding name 'PointerToeml__AbstractVerticalCrs' for type 'eml:AbstractVerticalCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__AbstractVerticalCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__AbstractVerticalCrs (1083)
#endif

/* enum eml__LengthUom * has binding name 'PointerToeml__LengthUom' for type 'eml:LengthUom' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__LengthUom
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__LengthUom (1082)
#endif

/* eml__AbstractProjectedCrs * has binding name 'PointerToeml__AbstractProjectedCrs' for type 'eml:AbstractProjectedCrs' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__AbstractProjectedCrs
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__AbstractProjectedCrs (1081)
#endif

/* resqml2__EdgePatch * has binding name 'PointerToresqml2__EdgePatch' for type 'resqml2:EdgePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__EdgePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__EdgePatch (1079)
#endif

/* resqml2__NameValuePair * has binding name 'PointerToresqml2__NameValuePair' for type 'resqml2:NameValuePair' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__NameValuePair
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__NameValuePair (1077)
#endif

/* resqml2__AdditionalGridPoints * has binding name 'PointerToresqml2__AdditionalGridPoints' for type 'resqml2:AdditionalGridPoints' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AdditionalGridPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AdditionalGridPoints (1075)
#endif

/* resqml2__ElementIndices * has binding name 'PointerToresqml2__ElementIndices' for type 'resqml2:ElementIndices' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ElementIndices
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ElementIndices (1073)
#endif

/* resqml2__ThreePoint3d * has binding name 'PointerToresqml2__ThreePoint3d' for type 'resqml2:ThreePoint3d' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ThreePoint3d
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ThreePoint3d (1071)
#endif

/* resqml2__IntegerConstantArray * has binding name 'PointerToresqml2__IntegerConstantArray' for type 'resqml2:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IntegerConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IntegerConstantArray (1069)
#endif

/* resqml2__DoubleConstantArray * has binding name 'PointerToresqml2__DoubleConstantArray' for type 'resqml2:DoubleConstantArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__DoubleConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__DoubleConstantArray (1067)
#endif

/* gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType' for type 'gmd:CI_OnLineFunctionCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (1066)
#endif

/* gmd__URL_USCOREPropertyType * has binding name 'PointerTogmd__URL_USCOREPropertyType' for type 'gmd:URL_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__URL_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__URL_USCOREPropertyType (1065)
#endif

/* gmd__CI_USCOREOnlineResource_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREOnlineResource_USCOREPropertyType' for type 'gmd:CI_OnlineResource_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREOnlineResource_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREOnlineResource_USCOREPropertyType (1064)
#endif

/* gmd__CI_USCOREAddress_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREAddress_USCOREPropertyType' for type 'gmd:CI_Address_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREAddress_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREAddress_USCOREPropertyType (1063)
#endif

/* gmd__CI_USCORETelephone_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCORETelephone_USCOREPropertyType' for type 'gmd:CI_Telephone_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORETelephone_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORETelephone_USCOREPropertyType (1062)
#endif

/* gmd__CI_USCORERoleCode_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCORERoleCode_USCOREPropertyType' for type 'gmd:CI_RoleCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORERoleCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORERoleCode_USCOREPropertyType (1061)
#endif

/* gmd__CI_USCOREContact_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREContact_USCOREPropertyType' for type 'gmd:CI_Contact_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREContact_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREContact_USCOREPropertyType (1060)
#endif

/* gmd__CI_USCOREDateTypeCode_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREDateTypeCode_USCOREPropertyType' for type 'gmd:CI_DateTypeCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREDateTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREDateTypeCode_USCOREPropertyType (1059)
#endif

/* gmd__CI_USCORESeries_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCORESeries_USCOREPropertyType' for type 'gmd:CI_Series_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORESeries_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORESeries_USCOREPropertyType (1058)
#endif

/* gmd__CI_USCOREPresentationFormCode_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType' for type 'gmd:CI_PresentationFormCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType (1056)
#endif

/* gmd__CI_USCOREResponsibleParty_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType' for type 'gmd:CI_ResponsibleParty_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType (1054)
#endif

/* gco__Date_USCOREPropertyType * has binding name 'PointerTogco__Date_USCOREPropertyType' for type 'gco:Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__Date_USCOREPropertyType (1052)
#endif

/* gmd__CI_USCOREDate_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCOREDate_USCOREPropertyType' for type 'gmd:CI_Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREDate_USCOREPropertyType (1050)
#endif

/* gmd__DQ_USCOREResult_USCOREPropertyType * has binding name 'PointerTogmd__DQ_USCOREResult_USCOREPropertyType' for type 'gmd:DQ_Result_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__DQ_USCOREResult_USCOREPropertyType (1048)
#endif

/* gco__DateTime_USCOREPropertyType * has binding name 'PointerTogco__DateTime_USCOREPropertyType' for type 'gco:DateTime_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__DateTime_USCOREPropertyType (1046)
#endif

/* gmd__CI_USCORECitation_USCOREPropertyType * has binding name 'PointerTogmd__CI_USCORECitation_USCOREPropertyType' for type 'gmd:CI_Citation_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORECitation_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORECitation_USCOREPropertyType (1045)
#endif

/* gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType * has binding name 'PointerTogmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType' for type 'gmd:DQ_EvaluationMethodTypeCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (1044)
#endif

/* gmd__MD_USCOREIdentifier_USCOREPropertyType * has binding name 'PointerTogmd__MD_USCOREIdentifier_USCOREPropertyType' for type 'gmd:MD_Identifier_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__MD_USCOREIdentifier_USCOREPropertyType (1043)
#endif

/* gsr__SC_USCORECRS_USCOREPropertyType * has binding name 'PointerTogsr__SC_USCORECRS_USCOREPropertyType' for type 'gsr:SC_CRS_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogsr__SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogsr__SC_USCORECRS_USCOREPropertyType (1041)
#endif

/* gco__Real_USCOREPropertyType * has binding name 'PointerTogco__Real_USCOREPropertyType' for type 'gco:Real_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__Real_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__Real_USCOREPropertyType (1040)
#endif

/* gts__TM_USCOREPrimitive_USCOREPropertyType * has binding name 'PointerTogts__TM_USCOREPrimitive_USCOREPropertyType' for type 'gts:TM_Primitive_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogts__TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogts__TM_USCOREPrimitive_USCOREPropertyType (1039)
#endif

/* gco__Boolean_USCOREPropertyType * has binding name 'PointerTogco__Boolean_USCOREPropertyType' for type 'gco:Boolean_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__Boolean_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__Boolean_USCOREPropertyType (1038)
#endif

/* gmd__EX_USCOREVerticalExtent_USCOREPropertyType * has binding name 'PointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType' for type 'gmd:EX_VerticalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType (1036)
#endif

/* gmd__EX_USCORETemporalExtent_USCOREPropertyType * has binding name 'PointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType' for type 'gmd:EX_TemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType (1034)
#endif

/* gmd__EX_USCOREGeographicExtent_USCOREPropertyType * has binding name 'PointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType' for type 'gmd:EX_GeographicExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType (1032)
#endif

/* gco__CharacterString_USCOREPropertyType * has binding name 'PointerTogco__CharacterString_USCOREPropertyType' for type 'gco:CharacterString_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__CharacterString_USCOREPropertyType (1031)
#endif

/* enum _gml__RelatedTimeType_relativePosition * has binding name 'PointerTo_gml__RelatedTimeType_relativePosition' for type 'gml:RelatedTimeType-relativePosition' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__RelatedTimeType_relativePosition (1030)
#endif

/* gml__ProjectedCRSType * has binding name 'PointerTogml__ProjectedCRSType' for type 'gml:ProjectedCRSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__ProjectedCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__ProjectedCRSType (1028)
#endif

/* gml__VerticalCRSType * has binding name 'PointerTogml__VerticalCRSType' for type 'gml:VerticalCRSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalCRSType (1027)
#endif

/* resqml2__IntervalGridCells * has binding name 'PointerToresqml2__IntervalGridCells' for type 'resqml2:IntervalGridCells' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IntervalGridCells
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IntervalGridCells (1026)
#endif

/* resqml2__PointGeometry * has binding name 'PointerToresqml2__PointGeometry' for type 'resqml2:PointGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PointGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__PointGeometry (1025)
#endif

/* resqml2__ContactPatch * has binding name 'PointerToresqml2__ContactPatch' for type 'resqml2:ContactPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactPatch (1023)
#endif

/* enum resqml2__ContactMode * has binding name 'PointerToresqml2__ContactMode' for type 'resqml2:ContactMode' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactMode
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactMode (1021)
#endif

/* enum resqml2__ContactSide * has binding name 'PointerToresqml2__ContactSide' for type 'resqml2:ContactSide' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactSide
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactSide (1020)
#endif

/* resqml2__ContactElementReference * has binding name 'PointerToresqml2__ContactElementReference' for type 'resqml2:ContactElementReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactElementReference
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ContactElementReference (1019)
#endif

/* resqml2__IjkGridGeometry * has binding name 'PointerToresqml2__IjkGridGeometry' for type 'resqml2:IjkGridGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IjkGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IjkGridGeometry (1018)
#endif

/* resqml2__UnstructuredGridGeometry * has binding name 'PointerToresqml2__UnstructuredGridGeometry' for type 'resqml2:UnstructuredGridGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredGridGeometry (1017)
#endif

/* resqml2__ColumnSubnodePatch * has binding name 'PointerToresqml2__ColumnSubnodePatch' for type 'resqml2:ColumnSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ColumnSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ColumnSubnodePatch (1015)
#endif

/* resqml2__TruncationCellPatch * has binding name 'PointerToresqml2__TruncationCellPatch' for type 'resqml2:TruncationCellPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TruncationCellPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TruncationCellPatch (1014)
#endif

/* resqml2__UnstructuredColumnLayerGridGeometry * has binding name 'PointerToresqml2__UnstructuredColumnLayerGridGeometry' for type 'resqml2:UnstructuredColumnLayerGridGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredColumnLayerGridGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredColumnLayerGridGeometry (1013)
#endif

/* resqml2__NodesPerCell * has binding name 'PointerToresqml2__NodesPerCell' for type 'resqml2:NodesPerCell' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__NodesPerCell
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__NodesPerCell (1012)
#endif

/* resqml2__Edges * has binding name 'PointerToresqml2__Edges' for type 'resqml2:Edges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Edges
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Edges (1011)
#endif

/* resqml2__Regrid * has binding name 'PointerToresqml2__Regrid' for type 'resqml2:Regrid' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Regrid
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Regrid (1010)
#endif

/* resqml2__AbstractParametricLineArray * has binding name 'PointerToresqml2__AbstractParametricLineArray' for type 'resqml2:AbstractParametricLineArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractParametricLineArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractParametricLineArray (1009)
#endif

/* resqml2__ParametricLineIntersections * has binding name 'PointerToresqml2__ParametricLineIntersections' for type 'resqml2:ParametricLineIntersections' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ParametricLineIntersections
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ParametricLineIntersections (1008)
#endif

/* resqml2__AbstractSeismicCoordinates * has binding name 'PointerToresqml2__AbstractSeismicCoordinates' for type 'resqml2:AbstractSeismicCoordinates' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractSeismicCoordinates
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractSeismicCoordinates (1007)
#endif

/* resqml2__Point3dOffset * has binding name 'PointerToresqml2__Point3dOffset' for type 'resqml2:Point3dOffset' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Point3dOffset
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Point3dOffset (1005)
#endif

/* resqml2__IntegerLatticeArray * has binding name 'PointerToresqml2__IntegerLatticeArray' for type 'resqml2:IntegerLatticeArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IntegerLatticeArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IntegerLatticeArray (1004)
#endif

/* eml__Hdf5Dataset * has binding name 'PointerToeml__Hdf5Dataset' for type 'eml:Hdf5Dataset' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__Hdf5Dataset
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__Hdf5Dataset (1003)
#endif

/* ptm__equivalentPropertyType * has binding name 'PointerToptm__equivalentPropertyType' for type 'ptm:equivalentPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToptm__equivalentPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToptm__equivalentPropertyType (1001)
#endif

/* enum resqml2__ResqmlPropertyKind * has binding name 'PointerToresqml2__ResqmlPropertyKind' for type 'resqml2:ResqmlPropertyKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ResqmlPropertyKind
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ResqmlPropertyKind (1000)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTobool
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTobool (999)
#endif

/* ptm__standardEnergisticsPropertyType * has binding name 'PointerToptm__standardEnergisticsPropertyType' for type 'ptm:standardEnergisticsPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToptm__standardEnergisticsPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToptm__standardEnergisticsPropertyType (997)
#endif

/* __gsr__SC_USCORECRS_USCOREPropertyType_sequence * has binding name 'PointerTo__gsr__SC_USCORECRS_USCOREPropertyType_sequence' for type '-gsr:SC_CRS_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gsr__SC_USCORECRS_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gsr__SC_USCORECRS_USCOREPropertyType_sequence (996)
#endif

/* __gco__DateTime_USCOREPropertyType_sequence * has binding name 'PointerTo__gco__DateTime_USCOREPropertyType_sequence' for type '-gco:DateTime_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gco__DateTime_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gco__DateTime_USCOREPropertyType_sequence (993)
#endif

/* std::string * has binding name 'PointerTogco__Date_USCOREType' for type 'gco:Date_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__Date_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__Date_USCOREType (990)
#endif

/* __gco__Real_USCOREPropertyType_sequence * has binding name 'PointerTo__gco__Real_USCOREPropertyType_sequence' for type '-gco:Real_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gco__Real_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gco__Real_USCOREPropertyType_sequence (989)
#endif

/* __gco__Boolean_USCOREPropertyType_sequence * has binding name 'PointerTo__gco__Boolean_USCOREPropertyType_sequence' for type '-gco:Boolean_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gco__Boolean_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gco__Boolean_USCOREPropertyType_sequence (987)
#endif

/* __gco__CharacterString_USCOREPropertyType_sequence * has binding name 'PointerTo__gco__CharacterString_USCOREPropertyType_sequence' for type '-gco:CharacterString_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gco__CharacterString_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gco__CharacterString_USCOREPropertyType_sequence (985)
#endif

/* std::string * has binding name 'PointerToxsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToxsd__ID
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToxsd__ID (982)
#endif

/* __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence * has binding name 'PointerTo__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence' for type '-gts:TM_Primitive_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence (981)
#endif

/* __gmd__DQ_USCOREResult_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_USCOREResult_USCOREPropertyType_sequence' for type '-gmd:DQ_Result_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__DQ_USCOREResult_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__DQ_USCOREResult_USCOREPropertyType_sequence (978)
#endif

/* __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence' for type '-gmd:DQ_EvaluationMethodTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence (975)
#endif

/* __gmd__CI_USCORESeries_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCORESeries_USCOREPropertyType_sequence' for type '-gmd:CI_Series_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCORESeries_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCORESeries_USCOREPropertyType_sequence (973)
#endif

/* gmd__CI_USCORESeries_USCOREType * has binding name 'PointerTogmd__CI_USCORESeries_USCOREType' for type 'gmd:CI_Series_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORESeries_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORESeries_USCOREType (972)
#endif

/* __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence' for type '-gmd:CI_PresentationFormCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence (970)
#endif

/* __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence' for type '-gmd:CI_RoleCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence (968)
#endif

/* __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence' for type '-gmd:CI_OnLineFunctionCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence (966)
#endif

/* __gmd__URL_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__URL_USCOREPropertyType_sequence' for type '-gmd:URL_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__URL_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__URL_USCOREPropertyType_sequence (964)
#endif

/* __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence' for type '-gmd:CI_OnlineResource_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence (962)
#endif

/* gmd__CI_USCOREOnlineResource_USCOREType * has binding name 'PointerTogmd__CI_USCOREOnlineResource_USCOREType' for type 'gmd:CI_OnlineResource_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREOnlineResource_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREOnlineResource_USCOREType (961)
#endif

/* __gmd__CI_USCOREAddress_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREAddress_USCOREPropertyType_sequence' for type '-gmd:CI_Address_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREAddress_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREAddress_USCOREPropertyType_sequence (959)
#endif

/* gmd__CI_USCOREAddress_USCOREType * has binding name 'PointerTogmd__CI_USCOREAddress_USCOREType' for type 'gmd:CI_Address_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREAddress_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREAddress_USCOREType (958)
#endif

/* __gmd__CI_USCORETelephone_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCORETelephone_USCOREPropertyType_sequence' for type '-gmd:CI_Telephone_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCORETelephone_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCORETelephone_USCOREPropertyType_sequence (956)
#endif

/* gmd__CI_USCORETelephone_USCOREType * has binding name 'PointerTogmd__CI_USCORETelephone_USCOREType' for type 'gmd:CI_Telephone_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORETelephone_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORETelephone_USCOREType (955)
#endif

/* __gmd__CI_USCOREContact_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREContact_USCOREPropertyType_sequence' for type '-gmd:CI_Contact_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREContact_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREContact_USCOREPropertyType_sequence (953)
#endif

/* gmd__CI_USCOREContact_USCOREType * has binding name 'PointerTogmd__CI_USCOREContact_USCOREType' for type 'gmd:CI_Contact_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREContact_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREContact_USCOREType (952)
#endif

/* __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence' for type '-gmd:CI_ResponsibleParty_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence (950)
#endif

/* gmd__CI_USCOREResponsibleParty_USCOREType * has binding name 'PointerTogmd__CI_USCOREResponsibleParty_USCOREType' for type 'gmd:CI_ResponsibleParty_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREResponsibleParty_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREResponsibleParty_USCOREType (949)
#endif

/* __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence' for type '-gmd:CI_DateTypeCode_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence (947)
#endif

/* gco__CodeListValue_USCOREType * has binding name 'PointerTogco__CodeListValue_USCOREType' for type 'gco:CodeListValue_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__CodeListValue_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogco__CodeListValue_USCOREType (946)
#endif

/* __gmd__CI_USCOREDate_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCOREDate_USCOREPropertyType_sequence' for type '-gmd:CI_Date_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREDate_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCOREDate_USCOREPropertyType_sequence (944)
#endif

/* gmd__CI_USCOREDate_USCOREType * has binding name 'PointerTogmd__CI_USCOREDate_USCOREType' for type 'gmd:CI_Date_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREDate_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCOREDate_USCOREType (943)
#endif

/* __gmd__CI_USCORECitation_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__CI_USCORECitation_USCOREPropertyType_sequence' for type '-gmd:CI_Citation_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCORECitation_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__CI_USCORECitation_USCOREPropertyType_sequence (941)
#endif

/* gmd__CI_USCORECitation_USCOREType * has binding name 'PointerTogmd__CI_USCORECitation_USCOREType' for type 'gmd:CI_Citation_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORECitation_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__CI_USCORECitation_USCOREType (940)
#endif

/* __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence' for type '-gmd:MD_Identifier_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence (938)
#endif

/* gmd__MD_USCOREIdentifier_USCOREType * has binding name 'PointerTogmd__MD_USCOREIdentifier_USCOREType' for type 'gmd:MD_Identifier_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__MD_USCOREIdentifier_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__MD_USCOREIdentifier_USCOREType (937)
#endif

/* __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence' for type '-gmd:EX_VerticalExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence (935)
#endif

/* gmd__EX_USCOREVerticalExtent_USCOREType * has binding name 'PointerTogmd__EX_USCOREVerticalExtent_USCOREType' for type 'gmd:EX_VerticalExtent_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCOREVerticalExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCOREVerticalExtent_USCOREType (934)
#endif

/* __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence' for type '-gmd:EX_TemporalExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence (932)
#endif

/* gmd__EX_USCORETemporalExtent_USCOREType * has binding name 'PointerTogmd__EX_USCORETemporalExtent_USCOREType' for type 'gmd:EX_TemporalExtent_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCORETemporalExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCORETemporalExtent_USCOREType (931)
#endif

/* __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence * has binding name 'PointerTo__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence' for type '-gmd:EX_GeographicExtent_PropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence (929)
#endif

/* __gml__coordinateOperationAccuracy_sequence * has binding name 'PointerTo__gml__coordinateOperationAccuracy_sequence' for type '-gml:coordinateOperationAccuracy-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__coordinateOperationAccuracy_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__coordinateOperationAccuracy_sequence (926)
#endif

/* gml__LengthType * has binding name 'PointerTogml__LengthType' for type 'gml:LengthType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__LengthType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__LengthType (922)
#endif

/* gml__MeasureType * has binding name 'PointerTogml__MeasureType' for type 'gml:MeasureType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__MeasureType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__MeasureType (921)
#endif

/* _gml__SecondDefiningParameter * has binding name 'PointerTo_gml__SecondDefiningParameter' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__SecondDefiningParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_gml__SecondDefiningParameter (920)
#endif

/* __gml__domainOfValidity_sequence * has binding name 'PointerTo__gml__domainOfValidity_sequence' for type '-gml:domainOfValidity-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__domainOfValidity_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__domainOfValidity_sequence (919)
#endif

/* gmd__EX_USCOREExtent_USCOREType * has binding name 'PointerTogmd__EX_USCOREExtent_USCOREType' for type 'gmd:EX_Extent_Type' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCOREExtent_USCOREType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogmd__EX_USCOREExtent_USCOREType (918)
#endif

/* __gml__VerticalDatumPropertyType_sequence * has binding name 'PointerTo__gml__VerticalDatumPropertyType_sequence' for type '-gml:VerticalDatumPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__VerticalDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__VerticalDatumPropertyType_sequence (916)
#endif

/* gml__VerticalDatumType * has binding name 'PointerTogml__VerticalDatumType' for type 'gml:VerticalDatumType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalDatumType (915)
#endif

/* __gml__VerticalCSPropertyType_sequence * has binding name 'PointerTo__gml__VerticalCSPropertyType_sequence' for type '-gml:VerticalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__VerticalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__VerticalCSPropertyType_sequence (913)
#endif

/* gml__VerticalCSType * has binding name 'PointerTogml__VerticalCSType' for type 'gml:VerticalCSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__VerticalCSType (912)
#endif

/* __gml__GeodeticCRSPropertyType_sequence * has binding name 'PointerTo__gml__GeodeticCRSPropertyType_sequence' for type '-gml:GeodeticCRSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__GeodeticCRSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__GeodeticCRSPropertyType_sequence (910)
#endif

/* gml__GeodeticCRSType * has binding name 'PointerTogml__GeodeticCRSType' for type 'gml:GeodeticCRSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeodeticCRSType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeodeticCRSType (909)
#endif

/* __gml__CRSPropertyType_sequence * has binding name 'PointerTo__gml__CRSPropertyType_sequence' for type '-gml:CRSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__CRSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__CRSPropertyType_sequence (907)
#endif

/* __gml__GeneralConversionPropertyType_sequence * has binding name 'PointerTo__gml__GeneralConversionPropertyType_sequence' for type '-gml:GeneralConversionPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__GeneralConversionPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__GeneralConversionPropertyType_sequence (904)
#endif

/* __gml__EllipsoidPropertyType_sequence * has binding name 'PointerTo__gml__EllipsoidPropertyType_sequence' for type '-gml:EllipsoidPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__EllipsoidPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__EllipsoidPropertyType_sequence (901)
#endif

/* gml__EllipsoidType * has binding name 'PointerTogml__EllipsoidType' for type 'gml:EllipsoidType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__EllipsoidType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__EllipsoidType (900)
#endif

/* __gml__PrimeMeridianPropertyType_sequence * has binding name 'PointerTo__gml__PrimeMeridianPropertyType_sequence' for type '-gml:PrimeMeridianPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__PrimeMeridianPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__PrimeMeridianPropertyType_sequence (898)
#endif

/* gml__PrimeMeridianType * has binding name 'PointerTogml__PrimeMeridianType' for type 'gml:PrimeMeridianType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__PrimeMeridianType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__PrimeMeridianType (897)
#endif

/* __gml__GeodeticDatumPropertyType_sequence * has binding name 'PointerTo__gml__GeodeticDatumPropertyType_sequence' for type '-gml:GeodeticDatumPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__GeodeticDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__GeodeticDatumPropertyType_sequence (895)
#endif

/* gml__GeodeticDatumType * has binding name 'PointerTogml__GeodeticDatumType' for type 'gml:GeodeticDatumType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeodeticDatumType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__GeodeticDatumType (894)
#endif

/* __gml__SphericalCSPropertyType_sequence * has binding name 'PointerTo__gml__SphericalCSPropertyType_sequence' for type '-gml:SphericalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__SphericalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__SphericalCSPropertyType_sequence (892)
#endif

/* gml__SphericalCSType * has binding name 'PointerTogml__SphericalCSType' for type 'gml:SphericalCSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__SphericalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__SphericalCSType (891)
#endif

/* __gml__CartesianCSPropertyType_sequence * has binding name 'PointerTo__gml__CartesianCSPropertyType_sequence' for type '-gml:CartesianCSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__CartesianCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__CartesianCSPropertyType_sequence (889)
#endif

/* gml__CartesianCSType * has binding name 'PointerTogml__CartesianCSType' for type 'gml:CartesianCSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CartesianCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CartesianCSType (888)
#endif

/* __gml__CoordinateSystemAxisPropertyType_sequence * has binding name 'PointerTo__gml__CoordinateSystemAxisPropertyType_sequence' for type '-gml:CoordinateSystemAxisPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__CoordinateSystemAxisPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__CoordinateSystemAxisPropertyType_sequence (886)
#endif

/* gml__CoordinateSystemAxisType * has binding name 'PointerTogml__CoordinateSystemAxisType' for type 'gml:CoordinateSystemAxisType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CoordinateSystemAxisType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CoordinateSystemAxisType (885)
#endif

/* __gml__EllipsoidalCSPropertyType_sequence * has binding name 'PointerTo__gml__EllipsoidalCSPropertyType_sequence' for type '-gml:EllipsoidalCSPropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__EllipsoidalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__EllipsoidalCSPropertyType_sequence (883)
#endif

/* gml__EllipsoidalCSType * has binding name 'PointerTogml__EllipsoidalCSType' for type 'gml:EllipsoidalCSType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__EllipsoidalCSType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__EllipsoidalCSType (882)
#endif

/* __gml__TimePrimitivePropertyType_sequence * has binding name 'PointerTo__gml__TimePrimitivePropertyType_sequence' for type '-gml:TimePrimitivePropertyType-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__TimePrimitivePropertyType_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__gml__TimePrimitivePropertyType_sequence (880)
#endif

/* enum _xlink__actuate * has binding name 'PointerTo_xlink__actuate' for type 'xlink:actuate' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_xlink__actuate
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_xlink__actuate (877)
#endif

/* enum _xlink__show * has binding name 'PointerTo_xlink__show' for type 'xlink:show' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_xlink__show
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo_xlink__show (876)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToxsd__anyURI
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToxsd__anyURI (875)
#endif

/* std::string * has binding name 'PointerTogml__NilReasonType' for type 'gml:NilReasonType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__NilReasonType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__NilReasonType (874)
#endif

/* gml__CodeType * has binding name 'PointerTogml__CodeType' for type 'gml:CodeType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CodeType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CodeType (872)
#endif

/* gml__CodeWithAuthorityType * has binding name 'PointerTogml__CodeWithAuthorityType' for type 'gml:CodeWithAuthorityType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CodeWithAuthorityType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__CodeWithAuthorityType (871)
#endif

/* gml__ReferenceType * has binding name 'PointerTogml__ReferenceType' for type 'gml:ReferenceType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__ReferenceType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__ReferenceType (870)
#endif

/* gml__StringOrRefType * has binding name 'PointerTogml__StringOrRefType' for type 'gml:StringOrRefType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__StringOrRefType
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTogml__StringOrRefType (869)
#endif

/* std::string * has binding name 'PointerToeml__DescriptionString' for type 'eml:DescriptionString' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__DescriptionString
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__DescriptionString (868)
#endif

/* eml__CustomData * has binding name 'PointerToeml__CustomData' for type 'eml:CustomData' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__CustomData
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__CustomData (867)
#endif

/* eml__ObjectAlias * has binding name 'PointerToeml__ObjectAlias' for type 'eml:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__ObjectAlias
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__ObjectAlias (865)
#endif

/* eml__Citation * has binding name 'PointerToeml__Citation' for type 'eml:Citation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__Citation
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__Citation (864)
#endif

/* std::string * has binding name 'PointerToeml__CommentString' for type 'eml:CommentString' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__CommentString
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__CommentString (863)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTodateTime
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTodateTime (862)
#endif

/* std::string * has binding name 'PointerToeml__NameString' for type 'eml:NameString' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__NameString
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__NameString (861)
#endif

/* resqml2__AbstractParameterKey * has binding name 'PointerToresqml2__AbstractParameterKey' for type 'resqml2:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractParameterKey (858)
#endif

/* resqml2__AbstractActivityParameter * has binding name 'PointerToresqml2__AbstractActivityParameter' for type 'resqml2:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractActivityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractActivityParameter (856)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTostd__string
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTostd__string (855)
#endif

/* resqml2__OrientedMacroFace * has binding name 'PointerToresqml2__OrientedMacroFace' for type 'resqml2:OrientedMacroFace' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__OrientedMacroFace
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__OrientedMacroFace (851)
#endif

/* resqml2__VolumeShell * has binding name 'PointerToresqml2__VolumeShell' for type 'resqml2:VolumeShell' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__VolumeShell
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__VolumeShell (849)
#endif

/* LONG64 * has binding name 'PointerToLONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToLONG64
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToLONG64 (848)
#endif

/* resqml2__TimeInterval * has binding name 'PointerToresqml2__TimeInterval' for type 'resqml2:TimeInterval' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TimeInterval
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TimeInterval (845)
#endif

/* resqml2__CellOverlap * has binding name 'PointerToresqml2__CellOverlap' for type 'resqml2:CellOverlap' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__CellOverlap
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__CellOverlap (843)
#endif

/* __resqml2__OverlapVolume_sequence * has binding name 'PointerTo__resqml2__OverlapVolume_sequence' for type '-resqml2:OverlapVolume-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__resqml2__OverlapVolume_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__resqml2__OverlapVolume_sequence (842)
#endif

/* __resqml2__CellOverlap_sequence * has binding name 'PointerTo__resqml2__CellOverlap_sequence' for type '-resqml2:CellOverlap-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__resqml2__CellOverlap_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__resqml2__CellOverlap_sequence (840)
#endif

/* resqml2__OverlapVolume * has binding name 'PointerToresqml2__OverlapVolume' for type 'resqml2:OverlapVolume' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__OverlapVolume
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__OverlapVolume (839)
#endif

/* resqml2__Intervals * has binding name 'PointerToresqml2__Intervals' for type 'resqml2:Intervals' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Intervals
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Intervals (836)
#endif

/* __resqml2__KGaps_sequence * has binding name 'PointerTo__resqml2__KGaps_sequence' for type '-resqml2:KGaps-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__resqml2__KGaps_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__resqml2__KGaps_sequence (835)
#endif

/* resqml2__AbstractBooleanArray * has binding name 'PointerToresqml2__AbstractBooleanArray' for type 'resqml2:AbstractBooleanArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractBooleanArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractBooleanArray (834)
#endif

/* resqml2__GpGridUnstructuredColumnLayerGridPatch * has binding name 'PointerToresqml2__GpGridUnstructuredColumnLayerGridPatch' for type 'resqml2:GpGridUnstructuredColumnLayerGridPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GpGridUnstructuredColumnLayerGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GpGridUnstructuredColumnLayerGridPatch (831)
#endif

/* resqml2__GpGridIjkGridPatch * has binding name 'PointerToresqml2__GpGridIjkGridPatch' for type 'resqml2:GpGridIjkGridPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GpGridIjkGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__GpGridIjkGridPatch (829)
#endif

/* resqml2__KGaps * has binding name 'PointerToresqml2__KGaps' for type 'resqml2:KGaps' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__KGaps
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__KGaps (828)
#endif

/* __resqml2__IjGaps_sequence * has binding name 'PointerTo__resqml2__IjGaps_sequence' for type '-resqml2:IjGaps-sequence' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__resqml2__IjGaps_sequence
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerTo__resqml2__IjGaps_sequence (827)
#endif

/* resqml2__ResqmlJaggedArray * has binding name 'PointerToresqml2__ResqmlJaggedArray' for type 'resqml2:ResqmlJaggedArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ResqmlJaggedArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ResqmlJaggedArray (826)
#endif

/* resqml2__UniformSubnodePatch * has binding name 'PointerToresqml2__UniformSubnodePatch' for type 'resqml2:UniformSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UniformSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UniformSubnodePatch (823)
#endif

/* resqml2__VariableSubnodePatch * has binding name 'PointerToresqml2__VariableSubnodePatch' for type 'resqml2:VariableSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__VariableSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__VariableSubnodePatch (821)
#endif

/* resqml2__ColumnLayerSubnodeTopology * has binding name 'PointerToresqml2__ColumnLayerSubnodeTopology' for type 'resqml2:ColumnLayerSubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ColumnLayerSubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ColumnLayerSubnodeTopology (820)
#endif

/* resqml2__UnstructuredSubnodeTopology * has binding name 'PointerToresqml2__UnstructuredSubnodeTopology' for type 'resqml2:UnstructuredSubnodeTopology' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredSubnodeTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredSubnodeTopology (819)
#endif

/* resqml2__IjSplitColumnEdges * has binding name 'PointerToresqml2__IjSplitColumnEdges' for type 'resqml2:IjSplitColumnEdges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IjSplitColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__IjSplitColumnEdges (818)
#endif

/* resqml2__SplitFaces * has binding name 'PointerToresqml2__SplitFaces' for type 'resqml2:SplitFaces' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SplitFaces
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SplitFaces (817)
#endif

/* resqml2__UnstructuredColumnEdges * has binding name 'PointerToresqml2__UnstructuredColumnEdges' for type 'resqml2:UnstructuredColumnEdges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__UnstructuredColumnEdges (816)
#endif

/* resqml2__ColumnLayerSplitColumnEdges * has binding name 'PointerToresqml2__ColumnLayerSplitColumnEdges' for type 'resqml2:ColumnLayerSplitColumnEdges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ColumnLayerSplitColumnEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ColumnLayerSplitColumnEdges (815)
#endif

/* resqml2__SplitNodePatch * has binding name 'PointerToresqml2__SplitNodePatch' for type 'resqml2:SplitNodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SplitNodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SplitNodePatch (814)
#endif

/* resqml2__SplitEdges * has binding name 'PointerToresqml2__SplitEdges' for type 'resqml2:SplitEdges' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SplitEdges
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__SplitEdges (813)
#endif

/* resqml2__AbstractGeometry * has binding name 'PointerToresqml2__AbstractGeometry' for type 'resqml2:AbstractGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractGeometry (812)
#endif

/* resqml2__AdditionalGridTopology * has binding name 'PointerToresqml2__AdditionalGridTopology' for type 'resqml2:AdditionalGridTopology' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AdditionalGridTopology
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AdditionalGridTopology (811)
#endif

/* resqml2__ElementIdentity * has binding name 'PointerToresqml2__ElementIdentity' for type 'resqml2:ElementIdentity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ElementIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__ElementIdentity (809)
#endif

/* resqml2__AbstractIntegerArray * has binding name 'PointerToresqml2__AbstractIntegerArray' for type 'resqml2:AbstractIntegerArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractIntegerArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractIntegerArray (808)
#endif

/* eml__DataObjectReference * has binding name 'PointerToeml__DataObjectReference' for type 'eml:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__DataObjectReference
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToeml__DataObjectReference (806)
#endif

/* resqml2__TimeIndex * has binding name 'PointerToresqml2__TimeIndex' for type 'resqml2:TimeIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TimeIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__TimeIndex (805)
#endif

/* resqml2__AbstractDoubleArray * has binding name 'PointerToresqml2__AbstractDoubleArray' for type 'resqml2:AbstractDoubleArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractDoubleArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractDoubleArray (804)
#endif

/* resqml2__Point3d * has binding name 'PointerToresqml2__Point3d' for type 'resqml2:Point3d' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Point3d
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__Point3d (803)
#endif

/* resqml2__AbstractValueArray * has binding name 'PointerToresqml2__AbstractValueArray' for type 'resqml2:AbstractValueArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractValueArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractValueArray (802)
#endif

/* resqml2__AbstractPoint3dArray * has binding name 'PointerToresqml2__AbstractPoint3dArray' for type 'resqml2:AbstractPoint3dArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractPoint3dArray
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToresqml2__AbstractPoint3dArray (801)
#endif

/* ULONG64 * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_resqml2_0_1_PointerToxsd__nonNegativeInteger (800)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__XML
#define SOAP_TYPE_gsoap_resqml2_0_1__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1__QName
#define SOAP_TYPE_gsoap_resqml2_0_1__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_string
#define SOAP_TYPE_gsoap_resqml2_0_1_string (4)
#endif

/* std::vector<resqml2__SealedContactRepresentationPart *>  has binding name 'std__vectorTemplateOfPointerToresqml2__SealedContactRepresentationPart' for type 'resqml2:SealedContactRepresentationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__SealedContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__SealedContactRepresentationPart (1198)
#endif

/* std::vector<resqml2__AbstractContactRepresentationPart *>  has binding name 'std__vectorTemplateOfPointerToresqml2__AbstractContactRepresentationPart' for type 'resqml2:AbstractContactRepresentationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractContactRepresentationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractContactRepresentationPart (1196)
#endif

/* std::vector<resqml2__GeologicUnitInterpretationIndex *>  has binding name 'std__vectorTemplateOfPointerToresqml2__GeologicUnitInterpretationIndex' for type 'resqml2:GeologicUnitInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GeologicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GeologicUnitInterpretationIndex (1194)
#endif

/* std::vector<resqml2__StratigraphicUnitInterpretationIndex *>  has binding name 'std__vectorTemplateOfPointerToresqml2__StratigraphicUnitInterpretationIndex' for type 'resqml2:StratigraphicUnitInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__StratigraphicUnitInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__StratigraphicUnitInterpretationIndex (1192)
#endif

/* std::vector<resqml2__Grid2dPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__Grid2dPatch' for type 'resqml2:Grid2dPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__Grid2dPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__Grid2dPatch (1179)
#endif

/* std::vector<resqml2__VolumeRegion *>  has binding name 'std__vectorTemplateOfPointerToresqml2__VolumeRegion' for type 'resqml2:VolumeRegion' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__VolumeRegion
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__VolumeRegion (1177)
#endif

/* std::vector<resqml2__ContactIdentity *>  has binding name 'std__vectorTemplateOfPointerToresqml2__ContactIdentity' for type 'resqml2:ContactIdentity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ContactIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ContactIdentity (1175)
#endif

/* std::vector<resqml2__AbstractPlaneGeometry *>  has binding name 'std__vectorTemplateOfPointerToresqml2__AbstractPlaneGeometry' for type 'resqml2:AbstractPlaneGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractPlaneGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractPlaneGeometry (1173)
#endif

/* std::vector<resqml2__TrianglePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__TrianglePatch' for type 'resqml2:TrianglePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__TrianglePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__TrianglePatch (1171)
#endif

/* std::vector<resqml2__WellboreMarker *>  has binding name 'std__vectorTemplateOfPointerToresqml2__WellboreMarker' for type 'resqml2:WellboreMarker' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__WellboreMarker
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__WellboreMarker (1169)
#endif

/* std::vector<resqml2__FaultThrow *>  has binding name 'std__vectorTemplateOfPointerToresqml2__FaultThrow' for type 'resqml2:FaultThrow' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__FaultThrow
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__FaultThrow (1164)
#endif

/* std::vector<resqml2__HorizonInterpretationIndex *>  has binding name 'std__vectorTemplateOfPointerToresqml2__HorizonInterpretationIndex' for type 'resqml2:HorizonInterpretationIndex' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__HorizonInterpretationIndex
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__HorizonInterpretationIndex (1161)
#endif

/* std::vector<enum resqml2__BoundaryRelation>  has binding name 'std__vectorTemplateOfresqml2__BoundaryRelation' for type 'resqml2:BoundaryRelation' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfresqml2__BoundaryRelation
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfresqml2__BoundaryRelation (1159)
#endif

/* std::vector<resqml2__GpGridUnstructuredGridPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__GpGridUnstructuredGridPatch' for type 'resqml2:GpGridUnstructuredGridPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GpGridUnstructuredGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GpGridUnstructuredGridPatch (1156)
#endif

/* std::vector<resqml2__GpGridColumnLayerGrid *>  has binding name 'std__vectorTemplateOfPointerToresqml2__GpGridColumnLayerGrid' for type 'resqml2:GpGridColumnLayerGrid' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GpGridColumnLayerGrid
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GpGridColumnLayerGrid (1154)
#endif

/* std::vector<LONG64>  has binding name 'std__vectorTemplateOfxsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfxsd__integer
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfxsd__integer (1152)
#endif

/* std::vector<double>  has binding name 'std__vectorTemplateOfdouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfdouble
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfdouble (1151)
#endif

/* std::vector<_gml__coordinateOperationAccuracy *>  has binding name 'std__vectorTemplateOfPointerTo_gml__coordinateOperationAccuracy' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTo_gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTo_gml__coordinateOperationAccuracy (1149)
#endif

/* std::vector<gml__CoordinateSystemAxisPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType' for type 'gml:CoordinateSystemAxisPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogml__CoordinateSystemAxisPropertyType (1142)
#endif

/* std::vector<_gml__domainOfValidity *>  has binding name 'std__vectorTemplateOfPointerTo_gml__domainOfValidity' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTo_gml__domainOfValidity
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTo_gml__domainOfValidity (1140)
#endif

/* std::vector<resqml2__PatchBoundaries *>  has binding name 'std__vectorTemplateOfPointerToresqml2__PatchBoundaries' for type 'resqml2:PatchBoundaries' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PatchBoundaries
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PatchBoundaries (1136)
#endif

/* std::vector<resqml2__PolylineSetPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__PolylineSetPatch' for type 'resqml2:PolylineSetPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PolylineSetPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PolylineSetPatch (1134)
#endif

/* std::vector<resqml2__NodePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__NodePatch' for type 'resqml2:NodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__NodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__NodePatch (1131)
#endif

/* std::vector<resqml2__AbstractContactInterpretationPart *>  has binding name 'std__vectorTemplateOfPointerToresqml2__AbstractContactInterpretationPart' for type 'resqml2:AbstractContactInterpretationPart' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractContactInterpretationPart
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractContactInterpretationPart (1123)
#endif

/* std::vector<resqml2__SubRepresentationPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__SubRepresentationPatch' for type 'resqml2:SubRepresentationPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__SubRepresentationPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__SubRepresentationPatch (1116)
#endif

/* std::vector<resqml2__PatchOfGeometry *>  has binding name 'std__vectorTemplateOfPointerToresqml2__PatchOfGeometry' for type 'resqml2:PatchOfGeometry' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PatchOfGeometry
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PatchOfGeometry (1114)
#endif

/* std::vector<resqml2__PropertyKindFacet *>  has binding name 'std__vectorTemplateOfPointerToresqml2__PropertyKindFacet' for type 'resqml2:PropertyKindFacet' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PropertyKindFacet
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PropertyKindFacet (1112)
#endif

/* std::vector<resqml2__PatchOfValues *>  has binding name 'std__vectorTemplateOfPointerToresqml2__PatchOfValues' for type 'resqml2:PatchOfValues' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PatchOfValues
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PatchOfValues (1110)
#endif

/* std::vector<resqml2__StringLookup *>  has binding name 'std__vectorTemplateOfPointerToresqml2__StringLookup' for type 'resqml2:StringLookup' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__StringLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__StringLookup (1108)
#endif

/* std::vector<resqml2__PatchOfPoints *>  has binding name 'std__vectorTemplateOfPointerToresqml2__PatchOfPoints' for type 'resqml2:PatchOfPoints' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PatchOfPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__PatchOfPoints (1106)
#endif

/* std::vector<resqml2__DoubleLookup *>  has binding name 'std__vectorTemplateOfPointerToresqml2__DoubleLookup' for type 'resqml2:DoubleLookup' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__DoubleLookup
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__DoubleLookup (1104)
#endif

/* std::vector<resqml2__ParameterTemplate *>  has binding name 'std__vectorTemplateOfPointerToresqml2__ParameterTemplate' for type 'resqml2:ParameterTemplate' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ParameterTemplate
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ParameterTemplate (1102)
#endif

/* std::vector<resqml2__Timestamp *>  has binding name 'std__vectorTemplateOfPointerToresqml2__Timestamp' for type 'resqml2:Timestamp' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__Timestamp
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__Timestamp (1096)
#endif

/* std::vector<resqml2__ChronostratigraphicRank *>  has binding name 'std__vectorTemplateOfPointerToresqml2__ChronostratigraphicRank' for type 'resqml2:ChronostratigraphicRank' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ChronostratigraphicRank
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ChronostratigraphicRank (1093)
#endif

/* std::vector<resqml2__RepresentationIdentity *>  has binding name 'std__vectorTemplateOfPointerToresqml2__RepresentationIdentity' for type 'resqml2:RepresentationIdentity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__RepresentationIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__RepresentationIdentity (1088)
#endif

/* std::vector<gml__RelatedTimeType *>  has binding name 'std__vectorTemplateOfPointerTogml__RelatedTimeType' for type 'gml:RelatedTimeType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogml__RelatedTimeType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogml__RelatedTimeType (1085)
#endif

/* std::vector<resqml2__EdgePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__EdgePatch' for type 'resqml2:EdgePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__EdgePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__EdgePatch (1080)
#endif

/* std::vector<resqml2__NameValuePair *>  has binding name 'std__vectorTemplateOfPointerToresqml2__NameValuePair' for type 'resqml2:NameValuePair' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__NameValuePair
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__NameValuePair (1078)
#endif

/* std::vector<resqml2__AdditionalGridPoints *>  has binding name 'std__vectorTemplateOfPointerToresqml2__AdditionalGridPoints' for type 'resqml2:AdditionalGridPoints' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AdditionalGridPoints
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AdditionalGridPoints (1076)
#endif

/* std::vector<resqml2__ElementIndices *>  has binding name 'std__vectorTemplateOfPointerToresqml2__ElementIndices' for type 'resqml2:ElementIndices' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ElementIndices
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ElementIndices (1074)
#endif

/* std::vector<resqml2__ThreePoint3d *>  has binding name 'std__vectorTemplateOfPointerToresqml2__ThreePoint3d' for type 'resqml2:ThreePoint3d' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ThreePoint3d
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ThreePoint3d (1072)
#endif

/* std::vector<resqml2__IntegerConstantArray *>  has binding name 'std__vectorTemplateOfPointerToresqml2__IntegerConstantArray' for type 'resqml2:IntegerConstantArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__IntegerConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__IntegerConstantArray (1070)
#endif

/* std::vector<resqml2__DoubleConstantArray *>  has binding name 'std__vectorTemplateOfPointerToresqml2__DoubleConstantArray' for type 'resqml2:DoubleConstantArray' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__DoubleConstantArray
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__DoubleConstantArray (1068)
#endif

/* std::vector<gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType' for type 'gmd:CI_PresentationFormCode_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__CI_USCOREPresentationFormCode_USCOREPropertyType (1057)
#endif

/* std::vector<gmd__CI_USCOREResponsibleParty_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType' for type 'gmd:CI_ResponsibleParty_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__CI_USCOREResponsibleParty_USCOREPropertyType (1055)
#endif

/* std::vector<gmd__MD_USCOREIdentifier_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__MD_USCOREIdentifier_USCOREPropertyType' for type 'gmd:MD_Identifier_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__MD_USCOREIdentifier_USCOREPropertyType (1053)
#endif

/* std::vector<gmd__CI_USCOREDate_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__CI_USCOREDate_USCOREPropertyType' for type 'gmd:CI_Date_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__CI_USCOREDate_USCOREPropertyType (1051)
#endif

/* std::vector<gmd__DQ_USCOREResult_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__DQ_USCOREResult_USCOREPropertyType' for type 'gmd:DQ_Result_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__DQ_USCOREResult_USCOREPropertyType (1049)
#endif

/* std::vector<gco__DateTime_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__DateTime_USCOREPropertyType' for type 'gco:DateTime_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogco__DateTime_USCOREPropertyType (1047)
#endif

/* std::vector<gco__CharacterString_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogco__CharacterString_USCOREPropertyType' for type 'gco:CharacterString_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogco__CharacterString_USCOREPropertyType (1042)
#endif

/* std::vector<gmd__EX_USCOREVerticalExtent_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType' for type 'gmd:EX_VerticalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__EX_USCOREVerticalExtent_USCOREPropertyType (1037)
#endif

/* std::vector<gmd__EX_USCORETemporalExtent_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType' for type 'gmd:EX_TemporalExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__EX_USCORETemporalExtent_USCOREPropertyType (1035)
#endif

/* std::vector<gmd__EX_USCOREGeographicExtent_USCOREPropertyType *>  has binding name 'std__vectorTemplateOfPointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType' for type 'gmd:EX_GeographicExtent_PropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogmd__EX_USCOREGeographicExtent_USCOREPropertyType (1033)
#endif

/* std::vector<resqml2__ContactPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__ContactPatch' for type 'resqml2:ContactPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ContactPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ContactPatch (1024)
#endif

/* std::vector<ULONG64>  has binding name 'std__vectorTemplateOfxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfxsd__nonNegativeInteger
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfxsd__nonNegativeInteger (1022)
#endif

/* std::vector<resqml2__ColumnSubnodePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__ColumnSubnodePatch' for type 'resqml2:ColumnSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ColumnSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ColumnSubnodePatch (1016)
#endif

/* std::vector<resqml2__Point3dOffset *>  has binding name 'std__vectorTemplateOfPointerToresqml2__Point3dOffset' for type 'resqml2:Point3dOffset' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__Point3dOffset
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__Point3dOffset (1006)
#endif

/* std::vector<ptm__equivalentPropertyType *>  has binding name 'std__vectorTemplateOfPointerToptm__equivalentPropertyType' for type 'ptm:equivalentPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToptm__equivalentPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToptm__equivalentPropertyType (1002)
#endif

/* std::vector<ptm__standardEnergisticsPropertyType *>  has binding name 'std__vectorTemplateOfPointerToptm__standardEnergisticsPropertyType' for type 'ptm:standardEnergisticsPropertyType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToptm__standardEnergisticsPropertyType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToptm__standardEnergisticsPropertyType (998)
#endif

/* std::vector<gml__CodeType *>  has binding name 'std__vectorTemplateOfPointerTogml__CodeType' for type 'gml:CodeType' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogml__CodeType
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerTogml__CodeType (873)
#endif

/* std::vector<eml__ObjectAlias *>  has binding name 'std__vectorTemplateOfPointerToeml__ObjectAlias' for type 'eml:ObjectAlias' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToeml__ObjectAlias
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToeml__ObjectAlias (866)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOf_XML
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOf_XML (860)
#endif

/* std::vector<resqml2__AbstractParameterKey *>  has binding name 'std__vectorTemplateOfPointerToresqml2__AbstractParameterKey' for type 'resqml2:AbstractParameterKey' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractParameterKey
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractParameterKey (859)
#endif

/* std::vector<resqml2__AbstractActivityParameter *>  has binding name 'std__vectorTemplateOfPointerToresqml2__AbstractActivityParameter' for type 'resqml2:AbstractActivityParameter' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractActivityParameter
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__AbstractActivityParameter (857)
#endif

/* std::vector<enum resqml2__ParameterKind>  has binding name 'std__vectorTemplateOfresqml2__ParameterKind' for type 'resqml2:ParameterKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfresqml2__ParameterKind
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfresqml2__ParameterKind (854)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfstd__string
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfstd__string (853)
#endif

/* std::vector<resqml2__OrientedMacroFace *>  has binding name 'std__vectorTemplateOfPointerToresqml2__OrientedMacroFace' for type 'resqml2:OrientedMacroFace' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__OrientedMacroFace
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__OrientedMacroFace (852)
#endif

/* std::vector<resqml2__VolumeShell *>  has binding name 'std__vectorTemplateOfPointerToresqml2__VolumeShell' for type 'resqml2:VolumeShell' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__VolumeShell
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__VolumeShell (850)
#endif

/* std::vector<enum resqml2__ThrowKind>  has binding name 'std__vectorTemplateOfresqml2__ThrowKind' for type 'resqml2:ThrowKind' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfresqml2__ThrowKind
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfresqml2__ThrowKind (844)
#endif

/* std::vector<eml__DataObjectReference *>  has binding name 'std__vectorTemplateOfPointerToeml__DataObjectReference' for type 'eml:DataObjectReference' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToeml__DataObjectReference
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToeml__DataObjectReference (837)
#endif

/* std::vector<resqml2__GpGridUnstructuredColumnLayerGridPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__GpGridUnstructuredColumnLayerGridPatch' for type 'resqml2:GpGridUnstructuredColumnLayerGridPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GpGridUnstructuredColumnLayerGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GpGridUnstructuredColumnLayerGridPatch (832)
#endif

/* std::vector<resqml2__GpGridIjkGridPatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__GpGridIjkGridPatch' for type 'resqml2:GpGridIjkGridPatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GpGridIjkGridPatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__GpGridIjkGridPatch (830)
#endif

/* std::vector<resqml2__UniformSubnodePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__UniformSubnodePatch' for type 'resqml2:UniformSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__UniformSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__UniformSubnodePatch (824)
#endif

/* std::vector<resqml2__VariableSubnodePatch *>  has binding name 'std__vectorTemplateOfPointerToresqml2__VariableSubnodePatch' for type 'resqml2:VariableSubnodePatch' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__VariableSubnodePatch
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__VariableSubnodePatch (822)
#endif

/* std::vector<resqml2__ElementIdentity *>  has binding name 'std__vectorTemplateOfPointerToresqml2__ElementIdentity' for type 'resqml2:ElementIdentity' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ElementIdentity
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__ElementIdentity (810)
#endif

/* std::vector<resqml2__Point3d *>  has binding name 'std__vectorTemplateOfPointerToresqml2__Point3d' for type 'resqml2:Point3d' */
#ifndef SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__Point3d
#define SOAP_TYPE_gsoap_resqml2_0_1_std__vectorTemplateOfPointerToresqml2__Point3d (807)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace gsoap_resqml2_0_1


#endif

/* End of gsoap_resqml2_0_1Stub.h */
