/* gsoap_witsml1_4_1_1Stub.h
   Generated by gSOAP 2.8.27 from witsml1_4_1_1ForGsoap.h

gSOAP XML Web services tools
Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool is licensed for commercial use, no resale/redistribution.
--------------------------------------------------------------------------------
Product and source code licensed by Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_witsml1	"http://www.witsml.org/schemas/1series"
#define SOAP_NAMESPACE_OF_abstract	"http://www.energistics.org/schemas/abstract"
#define SOAP_NAMESPACE_OF_gml	"http://www.opengis.net/gml/3.2"
#define SOAP_NAMESPACE_OF_xlink	"http://www.w3.org/1999/xlink"
#define SOAP_NAMESPACE_OF_gmd	"http://www.isotc211.org/2005/gmd"
#define SOAP_NAMESPACE_OF_gts	"http://www.isotc211.org/2005/gts"
#define SOAP_NAMESPACE_OF_gco	"http://www.isotc211.org/2005/gco"
#define SOAP_NAMESPACE_OF_gsr	"http://www.isotc211.org/2005/gsr"

#ifndef gsoap_witsml1_4_1_1Stub_H
#define gsoap_witsml1_4_1_1Stub_H
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20827
# error "GSOAP VERSION 20827 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace gsoap_witsml1_4_1_1 {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* witsml1_4_1_1ForGsoap.h:1018 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AggregationType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AggregationType (239)
/* gml:AggregationType */
enum gml__AggregationType
{
	gml__AggregationType__set = 0,
	gml__AggregationType__bag = 1,
	gml__AggregationType__sequence = 2,
	gml__AggregationType__array = 3,
	gml__AggregationType__record = 4,
	gml__AggregationType__table = 5
};
#endif

/* witsml1_4_1_1ForGsoap.h:1045 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__show
#define SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__show (240)
/* xlink:show */
enum _xlink__show
{
	_xlink__show__new_ = 0,
	_xlink__show__replace = 1,
	_xlink__show__embed = 2,
	_xlink__show__other = 3,
	_xlink__show__none = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:1061 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__actuate
#define SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__actuate (241)
/* xlink:actuate */
enum _xlink__actuate
{
	_xlink__actuate__onLoad = 0,
	_xlink__actuate__onRequest = 1,
	_xlink__actuate__other = 2,
	_xlink__actuate__none = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:1536 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PercentUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PercentUom (286)
/* witsml1:PercentUom */
enum witsml1__PercentUom
{
	witsml1__PercentUom___x0025 = 0
};
#endif

/* witsml1_4_1_1ForGsoap.h:1547 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MeasuredDepthUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MeasuredDepthUom (287)
/* witsml1:MeasuredDepthUom */
enum witsml1__MeasuredDepthUom
{
	witsml1__MeasuredDepthUom__m = 109,
	witsml1__MeasuredDepthUom__ft = 110,
	witsml1__MeasuredDepthUom__ftUS = 111
};
#endif

/* witsml1_4_1_1ForGsoap.h:1569 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellVerticalCoordinateUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellVerticalCoordinateUom (288)
/* witsml1:WellVerticalCoordinateUom */
enum witsml1__WellVerticalCoordinateUom
{
	witsml1__WellVerticalCoordinateUom__m = 109,
	witsml1__WellVerticalCoordinateUom__ft = 110,
	witsml1__WellVerticalCoordinateUom__ftUS = 111,
	witsml1__WellVerticalCoordinateUom__ftBr_x002865_x0029 = 112
};
#endif

/* witsml1_4_1_1ForGsoap.h:1592 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AccelerationLinearUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AccelerationLinearUom (289)
/* witsml1:AccelerationLinearUom */
enum witsml1__AccelerationLinearUom
{
	witsml1__AccelerationLinearUom__m_x002fs2 = 0,
	witsml1__AccelerationLinearUom__cm_x002fs2 = 1,
	witsml1__AccelerationLinearUom__ft_x002fs2 = 2,
	witsml1__AccelerationLinearUom__Gal = 3,
	witsml1__AccelerationLinearUom__mgn = 4,
	witsml1__AccelerationLinearUom__gn = 5,
	witsml1__AccelerationLinearUom__mGal = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:1606 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AnglePerLengthUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AnglePerLengthUom (290)
/* witsml1:AnglePerLengthUom */
enum witsml1__AnglePerLengthUom
{
	witsml1__AnglePerLengthUom__rad_x002fm = 0,
	witsml1__AnglePerLengthUom__dega_x002f30ft = 1,
	witsml1__AnglePerLengthUom__dega_x002fft = 2,
	witsml1__AnglePerLengthUom__dega_x002f100ft = 3,
	witsml1__AnglePerLengthUom__dega_x002fm = 4,
	witsml1__AnglePerLengthUom__dega_x002f30m = 5,
	witsml1__AnglePerLengthUom__rad_x002fft = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:1620 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AnglePerTimeUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AnglePerTimeUom (291)
/* witsml1:AnglePerTimeUom */
enum witsml1__AnglePerTimeUom
{
	witsml1__AnglePerTimeUom__rad_x002fs = 0,
	witsml1__AnglePerTimeUom__c_x002fs = 1,
	witsml1__AnglePerTimeUom__dega_x002fh = 2,
	witsml1__AnglePerTimeUom__dega_x002fmin = 3,
	witsml1__AnglePerTimeUom__dega_x002fs = 4,
	witsml1__AnglePerTimeUom__rev_x002fs = 5,
	witsml1__AnglePerTimeUom__rpm = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:1634 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AreaUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AreaUom (292)
/* witsml1:AreaUom */
enum witsml1__AreaUom
{
	witsml1__AreaUom__b = 98,
	witsml1__AreaUom__m2 = 99,
	witsml1__AreaUom__acre = 100,
	witsml1__AreaUom__cm2 = 101,
	witsml1__AreaUom__ft2 = 102,
	witsml1__AreaUom__ha = 103,
	witsml1__AreaUom__in2 = 104,
	witsml1__AreaUom__km2 = 105,
	witsml1__AreaUom__mi2 = 106,
	witsml1__AreaUom__miUS2 = 107,
	witsml1__AreaUom__mm2 = 108,
	witsml1__AreaUom__um2 = 109,
	witsml1__AreaUom__yd2 = 110
};
#endif

/* witsml1_4_1_1ForGsoap.h:1654 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AreaPerAreaUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AreaPerAreaUom (293)
/* witsml1:AreaPerAreaUom */
enum witsml1__AreaPerAreaUom
{
	witsml1__AreaPerAreaUom__Euc = 0,
	witsml1__AreaPerAreaUom___x0025 = 1,
	witsml1__AreaPerAreaUom__in2_x002fft2 = 2,
	witsml1__AreaPerAreaUom__in2_x002fin2 = 3,
	witsml1__AreaPerAreaUom__m2_x002fm2 = 4,
	witsml1__AreaPerAreaUom__mm2_x002fmm2 = 5
};
#endif

/* witsml1_4_1_1ForGsoap.h:1667 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__CompressibilityUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__CompressibilityUom (294)
/* witsml1:CompressibilityUom */
enum witsml1__CompressibilityUom
{
	witsml1__CompressibilityUom__1_x002fpsi = 0,
	witsml1__CompressibilityUom__1_x002fupsi = 1,
	witsml1__CompressibilityUom__1_x002fPa = 2,
	witsml1__CompressibilityUom__1_x002fbar = 3,
	witsml1__CompressibilityUom__1_x002fkPa = 4,
	witsml1__CompressibilityUom__1_x002fpPa = 5
};
#endif

/* witsml1_4_1_1ForGsoap.h:1680 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DensityUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DensityUom (295)
/* witsml1:DensityUom */
enum witsml1__DensityUom
{
	witsml1__DensityUom__kg_x002fm3 = 0,
	witsml1__DensityUom__10Mg_x002fm3 = 1,
	witsml1__DensityUom__dAPI = 2,
	witsml1__DensityUom__g_x002fcm3 = 3,
	witsml1__DensityUom__g_x002fdm3 = 4,
	witsml1__DensityUom__g_x002fgalUK = 5,
	witsml1__DensityUom__g_x002fgalUS = 6,
	witsml1__DensityUom__g_x002fL = 7,
	witsml1__DensityUom__g_x002fm3 = 8,
	witsml1__DensityUom__grain_x002fft3 = 9,
	witsml1__DensityUom__grain_x002fgalUS = 10,
	witsml1__DensityUom__grain_x002f100ft3 = 11,
	witsml1__DensityUom__kg_x002fdm3 = 12,
	witsml1__DensityUom__kg_x002fL = 13,
	witsml1__DensityUom__Mg_x002fm3 = 14,
	witsml1__DensityUom__lbm_x002f10bbl = 15,
	witsml1__DensityUom__lbm_x002fbbl = 16,
	witsml1__DensityUom__lbm_x002fft3 = 17,
	witsml1__DensityUom__lbm_x002fgalUK = 18,
	witsml1__DensityUom__lbm_x002f1000galUK = 19,
	witsml1__DensityUom__lbm_x002fgalUS = 20,
	witsml1__DensityUom__lbm_x002f1000galUS = 21,
	witsml1__DensityUom__lbm_x002fin3 = 22,
	witsml1__DensityUom__lbm_x002fMbbl = 23,
	witsml1__DensityUom__mg_x002fdm3 = 24,
	witsml1__DensityUom__mg_x002fgalUS = 25,
	witsml1__DensityUom__mg_x002fL = 26,
	witsml1__DensityUom__mg_x002fm3 = 27,
	witsml1__DensityUom__ug_x002fcm3 = 28
};
#endif

/* witsml1_4_1_1ForGsoap.h:1716 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DimensionlessUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DimensionlessUom (296)
/* witsml1:DimensionlessUom */
enum witsml1__DimensionlessUom
{
	witsml1__DimensionlessUom__Euc = 0,
	witsml1__DimensionlessUom___x0025 = 1,
	witsml1__DimensionlessUom__cEuc = 2,
	witsml1__DimensionlessUom__mEuc = 3,
	witsml1__DimensionlessUom__nEuc = 4,
	witsml1__DimensionlessUom__uEuc = 5
};
#endif

/* witsml1_4_1_1ForGsoap.h:1729 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DynamicViscosityUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DynamicViscosityUom (297)
/* witsml1:DynamicViscosityUom */
enum witsml1__DynamicViscosityUom
{
	witsml1__DynamicViscosityUom__P = 80,
	witsml1__DynamicViscosityUom__Pa_x002es = 81,
	witsml1__DynamicViscosityUom__cP = 82,
	witsml1__DynamicViscosityUom__psi_x002es = 83,
	witsml1__DynamicViscosityUom__dyne_x002es_x002fcm2 = 84,
	witsml1__DynamicViscosityUom__kgf_x002es_x002fm2 = 85,
	witsml1__DynamicViscosityUom__lbf_x002es_x002fft2 = 86,
	witsml1__DynamicViscosityUom__lbf_x002es_x002fin2 = 87,
	witsml1__DynamicViscosityUom__mPa_x002es = 88,
	witsml1__DynamicViscosityUom__N_x002es_x002fm2 = 89
};
#endif

/* witsml1_4_1_1ForGsoap.h:1746 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ElectricCurrentUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ElectricCurrentUom (298)
/* witsml1:ElectricCurrentUom */
enum witsml1__ElectricCurrentUom
{
	witsml1__ElectricCurrentUom__A = 65,
	witsml1__ElectricCurrentUom__MA = 66,
	witsml1__ElectricCurrentUom__kA = 67,
	witsml1__ElectricCurrentUom__mA = 68,
	witsml1__ElectricCurrentUom__nA = 69,
	witsml1__ElectricCurrentUom__pA = 70,
	witsml1__ElectricCurrentUom__uA = 71
};
#endif

/* witsml1_4_1_1ForGsoap.h:1760 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ElectricPotentialUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ElectricPotentialUom (299)
/* witsml1:ElectricPotentialUom */
enum witsml1__ElectricPotentialUom
{
	witsml1__ElectricPotentialUom__V = 86,
	witsml1__ElectricPotentialUom__kV = 87,
	witsml1__ElectricPotentialUom__mV = 88,
	witsml1__ElectricPotentialUom__MV = 89,
	witsml1__ElectricPotentialUom__uV = 90
};
#endif

/* witsml1_4_1_1ForGsoap.h:1772 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__EquivalentPerMassUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__EquivalentPerMassUom (300)
/* witsml1:EquivalentPerMassUom */
enum witsml1__EquivalentPerMassUom
{
	witsml1__EquivalentPerMassUom__eq_x002fkg = 0,
	witsml1__EquivalentPerMassUom__meq_x002fg = 1,
	witsml1__EquivalentPerMassUom__meq_x002f100g = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:1782 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ForceUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ForceUom (301)
/* witsml1:ForceUom */
enum witsml1__ForceUom
{
	witsml1__ForceUom__N = 78,
	witsml1__ForceUom__daN = 79,
	witsml1__ForceUom__dyne = 80,
	witsml1__ForceUom__gf = 81,
	witsml1__ForceUom__kdyne = 82,
	witsml1__ForceUom__kgf = 83,
	witsml1__ForceUom__klbf = 84,
	witsml1__ForceUom__kN = 85,
	witsml1__ForceUom__lbf = 86,
	witsml1__ForceUom__Mgf = 87,
	witsml1__ForceUom__mN = 88,
	witsml1__ForceUom__MN = 89,
	witsml1__ForceUom__ozf = 90,
	witsml1__ForceUom__pdl = 91,
	witsml1__ForceUom__tonfUK = 92,
	witsml1__ForceUom__tonfUS = 93,
	witsml1__ForceUom__uN = 94
};
#endif

/* witsml1_4_1_1ForGsoap.h:1806 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ForcePerLengthUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ForcePerLengthUom (302)
/* witsml1:ForcePerLengthUom */
enum witsml1__ForcePerLengthUom
{
	witsml1__ForcePerLengthUom__N_x002f30m = 0,
	witsml1__ForcePerLengthUom__N_x002fm = 1,
	witsml1__ForcePerLengthUom__dyne_x002fcm = 2,
	witsml1__ForcePerLengthUom__kN_x002fm = 3,
	witsml1__ForcePerLengthUom__kgf_x002fcm = 4,
	witsml1__ForcePerLengthUom__lbf_x002f100ft = 5,
	witsml1__ForcePerLengthUom__lbf_x002f30m = 6,
	witsml1__ForcePerLengthUom__lbf_x002fft = 7,
	witsml1__ForcePerLengthUom__lbf_x002fin = 8,
	witsml1__ForcePerLengthUom__mN_x002fkm = 9,
	witsml1__ForcePerLengthUom__mN_x002fm = 10,
	witsml1__ForcePerLengthUom__pdl_x002fcm = 11,
	witsml1__ForcePerLengthUom__tonfUK_x002fft = 12,
	witsml1__ForcePerLengthUom__tonfUS_x002fft = 13
};
#endif

/* witsml1_4_1_1ForGsoap.h:1827 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ForcePerVolumeUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ForcePerVolumeUom (303)
/* witsml1:ForcePerVolumeUom */
enum witsml1__ForcePerVolumeUom
{
	witsml1__ForcePerVolumeUom__N_x002fm3 = 0,
	witsml1__ForcePerVolumeUom__atm_x002f100m = 1,
	witsml1__ForcePerVolumeUom__atm_x002fm = 2,
	witsml1__ForcePerVolumeUom__bar_x002fkm = 3,
	witsml1__ForcePerVolumeUom__bar_x002fm = 4,
	witsml1__ForcePerVolumeUom__GPa_x002fcm = 5,
	witsml1__ForcePerVolumeUom__kPa_x002f100m = 6,
	witsml1__ForcePerVolumeUom__kPa_x002fm = 7,
	witsml1__ForcePerVolumeUom__lbf_x002fft3 = 8,
	witsml1__ForcePerVolumeUom__lbf_x002fgalUS = 9,
	witsml1__ForcePerVolumeUom__MPa_x002fm = 10,
	witsml1__ForcePerVolumeUom__psi_x002fft = 11,
	witsml1__ForcePerVolumeUom__psi_x002f100ft = 12,
	witsml1__ForcePerVolumeUom__psi_x002fkft = 13,
	witsml1__ForcePerVolumeUom__psi_x002fm = 14,
	witsml1__ForcePerVolumeUom__Pa_x002fm = 15,
	witsml1__ForcePerVolumeUom__atm_x002fft = 16
};
#endif

/* witsml1_4_1_1ForGsoap.h:1851 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__IlluminanceUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__IlluminanceUom (304)
/* witsml1:IlluminanceUom */
enum witsml1__IlluminanceUom
{
	witsml1__IlluminanceUom__lx = 0,
	witsml1__IlluminanceUom__lm_x002fm2 = 1,
	witsml1__IlluminanceUom__footcandle = 2,
	witsml1__IlluminanceUom__klx = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:1862 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LengthUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LengthUom (305)
/* witsml1:LengthUom */
enum witsml1__LengthUom
{
	witsml1__LengthUom__m = 109,
	witsml1__LengthUom__angstrom = 110,
	witsml1__LengthUom__chBnA = 111,
	witsml1__LengthUom__chBnB = 112,
	witsml1__LengthUom__chCla = 113,
	witsml1__LengthUom__chSe = 114,
	witsml1__LengthUom__chUS = 115,
	witsml1__LengthUom__cm = 116,
	witsml1__LengthUom__dm = 117,
	witsml1__LengthUom__fathom = 118,
	witsml1__LengthUom__fm = 119,
	witsml1__LengthUom__ft = 120,
	witsml1__LengthUom__ftBnA = 121,
	witsml1__LengthUom__ftBnB = 122,
	witsml1__LengthUom__ftBr_x002865_x0029 = 123,
	witsml1__LengthUom__ftCla = 124,
	witsml1__LengthUom__ftGC = 125,
	witsml1__LengthUom__ftInd = 126,
	witsml1__LengthUom__ftInd_x002837_x0029 = 127,
	witsml1__LengthUom__ftInd_x002862_x0029 = 128,
	witsml1__LengthUom__ftInd_x002875_x0029 = 129,
	witsml1__LengthUom__ftMA = 130,
	witsml1__LengthUom__ftSe = 131,
	witsml1__LengthUom__ftUS = 132,
	witsml1__LengthUom__in = 133,
	witsml1__LengthUom__in_x002f10 = 134,
	witsml1__LengthUom__in_x002f16 = 135,
	witsml1__LengthUom__in_x002f32 = 136,
	witsml1__LengthUom__in_x002f64 = 137,
	witsml1__LengthUom__inUS = 138,
	witsml1__LengthUom__km = 139,
	witsml1__LengthUom__lkBnA = 140,
	witsml1__LengthUom__lkBnB = 141,
	witsml1__LengthUom__lkCla = 142,
	witsml1__LengthUom__lkSe = 143,
	witsml1__LengthUom__lkUS = 144,
	witsml1__LengthUom__mGer = 145,
	witsml1__LengthUom__mi = 146,
	witsml1__LengthUom__mil = 147,
	witsml1__LengthUom__miUS = 148,
	witsml1__LengthUom__mm = 149,
	witsml1__LengthUom__Mm = 150,
	witsml1__LengthUom__nautmi = 151,
	witsml1__LengthUom__nm = 152,
	witsml1__LengthUom__pm = 153,
	witsml1__LengthUom__um = 154,
	witsml1__LengthUom__yd = 155,
	witsml1__LengthUom__ydBnA = 156,
	witsml1__LengthUom__ydBnB = 157,
	witsml1__LengthUom__ydCla = 158,
	witsml1__LengthUom__ydIm = 159,
	witsml1__LengthUom__ydInd = 160,
	witsml1__LengthUom__ydInd_x002837_x0029 = 161,
	witsml1__LengthUom__ydInd_x002862_x0029 = 162,
	witsml1__LengthUom__ydInd_x002875_x0029 = 163,
	witsml1__LengthUom__ydSe = 164
};
#endif

/* witsml1_4_1_1ForGsoap.h:1925 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LengthPerLengthUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LengthPerLengthUom (306)
/* witsml1:LengthPerLengthUom */
enum witsml1__LengthPerLengthUom
{
	witsml1__LengthPerLengthUom___x0025 = 0,
	witsml1__LengthPerLengthUom__ft_x002f100ft = 1,
	witsml1__LengthPerLengthUom__ft_x002fft = 2,
	witsml1__LengthPerLengthUom__ft_x002fin = 3,
	witsml1__LengthPerLengthUom__ft_x002fm = 4,
	witsml1__LengthPerLengthUom__ft_x002fmi = 5,
	witsml1__LengthPerLengthUom__km_x002fcm = 6,
	witsml1__LengthPerLengthUom__m_x002f30m = 7,
	witsml1__LengthPerLengthUom__m_x002fcm = 8,
	witsml1__LengthPerLengthUom__m_x002fkm = 9,
	witsml1__LengthPerLengthUom__m_x002fm = 10,
	witsml1__LengthPerLengthUom__mi_x002fin = 11
};
#endif

/* witsml1_4_1_1ForGsoap.h:1944 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MagneticInductionUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MagneticInductionUom (307)
/* witsml1:MagneticInductionUom */
enum witsml1__MagneticInductionUom
{
	witsml1__MagneticInductionUom__T = 84,
	witsml1__MagneticInductionUom__gauss = 85,
	witsml1__MagneticInductionUom__mT = 86,
	witsml1__MagneticInductionUom__mgauss = 87,
	witsml1__MagneticInductionUom__nT = 88,
	witsml1__MagneticInductionUom__uT = 89
};
#endif

/* witsml1_4_1_1ForGsoap.h:1957 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MassConcentrationUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MassConcentrationUom (308)
/* witsml1:MassConcentrationUom */
enum witsml1__MassConcentrationUom
{
	witsml1__MassConcentrationUom__Euc = 0,
	witsml1__MassConcentrationUom___x0025 = 1,
	witsml1__MassConcentrationUom__g_x002fkg = 2,
	witsml1__MassConcentrationUom__kg_x002fkg = 3,
	witsml1__MassConcentrationUom__kg_x002fsack94 = 4,
	witsml1__MassConcentrationUom__mg_x002fkg = 5,
	witsml1__MassConcentrationUom__permil = 6,
	witsml1__MassConcentrationUom__ppdk = 7,
	witsml1__MassConcentrationUom__ppk = 8,
	witsml1__MassConcentrationUom__ppm = 9
};
#endif

/* witsml1_4_1_1ForGsoap.h:1974 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MassUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MassUom (309)
/* witsml1:MassUom */
enum witsml1__MassUom
{
	witsml1__MassUom__g = 103,
	witsml1__MassUom__t = 116,
	witsml1__MassUom__kg = 117,
	witsml1__MassUom__ag = 118,
	witsml1__MassUom__ct = 119,
	witsml1__MassUom__cwtUK = 120,
	witsml1__MassUom__cwtUS = 121,
	witsml1__MassUom__grain = 122,
	witsml1__MassUom__klbm = 123,
	witsml1__MassUom__lbm = 124,
	witsml1__MassUom__Mg = 125,
	witsml1__MassUom__mg = 126,
	witsml1__MassUom__oz_x0028av_x0029 = 127,
	witsml1__MassUom__oz_x0028troy_x0029 = 128,
	witsml1__MassUom__ozm = 129,
	witsml1__MassUom__sack94 = 130,
	witsml1__MassUom__tonUK = 131,
	witsml1__MassUom__tonUS = 132,
	witsml1__MassUom__ug = 133
};
#endif

/* witsml1_4_1_1ForGsoap.h:2000 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MassPerLengthUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MassPerLengthUom (310)
/* witsml1:MassPerLengthUom */
enum witsml1__MassPerLengthUom
{
	witsml1__MassPerLengthUom__kg_x002fm = 0,
	witsml1__MassPerLengthUom__klbm_x002fin = 1,
	witsml1__MassPerLengthUom__lbm_x002fft = 2,
	witsml1__MassPerLengthUom__Mg_x002fin = 3,
	witsml1__MassPerLengthUom__kg_x002em_x002fcm2 = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:2012 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MomentOfForceUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MomentOfForceUom (311)
/* witsml1:MomentOfForceUom */
enum witsml1__MomentOfForceUom
{
	witsml1__MomentOfForceUom__J = 74,
	witsml1__MomentOfForceUom__dN_x002em = 75,
	witsml1__MomentOfForceUom__daN_x002em = 76,
	witsml1__MomentOfForceUom__ft_x002elbf = 77,
	witsml1__MomentOfForceUom__kft_x002elbf = 78,
	witsml1__MomentOfForceUom__kgf_x002em = 79,
	witsml1__MomentOfForceUom__kN_x002em = 80,
	witsml1__MomentOfForceUom__lbf_x002eft = 81,
	witsml1__MomentOfForceUom__lbf_x002ein = 82,
	witsml1__MomentOfForceUom__lbm_x002eft2_x002fs2 = 83,
	witsml1__MomentOfForceUom__N_x002em = 84,
	witsml1__MomentOfForceUom__pdl_x002eft = 85,
	witsml1__MomentOfForceUom__tonfUS_x002eft = 86,
	witsml1__MomentOfForceUom__tonfUS_x002emi = 87
};
#endif

/* witsml1_4_1_1ForGsoap.h:2033 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PerLengthUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PerLengthUom (312)
/* witsml1:PerLengthUom */
enum witsml1__PerLengthUom
{
	witsml1__PerLengthUom__1_x002fm = 0,
	witsml1__PerLengthUom__1_x002fangstrom = 1,
	witsml1__PerLengthUom__1_x002fcm = 2,
	witsml1__PerLengthUom__1_x002fft = 3,
	witsml1__PerLengthUom__1_x002fin = 4,
	witsml1__PerLengthUom__1_x002fmi = 5,
	witsml1__PerLengthUom__1_x002fmm = 6,
	witsml1__PerLengthUom__1_x002fnm = 7,
	witsml1__PerLengthUom__1_x002fyd = 8
};
#endif

/* witsml1_4_1_1ForGsoap.h:2049 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PermeabilityRockUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PermeabilityRockUom (313)
/* witsml1:PermeabilityRockUom */
enum witsml1__PermeabilityRockUom
{
	witsml1__PermeabilityRockUom__D = 68,
	witsml1__PermeabilityRockUom__mD = 69
};
#endif

/* witsml1_4_1_1ForGsoap.h:2058 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PlaneAngleUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PlaneAngleUom (314)
/* witsml1:PlaneAngleUom */
enum witsml1__PlaneAngleUom
{
	witsml1__PlaneAngleUom__c = 99,
	witsml1__PlaneAngleUom__rad = 100,
	witsml1__PlaneAngleUom__ccgr = 101,
	witsml1__PlaneAngleUom__cgr = 102,
	witsml1__PlaneAngleUom__dega = 103,
	witsml1__PlaneAngleUom__gon = 104,
	witsml1__PlaneAngleUom__gr = 105,
	witsml1__PlaneAngleUom__Grad = 106,
	witsml1__PlaneAngleUom__krad = 107,
	witsml1__PlaneAngleUom__mila = 108,
	witsml1__PlaneAngleUom__mina = 109,
	witsml1__PlaneAngleUom__mrad = 110,
	witsml1__PlaneAngleUom__Mrad = 111,
	witsml1__PlaneAngleUom__mseca = 112,
	witsml1__PlaneAngleUom__seca = 113,
	witsml1__PlaneAngleUom__urad = 114
};
#endif

/* witsml1_4_1_1ForGsoap.h:2081 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PowerUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PowerUom (315)
/* witsml1:PowerUom */
enum witsml1__PowerUom
{
	witsml1__PowerUom__W = 87,
	witsml1__PowerUom__ch = 88,
	witsml1__PowerUom__CV = 89,
	witsml1__PowerUom__ehp = 90,
	witsml1__PowerUom__GW = 91,
	witsml1__PowerUom__hhp = 92,
	witsml1__PowerUom__hp = 93,
	witsml1__PowerUom__kcal_x002fh = 94,
	witsml1__PowerUom__kW = 95,
	witsml1__PowerUom__MJ_x002fa = 96,
	witsml1__PowerUom__MW = 97,
	witsml1__PowerUom__mW = 98,
	witsml1__PowerUom__nW = 99,
	witsml1__PowerUom__ton_x0020of_x0020refrig = 100,
	witsml1__PowerUom__TW = 101,
	witsml1__PowerUom__uW = 102
};
#endif

/* witsml1_4_1_1ForGsoap.h:2104 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PressureUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PressureUom (316)
/* witsml1:PressureUom */
enum witsml1__PressureUom
{
	witsml1__PressureUom__Pa = 0,
	witsml1__PressureUom__at = 1,
	witsml1__PressureUom__atm = 2,
	witsml1__PressureUom__bar = 3,
	witsml1__PressureUom__cmH2O_x00284degC_x0029 = 4,
	witsml1__PressureUom__dyne_x002fcm2 = 5,
	witsml1__PressureUom__GPa = 6,
	witsml1__PressureUom__hbar = 7,
	witsml1__PressureUom__inH2O_x002839_x002e2F_x0029 = 8,
	witsml1__PressureUom__inH2O_x002860F_x0029 = 9,
	witsml1__PressureUom__inHg_x002832F_x0029 = 10,
	witsml1__PressureUom__inHg_x002860F_x0029 = 11,
	witsml1__PressureUom__kgf_x002fcm2 = 12,
	witsml1__PressureUom__kgf_x002fmm2 = 13,
	witsml1__PressureUom__kN_x002fm2 = 14,
	witsml1__PressureUom__kPa = 15,
	witsml1__PressureUom__kpsi = 16,
	witsml1__PressureUom__lbf_x002fft2 = 17,
	witsml1__PressureUom__lbf_x002f100ft2 = 18,
	witsml1__PressureUom__lbf_x002fin2 = 19,
	witsml1__PressureUom__mbar = 20,
	witsml1__PressureUom__mmHg_x00280C_x0029 = 21,
	witsml1__PressureUom__mPa = 22,
	witsml1__PressureUom__MPa = 23,
	witsml1__PressureUom__Mpsi = 24,
	witsml1__PressureUom__N_x002fm2 = 25,
	witsml1__PressureUom__N_x002fmm2 = 26,
	witsml1__PressureUom__Pa_x0028g_x0029 = 27,
	witsml1__PressureUom__pPa = 28,
	witsml1__PressureUom__psi = 29,
	witsml1__PressureUom__psia = 30,
	witsml1__PressureUom__psig = 31,
	witsml1__PressureUom__tonfUS_x002fft2 = 32,
	witsml1__PressureUom__tonfUS_x002fin2 = 33,
	witsml1__PressureUom__torr = 34,
	witsml1__PressureUom__ubar = 35,
	witsml1__PressureUom__umHg_x00280C_x0029 = 36,
	witsml1__PressureUom__uPa = 37,
	witsml1__PressureUom__upsi = 38
};
#endif

/* witsml1_4_1_1ForGsoap.h:2150 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RelativePowerUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RelativePowerUom (317)
/* witsml1:RelativePowerUom */
enum witsml1__RelativePowerUom
{
	witsml1__RelativePowerUom___x0025 = 0,
	witsml1__RelativePowerUom__Btu_x002fbhp_x002ehr = 1,
	witsml1__RelativePowerUom__W_x002fkW = 2,
	witsml1__RelativePowerUom__W_x002fW = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:2161 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SpecificHeatCapacityUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SpecificHeatCapacityUom (318)
/* witsml1:SpecificHeatCapacityUom */
enum witsml1__SpecificHeatCapacityUom
{
	witsml1__SpecificHeatCapacityUom__J_x002fkg_x002eK = 0,
	witsml1__SpecificHeatCapacityUom__Btu_x002flbm_x002edegF = 1,
	witsml1__SpecificHeatCapacityUom__Btu_x002flbm_x002edegR = 2,
	witsml1__SpecificHeatCapacityUom__cal_x002fg_x002eK = 3,
	witsml1__SpecificHeatCapacityUom__J_x002fg_x002eK = 4,
	witsml1__SpecificHeatCapacityUom__kcal_x002fkg_x002edegC = 5,
	witsml1__SpecificHeatCapacityUom__kJ_x002fkg_x002eK = 6,
	witsml1__SpecificHeatCapacityUom__kW_x002eh_x002fkg_x002edegC = 7
};
#endif

/* witsml1_4_1_1ForGsoap.h:2176 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SpecificVolumeUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SpecificVolumeUom (319)
/* witsml1:SpecificVolumeUom */
enum witsml1__SpecificVolumeUom
{
	witsml1__SpecificVolumeUom__m3_x002fkg = 0,
	witsml1__SpecificVolumeUom__bbl_x002ftonUK = 1,
	witsml1__SpecificVolumeUom__bbl_x002ftonUS = 2,
	witsml1__SpecificVolumeUom__cm3_x002fg = 3,
	witsml1__SpecificVolumeUom__dm3_x002fkg = 4,
	witsml1__SpecificVolumeUom__dm3_x002ft = 5,
	witsml1__SpecificVolumeUom__ft3_x002fkg = 6,
	witsml1__SpecificVolumeUom__ft3_x002flbm = 7,
	witsml1__SpecificVolumeUom__ft3_x002fsack94 = 8,
	witsml1__SpecificVolumeUom__galUS_x002fsack94 = 9,
	witsml1__SpecificVolumeUom__galUK_x002flbm = 10,
	witsml1__SpecificVolumeUom__galUS_x002flbm = 11,
	witsml1__SpecificVolumeUom__galUS_x002ftonUK = 12,
	witsml1__SpecificVolumeUom__galUS_x002ftonUS = 13,
	witsml1__SpecificVolumeUom__L_x002f100kg = 14,
	witsml1__SpecificVolumeUom__L_x002fkg = 15,
	witsml1__SpecificVolumeUom__L_x002ft = 16,
	witsml1__SpecificVolumeUom__L_x002ftonUK = 17,
	witsml1__SpecificVolumeUom__m3_x002fg = 18,
	witsml1__SpecificVolumeUom__m3_x002ft = 19,
	witsml1__SpecificVolumeUom__m3_x002ftonUK = 20,
	witsml1__SpecificVolumeUom__m3_x002ftonUS = 21
};
#endif

/* witsml1_4_1_1ForGsoap.h:2205 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StandardVolumeUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StandardVolumeUom (320)
/* witsml1:StandardVolumeUom */
enum witsml1__StandardVolumeUom
{
	witsml1__StandardVolumeUom__scm_x002815C_x0029 = 0,
	witsml1__StandardVolumeUom__scm_x00280C_x0029 = 1,
	witsml1__StandardVolumeUom__Gsm3 = 2,
	witsml1__StandardVolumeUom__ksm3 = 3,
	witsml1__StandardVolumeUom__MMscf_x002860F_x0029 = 4,
	witsml1__StandardVolumeUom__MMscm_x002815C_x0029 = 5,
	witsml1__StandardVolumeUom__MMstb_x002860F_x0029 = 6,
	witsml1__StandardVolumeUom__Mscf_x002860F_x0029 = 7,
	witsml1__StandardVolumeUom__Mstb_x002860F_x0029 = 8,
	witsml1__StandardVolumeUom__scf_x002860F_x0029 = 9,
	witsml1__StandardVolumeUom__stb_x002860F_x0029 = 10
};
#endif

/* witsml1_4_1_1ForGsoap.h:2223 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StandardVolumePerTimeUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StandardVolumePerTimeUom (321)
/* witsml1:StandardVolumePerTimeUom */
enum witsml1__StandardVolumePerTimeUom
{
	witsml1__StandardVolumePerTimeUom__scf_x002860F_x0029_x002fd = 0,
	witsml1__StandardVolumePerTimeUom__scm_x002815C_x0029_x002fs = 1,
	witsml1__StandardVolumePerTimeUom__scm_x002815C_x0029_x002fd = 2,
	witsml1__StandardVolumePerTimeUom__stb_x002860F_x0029_x002fd = 3,
	witsml1__StandardVolumePerTimeUom__ksm3_x002fd = 4,
	witsml1__StandardVolumePerTimeUom__Mscm_x002815C_x0029_x002fd = 5,
	witsml1__StandardVolumePerTimeUom__MMscm_x002815C_x0029_x002fd = 6,
	witsml1__StandardVolumePerTimeUom__Mstb_x002860F_x0029_x002fd = 7,
	witsml1__StandardVolumePerTimeUom__MMstb_x002860F_x0029_x002fd = 8,
	witsml1__StandardVolumePerTimeUom__Mscf_x002860F_x0029_x002fd = 9,
	witsml1__StandardVolumePerTimeUom__MMscf_x002860F_x0029_x002fd = 10
};
#endif

/* witsml1_4_1_1ForGsoap.h:2241 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ThermalConductivityUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ThermalConductivityUom (322)
/* witsml1:ThermalConductivityUom */
enum witsml1__ThermalConductivityUom
{
	witsml1__ThermalConductivityUom__W_x002fm_x002eK = 0,
	witsml1__ThermalConductivityUom__Btu_x002fhr_x002eft_x002edegF = 1,
	witsml1__ThermalConductivityUom__cal_x002fh_x002ecm_x002edegC = 2,
	witsml1__ThermalConductivityUom__kcal_x002fh_x002em_x002edegC = 3,
	witsml1__ThermalConductivityUom__cal_x002fs_x002ecm_x002edegC = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:2253 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ThermalVolumetricExpansionUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ThermalVolumetricExpansionUom (323)
/* witsml1:ThermalVolumetricExpansionUom */
enum witsml1__ThermalVolumetricExpansionUom
{
	witsml1__ThermalVolumetricExpansionUom__1_x002fK = 0,
	witsml1__ThermalVolumetricExpansionUom__ppm_x002fdegC = 1,
	witsml1__ThermalVolumetricExpansionUom__ppm_x002fdegF = 2,
	witsml1__ThermalVolumetricExpansionUom__1_x002fdegC = 3,
	witsml1__ThermalVolumetricExpansionUom__1_x002fdegF = 4,
	witsml1__ThermalVolumetricExpansionUom__1_x002fdegR = 5
};
#endif

/* witsml1_4_1_1ForGsoap.h:2266 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ThermodynamicTemperatureUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ThermodynamicTemperatureUom (324)
/* witsml1:ThermodynamicTemperatureUom */
enum witsml1__ThermodynamicTemperatureUom
{
	witsml1__ThermodynamicTemperatureUom__K = 75,
	witsml1__ThermodynamicTemperatureUom__degC = 76,
	witsml1__ThermodynamicTemperatureUom__degF = 77,
	witsml1__ThermodynamicTemperatureUom__degR = 78
};
#endif

/* witsml1_4_1_1ForGsoap.h:2277 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TimeUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TimeUom (325)
/* witsml1:TimeUom */
enum witsml1__TimeUom
{
	witsml1__TimeUom__s = 115,
	witsml1__TimeUom__a = 97,
	witsml1__TimeUom__d = 100,
	witsml1__TimeUom__h = 104,
	witsml1__TimeUom__cs = 116,
	witsml1__TimeUom__Ga = 117,
	witsml1__TimeUom__100s = 118,
	witsml1__TimeUom__Ma = 119,
	witsml1__TimeUom__min_ = 120,
	witsml1__TimeUom__ms = 121,
	witsml1__TimeUom__ms_x002f2 = 122,
	witsml1__TimeUom__ns = 123,
	witsml1__TimeUom__ps = 124,
	witsml1__TimeUom__us = 125,
	witsml1__TimeUom__wk = 126,
	witsml1__TimeUom__100ka = 127
};
#endif

/* witsml1_4_1_1ForGsoap.h:2300 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VelocityUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VelocityUom (326)
/* witsml1:VelocityUom */
enum witsml1__VelocityUom
{
	witsml1__VelocityUom__m_x002fs = 0,
	witsml1__VelocityUom__cm_x002fa = 1,
	witsml1__VelocityUom__cm_x002fs = 2,
	witsml1__VelocityUom__dm_x002fs = 3,
	witsml1__VelocityUom__ft_x002fd = 4,
	witsml1__VelocityUom__ft_x002fh = 5,
	witsml1__VelocityUom__ft_x002fmin = 6,
	witsml1__VelocityUom__ft_x002fms = 7,
	witsml1__VelocityUom__ft_x002fs = 8,
	witsml1__VelocityUom__ft_x002fus = 9,
	witsml1__VelocityUom__in_x002fa = 10,
	witsml1__VelocityUom__in_x002fmin = 11,
	witsml1__VelocityUom__in_x002fs = 12,
	witsml1__VelocityUom__kft_x002fh = 13,
	witsml1__VelocityUom__kft_x002fs = 14,
	witsml1__VelocityUom__km_x002fh = 15,
	witsml1__VelocityUom__km_x002fs = 16,
	witsml1__VelocityUom__knot = 17,
	witsml1__VelocityUom__m_x002fd = 18,
	witsml1__VelocityUom__m_x002fh = 19,
	witsml1__VelocityUom__m_x002fmin = 20,
	witsml1__VelocityUom__m_x002fms = 21,
	witsml1__VelocityUom__mi_x002fh = 22,
	witsml1__VelocityUom__mil_x002fyr = 23,
	witsml1__VelocityUom__mm_x002fa = 24,
	witsml1__VelocityUom__mm_x002fs = 25,
	witsml1__VelocityUom__nm_x002fs = 26,
	witsml1__VelocityUom__um_x002fs = 27
};
#endif

/* witsml1_4_1_1ForGsoap.h:2335 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VolumeUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VolumeUom (327)
/* witsml1:VolumeUom */
enum witsml1__VolumeUom
{
	witsml1__VolumeUom__L = 76,
	witsml1__VolumeUom__m3 = 77,
	witsml1__VolumeUom__acre_x002eft = 78,
	witsml1__VolumeUom__bbl = 79,
	witsml1__VolumeUom__bcf = 80,
	witsml1__VolumeUom__cm3 = 81,
	witsml1__VolumeUom__dm3 = 82,
	witsml1__VolumeUom__flozUK = 83,
	witsml1__VolumeUom__flozUS = 84,
	witsml1__VolumeUom__ft3 = 85,
	witsml1__VolumeUom__galUK = 86,
	witsml1__VolumeUom__galUS = 87,
	witsml1__VolumeUom__ha_x002em = 88,
	witsml1__VolumeUom__hL = 89,
	witsml1__VolumeUom__in3 = 90,
	witsml1__VolumeUom__1000ft3 = 91,
	witsml1__VolumeUom__km3 = 92,
	witsml1__VolumeUom__Mbbl = 93,
	witsml1__VolumeUom__Mcf = 94,
	witsml1__VolumeUom__M_x0028ft3_x0029 = 95,
	witsml1__VolumeUom__mi3 = 96,
	witsml1__VolumeUom__mL = 97,
	witsml1__VolumeUom__M_x0028m3_x0029 = 98,
	witsml1__VolumeUom__mm3 = 99,
	witsml1__VolumeUom__MMbbl = 100,
	witsml1__VolumeUom__ptUK = 101,
	witsml1__VolumeUom__ptUS = 102,
	witsml1__VolumeUom__qtUK = 103,
	witsml1__VolumeUom__qtUS = 104,
	witsml1__VolumeUom__tcf = 105,
	witsml1__VolumeUom__um2_x002em = 106,
	witsml1__VolumeUom__yd3 = 107
};
#endif

/* witsml1_4_1_1ForGsoap.h:2374 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VolumeFlowRateUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VolumeFlowRateUom (328)
/* witsml1:VolumeFlowRateUom */
enum witsml1__VolumeFlowRateUom
{
	witsml1__VolumeFlowRateUom__m3_x002fs = 0,
	witsml1__VolumeFlowRateUom__bbl_x002fd = 1,
	witsml1__VolumeFlowRateUom__bbl_x002fhr = 2,
	witsml1__VolumeFlowRateUom__bbl_x002fmin = 3,
	witsml1__VolumeFlowRateUom__cm3_x002f30min = 4,
	witsml1__VolumeFlowRateUom__cm3_x002fh = 5,
	witsml1__VolumeFlowRateUom__cm3_x002fmin = 6,
	witsml1__VolumeFlowRateUom__cm3_x002fs = 7,
	witsml1__VolumeFlowRateUom__dm3_x002fs = 8,
	witsml1__VolumeFlowRateUom__ft3_x002fd = 9,
	witsml1__VolumeFlowRateUom__ft3_x002fh = 10,
	witsml1__VolumeFlowRateUom__ft3_x002fmin = 11,
	witsml1__VolumeFlowRateUom__ft3_x002fs = 12,
	witsml1__VolumeFlowRateUom__galUK_x002fd = 13,
	witsml1__VolumeFlowRateUom__galUK_x002fhr = 14,
	witsml1__VolumeFlowRateUom__galUK_x002fmin = 15,
	witsml1__VolumeFlowRateUom__galUS_x002fd = 16,
	witsml1__VolumeFlowRateUom__galUS_x002fhr = 17,
	witsml1__VolumeFlowRateUom__galUS_x002fmin = 18,
	witsml1__VolumeFlowRateUom__kbbl_x002fd = 19,
	witsml1__VolumeFlowRateUom__1000ft3_x002fd = 20,
	witsml1__VolumeFlowRateUom__1000m3_x002fd = 21,
	witsml1__VolumeFlowRateUom__1000m3_x002fh = 22,
	witsml1__VolumeFlowRateUom__L_x002fh = 23,
	witsml1__VolumeFlowRateUom__L_x002fmin = 24,
	witsml1__VolumeFlowRateUom__L_x002fs = 25,
	witsml1__VolumeFlowRateUom__m3_x002fd = 26,
	witsml1__VolumeFlowRateUom__m3_x002fh = 27,
	witsml1__VolumeFlowRateUom__m3_x002fmin = 28,
	witsml1__VolumeFlowRateUom__Mbbl_x002fd = 29,
	witsml1__VolumeFlowRateUom__M_x0028ft3_x0029_x002fd = 30,
	witsml1__VolumeFlowRateUom__M_x0028m3_x0029_x002fd = 31
};
#endif

/* witsml1_4_1_1ForGsoap.h:2413 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VolumePerLengthUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VolumePerLengthUom (329)
/* witsml1:VolumePerLengthUom */
enum witsml1__VolumePerLengthUom
{
	witsml1__VolumePerLengthUom__bblPft = 0,
	witsml1__VolumePerLengthUom__bblPin = 1,
	witsml1__VolumePerLengthUom__bblPmi = 2,
	witsml1__VolumePerLengthUom__dm3P100km = 3,
	witsml1__VolumePerLengthUom__dm3Pkm_x0028100_x0029 = 4,
	witsml1__VolumePerLengthUom__dm3Pm = 5,
	witsml1__VolumePerLengthUom__ft3Pft = 6,
	witsml1__VolumePerLengthUom__galUKPmi = 7,
	witsml1__VolumePerLengthUom__galUSPft = 8,
	witsml1__VolumePerLengthUom__galUSPmi = 9,
	witsml1__VolumePerLengthUom__in3Pft = 10,
	witsml1__VolumePerLengthUom__LP100km = 11,
	witsml1__VolumePerLengthUom__LPkm_x0028100_x0029 = 12,
	witsml1__VolumePerLengthUom__LPm = 13,
	witsml1__VolumePerLengthUom__m3Pkm = 14,
	witsml1__VolumePerLengthUom__m3Pm = 15
};
#endif

/* witsml1_4_1_1ForGsoap.h:2436 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VolumePerVolumeUom
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__VolumePerVolumeUom (330)
/* witsml1:VolumePerVolumeUom */
enum witsml1__VolumePerVolumeUom
{
	witsml1__VolumePerVolumeUom__Euc = 0,
	witsml1__VolumePerVolumeUom___x0025 = 1,
	witsml1__VolumePerVolumeUom__permil = 2,
	witsml1__VolumePerVolumeUom__ppdk = 3,
	witsml1__VolumePerVolumeUom__ppk = 4,
	witsml1__VolumePerVolumeUom__ppm = 5,
	witsml1__VolumePerVolumeUom__bbl_x002facre_x002eft = 6,
	witsml1__VolumePerVolumeUom__bbl_x002fbbl = 7,
	witsml1__VolumePerVolumeUom__bbl_x002fft3 = 8,
	witsml1__VolumePerVolumeUom__bbl_x002f100bbl = 9,
	witsml1__VolumePerVolumeUom__bbl_x002fk_x0028ft3_x0029 = 10,
	witsml1__VolumePerVolumeUom__bbl_x002fM_x0028ft3_x0029 = 11,
	witsml1__VolumePerVolumeUom__cm3_x002fcm3 = 12,
	witsml1__VolumePerVolumeUom__cm3_x002fm3 = 13,
	witsml1__VolumePerVolumeUom__dm3_x002fm3 = 14,
	witsml1__VolumePerVolumeUom__ft3_x002fbbl = 15,
	witsml1__VolumePerVolumeUom__ft3_x002fft3 = 16,
	witsml1__VolumePerVolumeUom__galUS_x002fkgalUS = 17,
	witsml1__VolumePerVolumeUom__galUK_x002fkgalUK = 18,
	witsml1__VolumePerVolumeUom__galUK_x002fft3 = 19,
	witsml1__VolumePerVolumeUom__galUK_x002fMbbl = 20,
	witsml1__VolumePerVolumeUom__galUS_x002fbbl = 21,
	witsml1__VolumePerVolumeUom__galUS_x002f10bbl = 22,
	witsml1__VolumePerVolumeUom__galUS_x002fft3 = 23,
	witsml1__VolumePerVolumeUom__galUS_x002fMbbl = 24,
	witsml1__VolumePerVolumeUom__1000ft3_x002fbbl = 25,
	witsml1__VolumePerVolumeUom__ksm3_x002fsm3 = 26,
	witsml1__VolumePerVolumeUom__L_x002f10bbl = 27,
	witsml1__VolumePerVolumeUom__L_x002fm3 = 28,
	witsml1__VolumePerVolumeUom__m3_x002fha_x002em = 29,
	witsml1__VolumePerVolumeUom__m3_x002fm3 = 30,
	witsml1__VolumePerVolumeUom__M_x0028ft3_x0029_x002facre_x002eft = 31,
	witsml1__VolumePerVolumeUom__mL_x002fgalUK = 32,
	witsml1__VolumePerVolumeUom__mL_x002fgalUS = 33,
	witsml1__VolumePerVolumeUom__mL_x002fmL = 34,
	witsml1__VolumePerVolumeUom__MMbbl_x002facre_x002eft = 35,
	witsml1__VolumePerVolumeUom__MMscf60_x002fstb60 = 36,
	witsml1__VolumePerVolumeUom__Mscf60_x002fstb60 = 37,
	witsml1__VolumePerVolumeUom__ptUK_x002fMbbl = 38,
	witsml1__VolumePerVolumeUom__ptUS_x002f10bbl = 39,
	witsml1__VolumePerVolumeUom__pu = 40,
	witsml1__VolumePerVolumeUom__scm15_x002fstb60 = 41,
	witsml1__VolumePerVolumeUom__sm3_x002fksm3 = 42,
	witsml1__VolumePerVolumeUom__sm3_x002fsm3 = 43,
	witsml1__VolumePerVolumeUom__stb60_x002fMMscf60 = 44,
	witsml1__VolumePerVolumeUom__stb60_x002fMMscm15 = 45,
	witsml1__VolumePerVolumeUom__stb60_x002fMscf60 = 46,
	witsml1__VolumePerVolumeUom__stb60_x002fMscm15 = 47,
	witsml1__VolumePerVolumeUom__stb60_x002fscm15 = 48
};
#endif

/* witsml1_4_1_1ForGsoap.h:2499 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ActivityClassType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ActivityClassType (332)
/* witsml1:ActivityClassType */
enum witsml1__ActivityClassType
{
	witsml1__ActivityClassType__planned = 0,
	witsml1__ActivityClassType__unplanned = 1,
	witsml1__ActivityClassType__downtime = 2,
	witsml1__ActivityClassType__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:2529 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AuthorizationStatus
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AuthorizationStatus (334)
/* witsml1:AuthorizationStatus */
enum witsml1__AuthorizationStatus
{
	witsml1__AuthorizationStatus__draft = 0,
	witsml1__AuthorizationStatus__authorized = 1,
	witsml1__AuthorizationStatus__superceded = 2,
	witsml1__AuthorizationStatus__withdrawn = 3,
	witsml1__AuthorizationStatus__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:2558 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AziRef
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__AziRef (335)
/* witsml1:AziRef */
enum witsml1__AziRef
{
	witsml1__AziRef__magnetic_x0020north = 0,
	witsml1__AziRef__grid_x0020north = 1,
	witsml1__AziRef__true_x0020north = 2,
	witsml1__AziRef__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:2583 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BearingType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BearingType (336)
/* witsml1:BearingType */
enum witsml1__BearingType
{
	witsml1__BearingType__oil_x0020seal = 0,
	witsml1__BearingType__mud_x0020lube = 1,
	witsml1__BearingType__other = 2,
	witsml1__BearingType__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:2608 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BitDullCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BitDullCode (337)
/* witsml1:BitDullCode */
enum witsml1__BitDullCode
{
	witsml1__BitDullCode__BC = 0,
	witsml1__BitDullCode__BT = 1,
	witsml1__BitDullCode__BU = 2,
	witsml1__BitDullCode__CC = 3,
	witsml1__BitDullCode__CD = 4,
	witsml1__BitDullCode__CI = 5,
	witsml1__BitDullCode__CR = 6,
	witsml1__BitDullCode__CT = 7,
	witsml1__BitDullCode__ER = 8,
	witsml1__BitDullCode__FC = 9,
	witsml1__BitDullCode__HC = 10,
	witsml1__BitDullCode__JD = 11,
	witsml1__BitDullCode__LC = 12,
	witsml1__BitDullCode__LN = 13,
	witsml1__BitDullCode__LT = 14,
	witsml1__BitDullCode__NO = 15,
	witsml1__BitDullCode__OC = 16,
	witsml1__BitDullCode__PB = 17,
	witsml1__BitDullCode__PN = 18,
	witsml1__BitDullCode__RG = 19,
	witsml1__BitDullCode__RO = 20,
	witsml1__BitDullCode__SD = 21,
	witsml1__BitDullCode__SS = 22,
	witsml1__BitDullCode__TR = 23,
	witsml1__BitDullCode__WO = 24,
	witsml1__BitDullCode__WT = 25,
	witsml1__BitDullCode__unknown = 26
};
#endif

/* witsml1_4_1_1ForGsoap.h:2728 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BitReasonPulled
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BitReasonPulled (338)
/* witsml1:BitReasonPulled */
enum witsml1__BitReasonPulled
{
	witsml1__BitReasonPulled__BHA = 0,
	witsml1__BitReasonPulled__CM = 1,
	witsml1__BitReasonPulled__CP = 2,
	witsml1__BitReasonPulled__DMF = 3,
	witsml1__BitReasonPulled__DP = 4,
	witsml1__BitReasonPulled__DST = 5,
	witsml1__BitReasonPulled__DTF = 6,
	witsml1__BitReasonPulled__FM = 7,
	witsml1__BitReasonPulled__HP = 8,
	witsml1__BitReasonPulled__HR = 9,
	witsml1__BitReasonPulled__LOG = 10,
	witsml1__BitReasonPulled__PP = 11,
	witsml1__BitReasonPulled__PR = 12,
	witsml1__BitReasonPulled__RIG = 13,
	witsml1__BitReasonPulled__TD = 14,
	witsml1__BitReasonPulled__TQ = 15,
	witsml1__BitReasonPulled__TW = 16,
	witsml1__BitReasonPulled__WC = 17,
	witsml1__BitReasonPulled__unknown = 18
};
#endif

/* witsml1_4_1_1ForGsoap.h:2816 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BitType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BitType (339)
/* witsml1:BitType */
enum witsml1__BitType
{
	witsml1__BitType__diamond = 0,
	witsml1__BitType__diamond_x0020core = 1,
	witsml1__BitType__insert_x0020roller_x0020cone = 2,
	witsml1__BitType__PDC = 3,
	witsml1__BitType__PDC_x0020core = 4,
	witsml1__BitType__roller_x0020cone = 5,
	witsml1__BitType__unknown = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:2853 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BhaStatus
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BhaStatus (340)
/* witsml1:BhaStatus */
enum witsml1__BhaStatus
{
	witsml1__BhaStatus__final_ = 0,
	witsml1__BhaStatus__progress = 1,
	witsml1__BhaStatus__plan = 2,
	witsml1__BhaStatus__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:2875 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BladeShapeType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BladeShapeType (341)
/* witsml1:BladeShapeType */
enum witsml1__BladeShapeType
{
	witsml1__BladeShapeType__dynamic = 0,
	witsml1__BladeShapeType__melon = 1,
	witsml1__BladeShapeType__spiral = 2,
	witsml1__BladeShapeType__straight = 3,
	witsml1__BladeShapeType__variable = 4,
	witsml1__BladeShapeType__unknown = 5
};
#endif

/* witsml1_4_1_1ForGsoap.h:2903 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BladeType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BladeType (342)
/* witsml1:BladeType */
enum witsml1__BladeType
{
	witsml1__BladeType__clamp_on = 0,
	witsml1__BladeType__integral = 1,
	witsml1__BladeType__sleeve = 2,
	witsml1__BladeType__welded = 3,
	witsml1__BladeType__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:2928 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BopType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BopType (343)
/* witsml1:BopType */
enum witsml1__BopType
{
	witsml1__BopType__annular_x0020preventer = 0,
	witsml1__BopType__shear_x0020ram = 1,
	witsml1__BopType__blind_x0020ram = 2,
	witsml1__BopType__pipe_x0020ram = 3,
	witsml1__BopType__drilling_x0020spool = 4,
	witsml1__BopType__flexible_x0020joint = 5,
	witsml1__BopType__connector = 6,
	witsml1__BopType__unknown = 7
};
#endif

/* witsml1_4_1_1ForGsoap.h:2965 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BoxPinConfig
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__BoxPinConfig (344)
/* witsml1:BoxPinConfig */
enum witsml1__BoxPinConfig
{
	witsml1__BoxPinConfig__bottom_x0020box_x002c_x0020top_x0020box = 0,
	witsml1__BoxPinConfig__bottom_x0020box_x002c_x0020top_x0020pin = 1,
	witsml1__BoxPinConfig__bottom_x0020pin_x0020top_x0020box = 2,
	witsml1__BoxPinConfig__bottom_x0020pin = 3,
	witsml1__BoxPinConfig__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:2994 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__CementJobType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__CementJobType (345)
/* witsml1:CementJobType */
enum witsml1__CementJobType
{
	witsml1__CementJobType__primary = 0,
	witsml1__CementJobType__plug = 1,
	witsml1__CementJobType__squeeze = 2,
	witsml1__CementJobType__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:3016 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ChangeInfoType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ChangeInfoType (346)
/* witsml1:ChangeInfoType */
enum witsml1__ChangeInfoType
{
	witsml1__ChangeInfoType__add = 0,
	witsml1__ChangeInfoType__update = 1,
	witsml1__ChangeInfoType__delete_ = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:3038 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ChronostratigraphyUnit
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ChronostratigraphyUnit (347)
/* witsml1:ChronostratigraphyUnit */
enum witsml1__ChronostratigraphyUnit
{
	witsml1__ChronostratigraphyUnit__era = 0,
	witsml1__ChronostratigraphyUnit__period = 1,
	witsml1__ChronostratigraphyUnit__epoch = 2,
	witsml1__ChronostratigraphyUnit__stage = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:3073 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ConnectionPosition
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ConnectionPosition (348)
/* witsml1:ConnectionPosition */
enum witsml1__ConnectionPosition
{
	witsml1__ConnectionPosition__both = 0,
	witsml1__ConnectionPosition__bottom = 1,
	witsml1__ConnectionPosition__top = 2,
	witsml1__ConnectionPosition__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:3101 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DeflectionMethod
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DeflectionMethod (349)
/* witsml1:DeflectionMethod */
enum witsml1__DeflectionMethod
{
	witsml1__DeflectionMethod__point_x0020bit = 0,
	witsml1__DeflectionMethod__push_x0020bit = 1
};
#endif

/* witsml1_4_1_1ForGsoap.h:3119 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DerrickType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DerrickType (350)
/* witsml1:DerrickType */
enum witsml1__DerrickType
{
	witsml1__DerrickType__double_ = 0,
	witsml1__DerrickType__quadruple = 1,
	witsml1__DerrickType__slant = 2,
	witsml1__DerrickType__triple = 3,
	witsml1__DerrickType__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:3148 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DrawWorksType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DrawWorksType (351)
/* witsml1:DrawWorksType */
enum witsml1__DrawWorksType
{
	witsml1__DrawWorksType__mechanical = 0,
	witsml1__DrawWorksType__standard_x0020electric = 1,
	witsml1__DrawWorksType__diesel_x0020electric = 2,
	witsml1__DrawWorksType__ram_x0020rig = 3,
	witsml1__DrawWorksType__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:3176 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DriveType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__DriveType (352)
/* witsml1:DriveType */
enum witsml1__DriveType
{
	witsml1__DriveType__coiled_x0020tubing = 0,
	witsml1__DriveType__rotary_x0020kelly_x0020drive = 1,
	witsml1__DriveType__top_x0020drive = 2,
	witsml1__DriveType__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:3201 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__EastOrWest
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__EastOrWest (353)
/* witsml1:EastOrWest */
enum witsml1__EastOrWest
{
	witsml1__EastOrWest__east = 0,
	witsml1__EastOrWest__west = 1,
	witsml1__EastOrWest__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:3226 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ElevCodeEnum
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ElevCodeEnum (354)
/* witsml1:ElevCodeEnum */
enum witsml1__ElevCodeEnum
{
	witsml1__ElevCodeEnum__CF = 0,
	witsml1__ElevCodeEnum__CV = 1,
	witsml1__ElevCodeEnum__DF = 2,
	witsml1__ElevCodeEnum__GL = 3,
	witsml1__ElevCodeEnum__KB = 4,
	witsml1__ElevCodeEnum__RB = 5,
	witsml1__ElevCodeEnum__RT = 6,
	witsml1__ElevCodeEnum__SF = 7,
	witsml1__ElevCodeEnum__LAT = 8,
	witsml1__ElevCodeEnum__SL = 9,
	witsml1__ElevCodeEnum__MHHW = 10,
	witsml1__ElevCodeEnum__MHW = 11,
	witsml1__ElevCodeEnum__MLLW = 12,
	witsml1__ElevCodeEnum__MLW = 13,
	witsml1__ElevCodeEnum__MTL = 14,
	witsml1__ElevCodeEnum__KO = 15,
	witsml1__ElevCodeEnum__unknown = 16
};
#endif

/* witsml1_4_1_1ForGsoap.h:3307 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__Ellipsoid
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__Ellipsoid (355)
/* witsml1:Ellipsoid */
enum witsml1__Ellipsoid
{
	witsml1__Ellipsoid__AGD66 = 0,
	witsml1__Ellipsoid__AIRY_USCOREMOD = 1,
	witsml1__Ellipsoid__AIRY30 = 2,
	witsml1__Ellipsoid__AIRY49 = 3,
	witsml1__Ellipsoid__AUST_USCORENAT = 4,
	witsml1__Ellipsoid__BESL_DHD = 5,
	witsml1__Ellipsoid__BESL_NGL = 6,
	witsml1__Ellipsoid__BESL_RT9 = 7,
	witsml1__Ellipsoid__BESS41 = 8,
	witsml1__Ellipsoid__BESSNAM = 9,
	witsml1__Ellipsoid__BOGOTA = 10,
	witsml1__Ellipsoid__CL58 = 11,
	witsml1__Ellipsoid__CL58_1 = 12,
	witsml1__Ellipsoid__CL66 = 13,
	witsml1__Ellipsoid__CL66_M = 14,
	witsml1__Ellipsoid__CL80 = 15,
	witsml1__Ellipsoid__CL80_A = 16,
	witsml1__Ellipsoid__CL80_B = 17,
	witsml1__Ellipsoid__CL80_I = 18,
	witsml1__Ellipsoid__CL80_J = 19,
	witsml1__Ellipsoid__CL80_M = 20,
	witsml1__Ellipsoid__CL80_P = 21,
	witsml1__Ellipsoid__CMPOINCH = 22,
	witsml1__Ellipsoid__DAN = 23,
	witsml1__Ellipsoid__DELA = 24,
	witsml1__Ellipsoid__ED50 = 25,
	witsml1__Ellipsoid__EGYPT07 = 26,
	witsml1__Ellipsoid__EVER = 27,
	witsml1__Ellipsoid__EVER48 = 28,
	witsml1__Ellipsoid__EVER56 = 29,
	witsml1__Ellipsoid__EVER69 = 30,
	witsml1__Ellipsoid__EVER_BR = 31,
	witsml1__Ellipsoid__EVERMOD = 32,
	witsml1__Ellipsoid__EVER_P = 33,
	witsml1__Ellipsoid__EVER_TM = 34,
	witsml1__Ellipsoid__EVTM = 35,
	witsml1__Ellipsoid__FISC60 = 36,
	witsml1__Ellipsoid__FISC60MOD = 37,
	witsml1__Ellipsoid__FISC68 = 38,
	witsml1__Ellipsoid__FISCMOD = 39,
	witsml1__Ellipsoid__GDA94 = 40,
	witsml1__Ellipsoid__GRS67 = 41,
	witsml1__Ellipsoid__GRS80 = 42,
	witsml1__Ellipsoid__HAY09 = 43,
	witsml1__Ellipsoid__HEIS = 44,
	witsml1__Ellipsoid__HEL06 = 45,
	witsml1__Ellipsoid__HEL07 = 46,
	witsml1__Ellipsoid__HOUG = 47,
	witsml1__Ellipsoid__IAG_75 = 48,
	witsml1__Ellipsoid__INDIAN75 = 49,
	witsml1__Ellipsoid__INDO_74 = 50,
	witsml1__Ellipsoid__INT24 = 51,
	witsml1__Ellipsoid__IUGG67 = 52,
	witsml1__Ellipsoid__IUGG75 = 53,
	witsml1__Ellipsoid__JEFF48 = 54,
	witsml1__Ellipsoid__KAU63 = 55,
	witsml1__Ellipsoid__KRSV = 56,
	witsml1__Ellipsoid__MERIT83 = 57,
	witsml1__Ellipsoid__NAD27 = 58,
	witsml1__Ellipsoid__NAHRAN = 59,
	witsml1__Ellipsoid__NEWINT67 = 60,
	witsml1__Ellipsoid__NWL_10D = 61,
	witsml1__Ellipsoid__NWL_9D = 62,
	witsml1__Ellipsoid__OSGB36 = 63,
	witsml1__Ellipsoid__OSU86F = 64,
	witsml1__Ellipsoid__OSU91A = 65,
	witsml1__Ellipsoid__PLESSIS_1817 = 66,
	witsml1__Ellipsoid__PSAD56 = 67,
	witsml1__Ellipsoid__PTNOIRE = 68,
	witsml1__Ellipsoid__SA69 = 69,
	witsml1__Ellipsoid__SPHR = 70,
	witsml1__Ellipsoid__STRU = 71,
	witsml1__Ellipsoid__WALB = 72,
	witsml1__Ellipsoid__WAR24 = 73,
	witsml1__Ellipsoid__WGS60 = 74,
	witsml1__Ellipsoid__WGS66 = 75,
	witsml1__Ellipsoid__WGS72 = 76,
	witsml1__Ellipsoid__WGS84 = 77,
	witsml1__Ellipsoid__unknown = 78
};
#endif

/* witsml1_4_1_1ForGsoap.h:3635 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ErrorTermSource
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ErrorTermSource (356)
/* witsml1:ErrorTermSource */
enum witsml1__ErrorTermSource
{
	witsml1__ErrorTermSource__sensor = 0,
	witsml1__ErrorTermSource__azimuth_x0020reference = 1,
	witsml1__ErrorTermSource__magnetic = 2,
	witsml1__ErrorTermSource__alignment = 3,
	witsml1__ErrorTermSource__misalignment = 4,
	witsml1__ErrorTermSource__depth = 5,
	witsml1__ErrorTermSource__reference = 6,
	witsml1__ErrorTermSource__unknown = 7
};
#endif

/* witsml1_4_1_1ForGsoap.h:3681 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ErrorPropagationMode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ErrorPropagationMode (357)
/* witsml1:ErrorPropagationMode */
enum witsml1__ErrorPropagationMode
{
	witsml1__ErrorPropagationMode__B = 66,
	witsml1__ErrorPropagationMode__R = 82,
	witsml1__ErrorPropagationMode__S = 83,
	witsml1__ErrorPropagationMode__W = 87,
	witsml1__ErrorPropagationMode__G = 71,
	witsml1__ErrorPropagationMode__unknown = 88
};
#endif

/* witsml1_4_1_1ForGsoap.h:3717 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ErrorModelMisalignmentMode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ErrorModelMisalignmentMode (358)
/* witsml1:ErrorModelMisalignmentMode */
enum witsml1__ErrorModelMisalignmentMode
{
	witsml1__ErrorModelMisalignmentMode__1 = 1,
	witsml1__ErrorModelMisalignmentMode__2 = 2,
	witsml1__ErrorModelMisalignmentMode__3 = 3,
	witsml1__ErrorModelMisalignmentMode__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:3750 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__GasPeakType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__GasPeakType (360)
/* witsml1:GasPeakType */
enum witsml1__GasPeakType
{
	witsml1__GasPeakType__circulating_x0020background_x0020gas = 0,
	witsml1__GasPeakType__connection_x0020gas = 1,
	witsml1__GasPeakType__drilling_x0020background_x0020gas = 2,
	witsml1__GasPeakType__drilling_x0020gas_x0020peak = 3,
	witsml1__GasPeakType__flow_x0020check_x0020gas = 4,
	witsml1__GasPeakType__no_x0020readings = 5,
	witsml1__GasPeakType__other = 6,
	witsml1__GasPeakType__shut_x0020down_x0020gas = 7,
	witsml1__GasPeakType__trip_x0020gas = 8,
	witsml1__GasPeakType__unknown = 9
};
#endif

/* witsml1_4_1_1ForGsoap.h:3793 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__GeodeticDatum
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__GeodeticDatum (361)
/* witsml1:GeodeticDatum */
enum witsml1__GeodeticDatum
{
	witsml1__GeodeticDatum__ADND = 0,
	witsml1__GeodeticDatum__ARC50 = 1,
	witsml1__GeodeticDatum__AUSG = 2,
	witsml1__GeodeticDatum__CAA = 3,
	witsml1__GeodeticDatum__CHAS = 4,
	witsml1__GeodeticDatum__CORAL = 5,
	witsml1__GeodeticDatum__ED50 = 6,
	witsml1__GeodeticDatum__ED87 = 7,
	witsml1__GeodeticDatum__ERIN65 = 8,
	witsml1__GeodeticDatum__GD49 = 9,
	witsml1__GeodeticDatum__GHANA = 10,
	witsml1__GeodeticDatum__GUAM63 = 11,
	witsml1__GeodeticDatum__HJRS55 = 12,
	witsml1__GeodeticDatum__HTS = 13,
	witsml1__GeodeticDatum__INCH = 14,
	witsml1__GeodeticDatum__INDIA1 = 15,
	witsml1__GeodeticDatum__INDIA2 = 16,
	witsml1__GeodeticDatum__INDNS74 = 17,
	witsml1__GeodeticDatum__LIB64 = 18,
	witsml1__GeodeticDatum__LUZON = 19,
	witsml1__GeodeticDatum__MRCH = 20,
	witsml1__GeodeticDatum__NAD27 = 21,
	witsml1__GeodeticDatum__NAD83 = 22,
	witsml1__GeodeticDatum__NGRA = 23,
	witsml1__GeodeticDatum__None = 24,
	witsml1__GeodeticDatum__NPRM = 25,
	witsml1__GeodeticDatum__OSGB36 = 26,
	witsml1__GeodeticDatum__POTS1 = 27,
	witsml1__GeodeticDatum__PULK1 = 28,
	witsml1__GeodeticDatum__PULK2 = 29,
	witsml1__GeodeticDatum__QRNQ = 30,
	witsml1__GeodeticDatum__SA56 = 31,
	witsml1__GeodeticDatum__SRL60 = 32,
	witsml1__GeodeticDatum__TNRV25 = 33,
	witsml1__GeodeticDatum__TOKYO = 34,
	witsml1__GeodeticDatum__UserDefined = 35,
	witsml1__GeodeticDatum__VROL = 36,
	witsml1__GeodeticDatum__WGS72 = 37,
	witsml1__GeodeticDatum__WGS84 = 38,
	witsml1__GeodeticDatum__YACR = 39,
	witsml1__GeodeticDatum__unknown = 40
};
#endif

/* witsml1_4_1_1ForGsoap.h:3965 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__Hemispheres
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__Hemispheres (362)
/* witsml1:Hemispheres */
enum witsml1__Hemispheres
{
	witsml1__Hemispheres__northern = 0,
	witsml1__Hemispheres__southern = 1,
	witsml1__Hemispheres__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:3986 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__HoleCasingType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__HoleCasingType (363)
/* witsml1:HoleCasingType */
enum witsml1__HoleCasingType
{
	witsml1__HoleCasingType__blow_x0020out_x0020preventer = 0,
	witsml1__HoleCasingType__casing = 1,
	witsml1__HoleCasingType__conductor = 2,
	witsml1__HoleCasingType__curved_x0020conductor = 3,
	witsml1__HoleCasingType__liner = 4,
	witsml1__HoleCasingType__open_x0020hole = 5,
	witsml1__HoleCasingType__riser = 6,
	witsml1__HoleCasingType__tubing = 7,
	witsml1__HoleCasingType__unknown = 8
};
#endif

/* witsml1_4_1_1ForGsoap.h:4023 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__HoleOpenerType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__HoleOpenerType (364)
/* witsml1:HoleOpenerType */
enum witsml1__HoleOpenerType
{
	witsml1__HoleOpenerType__under_reamer = 0,
	witsml1__HoleOpenerType__fixed_x0020blade = 1,
	witsml1__HoleOpenerType__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:4042 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__InnerBarrelType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__InnerBarrelType (365)
/* witsml1:InnerBarrelType */
enum witsml1__InnerBarrelType
{
	witsml1__InnerBarrelType__undifferented = 0,
	witsml1__InnerBarrelType__aluminum = 1,
	witsml1__InnerBarrelType__gel = 2,
	witsml1__InnerBarrelType__fiberglass = 3,
	witsml1__InnerBarrelType__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:4074 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ItemState
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ItemState (366)
/* witsml1:ItemState */
enum witsml1__ItemState
{
	witsml1__ItemState__actual = 0,
	witsml1__ItemState__model = 1,
	witsml1__ItemState__plan = 2,
	witsml1__ItemState__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:4099 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__JarType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__JarType (367)
/* witsml1:JarType */
enum witsml1__JarType
{
	witsml1__JarType__mechanical = 0,
	witsml1__JarType__hydraulic = 1,
	witsml1__JarType__hydro_x0020mechanical = 2,
	witsml1__JarType__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:4121 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__JarAction
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__JarAction (368)
/* witsml1:JarAction */
enum witsml1__JarAction
{
	witsml1__JarAction__up = 0,
	witsml1__JarAction__down = 1,
	witsml1__JarAction__both = 2,
	witsml1__JarAction__vibrating = 3,
	witsml1__JarAction__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:4149 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LithologySource
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LithologySource (369)
/* witsml1:LithologySource */
enum witsml1__LithologySource
{
	witsml1__LithologySource__interpreted = 0,
	witsml1__LithologySource__core = 1,
	witsml1__LithologySource__cuttings = 2,
	witsml1__LithologySource__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:4187 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LithostratigraphyUnit
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LithostratigraphyUnit (371)
/* witsml1:LithostratigraphyUnit */
enum witsml1__LithostratigraphyUnit
{
	witsml1__LithostratigraphyUnit__group = 0,
	witsml1__LithostratigraphyUnit__formation = 1,
	witsml1__LithostratigraphyUnit__member = 2,
	witsml1__LithostratigraphyUnit__bed = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:4231 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogDataType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogDataType (372)
/* witsml1:LogDataType */
enum witsml1__LogDataType
{
	witsml1__LogDataType__byte = 0,
	witsml1__LogDataType__date_x0020time = 1,
	witsml1__LogDataType__double_ = 2,
	witsml1__LogDataType__float_ = 3,
	witsml1__LogDataType__int_ = 4,
	witsml1__LogDataType__long_ = 5,
	witsml1__LogDataType__short_ = 6,
	witsml1__LogDataType__string = 7,
	witsml1__LogDataType__string40 = 8,
	witsml1__LogDataType__string16 = 9,
	witsml1__LogDataType__unknown = 10
};
#endif

/* witsml1_4_1_1ForGsoap.h:4298 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogIndexDirection
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogIndexDirection (373)
/* witsml1:LogIndexDirection */
enum witsml1__LogIndexDirection
{
	witsml1__LogIndexDirection__decreasing = 0,
	witsml1__LogIndexDirection__increasing = 1,
	witsml1__LogIndexDirection__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:4322 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogIndexType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogIndexType (374)
/* witsml1:LogIndexType */
enum witsml1__LogIndexType
{
	witsml1__LogIndexType__date_x0020time = 0,
	witsml1__LogIndexType__elapsed_x0020time = 1,
	witsml1__LogIndexType__length = 2,
	witsml1__LogIndexType__measured_x0020depth = 3,
	witsml1__LogIndexType__vertical_x0020depth = 4,
	witsml1__LogIndexType__other = 5,
	witsml1__LogIndexType__unknown = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:4359 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogTraceOrigin
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogTraceOrigin (375)
/* witsml1:LogTraceOrigin */
enum witsml1__LogTraceOrigin
{
	witsml1__LogTraceOrigin__realtime = 0,
	witsml1__LogTraceOrigin__modeled = 1,
	witsml1__LogTraceOrigin__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:4380 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogTraceState
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LogTraceState (376)
/* witsml1:LogTraceState */
enum witsml1__LogTraceState
{
	witsml1__LogTraceState__depth_x0020adjusted = 0,
	witsml1__LogTraceState__edited = 1,
	witsml1__LogTraceState__joined = 2,
	witsml1__LogTraceState__processed = 3,
	witsml1__LogTraceState__raw = 4,
	witsml1__LogTraceState__unknown = 5
};
#endif

/* witsml1_4_1_1ForGsoap.h:4408 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MaterialType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MaterialType (377)
/* witsml1:MaterialType */
enum witsml1__MaterialType
{
	witsml1__MaterialType__aluminum = 0,
	witsml1__MaterialType__beryllium_x0020copper = 1,
	witsml1__MaterialType__chrome_x0020alloy = 2,
	witsml1__MaterialType__composite = 3,
	witsml1__MaterialType__other = 4,
	witsml1__MaterialType__non_magnetic_x0020steel = 5,
	witsml1__MaterialType__plastic = 6,
	witsml1__MaterialType__steel = 7,
	witsml1__MaterialType__steel_x0020alloy = 8,
	witsml1__MaterialType__titanium = 9,
	witsml1__MaterialType__unknown = 10
};
#endif

/* witsml1_4_1_1ForGsoap.h:4471 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MeasurementType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MeasurementType (380)
/* witsml1:MeasurementType */
enum witsml1__MeasurementType
{
	witsml1__MeasurementType__acceleration = 0,
	witsml1__MeasurementType__acoustic_x0020caliper = 1,
	witsml1__MeasurementType__acoustic_x0020casing_x0020collar_x0020locator = 2,
	witsml1__MeasurementType__acoustic_x0020impedance = 3,
	witsml1__MeasurementType__acoustic_x0020porosity = 4,
	witsml1__MeasurementType__acoustic_x0020velocity = 5,
	witsml1__MeasurementType__acoustic_x0020wave_x0020matrix_x0020travel_x0020time = 6,
	witsml1__MeasurementType__acoustic_x0020wave_x0020travel_x0020time = 7,
	witsml1__MeasurementType__amplitude = 8,
	witsml1__MeasurementType__amplitude_x0020of_x0020acoustic_x0020wave = 9,
	witsml1__MeasurementType__amplitude_x0020of_x0020E_M_x0020wave = 10,
	witsml1__MeasurementType__amplitude_x0020ratio = 11,
	witsml1__MeasurementType__area = 12,
	witsml1__MeasurementType__attenuation = 13,
	witsml1__MeasurementType__attenuation_x0020of_x0020acoustic_x0020wave = 14,
	witsml1__MeasurementType__attenuation_x0020of_x0020E_M_x0020wave = 15,
	witsml1__MeasurementType__auxiliary = 16,
	witsml1__MeasurementType__average_x0020porosity = 17,
	witsml1__MeasurementType__azimuth = 18,
	witsml1__MeasurementType__barite_x0020mud_x0020correction = 19,
	witsml1__MeasurementType__bed_x0020thickness_x0020correction = 20,
	witsml1__MeasurementType__bit_x0020size = 21,
	witsml1__MeasurementType__blocked = 22,
	witsml1__MeasurementType__borehole_x0020environment_x0020correction = 23,
	witsml1__MeasurementType__borehole_x0020fluid_x0020composition_x0020correction = 24,
	witsml1__MeasurementType__borehole_x0020fluid_x0020correction = 25,
	witsml1__MeasurementType__borehole_x0020size_x0020correction = 26,
	witsml1__MeasurementType__bromide_x0020mud_x0020correction = 27,
	witsml1__MeasurementType__bulk_x0020compressibility = 28,
	witsml1__MeasurementType__bulk_x0020density = 29,
	witsml1__MeasurementType__bulk_x0020volume = 30,
	witsml1__MeasurementType__bulk_x0020volume_x0020gas = 31,
	witsml1__MeasurementType__bulk_x0020volume_x0020hydrocarbon = 32,
	witsml1__MeasurementType__bulk_x0020volume_x0020oil = 33,
	witsml1__MeasurementType__bulk_x0020volume_x0020water = 34,
	witsml1__MeasurementType__C_x002fO_x0020ratio = 35,
	witsml1__MeasurementType__caliper = 36,
	witsml1__MeasurementType__cased_x0020hole_x0020correction = 37,
	witsml1__MeasurementType__casing_x0020collar_x0020locator = 38,
	witsml1__MeasurementType__casing_x0020correction = 39,
	witsml1__MeasurementType__casing_x0020diameter_x0020correction = 40,
	witsml1__MeasurementType__casing_x0020inspection = 41,
	witsml1__MeasurementType__casing_x0020thickness_x0020correction = 42,
	witsml1__MeasurementType__casing_x0020weight_x0020correction = 43,
	witsml1__MeasurementType__cement_x0020correction = 44,
	witsml1__MeasurementType__cement_x0020density_x0020correction = 45,
	witsml1__MeasurementType__cement_x0020evaluation = 46,
	witsml1__MeasurementType__cement_x0020thickness_x0020correction = 47,
	witsml1__MeasurementType__cement_x0020type_x0020correction = 48,
	witsml1__MeasurementType__CH_x0020density_x0020porosity = 49,
	witsml1__MeasurementType__CH_x0020dolomite_x0020density_x0020porosity = 50,
	witsml1__MeasurementType__CH_x0020dolomite_x0020neutron_x0020porosity = 51,
	witsml1__MeasurementType__CH_x0020limestone_x0020density_x0020porosity = 52,
	witsml1__MeasurementType__CH_x0020limestone_x0020neutron_x0020porosity = 53,
	witsml1__MeasurementType__CH_x0020neutron_x0020porosity = 54,
	witsml1__MeasurementType__CH_x0020sandstone_x0020density_x0020porosity = 55,
	witsml1__MeasurementType__CH_x0020sandstone_x0020neutron_x0020porosity = 56,
	witsml1__MeasurementType__compressional_x0020wave_x0020dolomite_x0020porosity = 57,
	witsml1__MeasurementType__compressional_x0020wave_x0020limestone_x0020porosity = 58,
	witsml1__MeasurementType__compressional_x0020wave_x0020matrix_x0020travel_x0020time = 59,
	witsml1__MeasurementType__compressional_x0020wave_x0020sandstone_x0020porosity = 60,
	witsml1__MeasurementType__compressional_x0020wave_x0020travel_x0020time = 61,
	witsml1__MeasurementType__conductivity = 62,
	witsml1__MeasurementType__conductivity_x0020from_x0020attenuation = 63,
	witsml1__MeasurementType__conductivity_x0020from_x0020phase_x0020shift = 64,
	witsml1__MeasurementType__connate_x0020water_x0020conductivity = 65,
	witsml1__MeasurementType__connate_x0020water_x0020resistivity = 66,
	witsml1__MeasurementType__conventional_x0020core_x0020porosity = 67,
	witsml1__MeasurementType__core_x0020matrix_x0020density = 68,
	witsml1__MeasurementType__core_x0020permeability = 69,
	witsml1__MeasurementType__core_x0020porosity = 70,
	witsml1__MeasurementType__corrected = 71,
	witsml1__MeasurementType__count_x0020rate = 72,
	witsml1__MeasurementType__count_x0020rate_x0020ratio = 73,
	witsml1__MeasurementType__cross_x0020plot_x0020porosity = 74,
	witsml1__MeasurementType__decay_x0020time = 75,
	witsml1__MeasurementType__deep_x0020conductivity = 76,
	witsml1__MeasurementType__deep_x0020induction_x0020conductivity = 77,
	witsml1__MeasurementType__deep_x0020induction_x0020resistivity = 78,
	witsml1__MeasurementType__deep_x0020laterolog_x0020conductivity = 79,
	witsml1__MeasurementType__deep_x0020laterolog_x0020resistivity = 80,
	witsml1__MeasurementType__deep_x0020resistivity = 81,
	witsml1__MeasurementType__density = 82,
	witsml1__MeasurementType__density_x0020porosity = 83,
	witsml1__MeasurementType__depth = 84,
	witsml1__MeasurementType__depth_x0020adjusted = 85,
	witsml1__MeasurementType__depth_x0020derived_x0020from_x0020velocity = 86,
	witsml1__MeasurementType__deviation = 87,
	witsml1__MeasurementType__dielectric = 88,
	witsml1__MeasurementType__diffusion_x0020correction = 89,
	witsml1__MeasurementType__dip = 90,
	witsml1__MeasurementType__dipmeter = 91,
	witsml1__MeasurementType__dipmeter_x0020conductivity = 92,
	witsml1__MeasurementType__dipmeter_x0020resistivity = 93,
	witsml1__MeasurementType__dolomite_x0020acoustic_x0020porosity = 94,
	witsml1__MeasurementType__dolomite_x0020density_x0020porosity = 95,
	witsml1__MeasurementType__dolomite_x0020neutron_x0020porosity = 96,
	witsml1__MeasurementType__edited = 97,
	witsml1__MeasurementType__effective_x0020porosity = 98,
	witsml1__MeasurementType__electric_x0020current = 99,
	witsml1__MeasurementType__electric_x0020potential = 100,
	witsml1__MeasurementType__electromagnetic_x0020wave_x0020matrix_x0020travel_x0020time = 101,
	witsml1__MeasurementType__electromagnetic_x0020wave_x0020travel_x0020time = 102,
	witsml1__MeasurementType__element = 103,
	witsml1__MeasurementType__elemental_x0020ratio = 104,
	witsml1__MeasurementType__enhanced = 105,
	witsml1__MeasurementType__filtered = 106,
	witsml1__MeasurementType__flowmeter = 107,
	witsml1__MeasurementType__fluid_x0020density = 108,
	witsml1__MeasurementType__fluid_x0020velocity = 109,
	witsml1__MeasurementType__fluid_x0020viscosity = 110,
	witsml1__MeasurementType__flushed_x0020zone_x0020conductivity = 111,
	witsml1__MeasurementType__flushed_x0020zone_x0020resistivity = 112,
	witsml1__MeasurementType__flushed_x0020zone_x0020saturation = 113,
	witsml1__MeasurementType__force = 114,
	witsml1__MeasurementType__formation_x0020density_x0020correction = 115,
	witsml1__MeasurementType__formation_x0020properties_x0020correction = 116,
	witsml1__MeasurementType__formation_x0020salinity_x0020correction = 117,
	witsml1__MeasurementType__formation_x0020saturation_x0020correction = 118,
	witsml1__MeasurementType__formation_x0020volume_x0020factor_x0020correction = 119,
	witsml1__MeasurementType__formation_x0020water_x0020density_x0020correction = 120,
	witsml1__MeasurementType__formation_x0020water_x0020saturation_x0020correction = 121,
	witsml1__MeasurementType__free_x0020fluid_x0020index = 122,
	witsml1__MeasurementType__friction_x0020effect_x0020correction = 123,
	witsml1__MeasurementType__gamma_x0020ray = 124,
	witsml1__MeasurementType__gamma_x0020ray_x0020minus_x0020uranium = 125,
	witsml1__MeasurementType__gas_x0020saturation = 126,
	witsml1__MeasurementType__gradiomanometer = 127,
	witsml1__MeasurementType__high_x0020frequency_x0020conductivity = 128,
	witsml1__MeasurementType__high_x0020frequency_x0020electromagnetic = 129,
	witsml1__MeasurementType__high_x0020frequency_x0020electromagnetic_x0020porosity = 130,
	witsml1__MeasurementType__high_x0020frequency_x0020E_M_x0020phase_x0020shift = 131,
	witsml1__MeasurementType__high_x0020frequency_x0020resistivity = 132,
	witsml1__MeasurementType__hydrocarbon_x0020correction = 133,
	witsml1__MeasurementType__hydrocarbon_x0020density_x0020correction = 134,
	witsml1__MeasurementType__hydrocarbon_x0020gravity_x0020correction = 135,
	witsml1__MeasurementType__hydrocarbon_x0020saturation = 136,
	witsml1__MeasurementType__hydrocarbon_x0020viscosity_x0020correction = 137,
	witsml1__MeasurementType__image = 138,
	witsml1__MeasurementType__interpretation_x0020variable = 139,
	witsml1__MeasurementType__iron_x0020mud_x0020correction = 140,
	witsml1__MeasurementType__joined = 141,
	witsml1__MeasurementType__KCl_x0020mud_x0020correction = 142,
	witsml1__MeasurementType__length = 143,
	witsml1__MeasurementType__limestone_x0020acoustic_x0020porosity = 144,
	witsml1__MeasurementType__limestone_x0020density_x0020porosity = 145,
	witsml1__MeasurementType__limestone_x0020neutron_x0020porosity = 146,
	witsml1__MeasurementType__lithology_x0020correction = 147,
	witsml1__MeasurementType__log_x0020derived_x0020permeability = 148,
	witsml1__MeasurementType__log_x0020matrix_x0020density = 149,
	witsml1__MeasurementType__magnetic_x0020casing_x0020collar_x0020locator = 150,
	witsml1__MeasurementType__matrix_x0020density = 151,
	witsml1__MeasurementType__matrix_x0020travel_x0020time = 152,
	witsml1__MeasurementType__measured_x0020depth = 153,
	witsml1__MeasurementType__mechanical_x0020caliper = 154,
	witsml1__MeasurementType__mechanical_x0020casing_x0020collar_x0020locator = 155,
	witsml1__MeasurementType__medium_x0020conductivity = 156,
	witsml1__MeasurementType__medium_x0020induction_x0020conductivity = 157,
	witsml1__MeasurementType__medium_x0020induction_x0020resistivity = 158,
	witsml1__MeasurementType__medium_x0020laterolog_x0020conductivity = 159,
	witsml1__MeasurementType__medium_x0020laterolog_x0020resistivity = 160,
	witsml1__MeasurementType__medium_x0020resistivity = 161,
	witsml1__MeasurementType__micro_x0020conductivity = 162,
	witsml1__MeasurementType__micro_x0020inverse_x0020conductivity = 163,
	witsml1__MeasurementType__micro_x0020inverse_x0020resistivity = 164,
	witsml1__MeasurementType__micro_x0020laterolog_x0020conductivity = 165,
	witsml1__MeasurementType__micro_x0020laterolog_x0020resistivity = 166,
	witsml1__MeasurementType__micro_x0020normal_x0020conductivity = 167,
	witsml1__MeasurementType__micro_x0020normal_x0020resistivity = 168,
	witsml1__MeasurementType__micro_x0020resistivity = 169,
	witsml1__MeasurementType__micro_x0020spherically_x0020focused_x0020conductivity = 170,
	witsml1__MeasurementType__micro_x0020spherically_x0020focused_x0020resistivity = 171,
	witsml1__MeasurementType__mineral = 172,
	witsml1__MeasurementType__mud_x0020cake_x0020conductivity = 173,
	witsml1__MeasurementType__mud_x0020cake_x0020correction = 174,
	witsml1__MeasurementType__mud_x0020cake_x0020density_x0020correction = 175,
	witsml1__MeasurementType__mud_x0020cake_x0020resistivity = 176,
	witsml1__MeasurementType__mud_x0020cake_x0020resistivity_x0020correction = 177,
	witsml1__MeasurementType__mud_x0020cake_x0020thickness_x0020correction = 178,
	witsml1__MeasurementType__mud_x0020composition_x0020correction = 179,
	witsml1__MeasurementType__mud_x0020conductivity = 180,
	witsml1__MeasurementType__mud_x0020filtrate_x0020conductivity = 181,
	witsml1__MeasurementType__mud_x0020filtrate_x0020correction = 182,
	witsml1__MeasurementType__mud_x0020filtrate_x0020density_x0020correction = 183,
	witsml1__MeasurementType__mud_x0020filtrate_x0020resistivity = 184,
	witsml1__MeasurementType__mud_x0020filtrate_x0020resistivity_x0020correction = 185,
	witsml1__MeasurementType__mud_x0020filtrate_x0020salinity_x0020correction = 186,
	witsml1__MeasurementType__mud_x0020resistivity = 187,
	witsml1__MeasurementType__mud_x0020salinity_x0020correction = 188,
	witsml1__MeasurementType__mud_x0020viscosity_x0020correction = 189,
	witsml1__MeasurementType__mud_x0020weight_x0020correction = 190,
	witsml1__MeasurementType__neutron_x0020die_x0020away_x0020time = 191,
	witsml1__MeasurementType__neutron_x0020porosity = 192,
	witsml1__MeasurementType__nuclear_x0020caliper = 193,
	witsml1__MeasurementType__nuclear_x0020magnetic_x0020decay_x0020time = 194,
	witsml1__MeasurementType__nuclear_x0020magnetism_x0020log_x0020permeability = 195,
	witsml1__MeasurementType__nuclear_x0020magnetism_x0020porosity = 196,
	witsml1__MeasurementType__OH_x0020density_x0020porosity = 197,
	witsml1__MeasurementType__OH_x0020dolomite_x0020density_x0020porosity = 198,
	witsml1__MeasurementType__OH_x0020dolomite_x0020neutron_x0020porosity = 199,
	witsml1__MeasurementType__OH_x0020limestone_x0020density_x0020porosity = 200,
	witsml1__MeasurementType__OH_x0020limestone_x0020neutron_x0020porosity = 201,
	witsml1__MeasurementType__OH_x0020neutron_x0020porosity = 202,
	witsml1__MeasurementType__OH_x0020sandstone_x0020density_x0020porosity = 203,
	witsml1__MeasurementType__OH_x0020sandstone_x0020neutron_x0020porosity = 204,
	witsml1__MeasurementType__oil_x0020based_x0020mud_x0020correction = 205,
	witsml1__MeasurementType__oil_x0020saturation = 206,
	witsml1__MeasurementType__perforating = 207,
	witsml1__MeasurementType__permeability = 208,
	witsml1__MeasurementType__phase_x0020shift = 209,
	witsml1__MeasurementType__photoelectric_x0020absorption = 210,
	witsml1__MeasurementType__photoelectric_x0020absorption_x0020correction = 211,
	witsml1__MeasurementType__physical_x0020measurement_x0020correction = 212,
	witsml1__MeasurementType__plane_x0020angle = 213,
	witsml1__MeasurementType__porosity = 214,
	witsml1__MeasurementType__porosity_x0020correction = 215,
	witsml1__MeasurementType__potassium = 216,
	witsml1__MeasurementType__pressure = 217,
	witsml1__MeasurementType__pressure_x0020correction = 218,
	witsml1__MeasurementType__processed = 219,
	witsml1__MeasurementType__pulsed_x0020neutron_x0020porosity = 220,
	witsml1__MeasurementType__quality = 221,
	witsml1__MeasurementType__ratio = 222,
	witsml1__MeasurementType__raw = 223,
	witsml1__MeasurementType__relative_x0020bearing = 224,
	witsml1__MeasurementType__resistivity = 225,
	witsml1__MeasurementType__resistivity_x0020factor_x0020correction = 226,
	witsml1__MeasurementType__resistivity_x0020from_x0020attenuation = 227,
	witsml1__MeasurementType__resistivity_x0020from_x0020phase_x0020shift = 228,
	witsml1__MeasurementType__resistivity_x0020phase_x0020shift = 229,
	witsml1__MeasurementType__resistivity_x0020ratio = 230,
	witsml1__MeasurementType__salinity = 231,
	witsml1__MeasurementType__sampling = 232,
	witsml1__MeasurementType__sandstone_x0020acoustic_x0020porosity = 233,
	witsml1__MeasurementType__sandstone_x0020density_x0020porosity = 234,
	witsml1__MeasurementType__sandstone_x0020neutron_x0020porosity = 235,
	witsml1__MeasurementType__saturation = 236,
	witsml1__MeasurementType__shale_x0020volume = 237,
	witsml1__MeasurementType__shallow_x0020conductivity = 238,
	witsml1__MeasurementType__shallow_x0020induction_x0020conductivity = 239,
	witsml1__MeasurementType__shallow_x0020induction_x0020resistivity = 240,
	witsml1__MeasurementType__shallow_x0020laterolog_x0020conductivity = 241,
	witsml1__MeasurementType__shallow_x0020laterolog_x0020resistivity = 242,
	witsml1__MeasurementType__shallow_x0020resistivity = 243,
	witsml1__MeasurementType__shear_x0020wave_x0020dolomite_x0020porosity = 244,
	witsml1__MeasurementType__shear_x0020wave_x0020limestone_x0020porosity = 245,
	witsml1__MeasurementType__shear_x0020wave_x0020matrix_x0020travel_x0020time = 246,
	witsml1__MeasurementType__shear_x0020wave_x0020sandstone_x0020porosity = 247,
	witsml1__MeasurementType__shear_x0020wave_x0020travel_x0020time = 248,
	witsml1__MeasurementType__shifted = 249,
	witsml1__MeasurementType__sidewall_x0020core_x0020porosity = 250,
	witsml1__MeasurementType__sigma = 251,
	witsml1__MeasurementType__sigma_x0020formation = 252,
	witsml1__MeasurementType__sigma_x0020gas = 253,
	witsml1__MeasurementType__sigma_x0020hydrocarbon = 254,
	witsml1__MeasurementType__sigma_x0020matrix = 255,
	witsml1__MeasurementType__sigma_x0020oil = 256,
	witsml1__MeasurementType__sigma_x0020water = 257,
	witsml1__MeasurementType__slippage_x0020velocity_x0020correction = 258,
	witsml1__MeasurementType__smoothed = 259,
	witsml1__MeasurementType__spectral_x0020gamma_x0020ray = 260,
	witsml1__MeasurementType__spherically_x0020focused_x0020conductivity = 261,
	witsml1__MeasurementType__spherically_x0020focused_x0020resistivity = 262,
	witsml1__MeasurementType__spontaneous_x0020potential = 263,
	witsml1__MeasurementType__spreading_x0020loss_x0020correction = 264,
	witsml1__MeasurementType__synthetic_x0020well_x0020log_x0020trace = 265,
	witsml1__MeasurementType__temperature = 266,
	witsml1__MeasurementType__temperature_x0020correction = 267,
	witsml1__MeasurementType__tension = 268,
	witsml1__MeasurementType__Th_x002fK_x0020ratio = 269,
	witsml1__MeasurementType__thorium = 270,
	witsml1__MeasurementType__time = 271,
	witsml1__MeasurementType__tool_x0020diameter_x0020correction = 272,
	witsml1__MeasurementType__tool_x0020eccentricity_x0020correction = 273,
	witsml1__MeasurementType__total_x0020gamma_x0020ray = 274,
	witsml1__MeasurementType__total_x0020porosity = 275,
	witsml1__MeasurementType__tracer_x0020survey = 276,
	witsml1__MeasurementType__travel_x0020time = 277,
	witsml1__MeasurementType__true_x0020conductivity = 278,
	witsml1__MeasurementType__true_x0020resistivity = 279,
	witsml1__MeasurementType__true_x0020vertical_x0020depth = 280,
	witsml1__MeasurementType__tube_x0020wave_x0020dolomite_x0020porosity = 281,
	witsml1__MeasurementType__tube_x0020wave_x0020limestone_x0020porosity = 282,
	witsml1__MeasurementType__tube_x0020wave_x0020matrix_x0020travel_x0020time = 283,
	witsml1__MeasurementType__tube_x0020wave_x0020sandstone_x0020porosity = 284,
	witsml1__MeasurementType__tube_x0020wave_x0020travel_x0020time = 285,
	witsml1__MeasurementType__uranium = 286,
	witsml1__MeasurementType__velocity = 287,
	witsml1__MeasurementType__volume = 288,
	witsml1__MeasurementType__water_x0020based_x0020fluid_x0020correction = 289,
	witsml1__MeasurementType__water_x0020holdup_x0020correction = 290,
	witsml1__MeasurementType__water_x0020saturated_x0020conductivity = 291,
	witsml1__MeasurementType__water_x0020saturated_x0020resistivity = 292,
	witsml1__MeasurementType__water_x0020saturation = 293,
	witsml1__MeasurementType__unknown = 294
};
#endif

/* witsml1_4_1_1ForGsoap.h:5656 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MessageProbability
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MessageProbability (381)
/* witsml1:MessageProbability */
enum witsml1__MessageProbability
{
	witsml1__MessageProbability__low = 0,
	witsml1__MessageProbability__medium = 1,
	witsml1__MessageProbability__high = 2,
	witsml1__MessageProbability__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:5678 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MessageSeverity
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MessageSeverity (382)
/* witsml1:MessageSeverity */
enum witsml1__MessageSeverity
{
	witsml1__MessageSeverity__catastrophic = 0,
	witsml1__MessageSeverity__major = 1,
	witsml1__MessageSeverity__minor = 2,
	witsml1__MessageSeverity__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:5703 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MessageType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MessageType (383)
/* witsml1:MessageType */
enum witsml1__MessageType
{
	witsml1__MessageType__alarm = 0,
	witsml1__MessageType__event = 1,
	witsml1__MessageType__informational = 2,
	witsml1__MessageType__warning = 3,
	witsml1__MessageType__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:5735 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MudClass
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MudClass (384)
/* witsml1:MudClass */
enum witsml1__MudClass
{
	witsml1__MudClass__water_x0020based = 0,
	witsml1__MudClass__oil_x0020based = 1,
	witsml1__MudClass__other = 2,
	witsml1__MudClass__pneumatic = 3,
	witsml1__MudClass__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:5771 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MudLogParameterType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MudLogParameterType (385)
/* witsml1:MudLogParameterType */
enum witsml1__MudLogParameterType
{
	witsml1__MudLogParameterType__bit_x0020parameters = 0,
	witsml1__MudLogParameterType__bit_x0020type_x0020comment = 1,
	witsml1__MudLogParameterType__casing_x0020point_x0020comment = 2,
	witsml1__MudLogParameterType__chromatograph_x0020comment = 3,
	witsml1__MudLogParameterType__circulation_x0020system_x0020comment = 4,
	witsml1__MudLogParameterType__core_x0020interval_x0020comment = 5,
	witsml1__MudLogParameterType__cuttings_x0020gas = 6,
	witsml1__MudLogParameterType__direct_x0020fracture_x0020pressure = 7,
	witsml1__MudLogParameterType__direct_x0020pore_x0020pressure_x0020measurements = 8,
	witsml1__MudLogParameterType__drilling_x0020data_x0020comment = 9,
	witsml1__MudLogParameterType__fracture_x0020PG_x0020estimate_x0020most_x0020likely = 10,
	witsml1__MudLogParameterType__gas_x0020peaks_x0020comment = 11,
	witsml1__MudLogParameterType__gas_x0020ratio_x0020comment = 12,
	witsml1__MudLogParameterType__general_x0020engineering_x0020comment = 13,
	witsml1__MudLogParameterType__kicks_x0020and_x0020flows = 14,
	witsml1__MudLogParameterType__lithlog_x0020comment = 15,
	witsml1__MudLogParameterType__lost_x0020returns = 16,
	witsml1__MudLogParameterType__LWD_x0020comment = 17,
	witsml1__MudLogParameterType__marker_x0020or_x0020formation_x0020top_x0020comment = 18,
	witsml1__MudLogParameterType__midnight_x0020depth_x0020date = 19,
	witsml1__MudLogParameterType__mud_x0020check_x0020comment = 20,
	witsml1__MudLogParameterType__mud_x0020data_x0020comment = 21,
	witsml1__MudLogParameterType__mudlog_x0020comment = 22,
	witsml1__MudLogParameterType__overburden_x0020gradient = 23,
	witsml1__MudLogParameterType__overpull_x0020on_x0020connection = 24,
	witsml1__MudLogParameterType__overpull_x0020on_x0020trip = 25,
	witsml1__MudLogParameterType__pore_x0020PG_x0020estimate_x0020most_x0020likely = 26,
	witsml1__MudLogParameterType__pore_x0020pressure_x0020estimate_x0020while_x0020drilling = 27,
	witsml1__MudLogParameterType__pressure_x0020data_x0020comment = 28,
	witsml1__MudLogParameterType__shale_x0020density_x0020comment = 29,
	witsml1__MudLogParameterType__short_x0020trip_x0020comment = 30,
	witsml1__MudLogParameterType__show_x0020report_x0020comment = 31,
	witsml1__MudLogParameterType__sidewall_x0020core_x0020comment = 32,
	witsml1__MudLogParameterType__sliding_x0020Interval = 33,
	witsml1__MudLogParameterType__steam_x0020still_x0020results_x0020comment = 34,
	witsml1__MudLogParameterType__survey_x0020comment = 35,
	witsml1__MudLogParameterType__temperature_x0020data_x0020comment = 36,
	witsml1__MudLogParameterType__temperature_x0020trend_x0020comment = 37,
	witsml1__MudLogParameterType__wireline_x0020log_x0020comment = 38,
	witsml1__MudLogParameterType__unknown = 39
};
#endif

/* witsml1_4_1_1ForGsoap.h:5949 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NADTypes
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NADTypes (387)
/* witsml1:NADTypes */
enum witsml1__NADTypes
{
	witsml1__NADTypes__NAD27 = 0,
	witsml1__NADTypes__NAD83 = 1,
	witsml1__NADTypes__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:5992 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NorthOrSouth
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NorthOrSouth (391)
/* witsml1:NorthOrSouth */
enum witsml1__NorthOrSouth
{
	witsml1__NorthOrSouth__north = 0,
	witsml1__NorthOrSouth__south = 1,
	witsml1__NorthOrSouth__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:6013 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NozzleType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NozzleType (392)
/* witsml1:NozzleType */
enum witsml1__NozzleType
{
	witsml1__NozzleType__extended = 0,
	witsml1__NozzleType__normal = 1,
	witsml1__NozzleType__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:6032 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__OpsReportVersion
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__OpsReportVersion (393)
/* witsml1:OpsReportVersion */
enum witsml1__OpsReportVersion
{
	witsml1__OpsReportVersion__preliminary = 0,
	witsml1__OpsReportVersion__normal = 1,
	witsml1__OpsReportVersion__final_ = 2,
	witsml1__OpsReportVersion__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:6062 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PIDXCommodityCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PIDXCommodityCode (394)
/* witsml1:PIDXCommodityCode */
enum witsml1__PIDXCommodityCode
{
	witsml1__PIDXCommodityCode__71131001 = 71131001LL,
	witsml1__PIDXCommodityCode__71131002 = 71131002LL,
	witsml1__PIDXCommodityCode__71131003 = 71131003LL,
	witsml1__PIDXCommodityCode__71131004 = 71131004LL,
	witsml1__PIDXCommodityCode__71131005 = 71131005LL,
	witsml1__PIDXCommodityCode__71131006 = 71131006LL,
	witsml1__PIDXCommodityCode__71131007 = 71131007LL,
	witsml1__PIDXCommodityCode__71131008 = 71131008LL,
	witsml1__PIDXCommodityCode__71131009 = 71131009LL,
	witsml1__PIDXCommodityCode__71131010 = 71131010LL,
	witsml1__PIDXCommodityCode__71131011 = 71131011LL,
	witsml1__PIDXCommodityCode__71131012 = 71131012LL,
	witsml1__PIDXCommodityCode__71131013 = 71131013LL,
	witsml1__PIDXCommodityCode__71131014 = 71131014LL,
	witsml1__PIDXCommodityCode__71131015 = 71131015LL,
	witsml1__PIDXCommodityCode__71131016 = 71131016LL,
	witsml1__PIDXCommodityCode__71131018 = 71131018LL,
	witsml1__PIDXCommodityCode__71131019 = 71131019LL
};
#endif

/* witsml1_4_1_1ForGsoap.h:6141 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PitType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PitType (395)
/* witsml1:PitType */
enum witsml1__PitType
{
	witsml1__PitType__bulk = 0,
	witsml1__PitType__chemical = 1,
	witsml1__PitType__drilling = 2,
	witsml1__PitType__mix = 3,
	witsml1__PitType__mud_x0020cleaning = 4,
	witsml1__PitType__sand_x0020trap = 5,
	witsml1__PitType__slug = 6,
	witsml1__PitType__storage = 7,
	witsml1__PitType__surge_x0020tank = 8,
	witsml1__PitType__trip_x0020tank = 9,
	witsml1__PitType__unknown = 10
};
#endif

/* witsml1_4_1_1ForGsoap.h:6189 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PrimitiveType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PrimitiveType (396)
/* witsml1:PrimitiveType */
enum witsml1__PrimitiveType
{
	witsml1__PrimitiveType__string = 0,
	witsml1__PrimitiveType__boolean = 1,
	witsml1__PrimitiveType__float_ = 2,
	witsml1__PrimitiveType__double_ = 3,
	witsml1__PrimitiveType__duration = 4,
	witsml1__PrimitiveType__dateTime = 5,
	witsml1__PrimitiveType__time = 6,
	witsml1__PrimitiveType__date = 7,
	witsml1__PrimitiveType__gYearMonth = 8,
	witsml1__PrimitiveType__gYear = 9,
	witsml1__PrimitiveType__gMonthDay = 10,
	witsml1__PrimitiveType__gDay = 11,
	witsml1__PrimitiveType__gMonth = 12,
	witsml1__PrimitiveType__base64Binary = 13,
	witsml1__PrimitiveType__anyURI = 14,
	witsml1__PrimitiveType__unknown = 15
};
#endif

/* witsml1_4_1_1ForGsoap.h:6221 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__Projection
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__Projection (397)
/* witsml1:Projection */
enum witsml1__Projection
{
	witsml1__Projection__Albers_x0020equal_x0020area = 0,
	witsml1__Projection__azimuthal_x0020equidistant = 1,
	witsml1__Projection__Cassini = 2,
	witsml1__Projection__equidistant_x0020conic = 3,
	witsml1__Projection__equirectangular = 4,
	witsml1__Projection__gnomonic = 5,
	witsml1__Projection__Lambert_x0020azimuthal = 6,
	witsml1__Projection__Lambert_x0020conformal_x0020conic = 7,
	witsml1__Projection__Mercator = 8,
	witsml1__Projection__Miller = 9,
	witsml1__Projection__oblique_x0020Mercator = 10,
	witsml1__Projection__orthographic = 11,
	witsml1__Projection__perspective = 12,
	witsml1__Projection__polar_x0020stereographic = 13,
	witsml1__Projection__polyconic = 14,
	witsml1__Projection__sinusoidal = 15,
	witsml1__Projection__state_x0020plane = 16,
	witsml1__Projection__stereographic = 17,
	witsml1__Projection__transverse_x0020Mercator = 18,
	witsml1__Projection__universal_x0020transverse_x0020Mercator = 19,
	witsml1__Projection__user_x0020defined = 20,
	witsml1__Projection__Van_x0020der_x0020Grinten = 21,
	witsml1__Projection__unknown = 22
};
#endif

/* witsml1_4_1_1ForGsoap.h:6321 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ProjectionVariantsObliqueMercator
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ProjectionVariantsObliqueMercator (398)
/* witsml1:ProjectionVariantsObliqueMercator */
enum witsml1__ProjectionVariantsObliqueMercator
{
	witsml1__ProjectionVariantsObliqueMercator__default_ = 0,
	witsml1__ProjectionVariantsObliqueMercator__rectified = 1,
	witsml1__ProjectionVariantsObliqueMercator__rectified_x0020skew = 2,
	witsml1__ProjectionVariantsObliqueMercator__rectified_x0020skew_x0020center_x0020origin = 3,
	witsml1__ProjectionVariantsObliqueMercator__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:6346 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PresTestType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PresTestType (399)
/* witsml1:PresTestType */
enum witsml1__PresTestType
{
	witsml1__PresTestType__leak_x0020off_x0020test = 0,
	witsml1__PresTestType__formation_x0020integrity_x0020test = 1,
	witsml1__PresTestType__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:6370 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PrincipalMeridian
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PrincipalMeridian (400)
/* witsml1:PrincipalMeridian */
enum witsml1__PrincipalMeridian
{
	witsml1__PrincipalMeridian__1st_x0020Principal_x0020Meridian = 0,
	witsml1__PrincipalMeridian__2nd_x0020Principal_x0020Meridian = 1,
	witsml1__PrincipalMeridian__3rd_x0020Principal_x0020Meridian = 2,
	witsml1__PrincipalMeridian__4th_x0020Principal_x0020Meridian = 3,
	witsml1__PrincipalMeridian__5th_x0020Principal_x0020Meridian = 4,
	witsml1__PrincipalMeridian__6th_x0020Principal_x0020Meridian = 5,
	witsml1__PrincipalMeridian__Black_x0020Hills_x0020Meridian = 6,
	witsml1__PrincipalMeridian__Boise_x0020Meridian = 7,
	witsml1__PrincipalMeridian__Choctaw_x0020Meridian = 8,
	witsml1__PrincipalMeridian__Chickasaw_x0020Meridian = 9,
	witsml1__PrincipalMeridian__Cimarron_x0020Meridian = 10,
	witsml1__PrincipalMeridian__Copper_x0020River_x0020Meridian = 11,
	witsml1__PrincipalMeridian__Fairbanks_x0020Meridian = 12,
	witsml1__PrincipalMeridian__Gila_x0020and_x0020Salt_x0020River_x0020Meridian = 13,
	witsml1__PrincipalMeridian__Humboldt_x0020Meridian = 14,
	witsml1__PrincipalMeridian__Huntsville_x0020Meridian = 15,
	witsml1__PrincipalMeridian__Indian_x0020Meridian = 16,
	witsml1__PrincipalMeridian__Kateel_x0020River_x0020Meridian = 17,
	witsml1__PrincipalMeridian__Lousiana_x0020Meridian = 18,
	witsml1__PrincipalMeridian__Michigan_x0020Meridian = 19,
	witsml1__PrincipalMeridian__Mount_x0020Diablo_x0020Meridian = 20,
	witsml1__PrincipalMeridian__New_x0020Mexico_x0020Meridian = 21,
	witsml1__PrincipalMeridian__Saint_x0020Stephens_x0020Meridian = 22,
	witsml1__PrincipalMeridian__Saint_x0020Helena_x0020Meridian = 23,
	witsml1__PrincipalMeridian__Salt_x0020Lake_x0020Meridian = 24,
	witsml1__PrincipalMeridian__San_x0020Bernardo_x0020Meridian = 25,
	witsml1__PrincipalMeridian__Seward_x0020Meridian = 26,
	witsml1__PrincipalMeridian__Tallahassee_x0020Meridian = 27,
	witsml1__PrincipalMeridian__Uintah_x0020Meridian = 28,
	witsml1__PrincipalMeridian__Umiat_x0020Meridian = 29,
	witsml1__PrincipalMeridian__Ute_x0020Meridian = 30,
	witsml1__PrincipalMeridian__Washington_x0020Meridian = 31,
	witsml1__PrincipalMeridian__Williamette_x0020Meridian = 32,
	witsml1__PrincipalMeridian__Wind_x0020River_x0020Meridian = 33,
	witsml1__PrincipalMeridian__unknown = 34
};
#endif

/* witsml1_4_1_1ForGsoap.h:6522 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PumpType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PumpType (401)
/* witsml1:PumpType */
enum witsml1__PumpType
{
	witsml1__PumpType__centrifugal = 0,
	witsml1__PumpType__duplex = 1,
	witsml1__PumpType__triplex = 2,
	witsml1__PumpType__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:6547 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PumpOpType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__PumpOpType (402)
/* witsml1:PumpOpType */
enum witsml1__PumpOpType
{
	witsml1__PumpOpType__drilling = 0,
	witsml1__PumpOpType__reaming = 1,
	witsml1__PumpOpType__circulating = 2,
	witsml1__PumpOpType__slow_x0020pump = 3,
	witsml1__PumpOpType__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:6580 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ReadingKind
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ReadingKind (404)
/* witsml1:ReadingKind */
enum witsml1__ReadingKind
{
	witsml1__ReadingKind__measured = 0,
	witsml1__ReadingKind__estimated = 1,
	witsml1__ReadingKind__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:6604 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RigType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RigType (405)
/* witsml1:RigType */
enum witsml1__RigType
{
	witsml1__RigType__barge = 0,
	witsml1__RigType__coiled_x0020tubing = 1,
	witsml1__RigType__floater = 2,
	witsml1__RigType__jackup = 3,
	witsml1__RigType__land = 4,
	witsml1__RigType__platform = 5,
	witsml1__RigType__semi_submersible = 6,
	witsml1__RigType__unknown = 7
};
#endif

/* witsml1_4_1_1ForGsoap.h:6648 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RiskAffectedPersonnel
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RiskAffectedPersonnel (406)
/* witsml1:RiskAffectedPersonnel */
enum witsml1__RiskAffectedPersonnel
{
	witsml1__RiskAffectedPersonnel__cementer = 0,
	witsml1__RiskAffectedPersonnel__company_x0020man = 1,
	witsml1__RiskAffectedPersonnel__contractor = 2,
	witsml1__RiskAffectedPersonnel__directional_x0020driller = 3,
	witsml1__RiskAffectedPersonnel__driller = 4,
	witsml1__RiskAffectedPersonnel__drilling_x0020engineer = 5,
	witsml1__RiskAffectedPersonnel__drilling_x0020superintendent = 6,
	witsml1__RiskAffectedPersonnel__drilling_x0020team = 7,
	witsml1__RiskAffectedPersonnel__facility_x0020engineer = 8,
	witsml1__RiskAffectedPersonnel__field_x0020service_x0020manager = 9,
	witsml1__RiskAffectedPersonnel__foreman = 10,
	witsml1__RiskAffectedPersonnel__general_x0020service_x0020supervisor = 11,
	witsml1__RiskAffectedPersonnel__geologist = 12,
	witsml1__RiskAffectedPersonnel__member = 13,
	witsml1__RiskAffectedPersonnel__mud_x0020engineer = 14,
	witsml1__RiskAffectedPersonnel__mud_x0020logger = 15,
	witsml1__RiskAffectedPersonnel__MWD_x0020or_x0020LWD_x0020engineer = 16,
	witsml1__RiskAffectedPersonnel__perform_x0020engineer = 17,
	witsml1__RiskAffectedPersonnel__petrophysicist = 18,
	witsml1__RiskAffectedPersonnel__production_x0020engineer = 19,
	witsml1__RiskAffectedPersonnel__remotely_x0020operated_x0020vehicle_x0020engineer = 20,
	witsml1__RiskAffectedPersonnel__safety_x0020manger = 21,
	witsml1__RiskAffectedPersonnel__sales_x0020engineer = 22,
	witsml1__RiskAffectedPersonnel__service_x0020supervisor = 23,
	witsml1__RiskAffectedPersonnel__technical_x0020support = 24,
	witsml1__RiskAffectedPersonnel__tool_x0020pusher = 25,
	witsml1__RiskAffectedPersonnel__wireline_x0020engineer = 26
};
#endif

/* witsml1_4_1_1ForGsoap.h:6740 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RiskCategory
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RiskCategory (407)
/* witsml1:RiskCategory */
enum witsml1__RiskCategory
{
	witsml1__RiskCategory__hydraulics = 0,
	witsml1__RiskCategory__mechanical = 1,
	witsml1__RiskCategory__time_x0020related = 2,
	witsml1__RiskCategory__wellbore_x0020stability = 3,
	witsml1__RiskCategory__directional_x0020drilling = 4,
	witsml1__RiskCategory__bit = 5,
	witsml1__RiskCategory__equipment_x0020failure = 6,
	witsml1__RiskCategory__completion = 7,
	witsml1__RiskCategory__casing = 8,
	witsml1__RiskCategory__other = 9,
	witsml1__RiskCategory__HSE = 10,
	witsml1__RiskCategory__unknown = 11
};
#endif

/* witsml1_4_1_1ForGsoap.h:6790 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RiskSubCategory
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RiskSubCategory (408)
/* witsml1:RiskSubCategory */
enum witsml1__RiskSubCategory
{
	witsml1__RiskSubCategory__gas_x0020kick = 0,
	witsml1__RiskSubCategory__shallow_x0020water_x0020influx = 1,
	witsml1__RiskSubCategory__other_x0020influx_x0020or_x0020kicks = 2,
	witsml1__RiskSubCategory__loss_x0020circulation = 3,
	witsml1__RiskSubCategory__poor_x0020hole_x0020cleaning = 4,
	witsml1__RiskSubCategory__good_x0020hole_x0020cleaning_x0020at_x0020high_x0020ROP = 5,
	witsml1__RiskSubCategory__high_x0020mud_x0020weight = 6,
	witsml1__RiskSubCategory__special_x0020additives_x0020needed = 7,
	witsml1__RiskSubCategory__gumbo_x0020problems = 8,
	witsml1__RiskSubCategory__high_x0020ECD_x0020__x0020rheology_x0020related = 9,
	witsml1__RiskSubCategory__excessive_x0020circulation = 10,
	witsml1__RiskSubCategory__performing_x0020a_x0020kill = 11,
	witsml1__RiskSubCategory__mud_x0020weight_x0020change = 12,
	witsml1__RiskSubCategory__excessive_x0020pipe_x0020cement_x0020scaling = 13,
	witsml1__RiskSubCategory__pit_x0020gain_x0020or_x0020loss = 14,
	witsml1__RiskSubCategory__mud_x0020stability_x0020problems = 15,
	witsml1__RiskSubCategory__shallow_x0020gas_x0020flow = 16,
	witsml1__RiskSubCategory__twist_x0020off = 17,
	witsml1__RiskSubCategory__stuck_x0020pipe = 18,
	witsml1__RiskSubCategory__wireline_x0020stuck_x0020in_x0020hole = 19,
	witsml1__RiskSubCategory__stick_x0020and_x0020slip = 20,
	witsml1__RiskSubCategory__vibration_x0020__x0020axial = 21,
	witsml1__RiskSubCategory__vibration_x0020__x0020torsional = 22,
	witsml1__RiskSubCategory__vibration_x0020__x0020transverse = 23,
	witsml1__RiskSubCategory__vibration_x0020unknown_x0020or_x0020rough_x0020drilling = 24,
	witsml1__RiskSubCategory__uneven_x0020wear_x0020of_x0020BHA = 25,
	witsml1__RiskSubCategory__uneven_x0020wear_x0020of_x0020drillstring = 26,
	witsml1__RiskSubCategory__excessive_x0020torque = 27,
	witsml1__RiskSubCategory__excessive_x0020drag = 28,
	witsml1__RiskSubCategory__reaming_x0020greater_x0020than_x00202_x0020hours = 29,
	witsml1__RiskSubCategory__washouts = 30,
	witsml1__RiskSubCategory__tight_x0020hole_x0020or_x0020overPull = 31,
	witsml1__RiskSubCategory__failed_x0020inspections_x0020or_x0020fatigue_x0020wear = 32,
	witsml1__RiskSubCategory__mechanical = 33,
	witsml1__RiskSubCategory__drilling_x0020greater_x0020than_x00201000_x0020feet_x002fday = 34,
	witsml1__RiskSubCategory__drilling_x0020greater_x0020than_x00202000_x0020feet_x002fday = 35,
	witsml1__RiskSubCategory__drilling_x0020less_x0020than_x002020_x0020feet_x002fday = 36,
	witsml1__RiskSubCategory__trips_x0020greater_x0020than_x002024_x0020hours = 37,
	witsml1__RiskSubCategory__excessive_x0020time_x0020for_x0020BHA_x0020makeup = 38,
	witsml1__RiskSubCategory__waiting_x0020on_x0020decisions = 39,
	witsml1__RiskSubCategory__waiting_x0020on_x0020weather = 40,
	witsml1__RiskSubCategory__waiting_x0020on_x0020tools = 41,
	witsml1__RiskSubCategory__sloughing_x0020or_x0020packoffs = 42,
	witsml1__RiskSubCategory__ballooning = 43,
	witsml1__RiskSubCategory__fracture_x0020problems = 44,
	witsml1__RiskSubCategory__unstable_x0020zones = 45,
	witsml1__RiskSubCategory__formation_x0020integrity_x0020test = 46,
	witsml1__RiskSubCategory__leak_off_x0020test = 47,
	witsml1__RiskSubCategory__tectonics = 48,
	witsml1__RiskSubCategory__pore_x0020pressure = 49,
	witsml1__RiskSubCategory__breakouts = 50,
	witsml1__RiskSubCategory__bed_x0020parallel = 51,
	witsml1__RiskSubCategory__wellbore_x0020stability = 52,
	witsml1__RiskSubCategory__excessive_x0020doglegs = 53,
	witsml1__RiskSubCategory__sidetrack = 54,
	witsml1__RiskSubCategory__BHA_x0020change_x0020for_x0020directional = 55,
	witsml1__RiskSubCategory__wrong_x0020total_x0020flow_x0020area = 56,
	witsml1__RiskSubCategory__well_x0020collision_x0020__x0020actual = 57,
	witsml1__RiskSubCategory__well_x0020collision_x0020__x0020technical = 58,
	witsml1__RiskSubCategory__geosteering = 59,
	witsml1__RiskSubCategory__abnormal_x0020tendency_x0020changes = 60,
	witsml1__RiskSubCategory__resurveying = 61,
	witsml1__RiskSubCategory__in_field_x0020referencing_x0020_x0028IFR_x0029_x0020actions = 62,
	witsml1__RiskSubCategory__bit_x0020or_x0020BHA_x0020performance = 63,
	witsml1__RiskSubCategory__drilling_x0020optimization = 64,
	witsml1__RiskSubCategory__bit_x0020balling = 65,
	witsml1__RiskSubCategory__lost_x0020cones_x0020or_x0020broken_x0020cutters = 66,
	witsml1__RiskSubCategory__excessive_x0020bit_x0020wear_x0020or_x0020gauge = 67,
	witsml1__RiskSubCategory__low_x0020rate_x0020of_x0020bit_x0020penetration = 68,
	witsml1__RiskSubCategory__high_x0020rate_x0020of_x0020bit_x0020penetration = 69,
	witsml1__RiskSubCategory__downhole_x0020tool = 70,
	witsml1__RiskSubCategory__surface_x0020system = 71,
	witsml1__RiskSubCategory__motor_x0020or_x0020rotary_x0020steerable_x0020system_x0020failure = 72,
	witsml1__RiskSubCategory__topdrive_x0020failure = 73,
	witsml1__RiskSubCategory__hoisting_x0020equipment_x0020failure = 74,
	witsml1__RiskSubCategory__circulating_x0020equipment_x0020failure = 75,
	witsml1__RiskSubCategory__electrical_x0020system_x0020failure = 76,
	witsml1__RiskSubCategory__blow_x0020out_x0020preventer_x0020events = 77,
	witsml1__RiskSubCategory__surface_x0020instrumentation_x0020problems = 78,
	witsml1__RiskSubCategory__rig_x0020communications = 79,
	witsml1__RiskSubCategory__completion_x0020equipment_x0020failure = 80,
	witsml1__RiskSubCategory__miscellaneous_x0020rig_x0020equipment = 81,
	witsml1__RiskSubCategory__tool_x0020or_x0020equipment_x0020failure = 82,
	witsml1__RiskSubCategory__squeeze_x0020jobs = 83,
	witsml1__RiskSubCategory__casing_x0020surge_x0020losses = 84,
	witsml1__RiskSubCategory__stuck_x0020casing_x0020or_x0020completion = 85,
	witsml1__RiskSubCategory__shoe_x0020failures = 86,
	witsml1__RiskSubCategory__early_x0020cement_x0020setup = 87,
	witsml1__RiskSubCategory__casing_x0020collapse = 88,
	witsml1__RiskSubCategory__milling = 89,
	witsml1__RiskSubCategory__excessive_x0020casing_x0020wear_x0020or_x0020cuttings = 90,
	witsml1__RiskSubCategory__excessive_x0020formation_x0020damage_x0020or_x0020skin = 91,
	witsml1__RiskSubCategory__casing_x0020rotation_x0020or_x0020reciprocation_x0020rqd = 92,
	witsml1__RiskSubCategory__broaching = 93,
	witsml1__RiskSubCategory__completion_x0020or_x0020casing = 94,
	witsml1__RiskSubCategory__stratigraphy = 95,
	witsml1__RiskSubCategory__fishing = 96,
	witsml1__RiskSubCategory__junk_x0020in_x0020hole = 97,
	witsml1__RiskSubCategory__delay_x0020due_x0020to_x0020political_x0020unrest = 98,
	witsml1__RiskSubCategory__rig_x0020move = 99,
	witsml1__RiskSubCategory__gas_x0020hydrates = 100,
	witsml1__RiskSubCategory__pending_x0020analysis = 101,
	witsml1__RiskSubCategory__riser_x0020disconnect = 102,
	witsml1__RiskSubCategory__other = 103,
	witsml1__RiskSubCategory__personnel = 104,
	witsml1__RiskSubCategory__environmental = 105,
	witsml1__RiskSubCategory__automotive = 106,
	witsml1__RiskSubCategory__asset = 107,
	witsml1__RiskSubCategory__information = 108,
	witsml1__RiskSubCategory__time = 109,
	witsml1__RiskSubCategory__HSE = 110
};
#endif

/* witsml1_4_1_1ForGsoap.h:7148 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RiskType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__RiskType (409)
/* witsml1:RiskType */
enum witsml1__RiskType
{
	witsml1__RiskType__risk = 0,
	witsml1__RiskType__event = 1,
	witsml1__RiskType__near_x0020miss = 2,
	witsml1__RiskType__best_x0020practice = 3,
	witsml1__RiskType__lessons_x0020learned = 4,
	witsml1__RiskType__other = 5,
	witsml1__RiskType__unknown = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:7182 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ScrType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ScrType (410)
/* witsml1:ScrType */
enum witsml1__ScrType
{
	witsml1__ScrType__string_x0020annulus = 0,
	witsml1__ScrType__string_x0020kill_x0020line = 1,
	witsml1__ScrType__string_x0020choke_x0020line = 2,
	witsml1__ScrType__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:7204 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ShowFluorescence
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ShowFluorescence (411)
/* witsml1:ShowFluorescence */
enum witsml1__ShowFluorescence
{
	witsml1__ShowFluorescence__faint = 0,
	witsml1__ShowFluorescence__bright = 1,
	witsml1__ShowFluorescence__none = 2,
	witsml1__ShowFluorescence__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:7226 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ShowLevel
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ShowLevel (412)
/* witsml1:ShowLevel */
enum witsml1__ShowLevel
{
	witsml1__ShowLevel__blooming = 0,
	witsml1__ShowLevel__streaming = 1,
	witsml1__ShowLevel__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:7245 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ShowRating
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ShowRating (413)
/* witsml1:ShowRating */
enum witsml1__ShowRating
{
	witsml1__ShowRating__none = 0,
	witsml1__ShowRating__very_x0020poor = 1,
	witsml1__ShowRating__poor = 2,
	witsml1__ShowRating__fair = 3,
	witsml1__ShowRating__good = 4,
	witsml1__ShowRating__very_x0020good = 5,
	witsml1__ShowRating__unknown = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:7276 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ShowSpeed
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ShowSpeed (414)
/* witsml1:ShowSpeed */
enum witsml1__ShowSpeed
{
	witsml1__ShowSpeed__slow = 0,
	witsml1__ShowSpeed__moderately_x0020fast = 1,
	witsml1__ShowSpeed__fast = 2,
	witsml1__ShowSpeed__instantaneous = 3,
	witsml1__ShowSpeed__none = 4,
	witsml1__ShowSpeed__unknown = 5
};
#endif

/* witsml1_4_1_1ForGsoap.h:7304 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StateDetailActivity
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StateDetailActivity (415)
/* witsml1:StateDetailActivity */
enum witsml1__StateDetailActivity
{
	witsml1__StateDetailActivity__injury = 0,
	witsml1__StateDetailActivity__operation_x0020failed = 1,
	witsml1__StateDetailActivity__kick = 2,
	witsml1__StateDetailActivity__circulation_x0020loss = 3,
	witsml1__StateDetailActivity__mud_x0020loss = 4,
	witsml1__StateDetailActivity__stuck_x0020equipment = 5,
	witsml1__StateDetailActivity__equipment_x0020failure = 6,
	witsml1__StateDetailActivity__equipment_x0020hang = 7,
	witsml1__StateDetailActivity__success = 8,
	witsml1__StateDetailActivity__unknown = 9
};
#endif

/* witsml1_4_1_1ForGsoap.h:7356 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimAdditiveType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimAdditiveType (416)
/* witsml1:StimAdditiveType */
enum witsml1__StimAdditiveType
{
	witsml1__StimAdditiveType__abrasive = 0,
	witsml1__StimAdditiveType__accelerator = 1,
	witsml1__StimAdditiveType__acid_x0020inhibitor_x002fretarder = 2,
	witsml1__StimAdditiveType__acid_x0020material = 3,
	witsml1__StimAdditiveType__acid_x0020soluble_x0020additive = 4,
	witsml1__StimAdditiveType__acid_x0020source = 5,
	witsml1__StimAdditiveType__activator = 6,
	witsml1__StimAdditiveType__additive_x0020material = 7,
	witsml1__StimAdditiveType__alcohol = 8,
	witsml1__StimAdditiveType__anti_Sludge = 9,
	witsml1__StimAdditiveType__anti_sulfide_x0020cracker = 10,
	witsml1__StimAdditiveType__aromatic_x0020solvent = 11,
	witsml1__StimAdditiveType__biocide = 12,
	witsml1__StimAdditiveType__borehole_x0020stabilizer = 13,
	witsml1__StimAdditiveType__breaker = 14,
	witsml1__StimAdditiveType__bridging_x0020agent = 15,
	witsml1__StimAdditiveType__buffer = 16,
	witsml1__StimAdditiveType__calcium_x0020remover = 17,
	witsml1__StimAdditiveType__carrying_x0020agent = 18,
	witsml1__StimAdditiveType__catalyst = 19,
	witsml1__StimAdditiveType__clay = 20,
	witsml1__StimAdditiveType__clay_x0020control = 21,
	witsml1__StimAdditiveType__conductivity_x0020enhancer = 22,
	witsml1__StimAdditiveType__conformance_x0020control = 23,
	witsml1__StimAdditiveType__conformance_x0020caterial = 24,
	witsml1__StimAdditiveType__corrosion_x0020inhibitor = 25,
	witsml1__StimAdditiveType__crosslink_x0020enhancer = 26,
	witsml1__StimAdditiveType__crosslinker = 27,
	witsml1__StimAdditiveType__curing_x0020agent = 28,
	witsml1__StimAdditiveType__defoamer = 29,
	witsml1__StimAdditiveType__demulsifier = 30,
	witsml1__StimAdditiveType__diluent = 31,
	witsml1__StimAdditiveType__dispersant = 32,
	witsml1__StimAdditiveType__diverter = 33,
	witsml1__StimAdditiveType__elastomeric_x0020additive = 34,
	witsml1__StimAdditiveType__emulsifier = 35,
	witsml1__StimAdditiveType__epoxy_x0020resin = 36,
	witsml1__StimAdditiveType__expoxy_x0020resin_x0020agent = 37,
	witsml1__StimAdditiveType__expander = 38,
	witsml1__StimAdditiveType__filtration_x0020control = 39,
	witsml1__StimAdditiveType__flocculant = 40,
	witsml1__StimAdditiveType__fluid_x0020loss_x0020control = 41,
	witsml1__StimAdditiveType__flush_x002fspacer_x0020additive = 42,
	witsml1__StimAdditiveType__foamer = 43,
	witsml1__StimAdditiveType__formation_x0020sealer = 44,
	witsml1__StimAdditiveType__free_x0020water_x0020control = 45,
	witsml1__StimAdditiveType__friction_x0020reducer = 46,
	witsml1__StimAdditiveType__gas = 47,
	witsml1__StimAdditiveType__gas_x0020migration_x0020control = 48,
	witsml1__StimAdditiveType__gel_x0020stabilizer = 49,
	witsml1__StimAdditiveType__gelling_x0020agent = 50,
	witsml1__StimAdditiveType__H2S_x0020scavenger = 51,
	witsml1__StimAdditiveType__intensifier = 52,
	witsml1__StimAdditiveType__iron_x0020control = 53,
	witsml1__StimAdditiveType__lost_x0020circulation_x0020additive = 54,
	witsml1__StimAdditiveType__low_x0020fluid_x0020loss_x0020control = 55,
	witsml1__StimAdditiveType__lubricant = 56,
	witsml1__StimAdditiveType__misc_x0020additive = 57,
	witsml1__StimAdditiveType__mixing_x0020fluid = 58,
	witsml1__StimAdditiveType__mud_x0020removal_x0020additive = 59,
	witsml1__StimAdditiveType__mud_x0020thinner = 60,
	witsml1__StimAdditiveType__mutual_x0020solvent = 61,
	witsml1__StimAdditiveType__oxydizer = 62,
	witsml1__StimAdditiveType__oxygen_x0020scavenger = 63,
	witsml1__StimAdditiveType__parafin_x0020control = 64,
	witsml1__StimAdditiveType__penetrating_x0020agent = 65,
	witsml1__StimAdditiveType__polymer = 66,
	witsml1__StimAdditiveType__proppant_x0020stabilizer = 67,
	witsml1__StimAdditiveType__radioactive_x0020tracer = 68,
	witsml1__StimAdditiveType__raw_x0020acid = 69,
	witsml1__StimAdditiveType__relative_x0020perm_x0020modifier = 70,
	witsml1__StimAdditiveType__retarder = 71,
	witsml1__StimAdditiveType__salt = 72,
	witsml1__StimAdditiveType__sand = 73,
	witsml1__StimAdditiveType__sand_x0020control_x0020material = 74,
	witsml1__StimAdditiveType__scale_x0020control_x0020additive = 75,
	witsml1__StimAdditiveType__stabilizer = 76,
	witsml1__StimAdditiveType__strength_x0020retrogression = 77,
	witsml1__StimAdditiveType__sulfide_x0020scavenger = 78,
	witsml1__StimAdditiveType__surfactant = 79,
	witsml1__StimAdditiveType__suspension_x0020agent = 80,
	witsml1__StimAdditiveType__tactifier = 81,
	witsml1__StimAdditiveType__viscosifier = 82,
	witsml1__StimAdditiveType__water_x0020additive = 83,
	witsml1__StimAdditiveType__water_x0020management_x0020material = 84,
	witsml1__StimAdditiveType__pH_x0020control = 85,
	witsml1__StimAdditiveType__unknown = 86
};
#endif

/* witsml1_4_1_1ForGsoap.h:7735 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimAnalysisMethod
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimAnalysisMethod (417)
/* witsml1:StimAnalysisMethod */
enum witsml1__StimAnalysisMethod
{
	witsml1__StimAnalysisMethod__average = 0,
	witsml1__StimAnalysisMethod__delta_x0020pressure_x0020over_x0020g_time = 1,
	witsml1__StimAnalysisMethod__delta_x0020pressure_x0020over_x0020linear_x0020time = 2,
	witsml1__StimAnalysisMethod__delta_x0020pressure_x0020over_x0020radial_x0020time = 3,
	witsml1__StimAnalysisMethod__gdk_x00202_d = 4,
	witsml1__StimAnalysisMethod__horner = 5,
	witsml1__StimAnalysisMethod__linear = 6,
	witsml1__StimAnalysisMethod__log_log = 7,
	witsml1__StimAnalysisMethod__nolte = 8,
	witsml1__StimAnalysisMethod__pdl_x0020coefficient = 9,
	witsml1__StimAnalysisMethod__perkins_x0020and_x0020kern_x00202_d = 10,
	witsml1__StimAnalysisMethod__radial_x00202_d = 11,
	witsml1__StimAnalysisMethod__square_x0020root = 12,
	witsml1__StimAnalysisMethod__third_party_x0020software = 13,
	witsml1__StimAnalysisMethod__other = 14,
	witsml1__StimAnalysisMethod__unknown = 15
};
#endif

/* witsml1_4_1_1ForGsoap.h:7810 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimFluidSubtype
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimFluidSubtype (418)
/* witsml1:StimFluidSubtype */
enum witsml1__StimFluidSubtype
{
	witsml1__StimFluidSubtype__acid = 0,
	witsml1__StimFluidSubtype__base = 1,
	witsml1__StimFluidSubtype__carbon_x0020dioxide = 2,
	witsml1__StimFluidSubtype__carbon_x0020dioxide_x0020and_x0020nitrogen = 3,
	witsml1__StimFluidSubtype__carbon_x0020dioxide_x0020and_x0020water = 4,
	witsml1__StimFluidSubtype__condensate = 5,
	witsml1__StimFluidSubtype__cross_linked_x0020gel = 6,
	witsml1__StimFluidSubtype__crude_x0020oil = 7,
	witsml1__StimFluidSubtype__diesel = 8,
	witsml1__StimFluidSubtype__foam = 9,
	witsml1__StimFluidSubtype__fracturing_x0020oil = 10,
	witsml1__StimFluidSubtype__fresh_x0020water = 11,
	witsml1__StimFluidSubtype__gelled_x0020acid = 12,
	witsml1__StimFluidSubtype__gelled_x0020condensate = 13,
	witsml1__StimFluidSubtype__gelled_x0020crude = 14,
	witsml1__StimFluidSubtype__gelled_x0020diesel = 15,
	witsml1__StimFluidSubtype__gelled_x0020oil = 16,
	witsml1__StimFluidSubtype__gelled_x0020salt_x0020water = 17,
	witsml1__StimFluidSubtype__hot_x0020condensate = 18,
	witsml1__StimFluidSubtype__hot_x0020fresh_x0020water = 19,
	witsml1__StimFluidSubtype__hot_x0020oil = 20,
	witsml1__StimFluidSubtype__hot_x0020salt_x0020water = 21,
	witsml1__StimFluidSubtype__hybrid = 22,
	witsml1__StimFluidSubtype__linear_x0020gel = 23,
	witsml1__StimFluidSubtype__liquefied_x0020petroleum_x0020gas = 24,
	witsml1__StimFluidSubtype__nitrogen = 25,
	witsml1__StimFluidSubtype__oil = 26,
	witsml1__StimFluidSubtype__produced_x0020water = 27,
	witsml1__StimFluidSubtype__salt_x0020water = 28,
	witsml1__StimFluidSubtype__slick_x0020water = 29,
	witsml1__StimFluidSubtype__other = 30
};
#endif

/* witsml1_4_1_1ForGsoap.h:7944 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimFluidType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimFluidType (419)
/* witsml1:StimFluidType */
enum witsml1__StimFluidType
{
	witsml1__StimFluidType__acid_based = 0,
	witsml1__StimFluidType__gas = 1,
	witsml1__StimFluidType__oil_based = 2,
	witsml1__StimFluidType__water_based = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:7973 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimProppantType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimProppantType (420)
/* witsml1:StimProppantType */
enum witsml1__StimProppantType
{
	witsml1__StimProppantType__sand = 0,
	witsml1__StimProppantType__manmade_x0020proppant = 1,
	witsml1__StimProppantType__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:7997 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimStageFlowPathType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimStageFlowPathType (421)
/* witsml1:StimStageFlowPathType */
enum witsml1__StimStageFlowPathType
{
	witsml1__StimStageFlowPathType__annulus = 0,
	witsml1__StimStageFlowPathType__casing = 1,
	witsml1__StimStageFlowPathType__coiled_x0020tubing = 2,
	witsml1__StimStageFlowPathType__drill_x0020pipe = 3,
	witsml1__StimStageFlowPathType__open_x0020hole = 4,
	witsml1__StimStageFlowPathType__tubing = 5,
	witsml1__StimStageFlowPathType__tubing_x0020and_x0020annulus = 6,
	witsml1__StimStageFlowPathType__unknown = 7
};
#endif

/* witsml1_4_1_1ForGsoap.h:8041 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimStageType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__StimStageType (422)
/* witsml1:StimStageType */
enum witsml1__StimStageType
{
	witsml1__StimStageType__acid = 0,
	witsml1__StimStageType__acid_x0020spearhead = 1,
	witsml1__StimStageType__acid_x0020ball_x0020out = 2,
	witsml1__StimStageType__acid_x0020breakdown = 3,
	witsml1__StimStageType__ball_x0020out = 4,
	witsml1__StimStageType__breakdown = 5,
	witsml1__StimStageType__chemical_x0020wash = 6,
	witsml1__StimStageType__circulate = 7,
	witsml1__StimStageType__displacement = 8,
	witsml1__StimStageType__diverter = 9,
	witsml1__StimStageType__fluid_x0020efficiency_x0020test = 10,
	witsml1__StimStageType__flowback = 11,
	witsml1__StimStageType__flush = 12,
	witsml1__StimStageType__foamed_x0020acid = 13,
	witsml1__StimStageType__hydrajet = 14,
	witsml1__StimStageType__load_x0020well = 15,
	witsml1__StimStageType__load_x0020annulus = 16,
	witsml1__StimStageType__overflush = 17,
	witsml1__StimStageType__pad = 18,
	witsml1__StimStageType__pump_in = 19,
	witsml1__StimStageType__pre_Job = 20,
	witsml1__StimStageType__pre_flush = 21,
	witsml1__StimStageType__pre_pad = 22,
	witsml1__StimStageType__shut_in = 23,
	witsml1__StimStageType__shut_in_x0020for_x0020FET_x0020analysis = 24,
	witsml1__StimStageType__proppant_x0020laden_x0020fluid = 25,
	witsml1__StimStageType__slurry = 26,
	witsml1__StimStageType__sand_x0020slug = 27,
	witsml1__StimStageType__spacer = 28,
	witsml1__StimStageType__spot_x0020acid = 29,
	witsml1__StimStageType__step_x0020rate_x0020test = 30,
	witsml1__StimStageType__treatment = 31,
	witsml1__StimStageType__other = 32,
	witsml1__StimStageType__unknown = 33
};
#endif

/* witsml1_4_1_1ForGsoap.h:8195 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SupportCraft
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SupportCraft (423)
/* witsml1:SupportCraft */
enum witsml1__SupportCraft
{
	witsml1__SupportCraft__barge = 0,
	witsml1__SupportCraft__standby_x0020boat = 1,
	witsml1__SupportCraft__helicopter = 2,
	witsml1__SupportCraft__supply_x0020boat = 3,
	witsml1__SupportCraft__truck = 4,
	witsml1__SupportCraft__crew_x0020vehicle = 5,
	witsml1__SupportCraft__tug_x0020boat = 6,
	witsml1__SupportCraft__unknown = 7
};
#endif

/* witsml1_4_1_1ForGsoap.h:8232 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SurfEquipType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SurfEquipType (424)
/* witsml1:SurfEquipType */
enum witsml1__SurfEquipType
{
	witsml1__SurfEquipType__IADC = 0,
	witsml1__SurfEquipType__custom = 1,
	witsml1__SurfEquipType__coiled_x0020tubing = 2,
	witsml1__SurfEquipType__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:8257 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SurveyToolOperatingMode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__SurveyToolOperatingMode (425)
/* witsml1:SurveyToolOperatingMode */
enum witsml1__SurveyToolOperatingMode
{
	witsml1__SurveyToolOperatingMode__stationary = 0,
	witsml1__SurveyToolOperatingMode__continuous_x0020XY = 1,
	witsml1__SurveyToolOperatingMode__continuous_x0020Z = 2,
	witsml1__SurveyToolOperatingMode__continuous_x0020XYZ = 3,
	witsml1__SurveyToolOperatingMode__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:8289 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TargetCategory
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TargetCategory (426)
/* witsml1:TargetCategory */
enum witsml1__TargetCategory
{
	witsml1__TargetCategory__geological = 0,
	witsml1__TargetCategory__unknown = 1
};
#endif

/* witsml1_4_1_1ForGsoap.h:8308 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TargetScope
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TargetScope (427)
/* witsml1:TargetScope */
enum witsml1__TargetScope
{
	witsml1__TargetScope__3D_x0020volume = 0,
	witsml1__TargetScope__ellipsoid = 1,
	witsml1__TargetScope__elliptical = 2,
	witsml1__TargetScope__hardLine = 3,
	witsml1__TargetScope__irregular = 4,
	witsml1__TargetScope__lease_x0020line = 5,
	witsml1__TargetScope__line = 6,
	witsml1__TargetScope__plane = 7,
	witsml1__TargetScope__point = 8,
	witsml1__TargetScope__rectangular = 9,
	witsml1__TargetScope__unknown = 10
};
#endif

/* witsml1_4_1_1ForGsoap.h:8364 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TargetSectionScope
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TargetSectionScope (428)
/* witsml1:TargetSectionScope */
enum witsml1__TargetSectionScope
{
	witsml1__TargetSectionScope__arc = 0,
	witsml1__TargetSectionScope__line = 1,
	witsml1__TargetSectionScope__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:8396 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TrajStationStatus
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TrajStationStatus (430)
/* witsml1:TrajStationStatus */
enum witsml1__TrajStationStatus
{
	witsml1__TrajStationStatus__open = 0,
	witsml1__TrajStationStatus__rejected = 1,
	witsml1__TrajStationStatus__position = 2,
	witsml1__TrajStationStatus__unknown = 3
};
#endif

/* witsml1_4_1_1ForGsoap.h:8424 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TrajStationType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TrajStationType (431)
/* witsml1:TrajStationType */
enum witsml1__TrajStationType
{
	witsml1__TrajStationType__azimuth_x0020on_x0020plane = 0,
	witsml1__TrajStationType__buildrate_x0020to_x0020delta_MD = 1,
	witsml1__TrajStationType__buildrate_x0020to_x0020INCL = 2,
	witsml1__TrajStationType__buildrate_x0020to_x0020MD = 3,
	witsml1__TrajStationType__buildrate_x0020and_x0020turnrate_x0020to_x0020AZI = 4,
	witsml1__TrajStationType__buildrate_x0020and_x0020turnrate_x0020to_x0020delta_MD = 5,
	witsml1__TrajStationType__buildrate_x0020and_x0020turnrate_x0020to_x0020INCL = 6,
	witsml1__TrajStationType__buildrate_x0020and_x0020turnrate_x0020to_x0020INCL_x0020and_x0020AZI = 7,
	witsml1__TrajStationType__buildrate_x0020and_x0020turnrate_x0020to_x0020MD = 8,
	witsml1__TrajStationType__buildrate_x0020and_x0020turnrate_x0020to_x0020TVD = 9,
	witsml1__TrajStationType__buildrate_x0020TVD = 10,
	witsml1__TrajStationType__casing_x0020MD = 11,
	witsml1__TrajStationType__casing_x0020TVD = 12,
	witsml1__TrajStationType__DLS = 13,
	witsml1__TrajStationType__DLS_x0020to_x0020AZI_x0020and_x0020MD = 14,
	witsml1__TrajStationType__DLS_x0020to_x0020AZI_TVD = 15,
	witsml1__TrajStationType__DLS_x0020to_x0020INCL = 16,
	witsml1__TrajStationType__DLS_x0020to_x0020INCL_x0020and_x0020AZI = 17,
	witsml1__TrajStationType__DLS_x0020to_x0020INCL_x0020and_x0020MD = 18,
	witsml1__TrajStationType__DLS_x0020to_x0020INCL_x0020and_x0020TVD = 19,
	witsml1__TrajStationType__DLS_x0020to_x0020NS_x002c_x0020EW_x0020and_x0020TVD = 20,
	witsml1__TrajStationType__DLS_x0020and_x0020toolface_x0020to_x0020AZI = 21,
	witsml1__TrajStationType__DLS_x0020and_x0020toolface_x0020to_x0020delta_MD = 22,
	witsml1__TrajStationType__DLS_x0020and_x0020toolface_x0020to_x0020INCL = 23,
	witsml1__TrajStationType__DLS_x0020and_x0020toolface_x0020to_x0020INCL_AZI = 24,
	witsml1__TrajStationType__DLS_x0020and_x0020toolface_x0020to_x0020MD = 25,
	witsml1__TrajStationType__DLS_x0020and_x0020toolface_x0020to_x0020TVD = 26,
	witsml1__TrajStationType__formation_x0020MD = 27,
	witsml1__TrajStationType__formation_x0020TVD = 28,
	witsml1__TrajStationType__gyro_x0020inertial = 29,
	witsml1__TrajStationType__gyro_x0020MWD = 30,
	witsml1__TrajStationType__gyro_x0020north_x0020seeking = 31,
	witsml1__TrajStationType__hold_x0020to_x0020delta_MD = 32,
	witsml1__TrajStationType__hold_x0020to_x0020MD = 33,
	witsml1__TrajStationType__hold_x0020to_x0020TVD = 34,
	witsml1__TrajStationType__INCL_x002c_x0020AZI_x0020and_x0020TVD = 35,
	witsml1__TrajStationType__magnetic_x0020multi_shot = 36,
	witsml1__TrajStationType__magnetic_x0020MWD = 37,
	witsml1__TrajStationType__magnetic_x0020single_x0020shot = 38,
	witsml1__TrajStationType__marker_x0020MD = 39,
	witsml1__TrajStationType__marker_x0020TVD = 40,
	witsml1__TrajStationType__NS_x002c_x0020EW_x0020and_x0020TVD = 41,
	witsml1__TrajStationType__target_x0020center = 42,
	witsml1__TrajStationType__target_x0020offset = 43,
	witsml1__TrajStationType__tie_x0020in_x0020point = 44,
	witsml1__TrajStationType__turnrate_x0020to_x0020AZI = 45,
	witsml1__TrajStationType__turnrate_x0020to_x0020delta_MD = 46,
	witsml1__TrajStationType__turnrate_x0020to_x0020MD = 47,
	witsml1__TrajStationType__turnrate_x0020to_x0020TVD = 48,
	witsml1__TrajStationType__unknown = 49
};
#endif

/* witsml1_4_1_1ForGsoap.h:8633 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TubularAssembly
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TubularAssembly (432)
/* witsml1:TubularAssembly */
enum witsml1__TubularAssembly
{
	witsml1__TubularAssembly__drilling = 0,
	witsml1__TubularAssembly__directional_x0020drilling = 1,
	witsml1__TubularAssembly__fishing = 2,
	witsml1__TubularAssembly__condition_x0020mud = 3,
	witsml1__TubularAssembly__tubing_x0020conveyed_x0020logging = 4,
	witsml1__TubularAssembly__cementing = 5,
	witsml1__TubularAssembly__casing = 6,
	witsml1__TubularAssembly__clean_x0020out = 7,
	witsml1__TubularAssembly__completion_x0020or_x0020testing = 8,
	witsml1__TubularAssembly__coring = 9,
	witsml1__TubularAssembly__hole_x0020opening_x0020or_x0020underreaming = 10,
	witsml1__TubularAssembly__milling_x0020or_x0020dressing_x0020or_x0020cutting = 11,
	witsml1__TubularAssembly__wiper_x0020or_x0020check_x0020or_x0020reaming = 12,
	witsml1__TubularAssembly__unknown = 13
};
#endif

/* witsml1_4_1_1ForGsoap.h:8685 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TubularComponent
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TubularComponent (433)
/* witsml1:TubularComponent */
enum witsml1__TubularComponent
{
	witsml1__TubularComponent__non_magnetic_x0020stabilizer = 0,
	witsml1__TubularComponent__non_magnetic_x0020collar = 1,
	witsml1__TubularComponent__stabilizer = 2,
	witsml1__TubularComponent__adjustable_x0020kickoff = 3,
	witsml1__TubularComponent__accelerator = 4,
	witsml1__TubularComponent__rotary_x0020steering_x0020tool = 5,
	witsml1__TubularComponent__sub_bar_x0020catcher = 6,
	witsml1__TubularComponent__sub_bent = 7,
	witsml1__TubularComponent__bit_x0020core_x0020diamond = 8,
	witsml1__TubularComponent__bit_x0020core_x0020PDC = 9,
	witsml1__TubularComponent__bit_x0020diamond_x0020fixed_x0020cut = 10,
	witsml1__TubularComponent__bit_x0020insert_x0020roller_x0020cone = 11,
	witsml1__TubularComponent__bit_x0020mill_x0020tooth_x0020roller_x0020cone = 12,
	witsml1__TubularComponent__bit_x0020PDC_x0020fixed_x0020cutter = 13,
	witsml1__TubularComponent__sub_bit = 14,
	witsml1__TubularComponent__bridge_x0020plug = 15,
	witsml1__TubularComponent__bullnose = 16,
	witsml1__TubularComponent__bull_x0020plug = 17,
	witsml1__TubularComponent__sub_bumper = 18,
	witsml1__TubularComponent__casing = 19,
	witsml1__TubularComponent__casing_x0020cutter = 20,
	witsml1__TubularComponent__hanger_x0020casing_x0020subsea = 21,
	witsml1__TubularComponent__hanger_x0020casing_x0020surface = 22,
	witsml1__TubularComponent__casing_x0020head = 23,
	witsml1__TubularComponent__catch_x0020assembly = 24,
	witsml1__TubularComponent__sub_catcher = 25,
	witsml1__TubularComponent__sub_circulation = 26,
	witsml1__TubularComponent__coiled_x0020tubing_x0020in_x0020hole = 27,
	witsml1__TubularComponent__coiled_x0020tubing_x0020on_x0020coil = 28,
	witsml1__TubularComponent__drill_x0020pipe_x0020compressive = 29,
	witsml1__TubularComponent__sub_cone = 30,
	witsml1__TubularComponent__core_x0020barrel = 31,
	witsml1__TubularComponent__core_x0020orientation_x0020barrel = 32,
	witsml1__TubularComponent__sub_crossover = 33,
	witsml1__TubularComponent__casing_x0020crossover = 34,
	witsml1__TubularComponent__sub_dart = 35,
	witsml1__TubularComponent__die_x0020collar = 36,
	witsml1__TubularComponent__die_x0020collar_x0020LH = 37,
	witsml1__TubularComponent__directional_x0020guidance_x0020system = 38,
	witsml1__TubularComponent__drill_x0020collar = 39,
	witsml1__TubularComponent__drill_x0020pipe = 40,
	witsml1__TubularComponent__drill_x0020pipe_x0020LH = 41,
	witsml1__TubularComponent__drill_x0020stem_x0020test_x0020BHA = 42,
	witsml1__TubularComponent__drive_x0020pipe = 43,
	witsml1__TubularComponent__dual_x0020catch_x0020assembly = 44,
	witsml1__TubularComponent__extension_x0020bowl_x0020overshot = 45,
	witsml1__TubularComponent__extension_x0020sub_overshot = 46,
	witsml1__TubularComponent__float_x0020collar = 47,
	witsml1__TubularComponent__float_x0020shoe = 48,
	witsml1__TubularComponent__sub_float = 49,
	witsml1__TubularComponent__flow_x0020head = 50,
	witsml1__TubularComponent__guide_x0020shoe = 51,
	witsml1__TubularComponent__MWD_x0020hang_x0020off_x0020sub = 52,
	witsml1__TubularComponent__heavy_x0020weight_x0020drill_x0020pipe = 53,
	witsml1__TubularComponent__heavy_x0020weight_x0020drill_x0020pipe_x0020LH = 54,
	witsml1__TubularComponent__riser_x0020high_x0020pressure = 55,
	witsml1__TubularComponent__bit_x0020hole_x0020opener = 56,
	witsml1__TubularComponent__casing_x0020inflatable_x0020packer = 57,
	witsml1__TubularComponent__motor_x0020instrumented = 58,
	witsml1__TubularComponent__jar = 59,
	witsml1__TubularComponent__sub_jetting = 60,
	witsml1__TubularComponent__junk_x0020basket = 61,
	witsml1__TubularComponent__junk_x0020basket_x0020reverse_x0020circulation = 62,
	witsml1__TubularComponent__sub_junk = 63,
	witsml1__TubularComponent__kelly = 64,
	witsml1__TubularComponent__keyseat_x0020wiper_x0020tool = 65,
	witsml1__TubularComponent__landing_x0020float_x0020collar = 66,
	witsml1__TubularComponent__lead_x0020impression_x0020block = 67,
	witsml1__TubularComponent__liner = 68,
	witsml1__TubularComponent__hanger_x0020liner = 69,
	witsml1__TubularComponent__magnet = 70,
	witsml1__TubularComponent__riser_x0020marine = 71,
	witsml1__TubularComponent__mill_x0020dress = 72,
	witsml1__TubularComponent__mill_x0020flat_x0020bottom = 73,
	witsml1__TubularComponent__mill_x0020hollow = 74,
	witsml1__TubularComponent__mill_x0020polish = 75,
	witsml1__TubularComponent__mill_x0020section = 76,
	witsml1__TubularComponent__mill_x0020taper = 77,
	witsml1__TubularComponent__mill_x0020washover = 78,
	witsml1__TubularComponent__mill_x0020packer_x0020picker_x0020assembly = 79,
	witsml1__TubularComponent__millout_x0020extension = 80,
	witsml1__TubularComponent__multilateral_x0020hanger_x0020running_x0020tool = 81,
	witsml1__TubularComponent__hanger_x0020mud_x0020line = 82,
	witsml1__TubularComponent__motor = 83,
	witsml1__TubularComponent__mule_x0020shoe = 84,
	witsml1__TubularComponent__logging_x0020while_x0020drilling_x0020tool = 85,
	witsml1__TubularComponent__stabilizer_x0020near_x0020bit_x0020roller_x0020reamer = 86,
	witsml1__TubularComponent__stabilizer_x0020near_x0020bit = 87,
	witsml1__TubularComponent__stabilizer_x0020non_rotating = 88,
	witsml1__TubularComponent__sub_orienting = 89,
	witsml1__TubularComponent__other = 90,
	witsml1__TubularComponent__overshot = 91,
	witsml1__TubularComponent__overshot_x0020LH = 92,
	witsml1__TubularComponent__oversize_x0020lip_x0020guide_x0020overshot = 93,
	witsml1__TubularComponent__packer = 94,
	witsml1__TubularComponent__polished_x0020bore_x0020receptacle = 95,
	witsml1__TubularComponent__mill_x0020pilot = 96,
	witsml1__TubularComponent__pipe_x0020cutter = 97,
	witsml1__TubularComponent__ported_x0020stinger = 98,
	witsml1__TubularComponent__sub_ported = 99,
	witsml1__TubularComponent__prepacked_x0020screens = 100,
	witsml1__TubularComponent__sub_pressure_x0020relief = 101,
	witsml1__TubularComponent__riser_x0020production = 102,
	witsml1__TubularComponent__MWD_x0020pulser = 103,
	witsml1__TubularComponent__sub_pump_x0020out = 104,
	witsml1__TubularComponent__sub_restrictor = 105,
	witsml1__TubularComponent__packer_x0020retrieve_x0020TT_x0020squeeze = 106,
	witsml1__TubularComponent__reversing_x0020tool = 107,
	witsml1__TubularComponent__stabilizer_x0020string_x0020roller_x0020reamer = 108,
	witsml1__TubularComponent__packer_x0020RTTS = 109,
	witsml1__TubularComponent__running_x0020tool = 110,
	witsml1__TubularComponent__safety_x0020joint = 111,
	witsml1__TubularComponent__safety_x0020joint_x0020LH = 112,
	witsml1__TubularComponent__sub_saver = 113,
	witsml1__TubularComponent__scab_x0020liner_x0020bit_x0020guide = 114,
	witsml1__TubularComponent__scraper = 115,
	witsml1__TubularComponent__scratchers = 116,
	witsml1__TubularComponent__casing_x0020shoe_x0020screw_in = 117,
	witsml1__TubularComponent__sub_shock = 118,
	witsml1__TubularComponent__drill_x0020collar_x0020short = 119,
	witsml1__TubularComponent__sub_side_x0020entry = 120,
	witsml1__TubularComponent__slotted_x0020liner = 121,
	witsml1__TubularComponent__spear = 122,
	witsml1__TubularComponent__stage_x0020cement_x0020collar = 123,
	witsml1__TubularComponent__motor_x0020steerable = 124,
	witsml1__TubularComponent__packer_x0020storm_x0020valve_x0020RTTS = 125,
	witsml1__TubularComponent__stabilizer_x0020string = 126,
	witsml1__TubularComponent__surface_x0020pipe = 127,
	witsml1__TubularComponent__taper_x0020tap = 128,
	witsml1__TubularComponent__taper_x0020tap_x0020LH = 129,
	witsml1__TubularComponent__tubing_conveyed_x0020perforating_x0020gun = 130,
	witsml1__TubularComponent__thruster = 131,
	witsml1__TubularComponent__tieback_x0020polished_x0020bore_x0020receptacle = 132,
	witsml1__TubularComponent__tieback_x0020stinger = 133,
	witsml1__TubularComponent__tubing = 134,
	witsml1__TubularComponent__hanger_x0020tubing = 135,
	witsml1__TubularComponent__turbine = 136,
	witsml1__TubularComponent__bit_x0020under_x0020reamer = 137,
	witsml1__TubularComponent__stabilizer_x0020variable_x0020blade = 138,
	witsml1__TubularComponent__washover_x0020pipe = 139,
	witsml1__TubularComponent__mill_x0020watermelon = 140,
	witsml1__TubularComponent__whipstock = 141,
	witsml1__TubularComponent__whipstock_x0020anchor = 142,
	witsml1__TubularComponent__stabilizer_x0020turbo_x0020back = 143,
	witsml1__TubularComponent__stabilizer_x0020inline = 144,
	witsml1__TubularComponent__stabilizer_x0020steerable = 145,
	witsml1__TubularComponent__sub_stop = 146,
	witsml1__TubularComponent__sub_filter = 147,
	witsml1__TubularComponent__mill_x0020casing_x0020cutting = 148,
	witsml1__TubularComponent__reamer = 149,
	witsml1__TubularComponent__unknown = 150
};
#endif

/* witsml1_4_1_1ForGsoap.h:9297 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellControlIncidentType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellControlIncidentType (435)
/* witsml1:WellControlIncidentType */
enum witsml1__WellControlIncidentType
{
	witsml1__WellControlIncidentType__shallow_x0020gas_x0020kick = 0,
	witsml1__WellControlIncidentType__water_x0020kick = 1,
	witsml1__WellControlIncidentType__oil_x0020kick = 2,
	witsml1__WellControlIncidentType__gas_x0020kick = 3,
	witsml1__WellControlIncidentType__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:9330 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellDirection
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellDirection (436)
/* witsml1:WellDirection */
enum witsml1__WellDirection
{
	witsml1__WellDirection__huff_n_puff = 0,
	witsml1__WellDirection__injector = 1,
	witsml1__WellDirection__producer = 2,
	witsml1__WellDirection__uncertain = 3,
	witsml1__WellDirection__unknown = 4
};
#endif

/* witsml1_4_1_1ForGsoap.h:9362 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellFluid
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellFluid (437)
/* witsml1:WellFluid */
enum witsml1__WellFluid
{
	witsml1__WellFluid__air = 0,
	witsml1__WellFluid__condensate = 1,
	witsml1__WellFluid__dry = 2,
	witsml1__WellFluid__gas = 3,
	witsml1__WellFluid__gas_water = 4,
	witsml1__WellFluid__non_x0020HC_x0020gas = 5,
	witsml1__WellFluid__non_x0020HC_x0020gas_x0020_x002d__x0020CO2 = 6,
	witsml1__WellFluid__oil = 7,
	witsml1__WellFluid__oil_gas = 8,
	witsml1__WellFluid__oil_water = 9,
	witsml1__WellFluid__steam = 10,
	witsml1__WellFluid__water = 11,
	witsml1__WellFluid__water_x0020_x002d__x0020brine = 12,
	witsml1__WellFluid__water_x0020_x002d__x0020fresh_x0020water = 13,
	witsml1__WellFluid__unknown = 14
};
#endif

/* witsml1_4_1_1ForGsoap.h:9431 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellKillingProcedureType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellKillingProcedureType (438)
/* witsml1:WellKillingProcedureType */
enum witsml1__WellKillingProcedureType
{
	witsml1__WellKillingProcedureType__drillers_x0020method = 0,
	witsml1__WellKillingProcedureType__wait_x0020and_x0020weight = 1,
	witsml1__WellKillingProcedureType__bullheading = 2,
	witsml1__WellKillingProcedureType__lubricate_x0020and_x0020bleed = 3,
	witsml1__WellKillingProcedureType__forward_x0020circulation = 4,
	witsml1__WellKillingProcedureType__reverse_x0020circulation = 5,
	witsml1__WellKillingProcedureType__unknown = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:9471 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellNamingSystem
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellNamingSystem (439)
/* witsml1:WellNamingSystem */
enum witsml1__WellNamingSystem
{
	witsml1__WellNamingSystem__DTI = 0,
	witsml1__WellNamingSystem__API = 1,
	witsml1__WellNamingSystem__NPD_x0020code = 2,
	witsml1__WellNamingSystem__NPD_x0020number = 3,
	witsml1__WellNamingSystem__local_x0020field = 4,
	witsml1__WellNamingSystem__prospect = 5,
	witsml1__WellNamingSystem__unknown = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:9506 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellTestType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellTestType (440)
/* witsml1:WellTestType */
enum witsml1__WellTestType
{
	witsml1__WellTestType__drill_x0020stem_x0020test = 0,
	witsml1__WellTestType__production_x0020test = 1,
	witsml1__WellTestType__unknown = 2
};
#endif

/* witsml1_4_1_1ForGsoap.h:9530 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellboreShape
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellboreShape (441)
/* witsml1:WellboreShape */
enum witsml1__WellboreShape
{
	witsml1__WellboreShape__build_x0020and_x0020hold = 0,
	witsml1__WellboreShape__deviated = 1,
	witsml1__WellboreShape__double_x0020kickoff = 2,
	witsml1__WellboreShape__horizontal = 3,
	witsml1__WellboreShape__S_shaped = 4,
	witsml1__WellboreShape__vertical = 5,
	witsml1__WellboreShape__unknown = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:9570 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellboreType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellboreType (442)
/* witsml1:WellboreType */
enum witsml1__WellboreType
{
	witsml1__WellboreType__bypass = 0,
	witsml1__WellboreType__initial = 1,
	witsml1__WellboreType__redrill = 2,
	witsml1__WellboreType__reentry = 3,
	witsml1__WellboreType__respud = 4,
	witsml1__WellboreType__sidetrack = 5,
	witsml1__WellboreType__unknown = 6
};
#endif

/* witsml1_4_1_1ForGsoap.h:9610 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellPurpose
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellPurpose (443)
/* witsml1:WellPurpose */
enum witsml1__WellPurpose
{
	witsml1__WellPurpose__appraisal = 0,
	witsml1__WellPurpose__appraisal_x0020_x002d__x0020confirmation_x0020appraisal = 1,
	witsml1__WellPurpose__appraisal_x0020_x002d__x0020exploratory_x0020appraisal = 2,
	witsml1__WellPurpose__exploration = 3,
	witsml1__WellPurpose__exploration_x0020_x002d__x0020deeper_pool_x0020wildcat = 4,
	witsml1__WellPurpose__exploration_x0020_x002d__x0020new_field_x0020wildcat = 5,
	witsml1__WellPurpose__exploration_x0020_x002d__x0020new_pool_x0020wildcat = 6,
	witsml1__WellPurpose__exploration_x0020_x002d__x0020outpost_x0020wildcat = 7,
	witsml1__WellPurpose__exploration_x0020_x002d__x0020shallower_pool_x0020wildcat = 8,
	witsml1__WellPurpose__development = 9,
	witsml1__WellPurpose__development_x0020_x002d__x0020infill_x0020development = 10,
	witsml1__WellPurpose__development_x0020_x002d__x0020injector = 11,
	witsml1__WellPurpose__development_x0020_x002d__x0020producer = 12,
	witsml1__WellPurpose__fluid_x0020storage = 13,
	witsml1__WellPurpose__fluid_x0020storage_x0020_x002d__x0020gas_x0020storage = 14,
	witsml1__WellPurpose__general_x0020srvc = 15,
	witsml1__WellPurpose__general_x0020srvc_x0020_x002d__x0020borehole_x0020re_acquisition = 16,
	witsml1__WellPurpose__general_x0020srvc_x0020_x002d__x0020observation = 17,
	witsml1__WellPurpose__general_x0020srvc_x0020_x002d__x0020relief = 18,
	witsml1__WellPurpose__general_x0020srvc_x0020_x002d__x0020research = 19,
	witsml1__WellPurpose__general_x0020srvc_x0020_x002d__x0020research_x0020_x002d__x0020drill_x0020test = 20,
	witsml1__WellPurpose__general_x0020srvc_x0020_x002d__x0020research_x0020_x002d__x0020strat_x0020test = 21,
	witsml1__WellPurpose__general_x0020srvc_x0020_x002d__x0020waste_x0020disposal = 22,
	witsml1__WellPurpose__mineral = 23,
	witsml1__WellPurpose__unknown = 24
};
#endif

/* witsml1_4_1_1ForGsoap.h:9722 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellStatus
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__WellStatus (444)
/* witsml1:WellStatus */
enum witsml1__WellStatus
{
	witsml1__WellStatus__abandoned = 0,
	witsml1__WellStatus__active = 1,
	witsml1__WellStatus__active_x0020_x002d__x0020injecting = 2,
	witsml1__WellStatus__active_x0020_x002d__x0020producing = 3,
	witsml1__WellStatus__completed = 4,
	witsml1__WellStatus__drilling = 5,
	witsml1__WellStatus__partially_x0020plugged = 6,
	witsml1__WellStatus__permitted = 7,
	witsml1__WellStatus__plugged_x0020and_x0020abandoned = 8,
	witsml1__WellStatus__proposed = 9,
	witsml1__WellStatus__sold = 10,
	witsml1__WellStatus__suspended = 11,
	witsml1__WellStatus__temporarily_x0020abandoned = 12,
	witsml1__WellStatus__testing = 13,
	witsml1__WellStatus__tight = 14,
	witsml1__WellStatus__working_x0020over = 15,
	witsml1__WellStatus__unknown = 16
};
#endif

/* witsml1_4_1_1ForGsoap.h:16253 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__RelatedTimeType_relativePosition
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__RelatedTimeType_relativePosition (732)
/* gml:RelatedTimeType-relativePosition */
enum _gml__RelatedTimeType_relativePosition
{
	_gml__RelatedTimeType_relativePosition__Before = 0,
	_gml__RelatedTimeType_relativePosition__After = 1,
	_gml__RelatedTimeType_relativePosition__Begins = 2,
	_gml__RelatedTimeType_relativePosition__Ends = 3,
	_gml__RelatedTimeType_relativePosition__During = 4,
	_gml__RelatedTimeType_relativePosition__Equals = 5,
	_gml__RelatedTimeType_relativePosition__Contains = 6,
	_gml__RelatedTimeType_relativePosition__Overlaps = 7,
	_gml__RelatedTimeType_relativePosition__Meets = 8,
	_gml__RelatedTimeType_relativePosition__OverlappedBy = 9,
	_gml__RelatedTimeType_relativePosition__MetBy = 10,
	_gml__RelatedTimeType_relativePosition__BegunBy = 11,
	_gml__RelatedTimeType_relativePosition__EndedBy = 12
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

class __witsml1__obj_USCOREwell_sequence;	/* witsml1_4_1_1ForGsoap.h:10026 */
class witsml1__obj_USCOREwell;	/* witsml1_4_1_1ForGsoap.h:201 */
class witsml1__cs_USCOREdocumentInfo;	/* witsml1_4_1_1ForGsoap.h:204 */
class witsml1__cs_USCOREdocumentFileCreation;	/* witsml1_4_1_1ForGsoap.h:207 */
class witsml1__cs_USCOREdocumentSecurityInfo;	/* witsml1_4_1_1ForGsoap.h:411 */
class witsml1__cs_USCOREextensionNameValue;	/* witsml1_4_1_1ForGsoap.h:414 */
class witsml1__cs_USCOREdocumentAudit;	/* witsml1_4_1_1ForGsoap.h:417 */
class witsml1__cs_USCOREdocumentEvent;	/* witsml1_4_1_1ForGsoap.h:420 */
class witsml1__cs_USCORElocation;	/* witsml1_4_1_1ForGsoap.h:423 */
union _witsml1__union_cs_USCOREwellDatum;	/* witsml1_4_1_1ForGsoap.h:10708 */
class witsml1__cs_USCOREwellDatum;	/* witsml1_4_1_1ForGsoap.h:426 */
class witsml1__cs_USCORErefWellWellbore;	/* witsml1_4_1_1ForGsoap.h:429 */
class witsml1__cs_USCORErefWellWellboreRig;	/* witsml1_4_1_1ForGsoap.h:432 */
class witsml1__cs_USCOREpublicLandSurveySystem;	/* witsml1_4_1_1ForGsoap.h:435 */
class witsml1__cs_USCOREreferencePoint;	/* witsml1_4_1_1ForGsoap.h:438 */
union _witsml1__union_cs_USCOREwellCRS;	/* witsml1_4_1_1ForGsoap.h:11046 */
class witsml1__cs_USCOREwellCRS;	/* witsml1_4_1_1ForGsoap.h:441 */
class witsml1__cs_USCOREgeodeticModel;	/* witsml1_4_1_1ForGsoap.h:444 */
class witsml1__cs_USCOREprojectionx;	/* witsml1_4_1_1ForGsoap.h:447 */
union _witsml1__union_cs_USCORElocalCRS;	/* witsml1_4_1_1ForGsoap.h:11361 */
class witsml1__cs_USCORElocalCRS;	/* witsml1_4_1_1ForGsoap.h:450 */
class witsml1__cs_USCOREcommonData;	/* witsml1_4_1_1ForGsoap.h:453 */
class witsml1__cs_USCOREextensionAny;	/* witsml1_4_1_1ForGsoap.h:456 */
class witsml1__cs_USCOREcustomData;	/* witsml1_4_1_1ForGsoap.h:459 */
class __witsml1__obj_USCOREwellbore_sequence;	/* witsml1_4_1_1ForGsoap.h:11566 */
class witsml1__obj_USCOREwellbore;	/* witsml1_4_1_1ForGsoap.h:465 */
class __witsml1__obj_USCOREtrajectory_sequence;	/* witsml1_4_1_1ForGsoap.h:11751 */
class witsml1__obj_USCOREtrajectory;	/* witsml1_4_1_1ForGsoap.h:471 */
class witsml1__cs_USCOREtrajectoryStation;	/* witsml1_4_1_1ForGsoap.h:474 */
class witsml1__cs_USCOREstnTrajRawData;	/* witsml1_4_1_1ForGsoap.h:477 */
class witsml1__cs_USCOREstnTrajCorUsed;	/* witsml1_4_1_1ForGsoap.h:480 */
class witsml1__cs_USCOREstnTrajValid;	/* witsml1_4_1_1ForGsoap.h:483 */
class witsml1__cs_USCOREstnTrajMatrixCov;	/* witsml1_4_1_1ForGsoap.h:486 */
class witsml1__cs_USCORErefWellboreTrajectoryStation;	/* witsml1_4_1_1ForGsoap.h:489 */
class witsml1__cs_USCORErefWellboreTrajectory;	/* witsml1_4_1_1ForGsoap.h:492 */
class __witsml1__obj_USCORElog_sequence;	/* witsml1_4_1_1ForGsoap.h:12544 */
class witsml1__obj_USCORElog;	/* witsml1_4_1_1ForGsoap.h:498 */
class witsml1__cs_USCORElogCurveInfo;	/* witsml1_4_1_1ForGsoap.h:501 */
union _witsml1__union_cs_USCOREaxisDefinition;	/* witsml1_4_1_1ForGsoap.h:12977 */
class witsml1__cs_USCOREaxisDefinition;	/* witsml1_4_1_1ForGsoap.h:504 */
class witsml1__cs_USCORElogData;	/* witsml1_4_1_1ForGsoap.h:507 */
class __witsml1__obj_USCOREformationMarker_sequence;	/* witsml1_4_1_1ForGsoap.h:13081 */
class witsml1__obj_USCOREformationMarker;	/* witsml1_4_1_1ForGsoap.h:513 */
union _witsml1__union_obj_USCOREcoordinateReferenceSystem;	/* witsml1_4_1_1ForGsoap.h:13243 */
class __witsml1__obj_USCOREcoordinateReferenceSystem_sequence;	/* witsml1_4_1_1ForGsoap.h:13222 */
class witsml1__obj_USCOREcoordinateReferenceSystem;	/* witsml1_4_1_1ForGsoap.h:519 */
union _witsml1__union_cs_USCOREstandardGeodeticCRS;	/* witsml1_4_1_1ForGsoap.h:13305 */
class witsml1__cs_USCOREstandardGeodeticCRS;	/* witsml1_4_1_1ForGsoap.h:522 */
union _witsml1__union_cs_USCOREstandardProjectedCRS;	/* witsml1_4_1_1ForGsoap.h:13345 */
class witsml1__cs_USCOREstandardProjectedCRS;	/* witsml1_4_1_1ForGsoap.h:525 */
union _witsml1__union_cs_USCOREstandardVerticalCRS;	/* witsml1_4_1_1ForGsoap.h:13385 */
class witsml1__cs_USCOREstandardVerticalCRS;	/* witsml1_4_1_1ForGsoap.h:528 */
class abstract__abstractObject;	/* witsml1_4_1_1ForGsoap.h:531 */
class gml__AbstractGMLType;	/* witsml1_4_1_1ForGsoap.h:549 */
class gml__ReferenceType;	/* witsml1_4_1_1ForGsoap.h:555 */
union _gml__union_TimePrimitivePropertyType;	/* witsml1_4_1_1ForGsoap.h:13563 */
class __gml__TimePrimitivePropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:13552 */
class gml__TimePrimitivePropertyType;	/* witsml1_4_1_1ForGsoap.h:573 */
class __gml__EllipsoidalCSPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:13623 */
class gml__EllipsoidalCSPropertyType;	/* witsml1_4_1_1ForGsoap.h:576 */
class __gml__CoordinateSystemAxisPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:13684 */
class gml__CoordinateSystemAxisPropertyType;	/* witsml1_4_1_1ForGsoap.h:585 */
class __gml__CartesianCSPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:13745 */
class gml__CartesianCSPropertyType;	/* witsml1_4_1_1ForGsoap.h:591 */
class __gml__SphericalCSPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:13806 */
class gml__SphericalCSPropertyType;	/* witsml1_4_1_1ForGsoap.h:597 */
class __gml__GeodeticDatumPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:13867 */
class gml__GeodeticDatumPropertyType;	/* witsml1_4_1_1ForGsoap.h:603 */
class __gml__PrimeMeridianPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:13928 */
class gml__PrimeMeridianPropertyType;	/* witsml1_4_1_1ForGsoap.h:612 */
class __gml__EllipsoidPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:13989 */
class gml__EllipsoidPropertyType;	/* witsml1_4_1_1ForGsoap.h:624 */
union _gml__union_GeneralConversionPropertyType;	/* witsml1_4_1_1ForGsoap.h:14062 */
class __gml__GeneralConversionPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14050 */
class gml__GeneralConversionPropertyType;	/* witsml1_4_1_1ForGsoap.h:639 */
union _gml__union_CRSPropertyType;	/* witsml1_4_1_1ForGsoap.h:14129 */
class __gml__CRSPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14118 */
class gml__CRSPropertyType;	/* witsml1_4_1_1ForGsoap.h:648 */
class __gml__GeodeticCRSPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14185 */
class gml__GeodeticCRSPropertyType;	/* witsml1_4_1_1ForGsoap.h:651 */
class __gml__VerticalCSPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14243 */
class gml__VerticalCSPropertyType;	/* witsml1_4_1_1ForGsoap.h:657 */
class __gml__VerticalDatumPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14304 */
class gml__VerticalDatumPropertyType;	/* witsml1_4_1_1ForGsoap.h:663 */
class __gml__domainOfValidity_sequence;	/* witsml1_4_1_1ForGsoap.h:14366 */
class _gml__domainOfValidity;	/* witsml1_4_1_1ForGsoap.h:669 */
class _gml__secondDefiningParameter;	/* witsml1_4_1_1ForGsoap.h:672 */
union _gml__union_SecondDefiningParameter;	/* witsml1_4_1_1ForGsoap.h:14458 */
class _gml__SecondDefiningParameter;	/* witsml1_4_1_1ForGsoap.h:675 */
union _gml__union_coordinateOperationAccuracy;	/* witsml1_4_1_1ForGsoap.h:14491 */
class __gml__coordinateOperationAccuracy_sequence;	/* witsml1_4_1_1ForGsoap.h:14483 */
class _gml__coordinateOperationAccuracy;	/* witsml1_4_1_1ForGsoap.h:678 */
union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:14568 */
class __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14560 */
class gmd__EX_USCOREGeographicExtent_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:684 */
class __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14623 */
class gmd__EX_USCORETemporalExtent_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:690 */
class __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14680 */
class gmd__EX_USCOREVerticalExtent_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:696 */
class __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14737 */
class gmd__MD_USCOREIdentifier_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:708 */
class __gmd__CI_USCORECitation_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14794 */
class gmd__CI_USCORECitation_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:714 */
class __gmd__CI_USCOREDate_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14851 */
class gmd__CI_USCOREDate_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:720 */
class __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14908 */
class gmd__CI_USCOREDateTypeCode_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:726 */
class __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14935 */
class gmd__CI_USCOREResponsibleParty_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:729 */
class __gmd__CI_USCOREContact_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:14992 */
class gmd__CI_USCOREContact_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:735 */
class __gmd__CI_USCORETelephone_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15049 */
class gmd__CI_USCORETelephone_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:741 */
class __gmd__CI_USCOREAddress_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15106 */
class gmd__CI_USCOREAddress_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:747 */
class __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15163 */
class gmd__CI_USCOREOnlineResource_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:753 */
class __gmd__URL_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15220 */
class gmd__URL_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:759 */
class __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15247 */
class gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:762 */
class __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15274 */
class gmd__CI_USCORERoleCode_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:765 */
class __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15301 */
class gmd__CI_USCOREPresentationFormCode_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:768 */
class __gmd__CI_USCORESeries_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15328 */
class gmd__CI_USCORESeries_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:771 */
class __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15385 */
class gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:777 */
union _gmd__union_DQ_USCOREResult_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:15420 */
class __gmd__DQ_USCOREResult_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15412 */
class gmd__DQ_USCOREResult_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:780 */
union _gts__union_TM_USCOREPrimitive_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:15494 */
class __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15483 */
class gts__TM_USCOREPrimitive_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:786 */
class gco__AbstractObject_USCOREType;	/* witsml1_4_1_1ForGsoap.h:789 */
union _gco__union_CharacterString_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:15610 */
class __gco__CharacterString_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15581 */
class gco__CharacterString_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:792 */
class __gco__Boolean_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15635 */
class gco__Boolean_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:795 */
class __gco__Real_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15662 */
class gco__Real_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:798 */
union _gco__union_Date_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:15697 */
class gco__Date_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:801 */
class __gco__DateTime_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15720 */
class gco__DateTime_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:807 */
union _gsr__union_SC_USCORECRS_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:15766 */
class __gsr__SC_USCORECRS_USCOREPropertyType_sequence;	/* witsml1_4_1_1ForGsoap.h:15755 */
class gsr__SC_USCORECRS_USCOREPropertyType;	/* witsml1_4_1_1ForGsoap.h:810 */
class witsml1__obj_USCOREwells;	/* witsml1_4_1_1ForGsoap.h:198 */
class witsml1__obj_USCOREwellbores;	/* witsml1_4_1_1ForGsoap.h:462 */
class witsml1__obj_USCOREtrajectorys;	/* witsml1_4_1_1ForGsoap.h:468 */
class witsml1__obj_USCORElogs;	/* witsml1_4_1_1ForGsoap.h:495 */
class witsml1__obj_USCOREformationMarkers;	/* witsml1_4_1_1ForGsoap.h:510 */
class witsml1__obj_USCOREcoordinateReferenceSystems;	/* witsml1_4_1_1ForGsoap.h:516 */
class gml__DefinitionBaseType;	/* witsml1_4_1_1ForGsoap.h:546 */
class gml__StringOrRefType;	/* witsml1_4_1_1ForGsoap.h:552 */
class gml__CodeType;	/* witsml1_4_1_1ForGsoap.h:561 */
class gml__AbstractTimeObjectType;	/* witsml1_4_1_1ForGsoap.h:567 */
class gml__RelatedTimeType;	/* witsml1_4_1_1ForGsoap.h:570 */
class gml__MeasureType;	/* witsml1_4_1_1ForGsoap.h:621 */
class gmd__EX_USCOREExtent_USCOREType;	/* witsml1_4_1_1ForGsoap.h:681 */
class gmd__AbstractEX_USCOREGeographicExtent_USCOREType;	/* witsml1_4_1_1ForGsoap.h:687 */
class gmd__EX_USCORETemporalExtent_USCOREType;	/* witsml1_4_1_1ForGsoap.h:693 */
class gmd__EX_USCOREVerticalExtent_USCOREType;	/* witsml1_4_1_1ForGsoap.h:699 */
class gmd__AbstractDQ_USCOREElement_USCOREType;	/* witsml1_4_1_1ForGsoap.h:705 */
class gmd__MD_USCOREIdentifier_USCOREType;	/* witsml1_4_1_1ForGsoap.h:711 */
class gmd__CI_USCORECitation_USCOREType;	/* witsml1_4_1_1ForGsoap.h:717 */
class gmd__CI_USCOREDate_USCOREType;	/* witsml1_4_1_1ForGsoap.h:723 */
class gmd__CI_USCOREResponsibleParty_USCOREType;	/* witsml1_4_1_1ForGsoap.h:732 */
class gmd__CI_USCOREContact_USCOREType;	/* witsml1_4_1_1ForGsoap.h:738 */
class gmd__CI_USCORETelephone_USCOREType;	/* witsml1_4_1_1ForGsoap.h:744 */
class gmd__CI_USCOREAddress_USCOREType;	/* witsml1_4_1_1ForGsoap.h:750 */
class gmd__CI_USCOREOnlineResource_USCOREType;	/* witsml1_4_1_1ForGsoap.h:756 */
class gmd__CI_USCORESeries_USCOREType;	/* witsml1_4_1_1ForGsoap.h:774 */
class gmd__AbstractDQ_USCOREResult_USCOREType;	/* witsml1_4_1_1ForGsoap.h:783 */
class gco__CodeListValue_USCOREType;	/* witsml1_4_1_1ForGsoap.h:804 */
class witsml1__cost;	/* witsml1_4_1_1ForGsoap.h:276 */
class witsml1__abstractMeasure;	/* witsml1_4_1_1ForGsoap.h:408 */
class gml__DefinitionType;	/* witsml1_4_1_1ForGsoap.h:543 */
class gml__CodeWithAuthorityType;	/* witsml1_4_1_1ForGsoap.h:558 */
class gml__AbstractTimePrimitiveType;	/* witsml1_4_1_1ForGsoap.h:564 */
class gml__AngleType;	/* witsml1_4_1_1ForGsoap.h:618 */
class gml__LengthType;	/* witsml1_4_1_1ForGsoap.h:630 */
class gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType;	/* witsml1_4_1_1ForGsoap.h:702 */
class witsml1__timestampedTimeZone;	/* witsml1_4_1_1ForGsoap.h:210 */
class witsml1__yAxisAzimuth;	/* witsml1_4_1_1ForGsoap.h:213 */
class witsml1__volumePerVolumeMeasurePercent;	/* witsml1_4_1_1ForGsoap.h:216 */
class witsml1__measureOrQuantity;	/* witsml1_4_1_1ForGsoap.h:219 */
class witsml1__genericMeasure;	/* witsml1_4_1_1ForGsoap.h:222 */
class witsml1__ratioGenericMeasure;	/* witsml1_4_1_1ForGsoap.h:225 */
class witsml1__refNameString;	/* witsml1_4_1_1ForGsoap.h:228 */
class witsml1__refObjectString;	/* witsml1_4_1_1ForGsoap.h:231 */
class witsml1__refPositiveCount;	/* witsml1_4_1_1ForGsoap.h:234 */
class witsml1__extensionvalue;	/* witsml1_4_1_1ForGsoap.h:240 */
class witsml1__nameStruct;	/* witsml1_4_1_1ForGsoap.h:243 */
class witsml1__shortNameStruct;	/* witsml1_4_1_1ForGsoap.h:246 */
class witsml1__wellKnownNameStruct;	/* witsml1_4_1_1ForGsoap.h:249 */
class witsml1__objectSequence;	/* witsml1_4_1_1ForGsoap.h:252 */
class witsml1__lithostratigraphyStruct;	/* witsml1_4_1_1ForGsoap.h:255 */
class witsml1__chronostratigraphyStruct;	/* witsml1_4_1_1ForGsoap.h:258 */
class witsml1__measuredDepthCoord;	/* witsml1_4_1_1ForGsoap.h:261 */
class witsml1__wellVerticalDepthCoord;	/* witsml1_4_1_1ForGsoap.h:264 */
class witsml1__wellElevationCoord;	/* witsml1_4_1_1ForGsoap.h:267 */
class witsml1__footageNorthSouth;	/* witsml1_4_1_1ForGsoap.h:270 */
class witsml1__footageEastWest;	/* witsml1_4_1_1ForGsoap.h:273 */
class witsml1__indexedObject;	/* witsml1_4_1_1ForGsoap.h:279 */
class witsml1__accelerationLinearMeasure;	/* witsml1_4_1_1ForGsoap.h:282 */
class witsml1__anglePerLengthMeasure;	/* witsml1_4_1_1ForGsoap.h:285 */
class witsml1__anglePerTimeMeasure;	/* witsml1_4_1_1ForGsoap.h:288 */
class witsml1__areaMeasure;	/* witsml1_4_1_1ForGsoap.h:291 */
class witsml1__areaPerAreaMeasure;	/* witsml1_4_1_1ForGsoap.h:294 */
class witsml1__compressibilityMeasure;	/* witsml1_4_1_1ForGsoap.h:297 */
class witsml1__densityMeasure;	/* witsml1_4_1_1ForGsoap.h:300 */
class witsml1__dimensionlessMeasure;	/* witsml1_4_1_1ForGsoap.h:303 */
class witsml1__dynamicViscosityMeasure;	/* witsml1_4_1_1ForGsoap.h:306 */
class witsml1__electricCurrentMeasure;	/* witsml1_4_1_1ForGsoap.h:309 */
class witsml1__electricPotentialMeasure;	/* witsml1_4_1_1ForGsoap.h:312 */
class witsml1__equivalentPerMassMeasure;	/* witsml1_4_1_1ForGsoap.h:315 */
class witsml1__forceMeasure;	/* witsml1_4_1_1ForGsoap.h:318 */
class witsml1__forcePerLengthMeasure;	/* witsml1_4_1_1ForGsoap.h:321 */
class witsml1__forcePerVolumeMeasure;	/* witsml1_4_1_1ForGsoap.h:324 */
class witsml1__illuminanceMeasure;	/* witsml1_4_1_1ForGsoap.h:327 */
class witsml1__lengthMeasure;	/* witsml1_4_1_1ForGsoap.h:330 */
class witsml1__lengthPerLengthMeasure;	/* witsml1_4_1_1ForGsoap.h:333 */
class witsml1__magneticInductionMeasure;	/* witsml1_4_1_1ForGsoap.h:336 */
class witsml1__massConcentrationMeasure;	/* witsml1_4_1_1ForGsoap.h:339 */
class witsml1__massMeasure;	/* witsml1_4_1_1ForGsoap.h:342 */
class witsml1__massPerLengthMeasure;	/* witsml1_4_1_1ForGsoap.h:345 */
class witsml1__momentOfForceMeasure;	/* witsml1_4_1_1ForGsoap.h:348 */
class witsml1__perLengthMeasure;	/* witsml1_4_1_1ForGsoap.h:351 */
class witsml1__permeabilityRockMeasure;	/* witsml1_4_1_1ForGsoap.h:354 */
class witsml1__planeAngleMeasure;	/* witsml1_4_1_1ForGsoap.h:357 */
class witsml1__powerMeasure;	/* witsml1_4_1_1ForGsoap.h:360 */
class witsml1__pressureMeasure;	/* witsml1_4_1_1ForGsoap.h:363 */
class witsml1__relativePowerMeasure;	/* witsml1_4_1_1ForGsoap.h:366 */
class witsml1__specificHeatCapacityMeasure;	/* witsml1_4_1_1ForGsoap.h:369 */
class witsml1__specificVolumeMeasure;	/* witsml1_4_1_1ForGsoap.h:372 */
class witsml1__standardVolumeMeasure;	/* witsml1_4_1_1ForGsoap.h:375 */
class witsml1__standardVolumePerTimeMeasure;	/* witsml1_4_1_1ForGsoap.h:378 */
class witsml1__thermalConductivityMeasure;	/* witsml1_4_1_1ForGsoap.h:381 */
class witsml1__thermalVolumetricExpansionMeasure;	/* witsml1_4_1_1ForGsoap.h:384 */
class witsml1__thermodynamicTemperatureMeasure;	/* witsml1_4_1_1ForGsoap.h:387 */
class witsml1__timeMeasure;	/* witsml1_4_1_1ForGsoap.h:390 */
class witsml1__velocityMeasure;	/* witsml1_4_1_1ForGsoap.h:393 */
class witsml1__volumeMeasure;	/* witsml1_4_1_1ForGsoap.h:396 */
class witsml1__volumeFlowRateMeasure;	/* witsml1_4_1_1ForGsoap.h:399 */
class witsml1__volumePerLengthMeasure;	/* witsml1_4_1_1ForGsoap.h:402 */
class witsml1__volumePerVolumeMeasure;	/* witsml1_4_1_1ForGsoap.h:405 */
class gml__IdentifiedObjectType;	/* witsml1_4_1_1ForGsoap.h:540 */
class witsml1__timestampedCommentString;	/* witsml1_4_1_1ForGsoap.h:237 */
class gml__AbstractCRSType;	/* witsml1_4_1_1ForGsoap.h:537 */
class gml__AbstractCoordinateSystemType;	/* witsml1_4_1_1ForGsoap.h:582 */
class gml__CoordinateSystemAxisType;	/* witsml1_4_1_1ForGsoap.h:588 */
class gml__AbstractDatumType;	/* witsml1_4_1_1ForGsoap.h:609 */
class gml__PrimeMeridianType;	/* witsml1_4_1_1ForGsoap.h:615 */
class gml__EllipsoidType;	/* witsml1_4_1_1ForGsoap.h:627 */
class gml__AbstractCoordinateOperationType;	/* witsml1_4_1_1ForGsoap.h:645 */
union _gml__union_GeodeticCRSType;	/* witsml1_4_1_1ForGsoap.h:18866 */
class gml__GeodeticCRSType;	/* witsml1_4_1_1ForGsoap.h:534 */
class gml__EllipsoidalCSType;	/* witsml1_4_1_1ForGsoap.h:579 */
class gml__CartesianCSType;	/* witsml1_4_1_1ForGsoap.h:594 */
class gml__SphericalCSType;	/* witsml1_4_1_1ForGsoap.h:600 */
class gml__GeodeticDatumType;	/* witsml1_4_1_1ForGsoap.h:606 */
class gml__AbstractGeneralDerivedCRSType;	/* witsml1_4_1_1ForGsoap.h:636 */
class gml__AbstractGeneralConversionType;	/* witsml1_4_1_1ForGsoap.h:642 */
class gml__VerticalCRSType;	/* witsml1_4_1_1ForGsoap.h:654 */
class gml__VerticalCSType;	/* witsml1_4_1_1ForGsoap.h:660 */
class gml__VerticalDatumType;	/* witsml1_4_1_1ForGsoap.h:666 */
union _gml__union_ProjectedCRSType;	/* witsml1_4_1_1ForGsoap.h:19342 */
class gml__ProjectedCRSType;	/* witsml1_4_1_1ForGsoap.h:633 */

/* witsml1_4_1_1ForGsoap.h:10026 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREwell_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREwell_sequence (446)
/* Operation wrapper: */
class SOAP_CMAC __witsml1__obj_USCOREwell_sequence
{
public:
	std::string *nameLegal;	/* optional element of XSD type witsml1:nameString */
	std::string *numLicense;	/* optional element of XSD type witsml1:nameString */
	std::string *numGovt;	/* optional element of XSD type witsml1:nameString */
	time_t *dTimLicense;	/* optional element of XSD type witsml1:timestamp */
	std::string *field;	/* optional element of XSD type witsml1:nameString */
	std::string *country;	/* optional element of XSD type witsml1:str32 */
	std::string *state;	/* optional element of XSD type witsml1:str32 */
	std::string *county;	/* optional element of XSD type witsml1:str32 */
	std::string *region;	/* optional element of XSD type witsml1:str32 */
	std::string *district;	/* optional element of XSD type witsml1:str32 */
	std::string *block;	/* optional element of XSD type witsml1:str32 */
	std::string timeZone;	/* required element of XSD type witsml1:timeZone */
	std::string *operator_;	/* optional element of XSD type witsml1:nameString */
	std::string *operatorDiv;	/* optional element of XSD type witsml1:nameString */
	witsml1__dimensionlessMeasure *pcInterest;	/* optional element of XSD type witsml1:dimensionlessMeasure */
	std::string *numAPI;	/* optional element of XSD type witsml1:str32 */
	enum witsml1__WellStatus *statusWell;	/* optional element of XSD type witsml1:WellStatus */
	enum witsml1__WellPurpose *purposeWell;	/* optional element of XSD type witsml1:WellPurpose */
	enum witsml1__WellFluid *fluidWell;	/* optional element of XSD type witsml1:WellFluid */
	enum witsml1__WellDirection *directionWell;	/* optional element of XSD type witsml1:WellDirection */
	time_t *dTimSpud;	/* optional element of XSD type witsml1:timestamp */
	time_t *dTimPa;	/* optional element of XSD type witsml1:timestamp */
	witsml1__wellElevationCoord *wellheadElevation;	/* optional element of XSD type witsml1:wellElevationCoord */
	std::vector<witsml1__cs_USCOREwellDatum *> wellDatum;	/* optional element of XSD type witsml1:cs_wellDatum */
	witsml1__wellElevationCoord *groundElevation;	/* optional element of XSD type witsml1:wellElevationCoord */
	witsml1__lengthMeasure *waterDepth;	/* optional element of XSD type witsml1:lengthMeasure */
	std::vector<witsml1__cs_USCORElocation *> wellLocation;	/* optional element of XSD type witsml1:cs_location */
	witsml1__cs_USCOREpublicLandSurveySystem *wellPublicLandSurveySystemLocation;	/* optional element of XSD type witsml1:cs_publicLandSurveySystem */
	std::vector<witsml1__cs_USCOREreferencePoint *> referencePoint;	/* optional element of XSD type witsml1:cs_referencePoint */
	std::vector<witsml1__cs_USCOREwellCRS *> wellCRS;	/* optional element of XSD type witsml1:cs_wellCRS */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREwell_sequence (446)
	virtual int soap_type(void) const { return 446; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __witsml1__obj_USCOREwell_sequence, default initialized and not managed by a soap context
	virtual __witsml1__obj_USCOREwell_sequence *soap_alloc(void) const { return SOAP_NEW(__witsml1__obj_USCOREwell_sequence); }
	         __witsml1__obj_USCOREwell_sequence() { __witsml1__obj_USCOREwell_sequence::soap_default(NULL); }
	virtual ~__witsml1__obj_USCOREwell_sequence() { }
	friend __witsml1__obj_USCOREwell_sequence *soap_instantiate___witsml1__obj_USCOREwell_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:201 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwell
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwell (16)
/* witsml1:obj_well complex type: */
class SOAP_CMAC witsml1__obj_USCOREwell
{
public:
	std::string name;	/* required element of XSD type witsml1:nameString */
	__witsml1__obj_USCOREwell_sequence *__obj_USCOREwell_sequence;
	witsml1__cs_USCOREcommonData *commonData;	/* optional element of XSD type witsml1:cs_commonData */
	witsml1__cs_USCOREcustomData *customData;	/* optional element of XSD type witsml1:cs_customData */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwell (16)
	virtual int soap_type(void) const { return 16; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREwell, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREwell *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREwell); }
	         witsml1__obj_USCOREwell() { witsml1__obj_USCOREwell::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREwell() { }
	friend witsml1__obj_USCOREwell *soap_instantiate_witsml1__obj_USCOREwell(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:204 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentInfo
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentInfo (17)
/* witsml1:cs_documentInfo complex type: */
class SOAP_CMAC witsml1__cs_USCOREdocumentInfo
{
public:
	witsml1__nameStruct *documentName;	/* required element of XSD type witsml1:nameStruct */
	std::vector<witsml1__nameStruct *> documentAlias;	/* optional element of XSD type witsml1:nameStruct */
	time_t *documentDate;	/* optional element of XSD type witsml1:timestamp */
	std::vector<witsml1__nameStruct *> documentClass;	/* optional element of XSD type witsml1:nameStruct */
	witsml1__cs_USCOREdocumentFileCreation *fileCreationInformation;	/* optional element of XSD type witsml1:cs_documentFileCreation */
	std::vector<witsml1__cs_USCOREdocumentSecurityInfo *> securityInformation;	/* optional element of XSD type witsml1:cs_documentSecurityInfo */
	std::string *disclaimer;	/* optional element of XSD type witsml1:commentString */
	witsml1__cs_USCOREdocumentAudit *auditTrail;	/* optional element of XSD type witsml1:cs_documentAudit */
	std::string *owner;	/* optional element of XSD type witsml1:nameString */
	std::string *comment;	/* optional element of XSD type witsml1:commentString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentInfo (17)
	virtual int soap_type(void) const { return 17; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREdocumentInfo, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREdocumentInfo *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREdocumentInfo); }
	         witsml1__cs_USCOREdocumentInfo() { witsml1__cs_USCOREdocumentInfo::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREdocumentInfo() { }
	friend witsml1__cs_USCOREdocumentInfo *soap_instantiate_witsml1__cs_USCOREdocumentInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:207 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentFileCreation
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentFileCreation (18)
/* witsml1:cs_documentFileCreation complex type: */
class SOAP_CMAC witsml1__cs_USCOREdocumentFileCreation
{
public:
	time_t fileCreationDate;	/* required element of XSD type witsml1:timestamp */
	std::string *softwareName;	/* optional element of XSD type witsml1:nameString */
	std::string *fileCreator;	/* optional element of XSD type witsml1:nameString */
	std::string *comment;	/* optional element of XSD type witsml1:commentString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentFileCreation (18)
	virtual int soap_type(void) const { return 18; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREdocumentFileCreation, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREdocumentFileCreation *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREdocumentFileCreation); }
	         witsml1__cs_USCOREdocumentFileCreation() { witsml1__cs_USCOREdocumentFileCreation::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREdocumentFileCreation() { }
	friend witsml1__cs_USCOREdocumentFileCreation *soap_instantiate_witsml1__cs_USCOREdocumentFileCreation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:411 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentSecurityInfo
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentSecurityInfo (86)
/* witsml1:cs_documentSecurityInfo complex type: */
class SOAP_CMAC witsml1__cs_USCOREdocumentSecurityInfo
{
public:
	std::string *class_;	/* optional element of XSD type witsml1:kindString */
	std::string *securitySystem;	/* optional element of XSD type witsml1:kindString */
	time_t *endDate;	/* optional element of XSD type witsml1:timestamp */
	std::string *comment;	/* optional element of XSD type witsml1:commentString */
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentSecurityInfo (86)
	virtual int soap_type(void) const { return 86; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREdocumentSecurityInfo, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREdocumentSecurityInfo *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREdocumentSecurityInfo); }
	         witsml1__cs_USCOREdocumentSecurityInfo() { witsml1__cs_USCOREdocumentSecurityInfo::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREdocumentSecurityInfo() { }
	friend witsml1__cs_USCOREdocumentSecurityInfo *soap_instantiate_witsml1__cs_USCOREdocumentSecurityInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:414 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREextensionNameValue
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREextensionNameValue (87)
/* witsml1:cs_extensionNameValue complex type: */
class SOAP_CMAC witsml1__cs_USCOREextensionNameValue
{
public:
	std::string name;	/* required element of XSD type witsml1:ExtensionName */
	witsml1__extensionvalue *value;	/* required element of XSD type witsml1:extensionvalue */
	enum witsml1__PrimitiveType dataType;	/* required element of XSD type witsml1:PrimitiveType */
	time_t *dTim;	/* optional element of XSD type witsml1:timestamp */
	witsml1__measuredDepthCoord *md;	/* optional element of XSD type witsml1:measuredDepthCoord */
	short *index;	/* optional element of XSD type witsml1:positiveCount */
	std::string *measureClass;	/* optional element of XSD type witsml1:MeasureClass */
	std::string *description;	/* optional element of XSD type witsml1:descriptionString */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREextensionNameValue (87)
	virtual int soap_type(void) const { return 87; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREextensionNameValue, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREextensionNameValue *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREextensionNameValue); }
	         witsml1__cs_USCOREextensionNameValue() { witsml1__cs_USCOREextensionNameValue::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREextensionNameValue() { }
	friend witsml1__cs_USCOREextensionNameValue *soap_instantiate_witsml1__cs_USCOREextensionNameValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:417 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentAudit
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentAudit (88)
/* witsml1:cs_documentAudit complex type: */
class SOAP_CMAC witsml1__cs_USCOREdocumentAudit
{
public:
	std::vector<witsml1__cs_USCOREdocumentEvent *> event;	/* required element of XSD type witsml1:cs_documentEvent */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentAudit (88)
	virtual int soap_type(void) const { return 88; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREdocumentAudit, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREdocumentAudit *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREdocumentAudit); }
	         witsml1__cs_USCOREdocumentAudit() { witsml1__cs_USCOREdocumentAudit::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREdocumentAudit() { }
	friend witsml1__cs_USCOREdocumentAudit *soap_instantiate_witsml1__cs_USCOREdocumentAudit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:420 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentEvent
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentEvent (89)
/* witsml1:cs_documentEvent complex type: */
class SOAP_CMAC witsml1__cs_USCOREdocumentEvent
{
public:
	time_t eventDate;	/* required element of XSD type witsml1:timestamp */
	std::string *eventType;	/* optional element of XSD type witsml1:nameString */
	std::string *responsibleParty;	/* optional element of XSD type witsml1:nameString */
	std::string *comment;	/* optional element of XSD type witsml1:commentString */
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREdocumentEvent (89)
	virtual int soap_type(void) const { return 89; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREdocumentEvent, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREdocumentEvent *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREdocumentEvent); }
	         witsml1__cs_USCOREdocumentEvent() { witsml1__cs_USCOREdocumentEvent::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREdocumentEvent() { }
	friend witsml1__cs_USCOREdocumentEvent *soap_instantiate_witsml1__cs_USCOREdocumentEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:423 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElocation
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElocation (90)
/* witsml1:cs_location complex type: */
class SOAP_CMAC witsml1__cs_USCORElocation
{
public:
	witsml1__refNameString *wellCRS;	/* optional element of XSD type witsml1:refNameString */
	witsml1__planeAngleMeasure *latitude;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *longitude;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__lengthMeasure *easting;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *northing;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *westing;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *southing;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *projectedX;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *projectedY;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *localX;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *localY;	/* optional element of XSD type witsml1:lengthMeasure */
	bool *original;	/* optional element of XSD type witsml1:logicalBoolean */
	std::string *description;	/* optional element of XSD type witsml1:descriptionString */
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElocation (90)
	virtual int soap_type(void) const { return 90; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCORElocation, default initialized and not managed by a soap context
	virtual witsml1__cs_USCORElocation *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCORElocation); }
	         witsml1__cs_USCORElocation() { witsml1__cs_USCORElocation::soap_default(NULL); }
	virtual ~witsml1__cs_USCORElocation() { }
	friend witsml1__cs_USCORElocation *soap_instantiate_witsml1__cs_USCORElocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:10708 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellDatum
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellDatum (493)
/* xsd:choice complex type: */
union _witsml1__union_cs_USCOREwellDatum
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellDatum_datumName	(1)
	witsml1__wellKnownNameStruct *datumName;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellDatum_datumCRS	(2)
	witsml1__refNameString *datumCRS;
};
#endif

/* witsml1_4_1_1ForGsoap.h:426 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREwellDatum
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREwellDatum (91)
/* witsml1:cs_wellDatum complex type: */
class SOAP_CMAC witsml1__cs_USCOREwellDatum
{
public:
	std::string name;	/* required element of XSD type witsml1:nameString */
	enum witsml1__ElevCodeEnum *code;	/* optional element of XSD type witsml1:ElevCodeEnum */
	int __union_cs_USCOREwellDatum;	/* union discriminant (of union defined below) */
	union _witsml1__union_cs_USCOREwellDatum union_cs_USCOREwellDatum;
	std::vector<std::string> kind;	/* optional element of XSD type witsml1:kindString */
	witsml1__cs_USCORErefWellWellbore *wellbore;	/* optional element of XSD type witsml1:cs_refWellWellbore */
	witsml1__cs_USCORErefWellWellboreRig *rig;	/* optional element of XSD type witsml1:cs_refWellWellboreRig */
	witsml1__wellElevationCoord *elevation;	/* optional element of XSD type witsml1:wellElevationCoord */
	witsml1__measuredDepthCoord *measuredDepth;	/* optional element of XSD type witsml1:measuredDepthCoord */
	witsml1__cs_USCORElocation *horizontalLocation;	/* optional element of XSD type witsml1:cs_location */
	std::string *comment;	/* optional element of XSD type witsml1:commentString */
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	std::string uid;	/* required attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREwellDatum (91)
	virtual int soap_type(void) const { return 91; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREwellDatum, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREwellDatum *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREwellDatum); }
	         witsml1__cs_USCOREwellDatum() { witsml1__cs_USCOREwellDatum::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREwellDatum() { }
	friend witsml1__cs_USCOREwellDatum *soap_instantiate_witsml1__cs_USCOREwellDatum(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:429 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellWellbore
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellWellbore (92)
/* witsml1:cs_refWellWellbore complex type: */
class SOAP_CMAC witsml1__cs_USCORErefWellWellbore
{
public:
	witsml1__refNameString *wellboreReference;	/* required element of XSD type witsml1:refNameString */
	witsml1__refNameString *wellParent;	/* optional element of XSD type witsml1:refNameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellWellbore (92)
	virtual int soap_type(void) const { return 92; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCORErefWellWellbore, default initialized and not managed by a soap context
	virtual witsml1__cs_USCORErefWellWellbore *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCORErefWellWellbore); }
	         witsml1__cs_USCORErefWellWellbore() { witsml1__cs_USCORErefWellWellbore::soap_default(NULL); }
	virtual ~witsml1__cs_USCORErefWellWellbore() { }
	friend witsml1__cs_USCORErefWellWellbore *soap_instantiate_witsml1__cs_USCORErefWellWellbore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:432 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellWellboreRig
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellWellboreRig (93)
/* witsml1:cs_refWellWellboreRig complex type: */
class SOAP_CMAC witsml1__cs_USCORErefWellWellboreRig
{
public:
	witsml1__refNameString *rigReference;	/* required element of XSD type witsml1:refNameString */
	witsml1__refNameString *wellboreParent;	/* optional element of XSD type witsml1:refNameString */
	witsml1__refNameString *wellParent;	/* optional element of XSD type witsml1:refNameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellWellboreRig (93)
	virtual int soap_type(void) const { return 93; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCORErefWellWellboreRig, default initialized and not managed by a soap context
	virtual witsml1__cs_USCORErefWellWellboreRig *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCORErefWellWellboreRig); }
	         witsml1__cs_USCORErefWellWellboreRig() { witsml1__cs_USCORErefWellWellboreRig::soap_default(NULL); }
	virtual ~witsml1__cs_USCORErefWellWellboreRig() { }
	friend witsml1__cs_USCORErefWellWellboreRig *soap_instantiate_witsml1__cs_USCORErefWellWellboreRig(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:435 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREpublicLandSurveySystem
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREpublicLandSurveySystem (94)
/* witsml1:cs_publicLandSurveySystem complex type: */
class SOAP_CMAC witsml1__cs_USCOREpublicLandSurveySystem
{
public:
	enum witsml1__PrincipalMeridian *principalMeridian;	/* optional element of XSD type witsml1:PrincipalMeridian */
	short *range;	/* optional element of XSD type witsml1:positiveCount */
	enum witsml1__EastOrWest *rangeDir;	/* optional element of XSD type witsml1:EastOrWest */
	short *township;	/* optional element of XSD type witsml1:positiveCount */
	enum witsml1__NorthOrSouth *townshipDir;	/* optional element of XSD type witsml1:NorthOrSouth */
	std::string *section;	/* optional element of XSD type witsml1:sectionNumber */
	std::string *quarterSection;	/* optional element of XSD type witsml1:publicLandSurveySystemQuarterSection */
	std::string *quarterTownship;	/* optional element of XSD type witsml1:publicLandSurveySystemQuarterTownship */
	witsml1__footageNorthSouth *footageNS;	/* optional element of XSD type witsml1:footageNorthSouth */
	witsml1__footageEastWest *footageEW;	/* optional element of XSD type witsml1:footageEastWest */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREpublicLandSurveySystem (94)
	virtual int soap_type(void) const { return 94; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREpublicLandSurveySystem, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREpublicLandSurveySystem *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREpublicLandSurveySystem); }
	         witsml1__cs_USCOREpublicLandSurveySystem() { witsml1__cs_USCOREpublicLandSurveySystem::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREpublicLandSurveySystem() { }
	friend witsml1__cs_USCOREpublicLandSurveySystem *soap_instantiate_witsml1__cs_USCOREpublicLandSurveySystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:438 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREreferencePoint
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREreferencePoint (95)
/* witsml1:cs_referencePoint complex type: */
class SOAP_CMAC witsml1__cs_USCOREreferencePoint
{
public:
	std::string name;	/* required element of XSD type witsml1:nameString */
	std::string *type;	/* optional element of XSD type witsml1:kindString */
	witsml1__wellElevationCoord *elevation;	/* optional element of XSD type witsml1:wellElevationCoord */
	witsml1__measuredDepthCoord *measuredDepth;	/* optional element of XSD type witsml1:measuredDepthCoord */
	std::vector<witsml1__cs_USCORElocation *> location;	/* required element of XSD type witsml1:cs_location */
	std::string *description;	/* optional element of XSD type witsml1:commentString */
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREreferencePoint (95)
	virtual int soap_type(void) const { return 95; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREreferencePoint, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREreferencePoint *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREreferencePoint); }
	         witsml1__cs_USCOREreferencePoint() { witsml1__cs_USCOREreferencePoint::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREreferencePoint() { }
	friend witsml1__cs_USCOREreferencePoint *soap_instantiate_witsml1__cs_USCOREreferencePoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:11046 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellCRS (508)
/* xsd:choice complex type: */
union _witsml1__union_cs_USCOREwellCRS
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellCRS_mapProjection	(1)
	witsml1__cs_USCOREprojectionx *mapProjection;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellCRS_geographic	(2)
	witsml1__cs_USCOREgeodeticModel *geographic;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellCRS_mapProjectionCRS	(3)
	witsml1__refNameString *mapProjectionCRS;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellCRS_geodeticCRS	(4)
	witsml1__refNameString *geodeticCRS;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREwellCRS_localCRS	(5)
	witsml1__cs_USCORElocalCRS *localCRS;
};
#endif

/* witsml1_4_1_1ForGsoap.h:441 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREwellCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREwellCRS (96)
/* witsml1:cs_wellCRS complex type: */
class SOAP_CMAC witsml1__cs_USCOREwellCRS
{
public:
	std::string name;	/* required element of XSD type witsml1:nameString */
	int __union_cs_USCOREwellCRS;	/* union discriminant (of union defined below) */
	union _witsml1__union_cs_USCOREwellCRS union_cs_USCOREwellCRS;
	std::string *description;	/* optional element of XSD type witsml1:descriptionString */
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREwellCRS (96)
	virtual int soap_type(void) const { return 96; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREwellCRS, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREwellCRS *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREwellCRS); }
	         witsml1__cs_USCOREwellCRS() { witsml1__cs_USCOREwellCRS::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREwellCRS() { }
	friend witsml1__cs_USCOREwellCRS *soap_instantiate_witsml1__cs_USCOREwellCRS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:444 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREgeodeticModel
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREgeodeticModel (97)
/* witsml1:cs_geodeticModel complex type: */
class SOAP_CMAC witsml1__cs_USCOREgeodeticModel
{
public:
	witsml1__wellKnownNameStruct *nameCRS;	/* optional element of XSD type witsml1:wellKnownNameStruct */
	enum witsml1__GeodeticDatum *geodeticDatumCode;	/* optional element of XSD type witsml1:GeodeticDatum */
	witsml1__lengthMeasure *xTranslation;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *yTranslation;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *zTranslation;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__planeAngleMeasure *xRotation;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *yRotation;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *zRotation;	/* optional element of XSD type witsml1:planeAngleMeasure */
	double *scaleFactor;	/* optional element of XSD type witsml1:unitlessQuantity */
	enum witsml1__Ellipsoid *ellipsoidCode;	/* optional element of XSD type witsml1:Ellipsoid */
	witsml1__lengthMeasure *ellipsoidSemiMajorAxis;	/* optional element of XSD type witsml1:lengthMeasure */
	double *ellipsoidInverseFlattening;	/* optional element of XSD type witsml1:unitlessQuantity */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREgeodeticModel (97)
	virtual int soap_type(void) const { return 97; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREgeodeticModel, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREgeodeticModel *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREgeodeticModel); }
	         witsml1__cs_USCOREgeodeticModel() { witsml1__cs_USCOREgeodeticModel::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREgeodeticModel() { }
	friend witsml1__cs_USCOREgeodeticModel *soap_instantiate_witsml1__cs_USCOREgeodeticModel(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:447 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREprojectionx
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREprojectionx (98)
/* witsml1:cs_projectionx complex type: */
class SOAP_CMAC witsml1__cs_USCOREprojectionx
{
public:
	witsml1__wellKnownNameStruct *nameCRS;	/* optional element of XSD type witsml1:wellKnownNameStruct */
	enum witsml1__Projection *projectionCode;	/* optional element of XSD type witsml1:Projection */
	witsml1__refNameString *projectedFrom;	/* optional element of XSD type witsml1:refNameString */
	witsml1__planeAngleMeasure *stdParallel1;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *stdParallel2;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *centralMeridian;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *originLatitude;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *originLongitude;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *latitude1;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *longitude1;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *latitude2;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *longitude2;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *latitudeForScale;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *longitudeForScale;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *trueScaleLatitude;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__lengthMeasure *spheroidRadius;	/* optional element of XSD type witsml1:lengthMeasure */
	double *scaleFactor;	/* optional element of XSD type witsml1:unitlessQuantity */
	enum witsml1__ProjectionVariantsObliqueMercator *methodVariant;	/* optional element of XSD type witsml1:ProjectionVariantsObliqueMercator */
	witsml1__lengthMeasure *perspectiveHeight;	/* optional element of XSD type witsml1:lengthMeasure */
	std::string *zone;	/* optional element of XSD type witsml1:geodeticZoneString */
	enum witsml1__NADTypes *NADType;	/* optional element of XSD type witsml1:NADTypes */
	witsml1__lengthMeasure *falseEasting;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *falseNorthing;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__planeAngleMeasure *bearing;	/* optional element of XSD type witsml1:planeAngleMeasure */
	enum witsml1__Hemispheres *hemisphere;	/* optional element of XSD type witsml1:Hemispheres */
	std::string *description;	/* optional element of XSD type witsml1:commentString */
	std::vector<witsml1__indexedObject *> parameter;	/* optional element of XSD type witsml1:indexedObject */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREprojectionx (98)
	virtual int soap_type(void) const { return 98; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREprojectionx, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREprojectionx *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREprojectionx); }
	         witsml1__cs_USCOREprojectionx() { witsml1__cs_USCOREprojectionx::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREprojectionx() { }
	friend witsml1__cs_USCOREprojectionx *soap_instantiate_witsml1__cs_USCOREprojectionx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:11361 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCORElocalCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCORElocalCRS (519)
/* xsd:choice complex type: */
union _witsml1__union_cs_USCORElocalCRS
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCORElocalCRS_usesWellAsOrigin	(1)
	bool *usesWellAsOrigin;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCORElocalCRS_origin	(2)
	witsml1__refNameString *origin;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCORElocalCRS_originDescription	(3)
	std::string *originDescription;
};
#endif

/* witsml1_4_1_1ForGsoap.h:450 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElocalCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElocalCRS (99)
/* witsml1:cs_localCRS complex type: */
class SOAP_CMAC witsml1__cs_USCORElocalCRS
{
public:
	int __union_cs_USCORElocalCRS;	/* union discriminant (of union defined below) */
	union _witsml1__union_cs_USCORElocalCRS union_cs_USCORElocalCRS;
	witsml1__yAxisAzimuth *yAxisAzimuth;	/* optional element of XSD type witsml1:yAxisAzimuth */
	witsml1__planeAngleMeasure *magneticDeclination;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *gridConvergence;	/* optional element of XSD type witsml1:planeAngleMeasure */
	std::string *yAxisDescription;	/* optional element of XSD type witsml1:commentString */
	bool *xRotationCounterClockwise;	/* optional element of XSD type witsml1:logicalBoolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElocalCRS (99)
	virtual int soap_type(void) const { return 99; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCORElocalCRS, default initialized and not managed by a soap context
	virtual witsml1__cs_USCORElocalCRS *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCORElocalCRS); }
	         witsml1__cs_USCORElocalCRS() { witsml1__cs_USCORElocalCRS::soap_default(NULL); }
	virtual ~witsml1__cs_USCORElocalCRS() { }
	friend witsml1__cs_USCORElocalCRS *soap_instantiate_witsml1__cs_USCORElocalCRS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:453 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREcommonData
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREcommonData (100)
/* witsml1:cs_commonData complex type: */
class SOAP_CMAC witsml1__cs_USCOREcommonData
{
public:
	std::string *sourceName;	/* optional element of XSD type witsml1:nameString */
	time_t *dTimCreation;	/* optional element of XSD type witsml1:timestamp */
	time_t *dTimLastChange;	/* optional element of XSD type witsml1:timestamp */
	enum witsml1__ItemState *itemState;	/* optional element of XSD type witsml1:ItemState */
	std::string *serviceCategory;	/* optional element of XSD type witsml1:kindString */
	std::string *comments;	/* optional element of XSD type witsml1:commentString */
	std::vector<witsml1__timestampedTimeZone *> acquisitionTimeZone;	/* optional element of XSD type witsml1:timestampedTimeZone */
	witsml1__refNameString *defaultDatum;	/* optional element of XSD type witsml1:refNameString */
	bool *privateGroupOnly;	/* optional element of XSD type xsd:boolean */
	witsml1__cs_USCOREextensionAny *extensionAny;	/* optional element of XSD type witsml1:cs_extensionAny */
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREcommonData (100)
	virtual int soap_type(void) const { return 100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREcommonData, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREcommonData *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREcommonData); }
	         witsml1__cs_USCOREcommonData() { witsml1__cs_USCOREcommonData::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREcommonData() { }
	friend witsml1__cs_USCOREcommonData *soap_instantiate_witsml1__cs_USCOREcommonData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:456 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREextensionAny
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREextensionAny (101)
/* witsml1:cs_extensionAny complex type: */
class SOAP_CMAC witsml1__cs_USCOREextensionAny
{
public:
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREextensionAny (101)
	virtual int soap_type(void) const { return 101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREextensionAny, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREextensionAny *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREextensionAny); }
	         witsml1__cs_USCOREextensionAny() { witsml1__cs_USCOREextensionAny::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREextensionAny() { }
	friend witsml1__cs_USCOREextensionAny *soap_instantiate_witsml1__cs_USCOREextensionAny(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:459 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREcustomData
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREcustomData (102)
/* witsml1:cs_customData complex type: */
class SOAP_CMAC witsml1__cs_USCOREcustomData
{
public:
	std::vector<char *> __any;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREcustomData (102)
	virtual int soap_type(void) const { return 102; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREcustomData, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREcustomData *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREcustomData); }
	         witsml1__cs_USCOREcustomData() { witsml1__cs_USCOREcustomData::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREcustomData() { }
	friend witsml1__cs_USCOREcustomData *soap_instantiate_witsml1__cs_USCOREcustomData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:11566 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREwellbore_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREwellbore_sequence (527)
/* Operation wrapper: */
class SOAP_CMAC __witsml1__obj_USCOREwellbore_sequence
{
public:
	witsml1__refNameString *parentWellbore;	/* optional element of XSD type witsml1:refNameString */
	std::string *number;	/* optional element of XSD type witsml1:str32 */
	std::string *suffixAPI;	/* optional element of XSD type witsml1:nameString */
	std::string *numGovt;	/* optional element of XSD type witsml1:nameString */
	enum witsml1__WellStatus *statusWellbore;	/* optional element of XSD type witsml1:WellStatus */
	bool *isActive;	/* optional element of XSD type witsml1:logicalBoolean */
	enum witsml1__WellPurpose *purposeWellbore;	/* optional element of XSD type witsml1:WellPurpose */
	enum witsml1__WellboreType *typeWellbore;	/* optional element of XSD type witsml1:WellboreType */
	enum witsml1__WellboreShape *shape;	/* optional element of XSD type witsml1:WellboreShape */
	time_t *dTimKickoff;	/* optional element of XSD type witsml1:timestamp */
	bool *achievedTD;	/* optional element of XSD type witsml1:logicalBoolean */
	witsml1__measuredDepthCoord *md;	/* optional element of XSD type witsml1:measuredDepthCoord */
	witsml1__wellVerticalDepthCoord *tvd;	/* optional element of XSD type witsml1:wellVerticalDepthCoord */
	witsml1__measuredDepthCoord *mdBit;	/* optional element of XSD type witsml1:measuredDepthCoord */
	witsml1__wellVerticalDepthCoord *tvdBit;	/* optional element of XSD type witsml1:wellVerticalDepthCoord */
	witsml1__measuredDepthCoord *mdKickoff;	/* optional element of XSD type witsml1:measuredDepthCoord */
	witsml1__wellVerticalDepthCoord *tvdKickoff;	/* optional element of XSD type witsml1:wellVerticalDepthCoord */
	witsml1__measuredDepthCoord *mdPlanned;	/* optional element of XSD type witsml1:measuredDepthCoord */
	witsml1__wellVerticalDepthCoord *tvdPlanned;	/* optional element of XSD type witsml1:wellVerticalDepthCoord */
	witsml1__measuredDepthCoord *mdSubSeaPlanned;	/* optional element of XSD type witsml1:measuredDepthCoord */
	witsml1__wellVerticalDepthCoord *tvdSubSeaPlanned;	/* optional element of XSD type witsml1:wellVerticalDepthCoord */
	witsml1__timeMeasure *dayTarget;	/* optional element of XSD type witsml1:timeMeasure */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREwellbore_sequence (527)
	virtual int soap_type(void) const { return 527; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __witsml1__obj_USCOREwellbore_sequence, default initialized and not managed by a soap context
	virtual __witsml1__obj_USCOREwellbore_sequence *soap_alloc(void) const { return SOAP_NEW(__witsml1__obj_USCOREwellbore_sequence); }
	         __witsml1__obj_USCOREwellbore_sequence() { __witsml1__obj_USCOREwellbore_sequence::soap_default(NULL); }
	virtual ~__witsml1__obj_USCOREwellbore_sequence() { }
	friend __witsml1__obj_USCOREwellbore_sequence *soap_instantiate___witsml1__obj_USCOREwellbore_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:465 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwellbore
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwellbore (104)
/* witsml1:obj_wellbore complex type: */
class SOAP_CMAC witsml1__obj_USCOREwellbore
{
public:
	std::string nameWell;	/* required element of XSD type witsml1:nameString */
	std::string name;	/* required element of XSD type witsml1:nameString */
	__witsml1__obj_USCOREwellbore_sequence *__obj_USCOREwellbore_sequence;
	witsml1__cs_USCOREcommonData *commonData;	/* optional element of XSD type witsml1:cs_commonData */
	witsml1__cs_USCOREcustomData *customData;	/* optional element of XSD type witsml1:cs_customData */
	std::string *uidWell;	/* optional attribute of XSD type witsml1:uidParentString */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwellbore (104)
	virtual int soap_type(void) const { return 104; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREwellbore, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREwellbore *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREwellbore); }
	         witsml1__obj_USCOREwellbore() { witsml1__obj_USCOREwellbore::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREwellbore() { }
	friend witsml1__obj_USCOREwellbore *soap_instantiate_witsml1__obj_USCOREwellbore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:11751 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREtrajectory_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREtrajectory_sequence (534)
/* Operation wrapper: */
class SOAP_CMAC __witsml1__obj_USCOREtrajectory_sequence
{
public:
	bool *objectGrowing;	/* optional element of XSD type witsml1:logicalBoolean */
	witsml1__cs_USCORErefWellboreTrajectory *parentTrajectory;	/* optional element of XSD type witsml1:cs_refWellboreTrajectory */
	time_t *dTimTrajStart;	/* optional element of XSD type witsml1:timestamp */
	time_t *dTimTrajEnd;	/* optional element of XSD type witsml1:timestamp */
	witsml1__measuredDepthCoord *mdMn;	/* optional element of XSD type witsml1:measuredDepthCoord */
	witsml1__measuredDepthCoord *mdMx;	/* optional element of XSD type witsml1:measuredDepthCoord */
	std::string *serviceCompany;	/* optional element of XSD type witsml1:nameString */
	witsml1__planeAngleMeasure *magDeclUsed;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *gridCorUsed;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *gridConUsed;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *aziVertSect;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__lengthMeasure *dispNsVertSectOrig;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *dispEwVertSectOrig;	/* optional element of XSD type witsml1:lengthMeasure */
	bool *definitive;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *memory;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *finalTraj;	/* optional element of XSD type witsml1:logicalBoolean */
	enum witsml1__AziRef *aziRef;	/* optional element of XSD type witsml1:AziRef */
	std::vector<witsml1__cs_USCOREtrajectoryStation *> trajectoryStation;	/* optional element of XSD type witsml1:cs_trajectoryStation */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREtrajectory_sequence (534)
	virtual int soap_type(void) const { return 534; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __witsml1__obj_USCOREtrajectory_sequence, default initialized and not managed by a soap context
	virtual __witsml1__obj_USCOREtrajectory_sequence *soap_alloc(void) const { return SOAP_NEW(__witsml1__obj_USCOREtrajectory_sequence); }
	         __witsml1__obj_USCOREtrajectory_sequence() { __witsml1__obj_USCOREtrajectory_sequence::soap_default(NULL); }
	virtual ~__witsml1__obj_USCOREtrajectory_sequence() { }
	friend __witsml1__obj_USCOREtrajectory_sequence *soap_instantiate___witsml1__obj_USCOREtrajectory_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:471 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREtrajectory
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREtrajectory (106)
/* witsml1:obj_trajectory complex type: */
class SOAP_CMAC witsml1__obj_USCOREtrajectory
{
public:
	std::string nameWell;	/* required element of XSD type witsml1:nameString */
	std::string nameWellbore;	/* required element of XSD type witsml1:nameString */
	std::string name;	/* required element of XSD type witsml1:nameString */
	__witsml1__obj_USCOREtrajectory_sequence *__obj_USCOREtrajectory_sequence;
	witsml1__cs_USCOREcommonData *commonData;	/* optional element of XSD type witsml1:cs_commonData */
	witsml1__cs_USCOREcustomData *customData;	/* optional element of XSD type witsml1:cs_customData */
	std::string *uidWell;	/* optional attribute of XSD type witsml1:uidParentString */
	std::string *uidWellbore;	/* optional attribute of XSD type witsml1:uidParentString */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREtrajectory (106)
	virtual int soap_type(void) const { return 106; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREtrajectory, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREtrajectory *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREtrajectory); }
	         witsml1__obj_USCOREtrajectory() { witsml1__obj_USCOREtrajectory::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREtrajectory() { }
	friend witsml1__obj_USCOREtrajectory *soap_instantiate_witsml1__obj_USCOREtrajectory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:474 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREtrajectoryStation
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREtrajectoryStation (107)
/* witsml1:cs_trajectoryStation complex type: */
class SOAP_CMAC witsml1__cs_USCOREtrajectoryStation
{
public:
	witsml1__refNameString *target;	/* optional element of XSD type witsml1:refNameString */
	time_t *dTimStn;	/* optional element of XSD type witsml1:timestamp */
	enum witsml1__TrajStationType typeTrajStation;	/* required element of XSD type witsml1:TrajStationType */
	std::string *typeSurveyTool;	/* optional element of XSD type witsml1:TypeSurveyTool */
	std::string *calcAlgorithm;	/* optional element of XSD type witsml1:TrajStnCalcAlgorithm */
	witsml1__measuredDepthCoord *md;	/* required element of XSD type witsml1:measuredDepthCoord */
	witsml1__wellVerticalDepthCoord *tvd;	/* optional element of XSD type witsml1:wellVerticalDepthCoord */
	witsml1__planeAngleMeasure *incl;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *azi;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *mtf;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *gtf;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__lengthMeasure *dispNs;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *dispEw;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *vertSect;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__anglePerLengthMeasure *dls;	/* optional element of XSD type witsml1:anglePerLengthMeasure */
	witsml1__anglePerLengthMeasure *rateTurn;	/* optional element of XSD type witsml1:anglePerLengthMeasure */
	witsml1__anglePerLengthMeasure *rateBuild;	/* optional element of XSD type witsml1:anglePerLengthMeasure */
	witsml1__lengthMeasure *mdDelta;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *tvdDelta;	/* optional element of XSD type witsml1:lengthMeasure */
	std::string *modelToolError;	/* optional element of XSD type witsml1:commentString */
	witsml1__refNameString *iscwsaToolErrorModel;	/* optional element of XSD type witsml1:refNameString */
	witsml1__accelerationLinearMeasure *gravTotalUncert;	/* optional element of XSD type witsml1:accelerationLinearMeasure */
	witsml1__planeAngleMeasure *dipAngleUncert;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__magneticInductionMeasure *magTotalUncert;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	bool *gravAccelCorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *magXAxialCorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *sagCorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *magDrlstrCorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *infieldRefCorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *interpolatedInfieldRefCorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *inHoleRefCorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *axialMagInterferenceCorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *cosagCorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	bool *MSACorUsed;	/* optional element of XSD type witsml1:logicalBoolean */
	witsml1__accelerationLinearMeasure *gravTotalFieldReference;	/* optional element of XSD type witsml1:accelerationLinearMeasure */
	witsml1__magneticInductionMeasure *magTotalFieldReference;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__planeAngleMeasure *magDipAngleReference;	/* optional element of XSD type witsml1:planeAngleMeasure */
	std::string *magModelUsed;	/* optional element of XSD type witsml1:nameString */
	std::string *magModelValid;	/* optional element of XSD type witsml1:nameString */
	std::string *geoModelUsed;	/* optional element of XSD type witsml1:nameString */
	enum witsml1__TrajStationStatus *statusTrajStation;	/* optional element of XSD type witsml1:TrajStationStatus */
	witsml1__cs_USCOREstnTrajRawData *rawData;	/* optional element of XSD type witsml1:cs_stnTrajRawData */
	witsml1__cs_USCOREstnTrajCorUsed *corUsed;	/* optional element of XSD type witsml1:cs_stnTrajCorUsed */
	witsml1__cs_USCOREstnTrajValid *valid;	/* optional element of XSD type witsml1:cs_stnTrajValid */
	witsml1__cs_USCOREstnTrajMatrixCov *matrixCov;	/* optional element of XSD type witsml1:cs_stnTrajMatrixCov */
	std::vector<witsml1__cs_USCORElocation *> location;	/* optional element of XSD type witsml1:cs_location */
	witsml1__cs_USCORErefWellboreTrajectoryStation *sourceStation;	/* optional element of XSD type witsml1:cs_refWellboreTrajectoryStation */
	witsml1__cs_USCOREcommonData *commonData;	/* optional element of XSD type witsml1:cs_commonData */
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREtrajectoryStation (107)
	virtual int soap_type(void) const { return 107; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREtrajectoryStation, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREtrajectoryStation *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREtrajectoryStation); }
	         witsml1__cs_USCOREtrajectoryStation() { witsml1__cs_USCOREtrajectoryStation::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREtrajectoryStation() { }
	friend witsml1__cs_USCOREtrajectoryStation *soap_instantiate_witsml1__cs_USCOREtrajectoryStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:477 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajRawData
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajRawData (108)
/* witsml1:cs_stnTrajRawData complex type: */
class SOAP_CMAC witsml1__cs_USCOREstnTrajRawData
{
public:
	witsml1__accelerationLinearMeasure *gravAxialRaw;	/* optional element of XSD type witsml1:accelerationLinearMeasure */
	witsml1__accelerationLinearMeasure *gravTran1Raw;	/* optional element of XSD type witsml1:accelerationLinearMeasure */
	witsml1__accelerationLinearMeasure *gravTran2Raw;	/* optional element of XSD type witsml1:accelerationLinearMeasure */
	witsml1__magneticInductionMeasure *magAxialRaw;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__magneticInductionMeasure *magTran1Raw;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__magneticInductionMeasure *magTran2Raw;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajRawData (108)
	virtual int soap_type(void) const { return 108; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREstnTrajRawData, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREstnTrajRawData *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREstnTrajRawData); }
	         witsml1__cs_USCOREstnTrajRawData() { witsml1__cs_USCOREstnTrajRawData::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREstnTrajRawData() { }
	friend witsml1__cs_USCOREstnTrajRawData *soap_instantiate_witsml1__cs_USCOREstnTrajRawData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:480 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajCorUsed
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajCorUsed (109)
/* witsml1:cs_stnTrajCorUsed complex type: */
class SOAP_CMAC witsml1__cs_USCOREstnTrajCorUsed
{
public:
	witsml1__accelerationLinearMeasure *gravAxialAccelCor;	/* optional element of XSD type witsml1:accelerationLinearMeasure */
	witsml1__accelerationLinearMeasure *gravTran1AccelCor;	/* optional element of XSD type witsml1:accelerationLinearMeasure */
	witsml1__accelerationLinearMeasure *gravTran2AccelCor;	/* optional element of XSD type witsml1:accelerationLinearMeasure */
	witsml1__magneticInductionMeasure *magAxialDrlstrCor;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__magneticInductionMeasure *magTran1DrlstrCor;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__magneticInductionMeasure *magTran2DrlstrCor;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__magneticInductionMeasure *magTran1MSACor;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__magneticInductionMeasure *magTran2MSACor;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__magneticInductionMeasure *magAxialMSACor;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__planeAngleMeasure *sagIncCor;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *sagAziCor;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *stnMagDeclUsed;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *stnGridCorUsed;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *stnGridConUsed;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__lengthMeasure *dirSensorOffset;	/* optional element of XSD type witsml1:lengthMeasure */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajCorUsed (109)
	virtual int soap_type(void) const { return 109; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREstnTrajCorUsed, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREstnTrajCorUsed *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREstnTrajCorUsed); }
	         witsml1__cs_USCOREstnTrajCorUsed() { witsml1__cs_USCOREstnTrajCorUsed::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREstnTrajCorUsed() { }
	friend witsml1__cs_USCOREstnTrajCorUsed *soap_instantiate_witsml1__cs_USCOREstnTrajCorUsed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:483 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajValid
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajValid (110)
/* witsml1:cs_stnTrajValid complex type: */
class SOAP_CMAC witsml1__cs_USCOREstnTrajValid
{
public:
	witsml1__magneticInductionMeasure *magTotalFieldCalc;	/* optional element of XSD type witsml1:magneticInductionMeasure */
	witsml1__planeAngleMeasure *magDipAngleCalc;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__accelerationLinearMeasure *gravTotalFieldCalc;	/* optional element of XSD type witsml1:accelerationLinearMeasure */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajValid (110)
	virtual int soap_type(void) const { return 110; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREstnTrajValid, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREstnTrajValid *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREstnTrajValid); }
	         witsml1__cs_USCOREstnTrajValid() { witsml1__cs_USCOREstnTrajValid::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREstnTrajValid() { }
	friend witsml1__cs_USCOREstnTrajValid *soap_instantiate_witsml1__cs_USCOREstnTrajValid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:486 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajMatrixCov
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajMatrixCov (111)
/* witsml1:cs_stnTrajMatrixCov complex type: */
class SOAP_CMAC witsml1__cs_USCOREstnTrajMatrixCov
{
public:
	witsml1__areaMeasure *varianceNN;	/* optional element of XSD type witsml1:areaMeasure */
	witsml1__areaMeasure *varianceNE;	/* optional element of XSD type witsml1:areaMeasure */
	witsml1__areaMeasure *varianceNVert;	/* optional element of XSD type witsml1:areaMeasure */
	witsml1__areaMeasure *varianceEE;	/* optional element of XSD type witsml1:areaMeasure */
	witsml1__areaMeasure *varianceEVert;	/* optional element of XSD type witsml1:areaMeasure */
	witsml1__areaMeasure *varianceVertVert;	/* optional element of XSD type witsml1:areaMeasure */
	witsml1__lengthMeasure *biasN;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *biasE;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *biasVert;	/* optional element of XSD type witsml1:lengthMeasure */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstnTrajMatrixCov (111)
	virtual int soap_type(void) const { return 111; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREstnTrajMatrixCov, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREstnTrajMatrixCov *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREstnTrajMatrixCov); }
	         witsml1__cs_USCOREstnTrajMatrixCov() { witsml1__cs_USCOREstnTrajMatrixCov::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREstnTrajMatrixCov() { }
	friend witsml1__cs_USCOREstnTrajMatrixCov *soap_instantiate_witsml1__cs_USCOREstnTrajMatrixCov(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:489 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellboreTrajectoryStation
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellboreTrajectoryStation (112)
/* witsml1:cs_refWellboreTrajectoryStation complex type: */
class SOAP_CMAC witsml1__cs_USCORErefWellboreTrajectoryStation
{
public:
	std::string stationReference;	/* required element of XSD type witsml1:refString */
	witsml1__refNameString *trajectoryParent;	/* required element of XSD type witsml1:refNameString */
	witsml1__refNameString *wellboreParent;	/* optional element of XSD type witsml1:refNameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellboreTrajectoryStation (112)
	virtual int soap_type(void) const { return 112; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCORErefWellboreTrajectoryStation, default initialized and not managed by a soap context
	virtual witsml1__cs_USCORErefWellboreTrajectoryStation *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCORErefWellboreTrajectoryStation); }
	         witsml1__cs_USCORErefWellboreTrajectoryStation() { witsml1__cs_USCORErefWellboreTrajectoryStation::soap_default(NULL); }
	virtual ~witsml1__cs_USCORErefWellboreTrajectoryStation() { }
	friend witsml1__cs_USCORErefWellboreTrajectoryStation *soap_instantiate_witsml1__cs_USCORErefWellboreTrajectoryStation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:492 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellboreTrajectory
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellboreTrajectory (113)
/* witsml1:cs_refWellboreTrajectory complex type: */
class SOAP_CMAC witsml1__cs_USCORErefWellboreTrajectory
{
public:
	witsml1__refNameString *trajectoryReference;	/* required element of XSD type witsml1:refNameString */
	witsml1__refNameString *wellboreParent;	/* optional element of XSD type witsml1:refNameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORErefWellboreTrajectory (113)
	virtual int soap_type(void) const { return 113; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCORErefWellboreTrajectory, default initialized and not managed by a soap context
	virtual witsml1__cs_USCORErefWellboreTrajectory *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCORErefWellboreTrajectory); }
	         witsml1__cs_USCORErefWellboreTrajectory() { witsml1__cs_USCORErefWellboreTrajectory::soap_default(NULL); }
	virtual ~witsml1__cs_USCORErefWellboreTrajectory() { }
	friend witsml1__cs_USCORErefWellboreTrajectory *soap_instantiate_witsml1__cs_USCORErefWellboreTrajectory(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:12544 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCORElog_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCORElog_sequence (552)
/* Operation wrapper: */
class SOAP_CMAC __witsml1__obj_USCORElog_sequence
{
public:
	bool *objectGrowing;	/* optional element of XSD type witsml1:logicalBoolean */
	int *dataUpateRate;	/* optional element of XSD type witsml1:positiveBigCount */
	bool *curveSensorsAligned;	/* optional element of XSD type witsml1:logicalBoolean */
	std::string *dataGroup;	/* optional element of XSD type witsml1:kindString */
	std::string *serviceCompany;	/* optional element of XSD type witsml1:nameString */
	std::string *runNumber;	/* optional element of XSD type witsml1:str16 */
	short *bhaRunNumber;	/* optional element of XSD type witsml1:positiveCount */
	std::string *pass;	/* optional element of XSD type witsml1:str16 */
	time_t *creationDate;	/* optional element of XSD type witsml1:timestamp */
	std::string *description;	/* optional element of XSD type witsml1:commentString */
	std::string *dataDelimiter;	/* optional element of XSD type witsml1:str2 */
	enum witsml1__LogIndexType indexType;	/* required element of XSD type witsml1:LogIndexType */
	witsml1__genericMeasure *startIndex;	/* optional element of XSD type witsml1:genericMeasure */
	witsml1__genericMeasure *endIndex;	/* optional element of XSD type witsml1:genericMeasure */
	witsml1__ratioGenericMeasure *stepIncrement;	/* optional element of XSD type witsml1:ratioGenericMeasure */
	time_t *startDateTimeIndex;	/* optional element of XSD type witsml1:timestamp */
	time_t *endDateTimeIndex;	/* optional element of XSD type witsml1:timestamp */
	enum witsml1__LogIndexDirection *direction;	/* optional element of XSD type witsml1:LogIndexDirection */
	std::string indexCurve;	/* required element of XSD type witsml1:str32 */
	std::string *nullValue;	/* optional element of XSD type witsml1:encodedValueString */
	std::vector<witsml1__indexedObject *> logParam;	/* optional element of XSD type witsml1:indexedObject */
	std::vector<witsml1__cs_USCORElogCurveInfo *> logCurveInfo;	/* optional element of XSD type witsml1:cs_logCurveInfo */
	std::vector<witsml1__cs_USCORElogData *> logData;	/* optional element of XSD type witsml1:cs_logData */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCORElog_sequence (552)
	virtual int soap_type(void) const { return 552; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __witsml1__obj_USCORElog_sequence, default initialized and not managed by a soap context
	virtual __witsml1__obj_USCORElog_sequence *soap_alloc(void) const { return SOAP_NEW(__witsml1__obj_USCORElog_sequence); }
	         __witsml1__obj_USCORElog_sequence() { __witsml1__obj_USCORElog_sequence::soap_default(NULL); }
	virtual ~__witsml1__obj_USCORElog_sequence() { }
	friend __witsml1__obj_USCORElog_sequence *soap_instantiate___witsml1__obj_USCORElog_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:498 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCORElog
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCORElog (115)
/* witsml1:obj_log complex type: */
class SOAP_CMAC witsml1__obj_USCORElog
{
public:
	std::string nameWell;	/* required element of XSD type witsml1:nameString */
	std::string nameWellbore;	/* required element of XSD type witsml1:nameString */
	std::string name;	/* required element of XSD type witsml1:nameString */
	__witsml1__obj_USCORElog_sequence *__obj_USCORElog_sequence;
	witsml1__cs_USCOREcommonData *commonData;	/* optional element of XSD type witsml1:cs_commonData */
	witsml1__cs_USCOREcustomData *customData;	/* optional element of XSD type witsml1:cs_customData */
	std::string *uidWell;	/* optional attribute of XSD type witsml1:uidParentString */
	std::string *uidWellbore;	/* optional attribute of XSD type witsml1:uidParentString */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCORElog (115)
	virtual int soap_type(void) const { return 115; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCORElog, default initialized and not managed by a soap context
	virtual witsml1__obj_USCORElog *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCORElog); }
	         witsml1__obj_USCORElog() { witsml1__obj_USCORElog::soap_default(NULL); }
	virtual ~witsml1__obj_USCORElog() { }
	friend witsml1__obj_USCORElog *soap_instantiate_witsml1__obj_USCORElog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:501 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElogCurveInfo
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElogCurveInfo (116)
/* witsml1:cs_logCurveInfo complex type: */
class SOAP_CMAC witsml1__cs_USCORElogCurveInfo
{
public:
	witsml1__shortNameStruct *mnemonic;	/* required element of XSD type witsml1:shortNameStruct */
	std::string *classWitsml;	/* optional element of XSD type witsml1:descriptionString */
	short *classIndex;	/* optional element of XSD type witsml1:positiveCount */
	std::string *unit;	/* optional element of XSD type witsml1:uomString */
	witsml1__shortNameStruct *mnemAlias;	/* optional element of XSD type witsml1:shortNameStruct */
	std::string *nullValue;	/* optional element of XSD type witsml1:encodedValueString */
	bool *alternateIndex;	/* optional element of XSD type witsml1:logicalBoolean */
	witsml1__refNameString *wellDatum;	/* optional element of XSD type witsml1:refNameString */
	witsml1__genericMeasure *minIndex;	/* optional element of XSD type witsml1:genericMeasure */
	witsml1__genericMeasure *maxIndex;	/* optional element of XSD type witsml1:genericMeasure */
	time_t *minDateTimeIndex;	/* optional element of XSD type witsml1:timestamp */
	time_t *maxDateTimeIndex;	/* optional element of XSD type witsml1:timestamp */
	std::string *curveDescription;	/* optional element of XSD type witsml1:descriptionString */
	witsml1__lengthMeasure *sensorOffset;	/* optional element of XSD type witsml1:lengthMeasure */
	std::string *dataSource;	/* optional element of XSD type witsml1:str32 */
	witsml1__perLengthMeasure *densData;	/* optional element of XSD type witsml1:perLengthMeasure */
	enum witsml1__LogTraceState *traceState;	/* optional element of XSD type witsml1:LogTraceState */
	enum witsml1__LogTraceOrigin *traceOrigin;	/* optional element of XSD type witsml1:LogTraceOrigin */
	enum witsml1__LogDataType typeLogData;	/* required element of XSD type witsml1:LogDataType */
	std::vector<witsml1__cs_USCOREaxisDefinition *> axisDefinition;	/* optional element of XSD type witsml1:cs_axisDefinition */
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElogCurveInfo (116)
	virtual int soap_type(void) const { return 116; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCORElogCurveInfo, default initialized and not managed by a soap context
	virtual witsml1__cs_USCORElogCurveInfo *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCORElogCurveInfo); }
	         witsml1__cs_USCORElogCurveInfo() { witsml1__cs_USCORElogCurveInfo::soap_default(NULL); }
	virtual ~witsml1__cs_USCORElogCurveInfo() { }
	friend witsml1__cs_USCORElogCurveInfo *soap_instantiate_witsml1__cs_USCORElogCurveInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:12977 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREaxisDefinition
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREaxisDefinition (573)
/* xsd:choice complex type: */
union _witsml1__union_cs_USCOREaxisDefinition
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREaxisDefinition_doubleValues	(1)
	std::string *doubleValues;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREaxisDefinition_stringValues	(2)
	std::string *stringValues;
};
#endif

/* witsml1_4_1_1ForGsoap.h:504 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREaxisDefinition
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREaxisDefinition (117)
/* witsml1:cs_axisDefinition complex type: */
class SOAP_CMAC witsml1__cs_USCOREaxisDefinition
{
public:
	short order;	/* required element of XSD type witsml1:positiveCount */
	short count;	/* required element of XSD type witsml1:positiveCount */
	std::string *name;	/* optional element of XSD type witsml1:nameString */
	std::string *propertyType;	/* optional element of XSD type witsml1:nameString */
	std::string *uom;	/* optional element of XSD type witsml1:uomString */
	int __union_cs_USCOREaxisDefinition;	/* union discriminant (of union defined below) */
	union _witsml1__union_cs_USCOREaxisDefinition union_cs_USCOREaxisDefinition;
	std::vector<witsml1__cs_USCOREextensionNameValue *> extensionNameValue;	/* optional element of XSD type witsml1:cs_extensionNameValue */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREaxisDefinition (117)
	virtual int soap_type(void) const { return 117; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREaxisDefinition, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREaxisDefinition *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREaxisDefinition); }
	         witsml1__cs_USCOREaxisDefinition() { witsml1__cs_USCOREaxisDefinition::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREaxisDefinition() { }
	friend witsml1__cs_USCOREaxisDefinition *soap_instantiate_witsml1__cs_USCOREaxisDefinition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:507 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElogData
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElogData (118)
/* witsml1:cs_logData complex type: */
class SOAP_CMAC witsml1__cs_USCORElogData
{
public:
	std::string mnemonicList;	/* required element of XSD type xsd:string */
	std::string unitList;	/* required element of XSD type xsd:string */
	std::vector<std::string> data;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCORElogData (118)
	virtual int soap_type(void) const { return 118; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCORElogData, default initialized and not managed by a soap context
	virtual witsml1__cs_USCORElogData *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCORElogData); }
	         witsml1__cs_USCORElogData() { witsml1__cs_USCORElogData::soap_default(NULL); }
	virtual ~witsml1__cs_USCORElogData() { }
	friend witsml1__cs_USCORElogData *soap_instantiate_witsml1__cs_USCORElogData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13081 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREformationMarker_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREformationMarker_sequence (575)
/* Operation wrapper: */
class SOAP_CMAC __witsml1__obj_USCOREformationMarker_sequence
{
public:
	witsml1__measuredDepthCoord *mdPrognosed;	/* optional element of XSD type witsml1:measuredDepthCoord */
	witsml1__wellVerticalDepthCoord *tvdPrognosed;	/* optional element of XSD type witsml1:wellVerticalDepthCoord */
	witsml1__measuredDepthCoord *mdTopSample;	/* required element of XSD type witsml1:measuredDepthCoord */
	witsml1__wellVerticalDepthCoord *tvdTopSample;	/* optional element of XSD type witsml1:wellVerticalDepthCoord */
	witsml1__lengthMeasure *thicknessBed;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *thicknessApparent;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__lengthMeasure *thicknessPerpen;	/* optional element of XSD type witsml1:lengthMeasure */
	witsml1__measuredDepthCoord *mdLogSample;	/* optional element of XSD type witsml1:measuredDepthCoord */
	witsml1__wellVerticalDepthCoord *tvdLogSample;	/* optional element of XSD type witsml1:wellVerticalDepthCoord */
	witsml1__planeAngleMeasure *dip;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__planeAngleMeasure *dipDirection;	/* optional element of XSD type witsml1:planeAngleMeasure */
	witsml1__lithostratigraphyStruct *lithostratigraphic;	/* optional element of XSD type witsml1:lithostratigraphyStruct */
	witsml1__chronostratigraphyStruct *chronostratigraphic;	/* optional element of XSD type witsml1:chronostratigraphyStruct */
	std::string *nameFormation;	/* optional element of XSD type witsml1:nameString */
	std::string *description;	/* optional element of XSD type witsml1:commentString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREformationMarker_sequence (575)
	virtual int soap_type(void) const { return 575; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __witsml1__obj_USCOREformationMarker_sequence, default initialized and not managed by a soap context
	virtual __witsml1__obj_USCOREformationMarker_sequence *soap_alloc(void) const { return SOAP_NEW(__witsml1__obj_USCOREformationMarker_sequence); }
	         __witsml1__obj_USCOREformationMarker_sequence() { __witsml1__obj_USCOREformationMarker_sequence::soap_default(NULL); }
	virtual ~__witsml1__obj_USCOREformationMarker_sequence() { }
	friend __witsml1__obj_USCOREformationMarker_sequence *soap_instantiate___witsml1__obj_USCOREformationMarker_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:513 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREformationMarker
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREformationMarker (120)
/* witsml1:obj_formationMarker complex type: */
class SOAP_CMAC witsml1__obj_USCOREformationMarker
{
public:
	std::string nameWell;	/* required element of XSD type witsml1:nameString */
	std::string nameWellbore;	/* required element of XSD type witsml1:nameString */
	std::string name;	/* required element of XSD type witsml1:nameString */
	__witsml1__obj_USCOREformationMarker_sequence *__obj_USCOREformationMarker_sequence;
	witsml1__cs_USCOREcommonData *commonData;	/* optional element of XSD type witsml1:cs_commonData */
	witsml1__cs_USCOREcustomData *customData;	/* optional element of XSD type witsml1:cs_customData */
	std::string *uidWell;	/* optional attribute of XSD type witsml1:uidParentString */
	std::string *uidWellbore;	/* optional attribute of XSD type witsml1:uidParentString */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREformationMarker (120)
	virtual int soap_type(void) const { return 120; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREformationMarker, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREformationMarker *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREformationMarker); }
	         witsml1__obj_USCOREformationMarker() { witsml1__obj_USCOREformationMarker::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREformationMarker() { }
	friend witsml1__obj_USCOREformationMarker *soap_instantiate_witsml1__obj_USCOREformationMarker(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13243 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_obj_USCOREcoordinateReferenceSystem
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_obj_USCOREcoordinateReferenceSystem (583)
/* xsd:choice complex type: */
union _witsml1__union_obj_USCOREcoordinateReferenceSystem
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_obj_USCOREcoordinateReferenceSystem_geodeticCRS	(1)
	witsml1__cs_USCOREstandardGeodeticCRS *geodeticCRS;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_obj_USCOREcoordinateReferenceSystem_projectedCRS	(2)
	witsml1__cs_USCOREstandardProjectedCRS *projectedCRS;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_obj_USCOREcoordinateReferenceSystem_verticalCRS	(3)
	witsml1__cs_USCOREstandardVerticalCRS *verticalCRS;
};
#endif

/* witsml1_4_1_1ForGsoap.h:13222 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREcoordinateReferenceSystem_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREcoordinateReferenceSystem_sequence (579)
/* Operation wrapper: */
class SOAP_CMAC __witsml1__obj_USCOREcoordinateReferenceSystem_sequence
{
public:
	int __union_obj_USCOREcoordinateReferenceSystem;	/* union discriminant (of union defined below) */
	union _witsml1__union_obj_USCOREcoordinateReferenceSystem union_obj_USCOREcoordinateReferenceSystem;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___witsml1__obj_USCOREcoordinateReferenceSystem_sequence (579)
	virtual int soap_type(void) const { return 579; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __witsml1__obj_USCOREcoordinateReferenceSystem_sequence, default initialized and not managed by a soap context
	virtual __witsml1__obj_USCOREcoordinateReferenceSystem_sequence *soap_alloc(void) const { return SOAP_NEW(__witsml1__obj_USCOREcoordinateReferenceSystem_sequence); }
	         __witsml1__obj_USCOREcoordinateReferenceSystem_sequence() { __witsml1__obj_USCOREcoordinateReferenceSystem_sequence::soap_default(NULL); }
	virtual ~__witsml1__obj_USCOREcoordinateReferenceSystem_sequence() { }
	friend __witsml1__obj_USCOREcoordinateReferenceSystem_sequence *soap_instantiate___witsml1__obj_USCOREcoordinateReferenceSystem_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:519 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREcoordinateReferenceSystem
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREcoordinateReferenceSystem (122)
/* witsml1:obj_coordinateReferenceSystem complex type: */
class SOAP_CMAC witsml1__obj_USCOREcoordinateReferenceSystem
{
public:
	std::string name;	/* required element of XSD type witsml1:nameString */
	__witsml1__obj_USCOREcoordinateReferenceSystem_sequence *__obj_USCOREcoordinateReferenceSystem_sequence;
	witsml1__cs_USCOREcommonData *commonData;	/* optional element of XSD type witsml1:cs_commonData */
	witsml1__cs_USCOREcustomData *customData;	/* optional element of XSD type witsml1:cs_customData */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREcoordinateReferenceSystem (122)
	virtual int soap_type(void) const { return 122; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREcoordinateReferenceSystem, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREcoordinateReferenceSystem *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREcoordinateReferenceSystem); }
	         witsml1__obj_USCOREcoordinateReferenceSystem() { witsml1__obj_USCOREcoordinateReferenceSystem::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREcoordinateReferenceSystem() { }
	friend witsml1__obj_USCOREcoordinateReferenceSystem *soap_instantiate_witsml1__obj_USCOREcoordinateReferenceSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13305 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardGeodeticCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardGeodeticCRS (586)
/* xsd:choice complex type: */
union _witsml1__union_cs_USCOREstandardGeodeticCRS
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardGeodeticCRS_nameCRS	(1)
	witsml1__wellKnownNameStruct *nameCRS;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardGeodeticCRS_gml__GeodeticCRS	(2)
	gml__GeodeticCRSType *gml__GeodeticCRS;
};
#endif

/* witsml1_4_1_1ForGsoap.h:522 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstandardGeodeticCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstandardGeodeticCRS (123)
/* Choice: */
class SOAP_CMAC witsml1__cs_USCOREstandardGeodeticCRS
{
public:
	int __union_cs_USCOREstandardGeodeticCRS;	/* union discriminant (of union defined below) */
	union _witsml1__union_cs_USCOREstandardGeodeticCRS union_cs_USCOREstandardGeodeticCRS;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstandardGeodeticCRS (123)
	virtual int soap_type(void) const { return 123; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREstandardGeodeticCRS, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREstandardGeodeticCRS *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREstandardGeodeticCRS); }
	         witsml1__cs_USCOREstandardGeodeticCRS() { witsml1__cs_USCOREstandardGeodeticCRS::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREstandardGeodeticCRS() { }
	friend witsml1__cs_USCOREstandardGeodeticCRS *soap_instantiate_witsml1__cs_USCOREstandardGeodeticCRS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13345 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardProjectedCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardProjectedCRS (588)
/* xsd:choice complex type: */
union _witsml1__union_cs_USCOREstandardProjectedCRS
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardProjectedCRS_nameCRS	(1)
	witsml1__wellKnownNameStruct *nameCRS;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardProjectedCRS_gml__ProjectedCRS	(2)
	gml__ProjectedCRSType *gml__ProjectedCRS;
};
#endif

/* witsml1_4_1_1ForGsoap.h:525 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstandardProjectedCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstandardProjectedCRS (124)
/* Choice: */
class SOAP_CMAC witsml1__cs_USCOREstandardProjectedCRS
{
public:
	int __union_cs_USCOREstandardProjectedCRS;	/* union discriminant (of union defined below) */
	union _witsml1__union_cs_USCOREstandardProjectedCRS union_cs_USCOREstandardProjectedCRS;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstandardProjectedCRS (124)
	virtual int soap_type(void) const { return 124; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREstandardProjectedCRS, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREstandardProjectedCRS *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREstandardProjectedCRS); }
	         witsml1__cs_USCOREstandardProjectedCRS() { witsml1__cs_USCOREstandardProjectedCRS::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREstandardProjectedCRS() { }
	friend witsml1__cs_USCOREstandardProjectedCRS *soap_instantiate_witsml1__cs_USCOREstandardProjectedCRS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13385 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardVerticalCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardVerticalCRS (590)
/* xsd:choice complex type: */
union _witsml1__union_cs_USCOREstandardVerticalCRS
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardVerticalCRS_nameCRS	(1)
	witsml1__wellKnownNameStruct *nameCRS;
#define SOAP_UNION_gsoap_witsml1_4_1_1__witsml1__union_cs_USCOREstandardVerticalCRS_gml__VerticalCRS	(2)
	gml__VerticalCRSType *gml__VerticalCRS;
};
#endif

/* witsml1_4_1_1ForGsoap.h:528 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstandardVerticalCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstandardVerticalCRS (125)
/* witsml1:cs_standardVerticalCRS complex type: */
class SOAP_CMAC witsml1__cs_USCOREstandardVerticalCRS
{
public:
	int __union_cs_USCOREstandardVerticalCRS;	/* union discriminant (of union defined below) */
	union _witsml1__union_cs_USCOREstandardVerticalCRS union_cs_USCOREstandardVerticalCRS;
	witsml1__refNameString *ellipsoidalDatum;	/* optional element of XSD type witsml1:refNameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cs_USCOREstandardVerticalCRS (125)
	virtual int soap_type(void) const { return 125; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cs_USCOREstandardVerticalCRS, default initialized and not managed by a soap context
	virtual witsml1__cs_USCOREstandardVerticalCRS *soap_alloc(void) const { return SOAP_NEW(witsml1__cs_USCOREstandardVerticalCRS); }
	         witsml1__cs_USCOREstandardVerticalCRS() { witsml1__cs_USCOREstandardVerticalCRS::soap_default(NULL); }
	virtual ~witsml1__cs_USCOREstandardVerticalCRS() { }
	friend witsml1__cs_USCOREstandardVerticalCRS *soap_instantiate_witsml1__cs_USCOREstandardVerticalCRS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:531 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_abstract__abstractObject
#define SOAP_TYPE_gsoap_witsml1_4_1_1_abstract__abstractObject (126)
/* Type abstract__abstractObject is a recursive data type (in)directly referencing itself through its (base) class members */
/* abstract:abstractObject complex type: */
class SOAP_CMAC abstract__abstractObject
{
public:
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_abstract__abstractObject (126)
	virtual int soap_type(void) const { return 126; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type abstract__abstractObject, default initialized and not managed by a soap context
	virtual abstract__abstractObject *soap_alloc(void) const { return SOAP_NEW(abstract__abstractObject); }
	         abstract__abstractObject() { abstract__abstractObject::soap_default(NULL); }
	virtual ~abstract__abstractObject() { }
	friend abstract__abstractObject *soap_instantiate_abstract__abstractObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:549 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractGMLType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractGMLType (132)
/* Type gml__AbstractGMLType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractGMLType complex type: */
class SOAP_CMAC gml__AbstractGMLType
{
public:
	gml__StringOrRefType *description;	/* optional element of XSD type gml:StringOrRefType */
	gml__ReferenceType *descriptionReference;	/* optional element of XSD type gml:ReferenceType */
	gml__CodeWithAuthorityType *identifier;	/* optional element of XSD type gml:CodeWithAuthorityType */
	std::vector<gml__CodeType *> name;	/* optional element of XSD type gml:CodeType */
	std::string gml__id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractGMLType (132)
	virtual int soap_type(void) const { return 132; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractGMLType, default initialized and not managed by a soap context
	virtual gml__AbstractGMLType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGMLType); }
	         gml__AbstractGMLType() { gml__AbstractGMLType::soap_default(NULL); }
	virtual ~gml__AbstractGMLType() { }
	friend gml__AbstractGMLType *soap_instantiate_gml__AbstractGMLType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:555 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__ReferenceType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__ReferenceType (134)
/* gml:ReferenceType complex type: */
class SOAP_CMAC gml__ReferenceType
{
public:
	bool owns;	/* optional attribute of XSD type xsd:boolean */
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__ReferenceType (134)
	virtual int soap_type(void) const { return 134; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__ReferenceType, default initialized and not managed by a soap context
	virtual gml__ReferenceType *soap_alloc(void) const { return SOAP_NEW(gml__ReferenceType); }
	         gml__ReferenceType() { gml__ReferenceType::soap_default(NULL); }
	virtual ~gml__ReferenceType() { }
	friend gml__ReferenceType *soap_instantiate_gml__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13563 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_TimePrimitivePropertyType (602)
/* xsd:choice complex type: */
union _gml__union_TimePrimitivePropertyType
{
};
#endif

/* witsml1_4_1_1ForGsoap.h:13552 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__TimePrimitivePropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__TimePrimitivePropertyType_sequence (601)
/* Operation wrapper: */
class SOAP_CMAC __gml__TimePrimitivePropertyType_sequence
{
public:
	int __unionAbstractTimePrimitive;	/* union discriminant (of union defined below) */
	union _gml__union_TimePrimitivePropertyType union_TimePrimitivePropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__TimePrimitivePropertyType_sequence (601)
	virtual int soap_type(void) const { return 601; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__TimePrimitivePropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__TimePrimitivePropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__TimePrimitivePropertyType_sequence); }
	         __gml__TimePrimitivePropertyType_sequence() { __gml__TimePrimitivePropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__TimePrimitivePropertyType_sequence() { }
	friend __gml__TimePrimitivePropertyType_sequence *soap_instantiate___gml__TimePrimitivePropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:573 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__TimePrimitivePropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__TimePrimitivePropertyType (140)
/* Type gml__TimePrimitivePropertyType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:TimePrimitivePropertyType complex type: */
class SOAP_CMAC gml__TimePrimitivePropertyType
{
public:
	__gml__TimePrimitivePropertyType_sequence *__TimePrimitivePropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	bool owns;	/* optional attribute of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__TimePrimitivePropertyType (140)
	virtual int soap_type(void) const { return 140; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__TimePrimitivePropertyType, default initialized and not managed by a soap context
	virtual gml__TimePrimitivePropertyType *soap_alloc(void) const { return SOAP_NEW(gml__TimePrimitivePropertyType); }
	         gml__TimePrimitivePropertyType() { gml__TimePrimitivePropertyType::soap_default(NULL); }
	virtual ~gml__TimePrimitivePropertyType() { }
	friend gml__TimePrimitivePropertyType *soap_instantiate_gml__TimePrimitivePropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13623 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__EllipsoidalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__EllipsoidalCSPropertyType_sequence (604)
/* Operation wrapper: */
class SOAP_CMAC __gml__EllipsoidalCSPropertyType_sequence
{
public:
	gml__EllipsoidalCSType *EllipsoidalCS;	/* required element of XSD type gml:EllipsoidalCSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__EllipsoidalCSPropertyType_sequence (604)
	virtual int soap_type(void) const { return 604; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__EllipsoidalCSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__EllipsoidalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__EllipsoidalCSPropertyType_sequence); }
	         __gml__EllipsoidalCSPropertyType_sequence() { __gml__EllipsoidalCSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__EllipsoidalCSPropertyType_sequence() { }
	friend __gml__EllipsoidalCSPropertyType_sequence *soap_instantiate___gml__EllipsoidalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:576 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidalCSPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidalCSPropertyType (141)
/* gml:EllipsoidalCSPropertyType complex type: */
class SOAP_CMAC gml__EllipsoidalCSPropertyType
{
public:
	__gml__EllipsoidalCSPropertyType_sequence *__EllipsoidalCSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidalCSPropertyType (141)
	virtual int soap_type(void) const { return 141; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__EllipsoidalCSPropertyType, default initialized and not managed by a soap context
	virtual gml__EllipsoidalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidalCSPropertyType); }
	         gml__EllipsoidalCSPropertyType() { gml__EllipsoidalCSPropertyType::soap_default(NULL); }
	virtual ~gml__EllipsoidalCSPropertyType() { }
	friend gml__EllipsoidalCSPropertyType *soap_instantiate_gml__EllipsoidalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13684 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__CoordinateSystemAxisPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__CoordinateSystemAxisPropertyType_sequence (607)
/* Operation wrapper: */
class SOAP_CMAC __gml__CoordinateSystemAxisPropertyType_sequence
{
public:
	gml__CoordinateSystemAxisType *CoordinateSystemAxis;	/* required element of XSD type gml:CoordinateSystemAxisType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__CoordinateSystemAxisPropertyType_sequence (607)
	virtual int soap_type(void) const { return 607; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__CoordinateSystemAxisPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__CoordinateSystemAxisPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CoordinateSystemAxisPropertyType_sequence); }
	         __gml__CoordinateSystemAxisPropertyType_sequence() { __gml__CoordinateSystemAxisPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__CoordinateSystemAxisPropertyType_sequence() { }
	friend __gml__CoordinateSystemAxisPropertyType_sequence *soap_instantiate___gml__CoordinateSystemAxisPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:585 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CoordinateSystemAxisPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CoordinateSystemAxisPropertyType (144)
/* gml:CoordinateSystemAxisPropertyType complex type: */
class SOAP_CMAC gml__CoordinateSystemAxisPropertyType
{
public:
	__gml__CoordinateSystemAxisPropertyType_sequence *__CoordinateSystemAxisPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CoordinateSystemAxisPropertyType (144)
	virtual int soap_type(void) const { return 144; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CoordinateSystemAxisPropertyType, default initialized and not managed by a soap context
	virtual gml__CoordinateSystemAxisPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CoordinateSystemAxisPropertyType); }
	         gml__CoordinateSystemAxisPropertyType() { gml__CoordinateSystemAxisPropertyType::soap_default(NULL); }
	virtual ~gml__CoordinateSystemAxisPropertyType() { }
	friend gml__CoordinateSystemAxisPropertyType *soap_instantiate_gml__CoordinateSystemAxisPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13745 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__CartesianCSPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__CartesianCSPropertyType_sequence (610)
/* Operation wrapper: */
class SOAP_CMAC __gml__CartesianCSPropertyType_sequence
{
public:
	gml__CartesianCSType *CartesianCS;	/* required element of XSD type gml:CartesianCSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__CartesianCSPropertyType_sequence (610)
	virtual int soap_type(void) const { return 610; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__CartesianCSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__CartesianCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CartesianCSPropertyType_sequence); }
	         __gml__CartesianCSPropertyType_sequence() { __gml__CartesianCSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__CartesianCSPropertyType_sequence() { }
	friend __gml__CartesianCSPropertyType_sequence *soap_instantiate___gml__CartesianCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:591 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CartesianCSPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CartesianCSPropertyType (146)
/* gml:CartesianCSPropertyType complex type: */
class SOAP_CMAC gml__CartesianCSPropertyType
{
public:
	__gml__CartesianCSPropertyType_sequence *__CartesianCSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CartesianCSPropertyType (146)
	virtual int soap_type(void) const { return 146; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CartesianCSPropertyType, default initialized and not managed by a soap context
	virtual gml__CartesianCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CartesianCSPropertyType); }
	         gml__CartesianCSPropertyType() { gml__CartesianCSPropertyType::soap_default(NULL); }
	virtual ~gml__CartesianCSPropertyType() { }
	friend gml__CartesianCSPropertyType *soap_instantiate_gml__CartesianCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13806 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__SphericalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__SphericalCSPropertyType_sequence (613)
/* Operation wrapper: */
class SOAP_CMAC __gml__SphericalCSPropertyType_sequence
{
public:
	gml__SphericalCSType *SphericalCS;	/* required element of XSD type gml:SphericalCSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__SphericalCSPropertyType_sequence (613)
	virtual int soap_type(void) const { return 613; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__SphericalCSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__SphericalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__SphericalCSPropertyType_sequence); }
	         __gml__SphericalCSPropertyType_sequence() { __gml__SphericalCSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__SphericalCSPropertyType_sequence() { }
	friend __gml__SphericalCSPropertyType_sequence *soap_instantiate___gml__SphericalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:597 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__SphericalCSPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__SphericalCSPropertyType (148)
/* gml:SphericalCSPropertyType complex type: */
class SOAP_CMAC gml__SphericalCSPropertyType
{
public:
	__gml__SphericalCSPropertyType_sequence *__SphericalCSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__SphericalCSPropertyType (148)
	virtual int soap_type(void) const { return 148; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__SphericalCSPropertyType, default initialized and not managed by a soap context
	virtual gml__SphericalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__SphericalCSPropertyType); }
	         gml__SphericalCSPropertyType() { gml__SphericalCSPropertyType::soap_default(NULL); }
	virtual ~gml__SphericalCSPropertyType() { }
	friend gml__SphericalCSPropertyType *soap_instantiate_gml__SphericalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13867 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__GeodeticDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__GeodeticDatumPropertyType_sequence (616)
/* Operation wrapper: */
class SOAP_CMAC __gml__GeodeticDatumPropertyType_sequence
{
public:
	gml__GeodeticDatumType *GeodeticDatum;	/* required element of XSD type gml:GeodeticDatumType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__GeodeticDatumPropertyType_sequence (616)
	virtual int soap_type(void) const { return 616; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__GeodeticDatumPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__GeodeticDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeodeticDatumPropertyType_sequence); }
	         __gml__GeodeticDatumPropertyType_sequence() { __gml__GeodeticDatumPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__GeodeticDatumPropertyType_sequence() { }
	friend __gml__GeodeticDatumPropertyType_sequence *soap_instantiate___gml__GeodeticDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:603 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticDatumPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticDatumPropertyType (150)
/* gml:GeodeticDatumPropertyType complex type: */
class SOAP_CMAC gml__GeodeticDatumPropertyType
{
public:
	__gml__GeodeticDatumPropertyType_sequence *__GeodeticDatumPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticDatumPropertyType (150)
	virtual int soap_type(void) const { return 150; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeodeticDatumPropertyType, default initialized and not managed by a soap context
	virtual gml__GeodeticDatumPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticDatumPropertyType); }
	         gml__GeodeticDatumPropertyType() { gml__GeodeticDatumPropertyType::soap_default(NULL); }
	virtual ~gml__GeodeticDatumPropertyType() { }
	friend gml__GeodeticDatumPropertyType *soap_instantiate_gml__GeodeticDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13928 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__PrimeMeridianPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__PrimeMeridianPropertyType_sequence (619)
/* Operation wrapper: */
class SOAP_CMAC __gml__PrimeMeridianPropertyType_sequence
{
public:
	gml__PrimeMeridianType *PrimeMeridian;	/* required element of XSD type gml:PrimeMeridianType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__PrimeMeridianPropertyType_sequence (619)
	virtual int soap_type(void) const { return 619; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__PrimeMeridianPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__PrimeMeridianPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__PrimeMeridianPropertyType_sequence); }
	         __gml__PrimeMeridianPropertyType_sequence() { __gml__PrimeMeridianPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__PrimeMeridianPropertyType_sequence() { }
	friend __gml__PrimeMeridianPropertyType_sequence *soap_instantiate___gml__PrimeMeridianPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:612 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__PrimeMeridianPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__PrimeMeridianPropertyType (153)
/* gml:PrimeMeridianPropertyType complex type: */
class SOAP_CMAC gml__PrimeMeridianPropertyType
{
public:
	__gml__PrimeMeridianPropertyType_sequence *__PrimeMeridianPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__PrimeMeridianPropertyType (153)
	virtual int soap_type(void) const { return 153; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__PrimeMeridianPropertyType, default initialized and not managed by a soap context
	virtual gml__PrimeMeridianPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__PrimeMeridianPropertyType); }
	         gml__PrimeMeridianPropertyType() { gml__PrimeMeridianPropertyType::soap_default(NULL); }
	virtual ~gml__PrimeMeridianPropertyType() { }
	friend gml__PrimeMeridianPropertyType *soap_instantiate_gml__PrimeMeridianPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:13989 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__EllipsoidPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__EllipsoidPropertyType_sequence (622)
/* Operation wrapper: */
class SOAP_CMAC __gml__EllipsoidPropertyType_sequence
{
public:
	gml__EllipsoidType *Ellipsoid;	/* required element of XSD type gml:EllipsoidType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__EllipsoidPropertyType_sequence (622)
	virtual int soap_type(void) const { return 622; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__EllipsoidPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__EllipsoidPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__EllipsoidPropertyType_sequence); }
	         __gml__EllipsoidPropertyType_sequence() { __gml__EllipsoidPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__EllipsoidPropertyType_sequence() { }
	friend __gml__EllipsoidPropertyType_sequence *soap_instantiate___gml__EllipsoidPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:624 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidPropertyType (157)
/* gml:EllipsoidPropertyType complex type: */
class SOAP_CMAC gml__EllipsoidPropertyType
{
public:
	__gml__EllipsoidPropertyType_sequence *__EllipsoidPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidPropertyType (157)
	virtual int soap_type(void) const { return 157; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__EllipsoidPropertyType, default initialized and not managed by a soap context
	virtual gml__EllipsoidPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidPropertyType); }
	         gml__EllipsoidPropertyType() { gml__EllipsoidPropertyType::soap_default(NULL); }
	virtual ~gml__EllipsoidPropertyType() { }
	friend gml__EllipsoidPropertyType *soap_instantiate_gml__EllipsoidPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14062 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_GeneralConversionPropertyType (626)
/* xsd:choice complex type: */
union _gml__union_GeneralConversionPropertyType
{
};
#endif

/* witsml1_4_1_1ForGsoap.h:14050 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__GeneralConversionPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__GeneralConversionPropertyType_sequence (625)
/* Operation wrapper: */
class SOAP_CMAC __gml__GeneralConversionPropertyType_sequence
{
public:
	int __unionAbstractGeneralConversion;	/* union discriminant (of union defined below) */
	union _gml__union_GeneralConversionPropertyType union_GeneralConversionPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__GeneralConversionPropertyType_sequence (625)
	virtual int soap_type(void) const { return 625; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__GeneralConversionPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__GeneralConversionPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeneralConversionPropertyType_sequence); }
	         __gml__GeneralConversionPropertyType_sequence() { __gml__GeneralConversionPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__GeneralConversionPropertyType_sequence() { }
	friend __gml__GeneralConversionPropertyType_sequence *soap_instantiate___gml__GeneralConversionPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:639 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeneralConversionPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeneralConversionPropertyType (162)
/* gml:GeneralConversionPropertyType complex type: */
class SOAP_CMAC gml__GeneralConversionPropertyType
{
public:
	__gml__GeneralConversionPropertyType_sequence *__GeneralConversionPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeneralConversionPropertyType (162)
	virtual int soap_type(void) const { return 162; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeneralConversionPropertyType, default initialized and not managed by a soap context
	virtual gml__GeneralConversionPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeneralConversionPropertyType); }
	         gml__GeneralConversionPropertyType() { gml__GeneralConversionPropertyType::soap_default(NULL); }
	virtual ~gml__GeneralConversionPropertyType() { }
	friend gml__GeneralConversionPropertyType *soap_instantiate_gml__GeneralConversionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14129 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_CRSPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_CRSPropertyType (629)
/* xsd:choice complex type: */
union _gml__union_CRSPropertyType
{
};
#endif

/* witsml1_4_1_1ForGsoap.h:14118 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__CRSPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__CRSPropertyType_sequence (628)
/* Operation wrapper: */
class SOAP_CMAC __gml__CRSPropertyType_sequence
{
public:
	int __unionAbstractCRS;	/* union discriminant (of union defined below) */
	union _gml__union_CRSPropertyType union_CRSPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__CRSPropertyType_sequence (628)
	virtual int soap_type(void) const { return 628; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__CRSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__CRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__CRSPropertyType_sequence); }
	         __gml__CRSPropertyType_sequence() { __gml__CRSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__CRSPropertyType_sequence() { }
	friend __gml__CRSPropertyType_sequence *soap_instantiate___gml__CRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:648 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CRSPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CRSPropertyType (165)
/* gml:CRSPropertyType complex type: */
class SOAP_CMAC gml__CRSPropertyType
{
public:
	__gml__CRSPropertyType_sequence *__CRSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CRSPropertyType (165)
	virtual int soap_type(void) const { return 165; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CRSPropertyType, default initialized and not managed by a soap context
	virtual gml__CRSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__CRSPropertyType); }
	         gml__CRSPropertyType() { gml__CRSPropertyType::soap_default(NULL); }
	virtual ~gml__CRSPropertyType() { }
	friend gml__CRSPropertyType *soap_instantiate_gml__CRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14185 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__GeodeticCRSPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__GeodeticCRSPropertyType_sequence (631)
/* Operation wrapper: */
class SOAP_CMAC __gml__GeodeticCRSPropertyType_sequence
{
public:
	gml__GeodeticCRSType *GeodeticCRS;	/* required element of XSD type gml:GeodeticCRSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__GeodeticCRSPropertyType_sequence (631)
	virtual int soap_type(void) const { return 631; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__GeodeticCRSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__GeodeticCRSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__GeodeticCRSPropertyType_sequence); }
	         __gml__GeodeticCRSPropertyType_sequence() { __gml__GeodeticCRSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__GeodeticCRSPropertyType_sequence() { }
	friend __gml__GeodeticCRSPropertyType_sequence *soap_instantiate___gml__GeodeticCRSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:651 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticCRSPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticCRSPropertyType (166)
/* gml:GeodeticCRSPropertyType complex type: */
class SOAP_CMAC gml__GeodeticCRSPropertyType
{
public:
	__gml__GeodeticCRSPropertyType_sequence *__GeodeticCRSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticCRSPropertyType (166)
	virtual int soap_type(void) const { return 166; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeodeticCRSPropertyType, default initialized and not managed by a soap context
	virtual gml__GeodeticCRSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticCRSPropertyType); }
	         gml__GeodeticCRSPropertyType() { gml__GeodeticCRSPropertyType::soap_default(NULL); }
	virtual ~gml__GeodeticCRSPropertyType() { }
	friend gml__GeodeticCRSPropertyType *soap_instantiate_gml__GeodeticCRSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14243 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__VerticalCSPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__VerticalCSPropertyType_sequence (633)
/* Operation wrapper: */
class SOAP_CMAC __gml__VerticalCSPropertyType_sequence
{
public:
	gml__VerticalCSType *VerticalCS;	/* required element of XSD type gml:VerticalCSType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__VerticalCSPropertyType_sequence (633)
	virtual int soap_type(void) const { return 633; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__VerticalCSPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__VerticalCSPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__VerticalCSPropertyType_sequence); }
	         __gml__VerticalCSPropertyType_sequence() { __gml__VerticalCSPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__VerticalCSPropertyType_sequence() { }
	friend __gml__VerticalCSPropertyType_sequence *soap_instantiate___gml__VerticalCSPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:657 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalCSPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalCSPropertyType (168)
/* gml:VerticalCSPropertyType complex type: */
class SOAP_CMAC gml__VerticalCSPropertyType
{
public:
	__gml__VerticalCSPropertyType_sequence *__VerticalCSPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalCSPropertyType (168)
	virtual int soap_type(void) const { return 168; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalCSPropertyType, default initialized and not managed by a soap context
	virtual gml__VerticalCSPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCSPropertyType); }
	         gml__VerticalCSPropertyType() { gml__VerticalCSPropertyType::soap_default(NULL); }
	virtual ~gml__VerticalCSPropertyType() { }
	friend gml__VerticalCSPropertyType *soap_instantiate_gml__VerticalCSPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14304 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__VerticalDatumPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__VerticalDatumPropertyType_sequence (636)
/* Operation wrapper: */
class SOAP_CMAC __gml__VerticalDatumPropertyType_sequence
{
public:
	gml__VerticalDatumType *VerticalDatum;	/* required element of XSD type gml:VerticalDatumType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__VerticalDatumPropertyType_sequence (636)
	virtual int soap_type(void) const { return 636; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__VerticalDatumPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gml__VerticalDatumPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__VerticalDatumPropertyType_sequence); }
	         __gml__VerticalDatumPropertyType_sequence() { __gml__VerticalDatumPropertyType_sequence::soap_default(NULL); }
	virtual ~__gml__VerticalDatumPropertyType_sequence() { }
	friend __gml__VerticalDatumPropertyType_sequence *soap_instantiate___gml__VerticalDatumPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:663 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalDatumPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalDatumPropertyType (170)
/* gml:VerticalDatumPropertyType complex type: */
class SOAP_CMAC gml__VerticalDatumPropertyType
{
public:
	__gml__VerticalDatumPropertyType_sequence *__VerticalDatumPropertyType_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalDatumPropertyType (170)
	virtual int soap_type(void) const { return 170; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalDatumPropertyType, default initialized and not managed by a soap context
	virtual gml__VerticalDatumPropertyType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalDatumPropertyType); }
	         gml__VerticalDatumPropertyType() { gml__VerticalDatumPropertyType::soap_default(NULL); }
	virtual ~gml__VerticalDatumPropertyType() { }
	friend gml__VerticalDatumPropertyType *soap_instantiate_gml__VerticalDatumPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14366 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__domainOfValidity_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__domainOfValidity_sequence (639)
/* Operation wrapper: */
class SOAP_CMAC __gml__domainOfValidity_sequence
{
public:
	gmd__EX_USCOREExtent_USCOREType *gmd__EX_USCOREExtent;	/* required element of XSD type gmd:EX_Extent_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__domainOfValidity_sequence (639)
	virtual int soap_type(void) const { return 639; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__domainOfValidity_sequence, default initialized and not managed by a soap context
	virtual __gml__domainOfValidity_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__domainOfValidity_sequence); }
	         __gml__domainOfValidity_sequence() { __gml__domainOfValidity_sequence::soap_default(NULL); }
	virtual ~__gml__domainOfValidity_sequence() { }
	friend __gml__domainOfValidity_sequence *soap_instantiate___gml__domainOfValidity_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:669 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__domainOfValidity
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__domainOfValidity (172)
/* gml:domainOfValidity complex type: */
class SOAP_CMAC _gml__domainOfValidity
{
public:
	__gml__domainOfValidity_sequence *__domainOfValidity_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1__gml__domainOfValidity (172)
	virtual int soap_type(void) const { return 172; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _gml__domainOfValidity, default initialized and not managed by a soap context
	virtual _gml__domainOfValidity *soap_alloc(void) const { return SOAP_NEW(_gml__domainOfValidity); }
	         _gml__domainOfValidity() { _gml__domainOfValidity::soap_default(NULL); }
	virtual ~_gml__domainOfValidity() { }
	friend _gml__domainOfValidity *soap_instantiate__gml__domainOfValidity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:672 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__secondDefiningParameter
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__secondDefiningParameter (173)
/* gml:secondDefiningParameter complex type: */
class SOAP_CMAC _gml__secondDefiningParameter
{
public:
	_gml__SecondDefiningParameter *SecondDefiningParameter;	/* required element of XSD type gml:SecondDefiningParameter */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1__gml__secondDefiningParameter (173)
	virtual int soap_type(void) const { return 173; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _gml__secondDefiningParameter, default initialized and not managed by a soap context
	virtual _gml__secondDefiningParameter *soap_alloc(void) const { return SOAP_NEW(_gml__secondDefiningParameter); }
	         _gml__secondDefiningParameter() { _gml__secondDefiningParameter::soap_default(NULL); }
	virtual ~_gml__secondDefiningParameter() { }
	friend _gml__secondDefiningParameter *soap_instantiate__gml__secondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14458 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_SecondDefiningParameter
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_SecondDefiningParameter (645)
/* xsd:choice complex type: */
union _gml__union_SecondDefiningParameter
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__gml__union_SecondDefiningParameter_inverseFlattening	(1)
	gml__MeasureType *inverseFlattening;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gml__union_SecondDefiningParameter_semiMinorAxis	(2)
	gml__LengthType *semiMinorAxis;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gml__union_SecondDefiningParameter_isSphere	(3)
	bool isSphere;
};
#endif

/* witsml1_4_1_1ForGsoap.h:675 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__SecondDefiningParameter
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__SecondDefiningParameter (174)
/* Choice: */
class SOAP_CMAC _gml__SecondDefiningParameter
{
public:
	int __union_SecondDefiningParameter;	/* union discriminant (of union defined below) */
	union _gml__union_SecondDefiningParameter union_SecondDefiningParameter;
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1__gml__SecondDefiningParameter (174)
	virtual int soap_type(void) const { return 174; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _gml__SecondDefiningParameter, default initialized and not managed by a soap context
	virtual _gml__SecondDefiningParameter *soap_alloc(void) const { return SOAP_NEW(_gml__SecondDefiningParameter); }
	         _gml__SecondDefiningParameter() { _gml__SecondDefiningParameter::soap_default(NULL); }
	virtual ~_gml__SecondDefiningParameter() { }
	friend _gml__SecondDefiningParameter *soap_instantiate__gml__SecondDefiningParameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14491 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_coordinateOperationAccuracy (647)
/* xsd:choice complex type: */
union _gml__union_coordinateOperationAccuracy
{
};
#endif

/* witsml1_4_1_1ForGsoap.h:14483 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gml__coordinateOperationAccuracy_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gml__coordinateOperationAccuracy_sequence (646)
/* Operation wrapper: */
class SOAP_CMAC __gml__coordinateOperationAccuracy_sequence
{
public:
	int __unionAbstractDQ_USCOREPositionalAccuracy;	/* union discriminant (of union defined below) */
	union _gml__union_coordinateOperationAccuracy union_coordinateOperationAccuracy;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gml__coordinateOperationAccuracy_sequence (646)
	virtual int soap_type(void) const { return 646; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gml__coordinateOperationAccuracy_sequence, default initialized and not managed by a soap context
	virtual __gml__coordinateOperationAccuracy_sequence *soap_alloc(void) const { return SOAP_NEW(__gml__coordinateOperationAccuracy_sequence); }
	         __gml__coordinateOperationAccuracy_sequence() { __gml__coordinateOperationAccuracy_sequence::soap_default(NULL); }
	virtual ~__gml__coordinateOperationAccuracy_sequence() { }
	friend __gml__coordinateOperationAccuracy_sequence *soap_instantiate___gml__coordinateOperationAccuracy_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:678 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__coordinateOperationAccuracy
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__coordinateOperationAccuracy (175)
/* gml:coordinateOperationAccuracy complex type: */
class SOAP_CMAC _gml__coordinateOperationAccuracy
{
public:
	__gml__coordinateOperationAccuracy_sequence *__coordinateOperationAccuracy_sequence;
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1__gml__coordinateOperationAccuracy (175)
	virtual int soap_type(void) const { return 175; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type _gml__coordinateOperationAccuracy, default initialized and not managed by a soap context
	virtual _gml__coordinateOperationAccuracy *soap_alloc(void) const { return SOAP_NEW(_gml__coordinateOperationAccuracy); }
	         _gml__coordinateOperationAccuracy() { _gml__coordinateOperationAccuracy::soap_default(NULL); }
	virtual ~_gml__coordinateOperationAccuracy() { }
	friend _gml__coordinateOperationAccuracy *soap_instantiate__gml__coordinateOperationAccuracy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14568 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType (650)
/* xsd:choice complex type: */
union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType
{
};
#endif

/* witsml1_4_1_1ForGsoap.h:14560 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence (649)
/* Operation wrapper: */
class SOAP_CMAC __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence
{
public:
	int __unionAbstractEX_USCOREGeographicExtent;	/* union discriminant (of union defined below) */
	union _gmd__union_EX_USCOREGeographicExtent_USCOREPropertyType union_EX_USCOREGeographicExtent_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence (649)
	virtual int soap_type(void) const { return 649; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence); }
	         __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence() { __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence() { }
	friend __gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *soap_instantiate___gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:684 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType (177)
/* gmd:EX_GeographicExtent_PropertyType complex type: */
class SOAP_CMAC gmd__EX_USCOREGeographicExtent_USCOREPropertyType
{
public:
	__gmd__EX_USCOREGeographicExtent_USCOREPropertyType_sequence *__EX_USCOREGeographicExtent_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREGeographicExtent_USCOREPropertyType (177)
	virtual int soap_type(void) const { return 177; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCOREGeographicExtent_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__EX_USCOREGeographicExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREGeographicExtent_USCOREPropertyType); }
	         gmd__EX_USCOREGeographicExtent_USCOREPropertyType() { gmd__EX_USCOREGeographicExtent_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__EX_USCOREGeographicExtent_USCOREPropertyType() { }
	friend gmd__EX_USCOREGeographicExtent_USCOREPropertyType *soap_instantiate_gmd__EX_USCOREGeographicExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14623 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence (652)
/* Operation wrapper: */
class SOAP_CMAC __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence
{
public:
	gmd__EX_USCORETemporalExtent_USCOREType *EX_USCORETemporalExtent;	/* required element of XSD type gmd:EX_TemporalExtent_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence (652)
	virtual int soap_type(void) const { return 652; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence); }
	         __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence() { __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence() { }
	friend __gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *soap_instantiate___gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:690 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType (179)
/* gmd:EX_TemporalExtent_PropertyType complex type: */
class SOAP_CMAC gmd__EX_USCORETemporalExtent_USCOREPropertyType
{
public:
	__gmd__EX_USCORETemporalExtent_USCOREPropertyType_sequence *__EX_USCORETemporalExtent_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCORETemporalExtent_USCOREPropertyType (179)
	virtual int soap_type(void) const { return 179; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCORETemporalExtent_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__EX_USCORETemporalExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCORETemporalExtent_USCOREPropertyType); }
	         gmd__EX_USCORETemporalExtent_USCOREPropertyType() { gmd__EX_USCORETemporalExtent_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__EX_USCORETemporalExtent_USCOREPropertyType() { }
	friend gmd__EX_USCORETemporalExtent_USCOREPropertyType *soap_instantiate_gmd__EX_USCORETemporalExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14680 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence (655)
/* Operation wrapper: */
class SOAP_CMAC __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence
{
public:
	gmd__EX_USCOREVerticalExtent_USCOREType *EX_USCOREVerticalExtent;	/* required element of XSD type gmd:EX_VerticalExtent_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence (655)
	virtual int soap_type(void) const { return 655; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence); }
	         __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence() { __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence() { }
	friend __gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *soap_instantiate___gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:696 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType (181)
/* gmd:EX_VerticalExtent_PropertyType complex type: */
class SOAP_CMAC gmd__EX_USCOREVerticalExtent_USCOREPropertyType
{
public:
	__gmd__EX_USCOREVerticalExtent_USCOREPropertyType_sequence *__EX_USCOREVerticalExtent_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREVerticalExtent_USCOREPropertyType (181)
	virtual int soap_type(void) const { return 181; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCOREVerticalExtent_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__EX_USCOREVerticalExtent_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREVerticalExtent_USCOREPropertyType); }
	         gmd__EX_USCOREVerticalExtent_USCOREPropertyType() { gmd__EX_USCOREVerticalExtent_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__EX_USCOREVerticalExtent_USCOREPropertyType() { }
	friend gmd__EX_USCOREVerticalExtent_USCOREPropertyType *soap_instantiate_gmd__EX_USCOREVerticalExtent_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14737 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence (658)
/* Operation wrapper: */
class SOAP_CMAC __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence
{
public:
	gmd__MD_USCOREIdentifier_USCOREType *MD_USCOREIdentifier;	/* required element of XSD type gmd:MD_Identifier_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence (658)
	virtual int soap_type(void) const { return 658; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence); }
	         __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence() { __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence() { }
	friend __gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *soap_instantiate___gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:708 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__MD_USCOREIdentifier_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__MD_USCOREIdentifier_USCOREPropertyType (185)
/* Type gmd__MD_USCOREIdentifier_USCOREPropertyType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:MD_Identifier_PropertyType complex type: */
class SOAP_CMAC gmd__MD_USCOREIdentifier_USCOREPropertyType
{
public:
	__gmd__MD_USCOREIdentifier_USCOREPropertyType_sequence *__MD_USCOREIdentifier_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__MD_USCOREIdentifier_USCOREPropertyType (185)
	virtual int soap_type(void) const { return 185; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__MD_USCOREIdentifier_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__MD_USCOREIdentifier_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__MD_USCOREIdentifier_USCOREPropertyType); }
	         gmd__MD_USCOREIdentifier_USCOREPropertyType() { gmd__MD_USCOREIdentifier_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__MD_USCOREIdentifier_USCOREPropertyType() { }
	friend gmd__MD_USCOREIdentifier_USCOREPropertyType *soap_instantiate_gmd__MD_USCOREIdentifier_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14794 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence (661)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCORECitation_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCORECitation_USCOREType *CI_USCORECitation;	/* required element of XSD type gmd:CI_Citation_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORECitation_USCOREPropertyType_sequence (661)
	virtual int soap_type(void) const { return 661; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCORECitation_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCORECitation_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORECitation_USCOREPropertyType_sequence); }
	         __gmd__CI_USCORECitation_USCOREPropertyType_sequence() { __gmd__CI_USCORECitation_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCORECitation_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCORECitation_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCORECitation_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:714 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORECitation_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORECitation_USCOREPropertyType (187)
/* gmd:CI_Citation_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCORECitation_USCOREPropertyType
{
public:
	__gmd__CI_USCORECitation_USCOREPropertyType_sequence *__CI_USCORECitation_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORECitation_USCOREPropertyType (187)
	virtual int soap_type(void) const { return 187; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORECitation_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORECitation_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORECitation_USCOREPropertyType); }
	         gmd__CI_USCORECitation_USCOREPropertyType() { gmd__CI_USCORECitation_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCORECitation_USCOREPropertyType() { }
	friend gmd__CI_USCORECitation_USCOREPropertyType *soap_instantiate_gmd__CI_USCORECitation_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14851 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence (664)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREDate_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREDate_USCOREType *CI_USCOREDate;	/* required element of XSD type gmd:CI_Date_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREDate_USCOREPropertyType_sequence (664)
	virtual int soap_type(void) const { return 664; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREDate_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREDate_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREDate_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREDate_USCOREPropertyType_sequence() { __gmd__CI_USCOREDate_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREDate_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREDate_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREDate_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:720 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREDate_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREDate_USCOREPropertyType (189)
/* gmd:CI_Date_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREDate_USCOREPropertyType
{
public:
	__gmd__CI_USCOREDate_USCOREPropertyType_sequence *__CI_USCOREDate_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREDate_USCOREPropertyType (189)
	virtual int soap_type(void) const { return 189; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREDate_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREDate_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDate_USCOREPropertyType); }
	         gmd__CI_USCOREDate_USCOREPropertyType() { gmd__CI_USCOREDate_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREDate_USCOREPropertyType() { }
	friend gmd__CI_USCOREDate_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREDate_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14908 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence (667)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *CI_USCOREDateTypeCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence (667)
	virtual int soap_type(void) const { return 667; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence() { __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:726 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType (191)
/* gmd:CI_DateTypeCode_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREDateTypeCode_USCOREPropertyType
{
public:
	__gmd__CI_USCOREDateTypeCode_USCOREPropertyType_sequence *__CI_USCOREDateTypeCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREDateTypeCode_USCOREPropertyType (191)
	virtual int soap_type(void) const { return 191; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREDateTypeCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREDateTypeCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDateTypeCode_USCOREPropertyType); }
	         gmd__CI_USCOREDateTypeCode_USCOREPropertyType() { gmd__CI_USCOREDateTypeCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREDateTypeCode_USCOREPropertyType() { }
	friend gmd__CI_USCOREDateTypeCode_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREDateTypeCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14935 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence (670)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREResponsibleParty_USCOREType *CI_USCOREResponsibleParty;	/* required element of XSD type gmd:CI_ResponsibleParty_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence (670)
	virtual int soap_type(void) const { return 670; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence() { __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:729 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType (192)
/* gmd:CI_ResponsibleParty_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREResponsibleParty_USCOREPropertyType
{
public:
	__gmd__CI_USCOREResponsibleParty_USCOREPropertyType_sequence *__CI_USCOREResponsibleParty_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREResponsibleParty_USCOREPropertyType (192)
	virtual int soap_type(void) const { return 192; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREResponsibleParty_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREResponsibleParty_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREResponsibleParty_USCOREPropertyType); }
	         gmd__CI_USCOREResponsibleParty_USCOREPropertyType() { gmd__CI_USCOREResponsibleParty_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREResponsibleParty_USCOREPropertyType() { }
	friend gmd__CI_USCOREResponsibleParty_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREResponsibleParty_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:14992 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence (673)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREContact_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREContact_USCOREType *CI_USCOREContact;	/* required element of XSD type gmd:CI_Contact_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREContact_USCOREPropertyType_sequence (673)
	virtual int soap_type(void) const { return 673; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREContact_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREContact_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREContact_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREContact_USCOREPropertyType_sequence() { __gmd__CI_USCOREContact_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREContact_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREContact_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREContact_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:735 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREContact_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREContact_USCOREPropertyType (194)
/* gmd:CI_Contact_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREContact_USCOREPropertyType
{
public:
	__gmd__CI_USCOREContact_USCOREPropertyType_sequence *__CI_USCOREContact_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREContact_USCOREPropertyType (194)
	virtual int soap_type(void) const { return 194; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREContact_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREContact_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREContact_USCOREPropertyType); }
	         gmd__CI_USCOREContact_USCOREPropertyType() { gmd__CI_USCOREContact_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREContact_USCOREPropertyType() { }
	friend gmd__CI_USCOREContact_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREContact_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15049 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence (676)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCORETelephone_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCORETelephone_USCOREType *CI_USCORETelephone;	/* required element of XSD type gmd:CI_Telephone_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORETelephone_USCOREPropertyType_sequence (676)
	virtual int soap_type(void) const { return 676; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCORETelephone_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCORETelephone_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORETelephone_USCOREPropertyType_sequence); }
	         __gmd__CI_USCORETelephone_USCOREPropertyType_sequence() { __gmd__CI_USCORETelephone_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCORETelephone_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCORETelephone_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCORETelephone_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:741 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORETelephone_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORETelephone_USCOREPropertyType (196)
/* gmd:CI_Telephone_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCORETelephone_USCOREPropertyType
{
public:
	__gmd__CI_USCORETelephone_USCOREPropertyType_sequence *__CI_USCORETelephone_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORETelephone_USCOREPropertyType (196)
	virtual int soap_type(void) const { return 196; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORETelephone_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORETelephone_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORETelephone_USCOREPropertyType); }
	         gmd__CI_USCORETelephone_USCOREPropertyType() { gmd__CI_USCORETelephone_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCORETelephone_USCOREPropertyType() { }
	friend gmd__CI_USCORETelephone_USCOREPropertyType *soap_instantiate_gmd__CI_USCORETelephone_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15106 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence (679)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREAddress_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREAddress_USCOREType *CI_USCOREAddress;	/* required element of XSD type gmd:CI_Address_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREAddress_USCOREPropertyType_sequence (679)
	virtual int soap_type(void) const { return 679; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREAddress_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREAddress_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREAddress_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREAddress_USCOREPropertyType_sequence() { __gmd__CI_USCOREAddress_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREAddress_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREAddress_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREAddress_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:747 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREAddress_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREAddress_USCOREPropertyType (198)
/* gmd:CI_Address_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREAddress_USCOREPropertyType
{
public:
	__gmd__CI_USCOREAddress_USCOREPropertyType_sequence *__CI_USCOREAddress_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREAddress_USCOREPropertyType (198)
	virtual int soap_type(void) const { return 198; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREAddress_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREAddress_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREAddress_USCOREPropertyType); }
	         gmd__CI_USCOREAddress_USCOREPropertyType() { gmd__CI_USCOREAddress_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREAddress_USCOREPropertyType() { }
	friend gmd__CI_USCOREAddress_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREAddress_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15163 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence (682)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCOREOnlineResource_USCOREType *CI_USCOREOnlineResource;	/* required element of XSD type gmd:CI_OnlineResource_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence (682)
	virtual int soap_type(void) const { return 682; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence() { __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:753 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType (200)
/* gmd:CI_OnlineResource_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREOnlineResource_USCOREPropertyType
{
public:
	__gmd__CI_USCOREOnlineResource_USCOREPropertyType_sequence *__CI_USCOREOnlineResource_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREOnlineResource_USCOREPropertyType (200)
	virtual int soap_type(void) const { return 200; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREOnlineResource_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREOnlineResource_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnlineResource_USCOREPropertyType); }
	         gmd__CI_USCOREOnlineResource_USCOREPropertyType() { gmd__CI_USCOREOnlineResource_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREOnlineResource_USCOREPropertyType() { }
	friend gmd__CI_USCOREOnlineResource_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREOnlineResource_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15220 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__URL_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__URL_USCOREPropertyType_sequence (685)
/* Operation wrapper: */
class SOAP_CMAC __gmd__URL_USCOREPropertyType_sequence
{
public:
	std::string URL;	/* required element of XSD type xsd:anyURI */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__URL_USCOREPropertyType_sequence (685)
	virtual int soap_type(void) const { return 685; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__URL_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__URL_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__URL_USCOREPropertyType_sequence); }
	         __gmd__URL_USCOREPropertyType_sequence() { __gmd__URL_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__URL_USCOREPropertyType_sequence() { }
	friend __gmd__URL_USCOREPropertyType_sequence *soap_instantiate___gmd__URL_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:759 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__URL_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__URL_USCOREPropertyType (202)
/* gmd:URL_PropertyType complex type: */
class SOAP_CMAC gmd__URL_USCOREPropertyType
{
public:
	__gmd__URL_USCOREPropertyType_sequence *__URL_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__URL_USCOREPropertyType (202)
	virtual int soap_type(void) const { return 202; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__URL_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__URL_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__URL_USCOREPropertyType); }
	         gmd__URL_USCOREPropertyType() { gmd__URL_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__URL_USCOREPropertyType() { }
	friend gmd__URL_USCOREPropertyType *soap_instantiate_gmd__URL_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15247 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence (687)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *CI_USCOREOnLineFunctionCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence (687)
	virtual int soap_type(void) const { return 687; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence() { __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:762 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (203)
/* gmd:CI_OnLineFunctionCode_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType
{
public:
	__gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence *__CI_USCOREOnLineFunctionCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType (203)
	virtual int soap_type(void) const { return 203; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType); }
	         gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType() { gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType() { }
	friend gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15274 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence (689)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *CI_USCORERoleCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence (689)
	virtual int soap_type(void) const { return 689; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence); }
	         __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence() { __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCORERoleCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:765 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORERoleCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORERoleCode_USCOREPropertyType (204)
/* gmd:CI_RoleCode_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCORERoleCode_USCOREPropertyType
{
public:
	__gmd__CI_USCORERoleCode_USCOREPropertyType_sequence *__CI_USCORERoleCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORERoleCode_USCOREPropertyType (204)
	virtual int soap_type(void) const { return 204; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORERoleCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORERoleCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORERoleCode_USCOREPropertyType); }
	         gmd__CI_USCORERoleCode_USCOREPropertyType() { gmd__CI_USCORERoleCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCORERoleCode_USCOREPropertyType() { }
	friend gmd__CI_USCORERoleCode_USCOREPropertyType *soap_instantiate_gmd__CI_USCORERoleCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15301 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence (691)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *CI_USCOREPresentationFormCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence (691)
	virtual int soap_type(void) const { return 691; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence); }
	         __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence() { __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:768 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType (205)
/* gmd:CI_PresentationFormCode_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCOREPresentationFormCode_USCOREPropertyType
{
public:
	__gmd__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence *__CI_USCOREPresentationFormCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType (205)
	virtual int soap_type(void) const { return 205; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREPresentationFormCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREPresentationFormCode_USCOREPropertyType); }
	         gmd__CI_USCOREPresentationFormCode_USCOREPropertyType() { gmd__CI_USCOREPresentationFormCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREPresentationFormCode_USCOREPropertyType() { }
	friend gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *soap_instantiate_gmd__CI_USCOREPresentationFormCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15328 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence (693)
/* Operation wrapper: */
class SOAP_CMAC __gmd__CI_USCORESeries_USCOREPropertyType_sequence
{
public:
	gmd__CI_USCORESeries_USCOREType *CI_USCORESeries;	/* required element of XSD type gmd:CI_Series_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__CI_USCORESeries_USCOREPropertyType_sequence (693)
	virtual int soap_type(void) const { return 693; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__CI_USCORESeries_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__CI_USCORESeries_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__CI_USCORESeries_USCOREPropertyType_sequence); }
	         __gmd__CI_USCORESeries_USCOREPropertyType_sequence() { __gmd__CI_USCORESeries_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__CI_USCORESeries_USCOREPropertyType_sequence() { }
	friend __gmd__CI_USCORESeries_USCOREPropertyType_sequence *soap_instantiate___gmd__CI_USCORESeries_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:771 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORESeries_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORESeries_USCOREPropertyType (206)
/* gmd:CI_Series_PropertyType complex type: */
class SOAP_CMAC gmd__CI_USCORESeries_USCOREPropertyType
{
public:
	__gmd__CI_USCORESeries_USCOREPropertyType_sequence *__CI_USCORESeries_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORESeries_USCOREPropertyType (206)
	virtual int soap_type(void) const { return 206; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORESeries_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORESeries_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORESeries_USCOREPropertyType); }
	         gmd__CI_USCORESeries_USCOREPropertyType() { gmd__CI_USCORESeries_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__CI_USCORESeries_USCOREPropertyType() { }
	friend gmd__CI_USCORESeries_USCOREPropertyType *soap_instantiate_gmd__CI_USCORESeries_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15385 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence (696)
/* Operation wrapper: */
class SOAP_CMAC __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence
{
public:
	gco__CodeListValue_USCOREType *DQ_USCOREEvaluationMethodTypeCode;	/* required element of XSD type gco:CodeListValue_Type */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence (696)
	virtual int soap_type(void) const { return 696; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence); }
	         __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence() { __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence() { }
	friend __gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *soap_instantiate___gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:777 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (208)
/* gmd:DQ_EvaluationMethodTypeCode_PropertyType complex type: */
class SOAP_CMAC gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType
{
public:
	__gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence *__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType (208)
	virtual int soap_type(void) const { return 208; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType); }
	         gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType() { gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType() { }
	friend gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *soap_instantiate_gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15420 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__union_DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__union_DQ_USCOREResult_USCOREPropertyType (699)
/* xsd:choice complex type: */
union _gmd__union_DQ_USCOREResult_USCOREPropertyType
{
};
#endif

/* witsml1_4_1_1ForGsoap.h:15412 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence (698)
/* Operation wrapper: */
class SOAP_CMAC __gmd__DQ_USCOREResult_USCOREPropertyType_sequence
{
public:
	int __unionAbstractDQ_USCOREResult;	/* union discriminant (of union defined below) */
	union _gmd__union_DQ_USCOREResult_USCOREPropertyType union_DQ_USCOREResult_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gmd__DQ_USCOREResult_USCOREPropertyType_sequence (698)
	virtual int soap_type(void) const { return 698; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gmd__DQ_USCOREResult_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gmd__DQ_USCOREResult_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gmd__DQ_USCOREResult_USCOREPropertyType_sequence); }
	         __gmd__DQ_USCOREResult_USCOREPropertyType_sequence() { __gmd__DQ_USCOREResult_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gmd__DQ_USCOREResult_USCOREPropertyType_sequence() { }
	friend __gmd__DQ_USCOREResult_USCOREPropertyType_sequence *soap_instantiate___gmd__DQ_USCOREResult_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:780 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__DQ_USCOREResult_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__DQ_USCOREResult_USCOREPropertyType (209)
/* gmd:DQ_Result_PropertyType complex type: */
class SOAP_CMAC gmd__DQ_USCOREResult_USCOREPropertyType
{
public:
	__gmd__DQ_USCOREResult_USCOREPropertyType_sequence *__DQ_USCOREResult_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__DQ_USCOREResult_USCOREPropertyType (209)
	virtual int soap_type(void) const { return 209; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__DQ_USCOREResult_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gmd__DQ_USCOREResult_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gmd__DQ_USCOREResult_USCOREPropertyType); }
	         gmd__DQ_USCOREResult_USCOREPropertyType() { gmd__DQ_USCOREResult_USCOREPropertyType::soap_default(NULL); }
	virtual ~gmd__DQ_USCOREResult_USCOREPropertyType() { }
	friend gmd__DQ_USCOREResult_USCOREPropertyType *soap_instantiate_gmd__DQ_USCOREResult_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15494 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gts__union_TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gts__union_TM_USCOREPrimitive_USCOREPropertyType (702)
/* xsd:choice complex type: */
union _gts__union_TM_USCOREPrimitive_USCOREPropertyType
{
};
#endif

/* witsml1_4_1_1ForGsoap.h:15483 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence (701)
/* Operation wrapper: */
class SOAP_CMAC __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence
{
public:
	int __unionAbstractTimePrimitive;	/* union discriminant (of union defined below) */
	union _gts__union_TM_USCOREPrimitive_USCOREPropertyType union_TM_USCOREPrimitive_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence (701)
	virtual int soap_type(void) const { return 701; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence); }
	         __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence() { __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence() { }
	friend __gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *soap_instantiate___gts__TM_USCOREPrimitive_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:786 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gts__TM_USCOREPrimitive_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gts__TM_USCOREPrimitive_USCOREPropertyType (211)
/* gts:TM_Primitive_PropertyType complex type: */
class SOAP_CMAC gts__TM_USCOREPrimitive_USCOREPropertyType
{
public:
	__gts__TM_USCOREPrimitive_USCOREPropertyType_sequence *__TM_USCOREPrimitive_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gts__TM_USCOREPrimitive_USCOREPropertyType (211)
	virtual int soap_type(void) const { return 211; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gts__TM_USCOREPrimitive_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gts__TM_USCOREPrimitive_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gts__TM_USCOREPrimitive_USCOREPropertyType); }
	         gts__TM_USCOREPrimitive_USCOREPropertyType() { gts__TM_USCOREPrimitive_USCOREPropertyType::soap_default(NULL); }
	virtual ~gts__TM_USCOREPrimitive_USCOREPropertyType() { }
	friend gts__TM_USCOREPrimitive_USCOREPropertyType *soap_instantiate_gts__TM_USCOREPrimitive_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:789 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gco__AbstractObject_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gco__AbstractObject_USCOREType (212)
/* Type gco__AbstractObject_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gco:AbstractObject_Type complex type: */
class SOAP_CMAC gco__AbstractObject_USCOREType
{
public:
	std::string *id;	/* optional attribute of XSD type xsd:ID */
	std::string *uuid;	/* optional attribute of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gco__AbstractObject_USCOREType (212)
	virtual int soap_type(void) const { return 212; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__AbstractObject_USCOREType, default initialized and not managed by a soap context
	virtual gco__AbstractObject_USCOREType *soap_alloc(void) const { return SOAP_NEW(gco__AbstractObject_USCOREType); }
	         gco__AbstractObject_USCOREType() { gco__AbstractObject_USCOREType::soap_default(NULL); }
	virtual ~gco__AbstractObject_USCOREType() { }
	friend gco__AbstractObject_USCOREType *soap_instantiate_gco__AbstractObject_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15610 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType (706)
/* xsd:choice complex type: */
union _gco__union_CharacterString_USCOREPropertyType
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_CharacterString	(1)
	std::string *CharacterString;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode	(2)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREDateTypeCode;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREDateTypeCode_	(3)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREDateTypeCode_;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode	(4)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREOnLineFunctionCode;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREOnLineFunctionCode_	(5)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREOnLineFunctionCode_;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode	(6)
	gco__CodeListValue_USCOREType *gmd__CI_USCORERoleCode;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCORERoleCode_	(7)
	gco__CodeListValue_USCOREType *gmd__CI_USCORERoleCode_;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode	(8)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREPresentationFormCode;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__CI_USCOREPresentationFormCode_	(9)
	gco__CodeListValue_USCOREType *gmd__CI_USCOREPresentationFormCode_;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode	(10)
	gco__CodeListValue_USCOREType *gmd__DQ_USCOREEvaluationMethodTypeCode;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_CharacterString_USCOREPropertyType_gmd__DQ_USCOREEvaluationMethodTypeCode_	(11)
	gco__CodeListValue_USCOREType *gmd__DQ_USCOREEvaluationMethodTypeCode_;
};
#endif

/* witsml1_4_1_1ForGsoap.h:15581 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gco__CharacterString_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gco__CharacterString_USCOREPropertyType_sequence (705)
/* Operation wrapper: */
class SOAP_CMAC __gco__CharacterString_USCOREPropertyType_sequence
{
public:
	int __unionCharacterString;	/* union discriminant (of union defined below) */
	union _gco__union_CharacterString_USCOREPropertyType union_CharacterString_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gco__CharacterString_USCOREPropertyType_sequence (705)
	virtual int soap_type(void) const { return 705; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gco__CharacterString_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gco__CharacterString_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__CharacterString_USCOREPropertyType_sequence); }
	         __gco__CharacterString_USCOREPropertyType_sequence() { __gco__CharacterString_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gco__CharacterString_USCOREPropertyType_sequence() { }
	friend __gco__CharacterString_USCOREPropertyType_sequence *soap_instantiate___gco__CharacterString_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:792 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gco__CharacterString_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gco__CharacterString_USCOREPropertyType (213)
/* gco:CharacterString_PropertyType complex type: */
class SOAP_CMAC gco__CharacterString_USCOREPropertyType
{
public:
	__gco__CharacterString_USCOREPropertyType_sequence *__CharacterString_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gco__CharacterString_USCOREPropertyType (213)
	virtual int soap_type(void) const { return 213; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__CharacterString_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__CharacterString_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__CharacterString_USCOREPropertyType); }
	         gco__CharacterString_USCOREPropertyType() { gco__CharacterString_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__CharacterString_USCOREPropertyType() { }
	friend gco__CharacterString_USCOREPropertyType *soap_instantiate_gco__CharacterString_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15635 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gco__Boolean_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gco__Boolean_USCOREPropertyType_sequence (708)
/* Operation wrapper: */
class SOAP_CMAC __gco__Boolean_USCOREPropertyType_sequence
{
public:
	bool Boolean;	/* required element of XSD type xsd:boolean */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gco__Boolean_USCOREPropertyType_sequence (708)
	virtual int soap_type(void) const { return 708; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gco__Boolean_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gco__Boolean_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__Boolean_USCOREPropertyType_sequence); }
	         __gco__Boolean_USCOREPropertyType_sequence() { __gco__Boolean_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gco__Boolean_USCOREPropertyType_sequence() { }
	friend __gco__Boolean_USCOREPropertyType_sequence *soap_instantiate___gco__Boolean_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:795 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Boolean_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Boolean_USCOREPropertyType (214)
/* gco:Boolean_PropertyType complex type: */
class SOAP_CMAC gco__Boolean_USCOREPropertyType
{
public:
	__gco__Boolean_USCOREPropertyType_sequence *__Boolean_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Boolean_USCOREPropertyType (214)
	virtual int soap_type(void) const { return 214; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__Boolean_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__Boolean_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Boolean_USCOREPropertyType); }
	         gco__Boolean_USCOREPropertyType() { gco__Boolean_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__Boolean_USCOREPropertyType() { }
	friend gco__Boolean_USCOREPropertyType *soap_instantiate_gco__Boolean_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15662 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gco__Real_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gco__Real_USCOREPropertyType_sequence (710)
/* Operation wrapper: */
class SOAP_CMAC __gco__Real_USCOREPropertyType_sequence
{
public:
	double Real;	/* required element of XSD type xsd:double */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gco__Real_USCOREPropertyType_sequence (710)
	virtual int soap_type(void) const { return 710; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gco__Real_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gco__Real_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__Real_USCOREPropertyType_sequence); }
	         __gco__Real_USCOREPropertyType_sequence() { __gco__Real_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gco__Real_USCOREPropertyType_sequence() { }
	friend __gco__Real_USCOREPropertyType_sequence *soap_instantiate___gco__Real_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:798 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Real_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Real_USCOREPropertyType (215)
/* gco:Real_PropertyType complex type: */
class SOAP_CMAC gco__Real_USCOREPropertyType
{
public:
	__gco__Real_USCOREPropertyType_sequence *__Real_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Real_USCOREPropertyType (215)
	virtual int soap_type(void) const { return 215; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__Real_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__Real_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Real_USCOREPropertyType); }
	         gco__Real_USCOREPropertyType() { gco__Real_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__Real_USCOREPropertyType() { }
	friend gco__Real_USCOREPropertyType *soap_instantiate_gco__Real_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15697 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gco__union_Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gco__union_Date_USCOREPropertyType (713)
/* xsd:choice complex type: */
union _gco__union_Date_USCOREPropertyType
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_Date_USCOREPropertyType_Date	(1)
	std::string *Date;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gco__union_Date_USCOREPropertyType_DateTime	(2)
	time_t DateTime;
};
#endif

/* witsml1_4_1_1ForGsoap.h:801 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Date_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Date_USCOREPropertyType (216)
/* gco:Date_PropertyType complex type: */
class SOAP_CMAC gco__Date_USCOREPropertyType
{
public:
	int __union_Date_USCOREPropertyType;	/* union discriminant (of union defined below) */
	union _gco__union_Date_USCOREPropertyType union_Date_USCOREPropertyType;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Date_USCOREPropertyType (216)
	virtual int soap_type(void) const { return 216; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__Date_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__Date_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__Date_USCOREPropertyType); }
	         gco__Date_USCOREPropertyType() { gco__Date_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__Date_USCOREPropertyType() { }
	friend gco__Date_USCOREPropertyType *soap_instantiate_gco__Date_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15720 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gco__DateTime_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gco__DateTime_USCOREPropertyType_sequence (714)
/* Operation wrapper: */
class SOAP_CMAC __gco__DateTime_USCOREPropertyType_sequence
{
public:
	time_t DateTime;	/* required element of XSD type xsd:dateTime */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gco__DateTime_USCOREPropertyType_sequence (714)
	virtual int soap_type(void) const { return 714; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gco__DateTime_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gco__DateTime_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gco__DateTime_USCOREPropertyType_sequence); }
	         __gco__DateTime_USCOREPropertyType_sequence() { __gco__DateTime_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gco__DateTime_USCOREPropertyType_sequence() { }
	friend __gco__DateTime_USCOREPropertyType_sequence *soap_instantiate___gco__DateTime_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:807 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gco__DateTime_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gco__DateTime_USCOREPropertyType (218)
/* gco:DateTime_PropertyType complex type: */
class SOAP_CMAC gco__DateTime_USCOREPropertyType
{
public:
	__gco__DateTime_USCOREPropertyType_sequence *__DateTime_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gco__DateTime_USCOREPropertyType (218)
	virtual int soap_type(void) const { return 218; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__DateTime_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gco__DateTime_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gco__DateTime_USCOREPropertyType); }
	         gco__DateTime_USCOREPropertyType() { gco__DateTime_USCOREPropertyType::soap_default(NULL); }
	virtual ~gco__DateTime_USCOREPropertyType() { }
	friend gco__DateTime_USCOREPropertyType *soap_instantiate_gco__DateTime_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:15766 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gsr__union_SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gsr__union_SC_USCORECRS_USCOREPropertyType (717)
/* xsd:choice complex type: */
union _gsr__union_SC_USCORECRS_USCOREPropertyType
{
};
#endif

/* witsml1_4_1_1ForGsoap.h:15755 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence (716)
/* Operation wrapper: */
class SOAP_CMAC __gsr__SC_USCORECRS_USCOREPropertyType_sequence
{
public:
	int __unionAbstractCRS;	/* union discriminant (of union defined below) */
	union _gsr__union_SC_USCORECRS_USCOREPropertyType union_SC_USCORECRS_USCOREPropertyType;
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1___gsr__SC_USCORECRS_USCOREPropertyType_sequence (716)
	virtual int soap_type(void) const { return 716; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type __gsr__SC_USCORECRS_USCOREPropertyType_sequence, default initialized and not managed by a soap context
	virtual __gsr__SC_USCORECRS_USCOREPropertyType_sequence *soap_alloc(void) const { return SOAP_NEW(__gsr__SC_USCORECRS_USCOREPropertyType_sequence); }
	         __gsr__SC_USCORECRS_USCOREPropertyType_sequence() { __gsr__SC_USCORECRS_USCOREPropertyType_sequence::soap_default(NULL); }
	virtual ~__gsr__SC_USCORECRS_USCOREPropertyType_sequence() { }
	friend __gsr__SC_USCORECRS_USCOREPropertyType_sequence *soap_instantiate___gsr__SC_USCORECRS_USCOREPropertyType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:810 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gsr__SC_USCORECRS_USCOREPropertyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gsr__SC_USCORECRS_USCOREPropertyType (219)
/* gsr:SC_CRS_PropertyType complex type: */
class SOAP_CMAC gsr__SC_USCORECRS_USCOREPropertyType
{
public:
	__gsr__SC_USCORECRS_USCOREPropertyType_sequence *__SC_USCORECRS_USCOREPropertyType_sequence;
	std::string *gco__nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *uuidref;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gsr__SC_USCORECRS_USCOREPropertyType (219)
	virtual int soap_type(void) const { return 219; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gsr__SC_USCORECRS_USCOREPropertyType, default initialized and not managed by a soap context
	virtual gsr__SC_USCORECRS_USCOREPropertyType *soap_alloc(void) const { return SOAP_NEW(gsr__SC_USCORECRS_USCOREPropertyType); }
	         gsr__SC_USCORECRS_USCOREPropertyType() { gsr__SC_USCORECRS_USCOREPropertyType::soap_default(NULL); }
	virtual ~gsr__SC_USCORECRS_USCOREPropertyType() { }
	friend gsr__SC_USCORECRS_USCOREPropertyType *soap_instantiate_gsr__SC_USCORECRS_USCOREPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:198 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwells
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwells (15)
/* Type witsml1__obj_USCOREwells is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:obj_wells complex type: */
class SOAP_CMAC witsml1__obj_USCOREwells : public abstract__abstractObject
{
public:
	witsml1__cs_USCOREdocumentInfo *documentInfo;	/* optional element of XSD type witsml1:cs_documentInfo */
	std::vector<witsml1__obj_USCOREwell *> well;	/* required element of XSD type witsml1:obj_well */
	std::string version;	/* required attribute of XSD type witsml1:schemaVersionString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwells (15)
	virtual int soap_type(void) const { return 15; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREwells, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREwells *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREwells); }
	         witsml1__obj_USCOREwells() { witsml1__obj_USCOREwells::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREwells() { }
	friend witsml1__obj_USCOREwells *soap_instantiate_witsml1__obj_USCOREwells(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:462 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwellbores
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwellbores (103)
/* Type witsml1__obj_USCOREwellbores is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:obj_wellbores complex type: */
class SOAP_CMAC witsml1__obj_USCOREwellbores : public abstract__abstractObject
{
public:
	witsml1__cs_USCOREdocumentInfo *documentInfo;	/* optional element of XSD type witsml1:cs_documentInfo */
	std::vector<witsml1__obj_USCOREwellbore *> wellbore;	/* required element of XSD type witsml1:obj_wellbore */
	std::string version;	/* required attribute of XSD type witsml1:schemaVersionString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREwellbores (103)
	virtual int soap_type(void) const { return 103; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREwellbores, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREwellbores *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREwellbores); }
	         witsml1__obj_USCOREwellbores() { witsml1__obj_USCOREwellbores::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREwellbores() { }
	friend witsml1__obj_USCOREwellbores *soap_instantiate_witsml1__obj_USCOREwellbores(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:468 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREtrajectorys
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREtrajectorys (105)
/* Type witsml1__obj_USCOREtrajectorys is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:obj_trajectorys complex type: */
class SOAP_CMAC witsml1__obj_USCOREtrajectorys : public abstract__abstractObject
{
public:
	witsml1__cs_USCOREdocumentInfo *documentInfo;	/* optional element of XSD type witsml1:cs_documentInfo */
	std::vector<witsml1__obj_USCOREtrajectory *> trajectory;	/* required element of XSD type witsml1:obj_trajectory */
	std::string version;	/* required attribute of XSD type witsml1:schemaVersionString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREtrajectorys (105)
	virtual int soap_type(void) const { return 105; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREtrajectorys, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREtrajectorys *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREtrajectorys); }
	         witsml1__obj_USCOREtrajectorys() { witsml1__obj_USCOREtrajectorys::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREtrajectorys() { }
	friend witsml1__obj_USCOREtrajectorys *soap_instantiate_witsml1__obj_USCOREtrajectorys(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:495 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCORElogs
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCORElogs (114)
/* Type witsml1__obj_USCORElogs is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:obj_logs complex type: */
class SOAP_CMAC witsml1__obj_USCORElogs : public abstract__abstractObject
{
public:
	witsml1__cs_USCOREdocumentInfo *documentInfo;	/* optional element of XSD type witsml1:cs_documentInfo */
	std::vector<witsml1__obj_USCORElog *> log;	/* required element of XSD type witsml1:obj_log */
	std::string version;	/* required attribute of XSD type witsml1:schemaVersionString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCORElogs (114)
	virtual int soap_type(void) const { return 114; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCORElogs, default initialized and not managed by a soap context
	virtual witsml1__obj_USCORElogs *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCORElogs); }
	         witsml1__obj_USCORElogs() { witsml1__obj_USCORElogs::soap_default(NULL); }
	virtual ~witsml1__obj_USCORElogs() { }
	friend witsml1__obj_USCORElogs *soap_instantiate_witsml1__obj_USCORElogs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:510 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREformationMarkers
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREformationMarkers (119)
/* Type witsml1__obj_USCOREformationMarkers is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:obj_formationMarkers complex type: */
class SOAP_CMAC witsml1__obj_USCOREformationMarkers : public abstract__abstractObject
{
public:
	witsml1__cs_USCOREdocumentInfo *documentInfo;	/* optional element of XSD type witsml1:cs_documentInfo */
	std::vector<witsml1__obj_USCOREformationMarker *> formationMarker;	/* required element of XSD type witsml1:obj_formationMarker */
	std::string version;	/* required attribute of XSD type witsml1:schemaVersionString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREformationMarkers (119)
	virtual int soap_type(void) const { return 119; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREformationMarkers, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREformationMarkers *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREformationMarkers); }
	         witsml1__obj_USCOREformationMarkers() { witsml1__obj_USCOREformationMarkers::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREformationMarkers() { }
	friend witsml1__obj_USCOREformationMarkers *soap_instantiate_witsml1__obj_USCOREformationMarkers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:516 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREcoordinateReferenceSystems
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREcoordinateReferenceSystems (121)
/* Type witsml1__obj_USCOREcoordinateReferenceSystems is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:obj_coordinateReferenceSystems complex type: */
class SOAP_CMAC witsml1__obj_USCOREcoordinateReferenceSystems : public abstract__abstractObject
{
public:
	witsml1__cs_USCOREdocumentInfo *documentInfo;	/* optional element of XSD type witsml1:cs_documentInfo */
	std::vector<witsml1__obj_USCOREcoordinateReferenceSystem *> coordinateReferenceSystem;	/* required element of XSD type witsml1:obj_coordinateReferenceSystem */
	std::string version;	/* required attribute of XSD type witsml1:schemaVersionString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__obj_USCOREcoordinateReferenceSystems (121)
	virtual int soap_type(void) const { return 121; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__obj_USCOREcoordinateReferenceSystems, default initialized and not managed by a soap context
	virtual witsml1__obj_USCOREcoordinateReferenceSystems *soap_alloc(void) const { return SOAP_NEW(witsml1__obj_USCOREcoordinateReferenceSystems); }
	         witsml1__obj_USCOREcoordinateReferenceSystems() { witsml1__obj_USCOREcoordinateReferenceSystems::soap_default(NULL); }
	virtual ~witsml1__obj_USCOREcoordinateReferenceSystems() { }
	friend witsml1__obj_USCOREcoordinateReferenceSystems *soap_instantiate_witsml1__obj_USCOREcoordinateReferenceSystems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:546 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__DefinitionBaseType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__DefinitionBaseType (131)
/* Type gml__DefinitionBaseType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:DefinitionBaseType complex type: */
class SOAP_CMAC gml__DefinitionBaseType
{
public:
	gml__StringOrRefType *description;	/* optional element of XSD type gml:StringOrRefType */
	gml__ReferenceType *descriptionReference;	/* optional element of XSD type gml:ReferenceType */
	gml__CodeWithAuthorityType *identifier;	/* required element of XSD type gml:CodeWithAuthorityType */
	std::vector<gml__CodeType *> name;	/* optional element of XSD type gml:CodeType */
	std::string gml__id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__DefinitionBaseType (131)
	virtual int soap_type(void) const { return 131; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__DefinitionBaseType, default initialized and not managed by a soap context
	virtual gml__DefinitionBaseType *soap_alloc(void) const { return SOAP_NEW(gml__DefinitionBaseType); }
	         gml__DefinitionBaseType() { gml__DefinitionBaseType::soap_default(NULL); }
	virtual ~gml__DefinitionBaseType() { }
	friend gml__DefinitionBaseType *soap_instantiate_gml__DefinitionBaseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:552 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__StringOrRefType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__StringOrRefType (133)
/* gml:StringOrRefType simple type: */
class SOAP_CMAC gml__StringOrRefType
{
public:
	std::string __item;	/* mixed XML content */
	std::string *nilReason;	/* optional attribute of XSD type gml:NilReasonType */
	std::string *xlink__type;	/* optional attribute of XSD type xsd:string */
	std::string *xlink__href;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__role;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__arcrole;	/* optional attribute of XSD type xsd:anyURI */
	std::string *xlink__title;	/* optional attribute of XSD type xsd:string */
	enum _xlink__show *xlink__show;	/* optional attribute of XSD type xlink:show */
	enum _xlink__actuate *xlink__actuate;	/* optional attribute of XSD type xlink:actuate */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__StringOrRefType (133)
	virtual int soap_type(void) const { return 133; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__StringOrRefType, default initialized and not managed by a soap context
	virtual gml__StringOrRefType *soap_alloc(void) const { return SOAP_NEW(gml__StringOrRefType); }
	         gml__StringOrRefType() { gml__StringOrRefType::soap_default(NULL); }
	virtual ~gml__StringOrRefType() { }
	friend gml__StringOrRefType *soap_instantiate_gml__StringOrRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:561 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CodeType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CodeType (136)
/* gml:CodeType simple type: */
class SOAP_CMAC gml__CodeType
{
public:
	std::string __item;	/* mixed XML content */
	std::string *codeSpace;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CodeType (136)
	virtual int soap_type(void) const { return 136; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CodeType, default initialized and not managed by a soap context
	virtual gml__CodeType *soap_alloc(void) const { return SOAP_NEW(gml__CodeType); }
	         gml__CodeType() { gml__CodeType::soap_default(NULL); }
	virtual ~gml__CodeType() { }
	friend gml__CodeType *soap_instantiate_gml__CodeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:567 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractTimeObjectType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractTimeObjectType (138)
/* Type gml__AbstractTimeObjectType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractTimeObjectType complex type: */
class SOAP_CMAC gml__AbstractTimeObjectType : public gml__AbstractGMLType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractTimeObjectType (138)
	virtual int soap_type(void) const { return 138; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractTimeObjectType, default initialized and not managed by a soap context
	virtual gml__AbstractTimeObjectType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractTimeObjectType); }
	         gml__AbstractTimeObjectType() { gml__AbstractTimeObjectType::soap_default(NULL); }
	virtual ~gml__AbstractTimeObjectType() { }
	friend gml__AbstractTimeObjectType *soap_instantiate_gml__AbstractTimeObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:570 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__RelatedTimeType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__RelatedTimeType (139)
/* Type gml__RelatedTimeType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:RelatedTimeType complex type: */
class SOAP_CMAC gml__RelatedTimeType : public gml__TimePrimitivePropertyType
{
public:
	enum _gml__RelatedTimeType_relativePosition *relativePosition;	/* optional attribute of XSD type gml:RelatedTimeType-relativePosition */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__RelatedTimeType (139)
	virtual int soap_type(void) const { return 139; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__RelatedTimeType, default initialized and not managed by a soap context
	virtual gml__RelatedTimeType *soap_alloc(void) const { return SOAP_NEW(gml__RelatedTimeType); }
	         gml__RelatedTimeType() { gml__RelatedTimeType::soap_default(NULL); }
	virtual ~gml__RelatedTimeType() { }
	friend gml__RelatedTimeType *soap_instantiate_gml__RelatedTimeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:621 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__MeasureType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__MeasureType (156)
/* Type gml__MeasureType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:MeasureType simple type: */
class SOAP_CMAC gml__MeasureType
{
public:
	double __item;	/* mixed XML content */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__MeasureType (156)
	virtual int soap_type(void) const { return 156; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__MeasureType, default initialized and not managed by a soap context
	virtual gml__MeasureType *soap_alloc(void) const { return SOAP_NEW(gml__MeasureType); }
	         gml__MeasureType() { gml__MeasureType::soap_default(NULL); }
	virtual ~gml__MeasureType() { }
	friend gml__MeasureType *soap_instantiate_gml__MeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:681 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREExtent_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREExtent_USCOREType (176)
/* Type gmd__EX_USCOREExtent_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:EX_Extent_Type complex type: */
class SOAP_CMAC gmd__EX_USCOREExtent_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__CharacterString_USCOREPropertyType *description;	/* optional element of XSD type gco:CharacterString_PropertyType */
	std::vector<gmd__EX_USCOREGeographicExtent_USCOREPropertyType *> geographicElement;	/* optional element of XSD type gmd:EX_GeographicExtent_PropertyType */
	std::vector<gmd__EX_USCORETemporalExtent_USCOREPropertyType *> temporalElement;	/* optional element of XSD type gmd:EX_TemporalExtent_PropertyType */
	std::vector<gmd__EX_USCOREVerticalExtent_USCOREPropertyType *> verticalElement;	/* optional element of XSD type gmd:EX_VerticalExtent_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREExtent_USCOREType (176)
	virtual int soap_type(void) const { return 176; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCOREExtent_USCOREType, default initialized and not managed by a soap context
	virtual gmd__EX_USCOREExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREExtent_USCOREType); }
	         gmd__EX_USCOREExtent_USCOREType() { gmd__EX_USCOREExtent_USCOREType::soap_default(NULL); }
	virtual ~gmd__EX_USCOREExtent_USCOREType() { }
	friend gmd__EX_USCOREExtent_USCOREType *soap_instantiate_gmd__EX_USCOREExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:687 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType (178)
/* Type gmd__AbstractEX_USCOREGeographicExtent_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:AbstractEX_GeographicExtent_Type complex type: */
class SOAP_CMAC gmd__AbstractEX_USCOREGeographicExtent_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__Boolean_USCOREPropertyType *extentTypeCode;	/* optional element of XSD type gco:Boolean_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractEX_USCOREGeographicExtent_USCOREType (178)
	virtual int soap_type(void) const { return 178; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__AbstractEX_USCOREGeographicExtent_USCOREType, default initialized and not managed by a soap context
	virtual gmd__AbstractEX_USCOREGeographicExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractEX_USCOREGeographicExtent_USCOREType); }
	         gmd__AbstractEX_USCOREGeographicExtent_USCOREType() { gmd__AbstractEX_USCOREGeographicExtent_USCOREType::soap_default(NULL); }
	virtual ~gmd__AbstractEX_USCOREGeographicExtent_USCOREType() { }
	friend gmd__AbstractEX_USCOREGeographicExtent_USCOREType *soap_instantiate_gmd__AbstractEX_USCOREGeographicExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:693 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCORETemporalExtent_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCORETemporalExtent_USCOREType (180)
/* Type gmd__EX_USCORETemporalExtent_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:EX_TemporalExtent_Type complex type: */
class SOAP_CMAC gmd__EX_USCORETemporalExtent_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gts__TM_USCOREPrimitive_USCOREPropertyType *extent;	/* required element of XSD type gts:TM_Primitive_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCORETemporalExtent_USCOREType (180)
	virtual int soap_type(void) const { return 180; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCORETemporalExtent_USCOREType, default initialized and not managed by a soap context
	virtual gmd__EX_USCORETemporalExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCORETemporalExtent_USCOREType); }
	         gmd__EX_USCORETemporalExtent_USCOREType() { gmd__EX_USCORETemporalExtent_USCOREType::soap_default(NULL); }
	virtual ~gmd__EX_USCORETemporalExtent_USCOREType() { }
	friend gmd__EX_USCORETemporalExtent_USCOREType *soap_instantiate_gmd__EX_USCORETemporalExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:699 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREVerticalExtent_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREVerticalExtent_USCOREType (182)
/* Type gmd__EX_USCOREVerticalExtent_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:EX_VerticalExtent_Type complex type: */
class SOAP_CMAC gmd__EX_USCOREVerticalExtent_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__Real_USCOREPropertyType *minimumValue;	/* required element of XSD type gco:Real_PropertyType */
	gco__Real_USCOREPropertyType *maximumValue;	/* required element of XSD type gco:Real_PropertyType */
	gsr__SC_USCORECRS_USCOREPropertyType *verticalCRS;	/* required element of XSD type gsr:SC_CRS_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__EX_USCOREVerticalExtent_USCOREType (182)
	virtual int soap_type(void) const { return 182; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__EX_USCOREVerticalExtent_USCOREType, default initialized and not managed by a soap context
	virtual gmd__EX_USCOREVerticalExtent_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__EX_USCOREVerticalExtent_USCOREType); }
	         gmd__EX_USCOREVerticalExtent_USCOREType() { gmd__EX_USCOREVerticalExtent_USCOREType::soap_default(NULL); }
	virtual ~gmd__EX_USCOREVerticalExtent_USCOREType() { }
	friend gmd__EX_USCOREVerticalExtent_USCOREType *soap_instantiate_gmd__EX_USCOREVerticalExtent_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:705 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractDQ_USCOREElement_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractDQ_USCOREElement_USCOREType (184)
/* Type gmd__AbstractDQ_USCOREElement_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:AbstractDQ_Element_Type complex type: */
class SOAP_CMAC gmd__AbstractDQ_USCOREElement_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	std::vector<gco__CharacterString_USCOREPropertyType *> nameOfMeasure;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__MD_USCOREIdentifier_USCOREPropertyType *measureIdentification;	/* optional element of XSD type gmd:MD_Identifier_PropertyType */
	gco__CharacterString_USCOREPropertyType *measureDescription;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__DQ_USCOREEvaluationMethodTypeCode_USCOREPropertyType *evaluationMethodType;	/* optional element of XSD type gmd:DQ_EvaluationMethodTypeCode_PropertyType */
	gco__CharacterString_USCOREPropertyType *evaluationMethodDescription;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__CI_USCORECitation_USCOREPropertyType *evaluationProcedure;	/* optional element of XSD type gmd:CI_Citation_PropertyType */
	std::vector<gco__DateTime_USCOREPropertyType *> dateTime;	/* optional element of XSD type gco:DateTime_PropertyType */
	std::vector<gmd__DQ_USCOREResult_USCOREPropertyType *> result;	/* required element of XSD type gmd:DQ_Result_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractDQ_USCOREElement_USCOREType (184)
	virtual int soap_type(void) const { return 184; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__AbstractDQ_USCOREElement_USCOREType, default initialized and not managed by a soap context
	virtual gmd__AbstractDQ_USCOREElement_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREElement_USCOREType); }
	         gmd__AbstractDQ_USCOREElement_USCOREType() { gmd__AbstractDQ_USCOREElement_USCOREType::soap_default(NULL); }
	virtual ~gmd__AbstractDQ_USCOREElement_USCOREType() { }
	friend gmd__AbstractDQ_USCOREElement_USCOREType *soap_instantiate_gmd__AbstractDQ_USCOREElement_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:711 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__MD_USCOREIdentifier_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__MD_USCOREIdentifier_USCOREType (186)
/* Type gmd__MD_USCOREIdentifier_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:MD_Identifier_Type complex type: */
class SOAP_CMAC gmd__MD_USCOREIdentifier_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gmd__CI_USCORECitation_USCOREPropertyType *authority;	/* optional element of XSD type gmd:CI_Citation_PropertyType */
	gco__CharacterString_USCOREPropertyType *code;	/* required element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__MD_USCOREIdentifier_USCOREType (186)
	virtual int soap_type(void) const { return 186; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__MD_USCOREIdentifier_USCOREType, default initialized and not managed by a soap context
	virtual gmd__MD_USCOREIdentifier_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__MD_USCOREIdentifier_USCOREType); }
	         gmd__MD_USCOREIdentifier_USCOREType() { gmd__MD_USCOREIdentifier_USCOREType::soap_default(NULL); }
	virtual ~gmd__MD_USCOREIdentifier_USCOREType() { }
	friend gmd__MD_USCOREIdentifier_USCOREType *soap_instantiate_gmd__MD_USCOREIdentifier_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:717 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORECitation_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORECitation_USCOREType (188)
/* Type gmd__CI_USCORECitation_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Citation_Type complex type: */
class SOAP_CMAC gmd__CI_USCORECitation_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__CharacterString_USCOREPropertyType *title;	/* required element of XSD type gco:CharacterString_PropertyType */
	std::vector<gco__CharacterString_USCOREPropertyType *> alternateTitle;	/* optional element of XSD type gco:CharacterString_PropertyType */
	std::vector<gmd__CI_USCOREDate_USCOREPropertyType *> date;	/* required element of XSD type gmd:CI_Date_PropertyType */
	gco__CharacterString_USCOREPropertyType *edition;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__Date_USCOREPropertyType *editionDate;	/* optional element of XSD type gco:Date_PropertyType */
	std::vector<gmd__MD_USCOREIdentifier_USCOREPropertyType *> identifier;	/* optional element of XSD type gmd:MD_Identifier_PropertyType */
	std::vector<gmd__CI_USCOREResponsibleParty_USCOREPropertyType *> citedResponsibleParty;	/* optional element of XSD type gmd:CI_ResponsibleParty_PropertyType */
	std::vector<gmd__CI_USCOREPresentationFormCode_USCOREPropertyType *> presentationForm;	/* optional element of XSD type gmd:CI_PresentationFormCode_PropertyType */
	gmd__CI_USCORESeries_USCOREPropertyType *series;	/* optional element of XSD type gmd:CI_Series_PropertyType */
	gco__CharacterString_USCOREPropertyType *otherCitationDetails;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *collectiveTitle;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *ISBN;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *ISSN;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORECitation_USCOREType (188)
	virtual int soap_type(void) const { return 188; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORECitation_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORECitation_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORECitation_USCOREType); }
	         gmd__CI_USCORECitation_USCOREType() { gmd__CI_USCORECitation_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCORECitation_USCOREType() { }
	friend gmd__CI_USCORECitation_USCOREType *soap_instantiate_gmd__CI_USCORECitation_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:723 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREDate_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREDate_USCOREType (190)
/* Type gmd__CI_USCOREDate_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Date_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREDate_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__Date_USCOREPropertyType *date;	/* required element of XSD type gco:Date_PropertyType */
	gmd__CI_USCOREDateTypeCode_USCOREPropertyType *dateType;	/* required element of XSD type gmd:CI_DateTypeCode_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREDate_USCOREType (190)
	virtual int soap_type(void) const { return 190; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREDate_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREDate_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREDate_USCOREType); }
	         gmd__CI_USCOREDate_USCOREType() { gmd__CI_USCOREDate_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREDate_USCOREType() { }
	friend gmd__CI_USCOREDate_USCOREType *soap_instantiate_gmd__CI_USCOREDate_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:732 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREResponsibleParty_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREResponsibleParty_USCOREType (193)
/* Type gmd__CI_USCOREResponsibleParty_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_ResponsibleParty_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREResponsibleParty_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__CharacterString_USCOREPropertyType *individualName;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *organisationName;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *positionName;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__CI_USCOREContact_USCOREPropertyType *contactInfo;	/* optional element of XSD type gmd:CI_Contact_PropertyType */
	gmd__CI_USCORERoleCode_USCOREPropertyType *role;	/* required element of XSD type gmd:CI_RoleCode_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREResponsibleParty_USCOREType (193)
	virtual int soap_type(void) const { return 193; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREResponsibleParty_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREResponsibleParty_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREResponsibleParty_USCOREType); }
	         gmd__CI_USCOREResponsibleParty_USCOREType() { gmd__CI_USCOREResponsibleParty_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREResponsibleParty_USCOREType() { }
	friend gmd__CI_USCOREResponsibleParty_USCOREType *soap_instantiate_gmd__CI_USCOREResponsibleParty_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:738 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREContact_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREContact_USCOREType (195)
/* Type gmd__CI_USCOREContact_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Contact_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREContact_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gmd__CI_USCORETelephone_USCOREPropertyType *phone;	/* optional element of XSD type gmd:CI_Telephone_PropertyType */
	gmd__CI_USCOREAddress_USCOREPropertyType *address;	/* optional element of XSD type gmd:CI_Address_PropertyType */
	gmd__CI_USCOREOnlineResource_USCOREPropertyType *onlineResource;	/* optional element of XSD type gmd:CI_OnlineResource_PropertyType */
	gco__CharacterString_USCOREPropertyType *hoursOfService;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *contactInstructions;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREContact_USCOREType (195)
	virtual int soap_type(void) const { return 195; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREContact_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREContact_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREContact_USCOREType); }
	         gmd__CI_USCOREContact_USCOREType() { gmd__CI_USCOREContact_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREContact_USCOREType() { }
	friend gmd__CI_USCOREContact_USCOREType *soap_instantiate_gmd__CI_USCOREContact_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:744 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORETelephone_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORETelephone_USCOREType (197)
/* Type gmd__CI_USCORETelephone_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Telephone_Type complex type: */
class SOAP_CMAC gmd__CI_USCORETelephone_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	std::vector<gco__CharacterString_USCOREPropertyType *> voice;	/* optional element of XSD type gco:CharacterString_PropertyType */
	std::vector<gco__CharacterString_USCOREPropertyType *> facsimile;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORETelephone_USCOREType (197)
	virtual int soap_type(void) const { return 197; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORETelephone_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORETelephone_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORETelephone_USCOREType); }
	         gmd__CI_USCORETelephone_USCOREType() { gmd__CI_USCORETelephone_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCORETelephone_USCOREType() { }
	friend gmd__CI_USCORETelephone_USCOREType *soap_instantiate_gmd__CI_USCORETelephone_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:750 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREAddress_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREAddress_USCOREType (199)
/* Type gmd__CI_USCOREAddress_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Address_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREAddress_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	std::vector<gco__CharacterString_USCOREPropertyType *> deliveryPoint;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *city;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *administrativeArea;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *postalCode;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *country;	/* optional element of XSD type gco:CharacterString_PropertyType */
	std::vector<gco__CharacterString_USCOREPropertyType *> electronicMailAddress;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREAddress_USCOREType (199)
	virtual int soap_type(void) const { return 199; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREAddress_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREAddress_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREAddress_USCOREType); }
	         gmd__CI_USCOREAddress_USCOREType() { gmd__CI_USCOREAddress_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREAddress_USCOREType() { }
	friend gmd__CI_USCOREAddress_USCOREType *soap_instantiate_gmd__CI_USCOREAddress_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:756 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREOnlineResource_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREOnlineResource_USCOREType (201)
/* Type gmd__CI_USCOREOnlineResource_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_OnlineResource_Type complex type: */
class SOAP_CMAC gmd__CI_USCOREOnlineResource_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gmd__URL_USCOREPropertyType *linkage;	/* required element of XSD type gmd:URL_PropertyType */
	gco__CharacterString_USCOREPropertyType *protocol;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *applicationProfile;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *name;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *description;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gmd__CI_USCOREOnLineFunctionCode_USCOREPropertyType *function;	/* optional element of XSD type gmd:CI_OnLineFunctionCode_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCOREOnlineResource_USCOREType (201)
	virtual int soap_type(void) const { return 201; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCOREOnlineResource_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCOREOnlineResource_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCOREOnlineResource_USCOREType); }
	         gmd__CI_USCOREOnlineResource_USCOREType() { gmd__CI_USCOREOnlineResource_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCOREOnlineResource_USCOREType() { }
	friend gmd__CI_USCOREOnlineResource_USCOREType *soap_instantiate_gmd__CI_USCOREOnlineResource_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:774 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORESeries_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORESeries_USCOREType (207)
/* Type gmd__CI_USCORESeries_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:CI_Series_Type complex type: */
class SOAP_CMAC gmd__CI_USCORESeries_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	gco__CharacterString_USCOREPropertyType *name;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *issueIdentification;	/* optional element of XSD type gco:CharacterString_PropertyType */
	gco__CharacterString_USCOREPropertyType *page;	/* optional element of XSD type gco:CharacterString_PropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__CI_USCORESeries_USCOREType (207)
	virtual int soap_type(void) const { return 207; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__CI_USCORESeries_USCOREType, default initialized and not managed by a soap context
	virtual gmd__CI_USCORESeries_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__CI_USCORESeries_USCOREType); }
	         gmd__CI_USCORESeries_USCOREType() { gmd__CI_USCORESeries_USCOREType::soap_default(NULL); }
	virtual ~gmd__CI_USCORESeries_USCOREType() { }
	friend gmd__CI_USCORESeries_USCOREType *soap_instantiate_gmd__CI_USCORESeries_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:783 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractDQ_USCOREResult_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractDQ_USCOREResult_USCOREType (210)
/* Type gmd__AbstractDQ_USCOREResult_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:AbstractDQ_Result_Type complex type: */
class SOAP_CMAC gmd__AbstractDQ_USCOREResult_USCOREType : public gco__AbstractObject_USCOREType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractDQ_USCOREResult_USCOREType (210)
	virtual int soap_type(void) const { return 210; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__AbstractDQ_USCOREResult_USCOREType, default initialized and not managed by a soap context
	virtual gmd__AbstractDQ_USCOREResult_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREResult_USCOREType); }
	         gmd__AbstractDQ_USCOREResult_USCOREType() { gmd__AbstractDQ_USCOREResult_USCOREType::soap_default(NULL); }
	virtual ~gmd__AbstractDQ_USCOREResult_USCOREType() { }
	friend gmd__AbstractDQ_USCOREResult_USCOREType *soap_instantiate_gmd__AbstractDQ_USCOREResult_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:804 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gco__CodeListValue_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gco__CodeListValue_USCOREType (217)
/* gco:CodeListValue_Type simple type: */
class SOAP_CMAC gco__CodeListValue_USCOREType
{
public:
	std::string __item;	/* mixed XML content */
	std::string codeList;	/* required attribute of XSD type xsd:anyURI */
	std::string codeListValue;	/* required attribute of XSD type xsd:anyURI */
	std::string *codeSpace;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gco__CodeListValue_USCOREType (217)
	virtual int soap_type(void) const { return 217; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gco__CodeListValue_USCOREType, default initialized and not managed by a soap context
	virtual gco__CodeListValue_USCOREType *soap_alloc(void) const { return SOAP_NEW(gco__CodeListValue_USCOREType); }
	         gco__CodeListValue_USCOREType() { gco__CodeListValue_USCOREType::soap_default(NULL); }
	virtual ~gco__CodeListValue_USCOREType() { }
	friend gco__CodeListValue_USCOREType *soap_instantiate_gco__CodeListValue_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:276 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cost
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cost (41)
/* witsml1:cost simple type: */
class SOAP_CMAC witsml1__cost
{
public:
	double __item;	/* mixed XML content */
	std::string *currency;	/* optional attribute of XSD type witsml1:kindString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__cost (41)
	virtual int soap_type(void) const { return 41; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__cost, default initialized and not managed by a soap context
	virtual witsml1__cost *soap_alloc(void) const { return SOAP_NEW(witsml1__cost); }
	         witsml1__cost() { witsml1__cost::soap_default(NULL); }
	virtual ~witsml1__cost() { }
	friend witsml1__cost *soap_instantiate_witsml1__cost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:408 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractMeasure (85)
/* Type witsml1__abstractMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:abstractMeasure simple type: */
class SOAP_CMAC witsml1__abstractMeasure
{
public:
	double __item;	/* mixed XML content */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractMeasure (85)
	virtual int soap_type(void) const { return 85; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__abstractMeasure, default initialized and not managed by a soap context
	virtual witsml1__abstractMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__abstractMeasure); }
	         witsml1__abstractMeasure() { witsml1__abstractMeasure::soap_default(NULL); }
	virtual ~witsml1__abstractMeasure() { }
	friend witsml1__abstractMeasure *soap_instantiate_witsml1__abstractMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:543 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__DefinitionType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__DefinitionType (130)
/* Type gml__DefinitionType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:DefinitionType complex type: */
class SOAP_CMAC gml__DefinitionType : public gml__DefinitionBaseType
{
public:
	std::string *remarks;	/* optional element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__DefinitionType (130)
	virtual int soap_type(void) const { return 130; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__DefinitionType, default initialized and not managed by a soap context
	virtual gml__DefinitionType *soap_alloc(void) const { return SOAP_NEW(gml__DefinitionType); }
	         gml__DefinitionType() { gml__DefinitionType::soap_default(NULL); }
	virtual ~gml__DefinitionType() { }
	friend gml__DefinitionType *soap_instantiate_gml__DefinitionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:558 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CodeWithAuthorityType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CodeWithAuthorityType (135)
/* gml:CodeWithAuthorityType simple type: */
class SOAP_CMAC gml__CodeWithAuthorityType
{
public:
	std::string __item;	/* mixed XML content */
	std::string codeSpace;	/* required attribute of XSD type xsd:anyURI */
	std::string *codeSpace_;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CodeWithAuthorityType (135)
	virtual int soap_type(void) const { return 135; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CodeWithAuthorityType, default initialized and not managed by a soap context
	virtual gml__CodeWithAuthorityType *soap_alloc(void) const { return SOAP_NEW(gml__CodeWithAuthorityType); }
	         gml__CodeWithAuthorityType() { gml__CodeWithAuthorityType::soap_default(NULL); }
	virtual ~gml__CodeWithAuthorityType() { }
	friend gml__CodeWithAuthorityType *soap_instantiate_gml__CodeWithAuthorityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:564 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractTimePrimitiveType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractTimePrimitiveType (137)
/* Type gml__AbstractTimePrimitiveType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractTimePrimitiveType complex type: */
class SOAP_CMAC gml__AbstractTimePrimitiveType : public gml__AbstractTimeObjectType
{
public:
	std::vector<gml__RelatedTimeType *> relatedTime;	/* optional element of XSD type gml:RelatedTimeType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractTimePrimitiveType (137)
	virtual int soap_type(void) const { return 137; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractTimePrimitiveType, default initialized and not managed by a soap context
	virtual gml__AbstractTimePrimitiveType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractTimePrimitiveType); }
	         gml__AbstractTimePrimitiveType() { gml__AbstractTimePrimitiveType::soap_default(NULL); }
	virtual ~gml__AbstractTimePrimitiveType() { }
	friend gml__AbstractTimePrimitiveType *soap_instantiate_gml__AbstractTimePrimitiveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:618 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AngleType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AngleType (155)
/* Type gml__AngleType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AngleType simple type: */
class SOAP_CMAC gml__AngleType : public gml__MeasureType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AngleType (155)
	virtual int soap_type(void) const { return 155; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AngleType, default initialized and not managed by a soap context
	virtual gml__AngleType *soap_alloc(void) const { return SOAP_NEW(gml__AngleType); }
	         gml__AngleType() { gml__AngleType::soap_default(NULL); }
	virtual ~gml__AngleType() { }
	friend gml__AngleType *soap_instantiate_gml__AngleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:630 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__LengthType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__LengthType (159)
/* Type gml__LengthType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:LengthType simple type: */
class SOAP_CMAC gml__LengthType : public gml__MeasureType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__LengthType (159)
	virtual int soap_type(void) const { return 159; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__LengthType, default initialized and not managed by a soap context
	virtual gml__LengthType *soap_alloc(void) const { return SOAP_NEW(gml__LengthType); }
	         gml__LengthType() { gml__LengthType::soap_default(NULL); }
	virtual ~gml__LengthType() { }
	friend gml__LengthType *soap_instantiate_gml__LengthType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:702 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType (183)
/* Type gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gmd:AbstractDQ_PositionalAccuracy_Type complex type: */
class SOAP_CMAC gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType : public gmd__AbstractDQ_USCOREElement_USCOREType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType (183)
	virtual int soap_type(void) const { return 183; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType, default initialized and not managed by a soap context
	virtual gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType *soap_alloc(void) const { return SOAP_NEW(gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType); }
	         gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType() { gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType::soap_default(NULL); }
	virtual ~gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType() { }
	friend gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType *soap_instantiate_gmd__AbstractDQ_USCOREPositionalAccuracy_USCOREType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:210 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timestampedTimeZone
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timestampedTimeZone (19)
/* witsml1:timestampedTimeZone simple type: */
class SOAP_CMAC witsml1__timestampedTimeZone
{
public:
	std::string __item;	/* mixed XML content */
	time_t *dTim;	/* optional attribute of XSD type witsml1:timestamp */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timestampedTimeZone (19)
	virtual int soap_type(void) const { return 19; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__timestampedTimeZone, default initialized and not managed by a soap context
	virtual witsml1__timestampedTimeZone *soap_alloc(void) const { return SOAP_NEW(witsml1__timestampedTimeZone); }
	         witsml1__timestampedTimeZone() { witsml1__timestampedTimeZone::soap_default(NULL); }
	virtual ~witsml1__timestampedTimeZone() { }
	friend witsml1__timestampedTimeZone *soap_instantiate_witsml1__timestampedTimeZone(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:213 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__yAxisAzimuth
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__yAxisAzimuth (20)
/* Type witsml1__yAxisAzimuth is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:yAxisAzimuth simple type: */
class SOAP_CMAC witsml1__yAxisAzimuth : public witsml1__abstractMeasure
{
public:
	enum witsml1__PlaneAngleUom uom;	/* required attribute of XSD type witsml1:PlaneAngleUom */
	enum witsml1__AziRef *northDirection;	/* optional attribute of XSD type witsml1:AziRef */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__yAxisAzimuth (20)
	virtual int soap_type(void) const { return 20; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__yAxisAzimuth, default initialized and not managed by a soap context
	virtual witsml1__yAxisAzimuth *soap_alloc(void) const { return SOAP_NEW(witsml1__yAxisAzimuth); }
	         witsml1__yAxisAzimuth() { witsml1__yAxisAzimuth::soap_default(NULL); }
	virtual ~witsml1__yAxisAzimuth() { }
	friend witsml1__yAxisAzimuth *soap_instantiate_witsml1__yAxisAzimuth(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:216 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumePerVolumeMeasurePercent
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumePerVolumeMeasurePercent (21)
/* Type witsml1__volumePerVolumeMeasurePercent is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:volumePerVolumeMeasurePercent simple type: */
class SOAP_CMAC witsml1__volumePerVolumeMeasurePercent : public witsml1__abstractMeasure
{
public:
	enum witsml1__PercentUom uom;	/* required attribute of XSD type witsml1:PercentUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumePerVolumeMeasurePercent (21)
	virtual int soap_type(void) const { return 21; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__volumePerVolumeMeasurePercent, default initialized and not managed by a soap context
	virtual witsml1__volumePerVolumeMeasurePercent *soap_alloc(void) const { return SOAP_NEW(witsml1__volumePerVolumeMeasurePercent); }
	         witsml1__volumePerVolumeMeasurePercent() { witsml1__volumePerVolumeMeasurePercent::soap_default(NULL); }
	virtual ~witsml1__volumePerVolumeMeasurePercent() { }
	friend witsml1__volumePerVolumeMeasurePercent *soap_instantiate_witsml1__volumePerVolumeMeasurePercent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:219 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__measureOrQuantity
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__measureOrQuantity (22)
/* Type witsml1__measureOrQuantity is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:measureOrQuantity simple type: */
class SOAP_CMAC witsml1__measureOrQuantity : public witsml1__abstractMeasure
{
public:
	std::string *uom;	/* optional attribute of XSD type witsml1:uomString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__measureOrQuantity (22)
	virtual int soap_type(void) const { return 22; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__measureOrQuantity, default initialized and not managed by a soap context
	virtual witsml1__measureOrQuantity *soap_alloc(void) const { return SOAP_NEW(witsml1__measureOrQuantity); }
	         witsml1__measureOrQuantity() { witsml1__measureOrQuantity::soap_default(NULL); }
	virtual ~witsml1__measureOrQuantity() { }
	friend witsml1__measureOrQuantity *soap_instantiate_witsml1__measureOrQuantity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:222 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__genericMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__genericMeasure (23)
/* Type witsml1__genericMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:genericMeasure simple type: */
class SOAP_CMAC witsml1__genericMeasure : public witsml1__abstractMeasure
{
public:
	std::string uom;	/* required attribute of XSD type witsml1:uomString */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__genericMeasure (23)
	virtual int soap_type(void) const { return 23; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__genericMeasure, default initialized and not managed by a soap context
	virtual witsml1__genericMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__genericMeasure); }
	         witsml1__genericMeasure() { witsml1__genericMeasure::soap_default(NULL); }
	virtual ~witsml1__genericMeasure() { }
	friend witsml1__genericMeasure *soap_instantiate_witsml1__genericMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:225 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ratioGenericMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ratioGenericMeasure (24)
/* Type witsml1__ratioGenericMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:ratioGenericMeasure simple type: */
class SOAP_CMAC witsml1__ratioGenericMeasure : public witsml1__abstractMeasure
{
public:
	std::string uom;	/* required attribute of XSD type witsml1:uomString */
	double *numerator;	/* optional attribute of XSD type witsml1:unitlessQuantity */
	double *denominator;	/* optional attribute of XSD type witsml1:unitlessQuantity */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ratioGenericMeasure (24)
	virtual int soap_type(void) const { return 24; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__ratioGenericMeasure, default initialized and not managed by a soap context
	virtual witsml1__ratioGenericMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__ratioGenericMeasure); }
	         witsml1__ratioGenericMeasure() { witsml1__ratioGenericMeasure::soap_default(NULL); }
	virtual ~witsml1__ratioGenericMeasure() { }
	friend witsml1__ratioGenericMeasure *soap_instantiate_witsml1__ratioGenericMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:228 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refNameString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refNameString (25)
/* witsml1:refNameString simple type: */
class SOAP_CMAC witsml1__refNameString
{
public:
	std::string __item;	/* mixed XML content */
	std::string *uidRef;	/* optional attribute of XSD type witsml1:refString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refNameString (25)
	virtual int soap_type(void) const { return 25; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__refNameString, default initialized and not managed by a soap context
	virtual witsml1__refNameString *soap_alloc(void) const { return SOAP_NEW(witsml1__refNameString); }
	         witsml1__refNameString() { witsml1__refNameString::soap_default(NULL); }
	virtual ~witsml1__refNameString() { }
	friend witsml1__refNameString *soap_instantiate_witsml1__refNameString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:231 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refObjectString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refObjectString (26)
/* witsml1:refObjectString simple type: */
class SOAP_CMAC witsml1__refObjectString
{
public:
	std::string __item;	/* mixed XML content */
	std::string object;	/* required attribute of XSD type witsml1:nameString */
	std::string *uidRef;	/* optional attribute of XSD type witsml1:refString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refObjectString (26)
	virtual int soap_type(void) const { return 26; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__refObjectString, default initialized and not managed by a soap context
	virtual witsml1__refObjectString *soap_alloc(void) const { return SOAP_NEW(witsml1__refObjectString); }
	         witsml1__refObjectString() { witsml1__refObjectString::soap_default(NULL); }
	virtual ~witsml1__refObjectString() { }
	friend witsml1__refObjectString *soap_instantiate_witsml1__refObjectString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:234 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refPositiveCount
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refPositiveCount (27)
/* witsml1:refPositiveCount simple type: */
class SOAP_CMAC witsml1__refPositiveCount
{
public:
	short __item;	/* mixed XML content */
	std::string *uidRef;	/* optional attribute of XSD type witsml1:refString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refPositiveCount (27)
	virtual int soap_type(void) const { return 27; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__refPositiveCount, default initialized and not managed by a soap context
	virtual witsml1__refPositiveCount *soap_alloc(void) const { return SOAP_NEW(witsml1__refPositiveCount); }
	         witsml1__refPositiveCount() { witsml1__refPositiveCount::soap_default(NULL); }
	virtual ~witsml1__refPositiveCount() { }
	friend witsml1__refPositiveCount *soap_instantiate_witsml1__refPositiveCount(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:240 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__extensionvalue
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__extensionvalue (29)
/* witsml1:extensionvalue simple type: */
class SOAP_CMAC witsml1__extensionvalue
{
public:
	std::string __item;	/* mixed XML content */
	std::string *uom;	/* optional attribute of XSD type witsml1:uomString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__extensionvalue (29)
	virtual int soap_type(void) const { return 29; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__extensionvalue, default initialized and not managed by a soap context
	virtual witsml1__extensionvalue *soap_alloc(void) const { return SOAP_NEW(witsml1__extensionvalue); }
	         witsml1__extensionvalue() { witsml1__extensionvalue::soap_default(NULL); }
	virtual ~witsml1__extensionvalue() { }
	friend witsml1__extensionvalue *soap_instantiate_witsml1__extensionvalue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:243 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__nameStruct
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__nameStruct (30)
/* witsml1:nameStruct simple type: */
class SOAP_CMAC witsml1__nameStruct
{
public:
	std::string __item;	/* mixed XML content */
	std::string *namingSystem;	/* optional attribute of XSD type witsml1:nameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__nameStruct (30)
	virtual int soap_type(void) const { return 30; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__nameStruct, default initialized and not managed by a soap context
	virtual witsml1__nameStruct *soap_alloc(void) const { return SOAP_NEW(witsml1__nameStruct); }
	         witsml1__nameStruct() { witsml1__nameStruct::soap_default(NULL); }
	virtual ~witsml1__nameStruct() { }
	friend witsml1__nameStruct *soap_instantiate_witsml1__nameStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:246 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__shortNameStruct
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__shortNameStruct (31)
/* witsml1:shortNameStruct simple type: */
class SOAP_CMAC witsml1__shortNameStruct
{
public:
	std::string __item;	/* mixed XML content */
	std::string *namingSystem;	/* optional attribute of XSD type witsml1:nameString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__shortNameStruct (31)
	virtual int soap_type(void) const { return 31; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__shortNameStruct, default initialized and not managed by a soap context
	virtual witsml1__shortNameStruct *soap_alloc(void) const { return SOAP_NEW(witsml1__shortNameStruct); }
	         witsml1__shortNameStruct() { witsml1__shortNameStruct::soap_default(NULL); }
	virtual ~witsml1__shortNameStruct() { }
	friend witsml1__shortNameStruct *soap_instantiate_witsml1__shortNameStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:249 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__wellKnownNameStruct
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__wellKnownNameStruct (32)
/* witsml1:wellKnownNameStruct simple type: */
class SOAP_CMAC witsml1__wellKnownNameStruct
{
public:
	std::string __item;	/* mixed XML content */
	std::string namingSystem;	/* required attribute of XSD type witsml1:nameString */
	std::string *code;	/* optional attribute of XSD type witsml1:kindString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__wellKnownNameStruct (32)
	virtual int soap_type(void) const { return 32; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__wellKnownNameStruct, default initialized and not managed by a soap context
	virtual witsml1__wellKnownNameStruct *soap_alloc(void) const { return SOAP_NEW(witsml1__wellKnownNameStruct); }
	         witsml1__wellKnownNameStruct() { witsml1__wellKnownNameStruct::soap_default(NULL); }
	virtual ~witsml1__wellKnownNameStruct() { }
	friend witsml1__wellKnownNameStruct *soap_instantiate_witsml1__wellKnownNameStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:252 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__objectSequence
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__objectSequence (33)
/* witsml1:objectSequence simple type: */
class SOAP_CMAC witsml1__objectSequence
{
public:
	short __item;	/* mixed XML content */
	std::string *description;	/* optional attribute of XSD type witsml1:descriptionString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__objectSequence (33)
	virtual int soap_type(void) const { return 33; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__objectSequence, default initialized and not managed by a soap context
	virtual witsml1__objectSequence *soap_alloc(void) const { return SOAP_NEW(witsml1__objectSequence); }
	         witsml1__objectSequence() { witsml1__objectSequence::soap_default(NULL); }
	virtual ~witsml1__objectSequence() { }
	friend witsml1__objectSequence *soap_instantiate_witsml1__objectSequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:255 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__lithostratigraphyStruct
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__lithostratigraphyStruct (34)
/* witsml1:lithostratigraphyStruct simple type: */
class SOAP_CMAC witsml1__lithostratigraphyStruct
{
public:
	std::string __item;	/* mixed XML content */
	enum witsml1__LithostratigraphyUnit *kind;	/* optional attribute of XSD type witsml1:LithostratigraphyUnit */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__lithostratigraphyStruct (34)
	virtual int soap_type(void) const { return 34; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__lithostratigraphyStruct, default initialized and not managed by a soap context
	virtual witsml1__lithostratigraphyStruct *soap_alloc(void) const { return SOAP_NEW(witsml1__lithostratigraphyStruct); }
	         witsml1__lithostratigraphyStruct() { witsml1__lithostratigraphyStruct::soap_default(NULL); }
	virtual ~witsml1__lithostratigraphyStruct() { }
	friend witsml1__lithostratigraphyStruct *soap_instantiate_witsml1__lithostratigraphyStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:258 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__chronostratigraphyStruct
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__chronostratigraphyStruct (35)
/* witsml1:chronostratigraphyStruct simple type: */
class SOAP_CMAC witsml1__chronostratigraphyStruct
{
public:
	std::string __item;	/* mixed XML content */
	enum witsml1__ChronostratigraphyUnit *kind;	/* optional attribute of XSD type witsml1:ChronostratigraphyUnit */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__chronostratigraphyStruct (35)
	virtual int soap_type(void) const { return 35; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__chronostratigraphyStruct, default initialized and not managed by a soap context
	virtual witsml1__chronostratigraphyStruct *soap_alloc(void) const { return SOAP_NEW(witsml1__chronostratigraphyStruct); }
	         witsml1__chronostratigraphyStruct() { witsml1__chronostratigraphyStruct::soap_default(NULL); }
	virtual ~witsml1__chronostratigraphyStruct() { }
	friend witsml1__chronostratigraphyStruct *soap_instantiate_witsml1__chronostratigraphyStruct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:261 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__measuredDepthCoord
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__measuredDepthCoord (36)
/* Type witsml1__measuredDepthCoord is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:measuredDepthCoord simple type: */
class SOAP_CMAC witsml1__measuredDepthCoord : public witsml1__abstractMeasure
{
public:
	enum witsml1__MeasuredDepthUom uom;	/* required attribute of XSD type witsml1:MeasuredDepthUom */
	std::string *datum;	/* optional attribute of XSD type witsml1:refWellDatum */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__measuredDepthCoord (36)
	virtual int soap_type(void) const { return 36; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__measuredDepthCoord, default initialized and not managed by a soap context
	virtual witsml1__measuredDepthCoord *soap_alloc(void) const { return SOAP_NEW(witsml1__measuredDepthCoord); }
	         witsml1__measuredDepthCoord() { witsml1__measuredDepthCoord::soap_default(NULL); }
	virtual ~witsml1__measuredDepthCoord() { }
	friend witsml1__measuredDepthCoord *soap_instantiate_witsml1__measuredDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:264 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__wellVerticalDepthCoord
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__wellVerticalDepthCoord (37)
/* Type witsml1__wellVerticalDepthCoord is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:wellVerticalDepthCoord simple type: */
class SOAP_CMAC witsml1__wellVerticalDepthCoord : public witsml1__abstractMeasure
{
public:
	enum witsml1__WellVerticalCoordinateUom uom;	/* required attribute of XSD type witsml1:WellVerticalCoordinateUom */
	std::string *datum;	/* optional attribute of XSD type witsml1:refWellDatum */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__wellVerticalDepthCoord (37)
	virtual int soap_type(void) const { return 37; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__wellVerticalDepthCoord, default initialized and not managed by a soap context
	virtual witsml1__wellVerticalDepthCoord *soap_alloc(void) const { return SOAP_NEW(witsml1__wellVerticalDepthCoord); }
	         witsml1__wellVerticalDepthCoord() { witsml1__wellVerticalDepthCoord::soap_default(NULL); }
	virtual ~witsml1__wellVerticalDepthCoord() { }
	friend witsml1__wellVerticalDepthCoord *soap_instantiate_witsml1__wellVerticalDepthCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:267 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__wellElevationCoord
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__wellElevationCoord (38)
/* Type witsml1__wellElevationCoord is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:wellElevationCoord simple type: */
class SOAP_CMAC witsml1__wellElevationCoord : public witsml1__abstractMeasure
{
public:
	enum witsml1__WellVerticalCoordinateUom uom;	/* required attribute of XSD type witsml1:WellVerticalCoordinateUom */
	std::string *datum;	/* optional attribute of XSD type witsml1:refWellDatum */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__wellElevationCoord (38)
	virtual int soap_type(void) const { return 38; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__wellElevationCoord, default initialized and not managed by a soap context
	virtual witsml1__wellElevationCoord *soap_alloc(void) const { return SOAP_NEW(witsml1__wellElevationCoord); }
	         witsml1__wellElevationCoord() { witsml1__wellElevationCoord::soap_default(NULL); }
	virtual ~witsml1__wellElevationCoord() { }
	friend witsml1__wellElevationCoord *soap_instantiate_witsml1__wellElevationCoord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:270 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__footageNorthSouth
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__footageNorthSouth (39)
/* Type witsml1__footageNorthSouth is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:footageNorthSouth simple type: */
class SOAP_CMAC witsml1__footageNorthSouth : public witsml1__abstractMeasure
{
public:
	enum witsml1__LengthUom uom;	/* required attribute of XSD type witsml1:LengthUom */
	enum witsml1__NorthOrSouth ref;	/* required attribute of XSD type witsml1:NorthOrSouth */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__footageNorthSouth (39)
	virtual int soap_type(void) const { return 39; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__footageNorthSouth, default initialized and not managed by a soap context
	virtual witsml1__footageNorthSouth *soap_alloc(void) const { return SOAP_NEW(witsml1__footageNorthSouth); }
	         witsml1__footageNorthSouth() { witsml1__footageNorthSouth::soap_default(NULL); }
	virtual ~witsml1__footageNorthSouth() { }
	friend witsml1__footageNorthSouth *soap_instantiate_witsml1__footageNorthSouth(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:273 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__footageEastWest
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__footageEastWest (40)
/* Type witsml1__footageEastWest is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:footageEastWest simple type: */
class SOAP_CMAC witsml1__footageEastWest : public witsml1__abstractMeasure
{
public:
	enum witsml1__LengthUom uom;	/* required attribute of XSD type witsml1:LengthUom */
	enum witsml1__EastOrWest ref;	/* required attribute of XSD type witsml1:EastOrWest */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__footageEastWest (40)
	virtual int soap_type(void) const { return 40; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__footageEastWest, default initialized and not managed by a soap context
	virtual witsml1__footageEastWest *soap_alloc(void) const { return SOAP_NEW(witsml1__footageEastWest); }
	         witsml1__footageEastWest() { witsml1__footageEastWest::soap_default(NULL); }
	virtual ~witsml1__footageEastWest() { }
	friend witsml1__footageEastWest *soap_instantiate_witsml1__footageEastWest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:279 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__indexedObject
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__indexedObject (42)
/* witsml1:indexedObject simple type: */
class SOAP_CMAC witsml1__indexedObject
{
public:
	std::string __item;	/* mixed XML content */
	short index;	/* required attribute of XSD type witsml1:positiveCount */
	std::string *name;	/* optional attribute of XSD type witsml1:kindString */
	std::string *uom;	/* optional attribute of XSD type witsml1:uomString */
	std::string *description;	/* optional attribute of XSD type witsml1:descriptionString */
	std::string *uid;	/* optional attribute of XSD type witsml1:uidString */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__indexedObject (42)
	virtual int soap_type(void) const { return 42; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__indexedObject, default initialized and not managed by a soap context
	virtual witsml1__indexedObject *soap_alloc(void) const { return SOAP_NEW(witsml1__indexedObject); }
	         witsml1__indexedObject() { witsml1__indexedObject::soap_default(NULL); }
	virtual ~witsml1__indexedObject() { }
	friend witsml1__indexedObject *soap_instantiate_witsml1__indexedObject(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:282 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__accelerationLinearMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__accelerationLinearMeasure (43)
/* Type witsml1__accelerationLinearMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:accelerationLinearMeasure simple type: */
class SOAP_CMAC witsml1__accelerationLinearMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__AccelerationLinearUom uom;	/* required attribute of XSD type witsml1:AccelerationLinearUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__accelerationLinearMeasure (43)
	virtual int soap_type(void) const { return 43; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__accelerationLinearMeasure, default initialized and not managed by a soap context
	virtual witsml1__accelerationLinearMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__accelerationLinearMeasure); }
	         witsml1__accelerationLinearMeasure() { witsml1__accelerationLinearMeasure::soap_default(NULL); }
	virtual ~witsml1__accelerationLinearMeasure() { }
	friend witsml1__accelerationLinearMeasure *soap_instantiate_witsml1__accelerationLinearMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:285 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__anglePerLengthMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__anglePerLengthMeasure (44)
/* Type witsml1__anglePerLengthMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:anglePerLengthMeasure simple type: */
class SOAP_CMAC witsml1__anglePerLengthMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__AnglePerLengthUom uom;	/* required attribute of XSD type witsml1:AnglePerLengthUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__anglePerLengthMeasure (44)
	virtual int soap_type(void) const { return 44; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__anglePerLengthMeasure, default initialized and not managed by a soap context
	virtual witsml1__anglePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__anglePerLengthMeasure); }
	         witsml1__anglePerLengthMeasure() { witsml1__anglePerLengthMeasure::soap_default(NULL); }
	virtual ~witsml1__anglePerLengthMeasure() { }
	friend witsml1__anglePerLengthMeasure *soap_instantiate_witsml1__anglePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:288 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__anglePerTimeMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__anglePerTimeMeasure (45)
/* Type witsml1__anglePerTimeMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:anglePerTimeMeasure simple type: */
class SOAP_CMAC witsml1__anglePerTimeMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__AnglePerTimeUom uom;	/* required attribute of XSD type witsml1:AnglePerTimeUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__anglePerTimeMeasure (45)
	virtual int soap_type(void) const { return 45; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__anglePerTimeMeasure, default initialized and not managed by a soap context
	virtual witsml1__anglePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__anglePerTimeMeasure); }
	         witsml1__anglePerTimeMeasure() { witsml1__anglePerTimeMeasure::soap_default(NULL); }
	virtual ~witsml1__anglePerTimeMeasure() { }
	friend witsml1__anglePerTimeMeasure *soap_instantiate_witsml1__anglePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:291 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__areaMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__areaMeasure (46)
/* Type witsml1__areaMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:areaMeasure simple type: */
class SOAP_CMAC witsml1__areaMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__AreaUom uom;	/* required attribute of XSD type witsml1:AreaUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__areaMeasure (46)
	virtual int soap_type(void) const { return 46; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__areaMeasure, default initialized and not managed by a soap context
	virtual witsml1__areaMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__areaMeasure); }
	         witsml1__areaMeasure() { witsml1__areaMeasure::soap_default(NULL); }
	virtual ~witsml1__areaMeasure() { }
	friend witsml1__areaMeasure *soap_instantiate_witsml1__areaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:294 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__areaPerAreaMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__areaPerAreaMeasure (47)
/* Type witsml1__areaPerAreaMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:areaPerAreaMeasure simple type: */
class SOAP_CMAC witsml1__areaPerAreaMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__AreaPerAreaUom uom;	/* required attribute of XSD type witsml1:AreaPerAreaUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__areaPerAreaMeasure (47)
	virtual int soap_type(void) const { return 47; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__areaPerAreaMeasure, default initialized and not managed by a soap context
	virtual witsml1__areaPerAreaMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__areaPerAreaMeasure); }
	         witsml1__areaPerAreaMeasure() { witsml1__areaPerAreaMeasure::soap_default(NULL); }
	virtual ~witsml1__areaPerAreaMeasure() { }
	friend witsml1__areaPerAreaMeasure *soap_instantiate_witsml1__areaPerAreaMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:297 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__compressibilityMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__compressibilityMeasure (48)
/* Type witsml1__compressibilityMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:compressibilityMeasure simple type: */
class SOAP_CMAC witsml1__compressibilityMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__CompressibilityUom uom;	/* required attribute of XSD type witsml1:CompressibilityUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__compressibilityMeasure (48)
	virtual int soap_type(void) const { return 48; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__compressibilityMeasure, default initialized and not managed by a soap context
	virtual witsml1__compressibilityMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__compressibilityMeasure); }
	         witsml1__compressibilityMeasure() { witsml1__compressibilityMeasure::soap_default(NULL); }
	virtual ~witsml1__compressibilityMeasure() { }
	friend witsml1__compressibilityMeasure *soap_instantiate_witsml1__compressibilityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:300 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__densityMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__densityMeasure (49)
/* Type witsml1__densityMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:densityMeasure simple type: */
class SOAP_CMAC witsml1__densityMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__DensityUom uom;	/* required attribute of XSD type witsml1:DensityUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__densityMeasure (49)
	virtual int soap_type(void) const { return 49; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__densityMeasure, default initialized and not managed by a soap context
	virtual witsml1__densityMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__densityMeasure); }
	         witsml1__densityMeasure() { witsml1__densityMeasure::soap_default(NULL); }
	virtual ~witsml1__densityMeasure() { }
	friend witsml1__densityMeasure *soap_instantiate_witsml1__densityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:303 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__dimensionlessMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__dimensionlessMeasure (50)
/* Type witsml1__dimensionlessMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:dimensionlessMeasure simple type: */
class SOAP_CMAC witsml1__dimensionlessMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__DimensionlessUom uom;	/* required attribute of XSD type witsml1:DimensionlessUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__dimensionlessMeasure (50)
	virtual int soap_type(void) const { return 50; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__dimensionlessMeasure, default initialized and not managed by a soap context
	virtual witsml1__dimensionlessMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__dimensionlessMeasure); }
	         witsml1__dimensionlessMeasure() { witsml1__dimensionlessMeasure::soap_default(NULL); }
	virtual ~witsml1__dimensionlessMeasure() { }
	friend witsml1__dimensionlessMeasure *soap_instantiate_witsml1__dimensionlessMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:306 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__dynamicViscosityMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__dynamicViscosityMeasure (51)
/* Type witsml1__dynamicViscosityMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:dynamicViscosityMeasure simple type: */
class SOAP_CMAC witsml1__dynamicViscosityMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__DynamicViscosityUom uom;	/* required attribute of XSD type witsml1:DynamicViscosityUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__dynamicViscosityMeasure (51)
	virtual int soap_type(void) const { return 51; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__dynamicViscosityMeasure, default initialized and not managed by a soap context
	virtual witsml1__dynamicViscosityMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__dynamicViscosityMeasure); }
	         witsml1__dynamicViscosityMeasure() { witsml1__dynamicViscosityMeasure::soap_default(NULL); }
	virtual ~witsml1__dynamicViscosityMeasure() { }
	friend witsml1__dynamicViscosityMeasure *soap_instantiate_witsml1__dynamicViscosityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:309 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__electricCurrentMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__electricCurrentMeasure (52)
/* Type witsml1__electricCurrentMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:electricCurrentMeasure simple type: */
class SOAP_CMAC witsml1__electricCurrentMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__ElectricCurrentUom uom;	/* required attribute of XSD type witsml1:ElectricCurrentUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__electricCurrentMeasure (52)
	virtual int soap_type(void) const { return 52; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__electricCurrentMeasure, default initialized and not managed by a soap context
	virtual witsml1__electricCurrentMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__electricCurrentMeasure); }
	         witsml1__electricCurrentMeasure() { witsml1__electricCurrentMeasure::soap_default(NULL); }
	virtual ~witsml1__electricCurrentMeasure() { }
	friend witsml1__electricCurrentMeasure *soap_instantiate_witsml1__electricCurrentMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:312 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__electricPotentialMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__electricPotentialMeasure (53)
/* Type witsml1__electricPotentialMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:electricPotentialMeasure simple type: */
class SOAP_CMAC witsml1__electricPotentialMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__ElectricPotentialUom uom;	/* required attribute of XSD type witsml1:ElectricPotentialUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__electricPotentialMeasure (53)
	virtual int soap_type(void) const { return 53; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__electricPotentialMeasure, default initialized and not managed by a soap context
	virtual witsml1__electricPotentialMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__electricPotentialMeasure); }
	         witsml1__electricPotentialMeasure() { witsml1__electricPotentialMeasure::soap_default(NULL); }
	virtual ~witsml1__electricPotentialMeasure() { }
	friend witsml1__electricPotentialMeasure *soap_instantiate_witsml1__electricPotentialMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:315 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__equivalentPerMassMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__equivalentPerMassMeasure (54)
/* Type witsml1__equivalentPerMassMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:equivalentPerMassMeasure simple type: */
class SOAP_CMAC witsml1__equivalentPerMassMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__EquivalentPerMassUom uom;	/* required attribute of XSD type witsml1:EquivalentPerMassUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__equivalentPerMassMeasure (54)
	virtual int soap_type(void) const { return 54; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__equivalentPerMassMeasure, default initialized and not managed by a soap context
	virtual witsml1__equivalentPerMassMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__equivalentPerMassMeasure); }
	         witsml1__equivalentPerMassMeasure() { witsml1__equivalentPerMassMeasure::soap_default(NULL); }
	virtual ~witsml1__equivalentPerMassMeasure() { }
	friend witsml1__equivalentPerMassMeasure *soap_instantiate_witsml1__equivalentPerMassMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:318 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__forceMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__forceMeasure (55)
/* Type witsml1__forceMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:forceMeasure simple type: */
class SOAP_CMAC witsml1__forceMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__ForceUom uom;	/* required attribute of XSD type witsml1:ForceUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__forceMeasure (55)
	virtual int soap_type(void) const { return 55; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__forceMeasure, default initialized and not managed by a soap context
	virtual witsml1__forceMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__forceMeasure); }
	         witsml1__forceMeasure() { witsml1__forceMeasure::soap_default(NULL); }
	virtual ~witsml1__forceMeasure() { }
	friend witsml1__forceMeasure *soap_instantiate_witsml1__forceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:321 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__forcePerLengthMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__forcePerLengthMeasure (56)
/* Type witsml1__forcePerLengthMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:forcePerLengthMeasure simple type: */
class SOAP_CMAC witsml1__forcePerLengthMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__ForcePerLengthUom uom;	/* required attribute of XSD type witsml1:ForcePerLengthUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__forcePerLengthMeasure (56)
	virtual int soap_type(void) const { return 56; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__forcePerLengthMeasure, default initialized and not managed by a soap context
	virtual witsml1__forcePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__forcePerLengthMeasure); }
	         witsml1__forcePerLengthMeasure() { witsml1__forcePerLengthMeasure::soap_default(NULL); }
	virtual ~witsml1__forcePerLengthMeasure() { }
	friend witsml1__forcePerLengthMeasure *soap_instantiate_witsml1__forcePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:324 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__forcePerVolumeMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__forcePerVolumeMeasure (57)
/* Type witsml1__forcePerVolumeMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:forcePerVolumeMeasure simple type: */
class SOAP_CMAC witsml1__forcePerVolumeMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__ForcePerVolumeUom uom;	/* required attribute of XSD type witsml1:ForcePerVolumeUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__forcePerVolumeMeasure (57)
	virtual int soap_type(void) const { return 57; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__forcePerVolumeMeasure, default initialized and not managed by a soap context
	virtual witsml1__forcePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__forcePerVolumeMeasure); }
	         witsml1__forcePerVolumeMeasure() { witsml1__forcePerVolumeMeasure::soap_default(NULL); }
	virtual ~witsml1__forcePerVolumeMeasure() { }
	friend witsml1__forcePerVolumeMeasure *soap_instantiate_witsml1__forcePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:327 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__illuminanceMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__illuminanceMeasure (58)
/* Type witsml1__illuminanceMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:illuminanceMeasure simple type: */
class SOAP_CMAC witsml1__illuminanceMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__IlluminanceUom uom;	/* required attribute of XSD type witsml1:IlluminanceUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__illuminanceMeasure (58)
	virtual int soap_type(void) const { return 58; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__illuminanceMeasure, default initialized and not managed by a soap context
	virtual witsml1__illuminanceMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__illuminanceMeasure); }
	         witsml1__illuminanceMeasure() { witsml1__illuminanceMeasure::soap_default(NULL); }
	virtual ~witsml1__illuminanceMeasure() { }
	friend witsml1__illuminanceMeasure *soap_instantiate_witsml1__illuminanceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:330 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__lengthMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__lengthMeasure (59)
/* Type witsml1__lengthMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:lengthMeasure simple type: */
class SOAP_CMAC witsml1__lengthMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__LengthUom uom;	/* required attribute of XSD type witsml1:LengthUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__lengthMeasure (59)
	virtual int soap_type(void) const { return 59; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__lengthMeasure, default initialized and not managed by a soap context
	virtual witsml1__lengthMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__lengthMeasure); }
	         witsml1__lengthMeasure() { witsml1__lengthMeasure::soap_default(NULL); }
	virtual ~witsml1__lengthMeasure() { }
	friend witsml1__lengthMeasure *soap_instantiate_witsml1__lengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:333 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__lengthPerLengthMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__lengthPerLengthMeasure (60)
/* Type witsml1__lengthPerLengthMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:lengthPerLengthMeasure simple type: */
class SOAP_CMAC witsml1__lengthPerLengthMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__LengthPerLengthUom uom;	/* required attribute of XSD type witsml1:LengthPerLengthUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__lengthPerLengthMeasure (60)
	virtual int soap_type(void) const { return 60; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__lengthPerLengthMeasure, default initialized and not managed by a soap context
	virtual witsml1__lengthPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__lengthPerLengthMeasure); }
	         witsml1__lengthPerLengthMeasure() { witsml1__lengthPerLengthMeasure::soap_default(NULL); }
	virtual ~witsml1__lengthPerLengthMeasure() { }
	friend witsml1__lengthPerLengthMeasure *soap_instantiate_witsml1__lengthPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:336 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__magneticInductionMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__magneticInductionMeasure (61)
/* Type witsml1__magneticInductionMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:magneticInductionMeasure simple type: */
class SOAP_CMAC witsml1__magneticInductionMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__MagneticInductionUom uom;	/* required attribute of XSD type witsml1:MagneticInductionUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__magneticInductionMeasure (61)
	virtual int soap_type(void) const { return 61; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__magneticInductionMeasure, default initialized and not managed by a soap context
	virtual witsml1__magneticInductionMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__magneticInductionMeasure); }
	         witsml1__magneticInductionMeasure() { witsml1__magneticInductionMeasure::soap_default(NULL); }
	virtual ~witsml1__magneticInductionMeasure() { }
	friend witsml1__magneticInductionMeasure *soap_instantiate_witsml1__magneticInductionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:339 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__massConcentrationMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__massConcentrationMeasure (62)
/* Type witsml1__massConcentrationMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:massConcentrationMeasure simple type: */
class SOAP_CMAC witsml1__massConcentrationMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__MassConcentrationUom uom;	/* required attribute of XSD type witsml1:MassConcentrationUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__massConcentrationMeasure (62)
	virtual int soap_type(void) const { return 62; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__massConcentrationMeasure, default initialized and not managed by a soap context
	virtual witsml1__massConcentrationMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__massConcentrationMeasure); }
	         witsml1__massConcentrationMeasure() { witsml1__massConcentrationMeasure::soap_default(NULL); }
	virtual ~witsml1__massConcentrationMeasure() { }
	friend witsml1__massConcentrationMeasure *soap_instantiate_witsml1__massConcentrationMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:342 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__massMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__massMeasure (63)
/* Type witsml1__massMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:massMeasure simple type: */
class SOAP_CMAC witsml1__massMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__MassUom uom;	/* required attribute of XSD type witsml1:MassUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__massMeasure (63)
	virtual int soap_type(void) const { return 63; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__massMeasure, default initialized and not managed by a soap context
	virtual witsml1__massMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__massMeasure); }
	         witsml1__massMeasure() { witsml1__massMeasure::soap_default(NULL); }
	virtual ~witsml1__massMeasure() { }
	friend witsml1__massMeasure *soap_instantiate_witsml1__massMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:345 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__massPerLengthMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__massPerLengthMeasure (64)
/* Type witsml1__massPerLengthMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:massPerLengthMeasure simple type: */
class SOAP_CMAC witsml1__massPerLengthMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__MassPerLengthUom uom;	/* required attribute of XSD type witsml1:MassPerLengthUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__massPerLengthMeasure (64)
	virtual int soap_type(void) const { return 64; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__massPerLengthMeasure, default initialized and not managed by a soap context
	virtual witsml1__massPerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__massPerLengthMeasure); }
	         witsml1__massPerLengthMeasure() { witsml1__massPerLengthMeasure::soap_default(NULL); }
	virtual ~witsml1__massPerLengthMeasure() { }
	friend witsml1__massPerLengthMeasure *soap_instantiate_witsml1__massPerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:348 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__momentOfForceMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__momentOfForceMeasure (65)
/* Type witsml1__momentOfForceMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:momentOfForceMeasure simple type: */
class SOAP_CMAC witsml1__momentOfForceMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__MomentOfForceUom uom;	/* required attribute of XSD type witsml1:MomentOfForceUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__momentOfForceMeasure (65)
	virtual int soap_type(void) const { return 65; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__momentOfForceMeasure, default initialized and not managed by a soap context
	virtual witsml1__momentOfForceMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__momentOfForceMeasure); }
	         witsml1__momentOfForceMeasure() { witsml1__momentOfForceMeasure::soap_default(NULL); }
	virtual ~witsml1__momentOfForceMeasure() { }
	friend witsml1__momentOfForceMeasure *soap_instantiate_witsml1__momentOfForceMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:351 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__perLengthMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__perLengthMeasure (66)
/* Type witsml1__perLengthMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:perLengthMeasure simple type: */
class SOAP_CMAC witsml1__perLengthMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__PerLengthUom uom;	/* required attribute of XSD type witsml1:PerLengthUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__perLengthMeasure (66)
	virtual int soap_type(void) const { return 66; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__perLengthMeasure, default initialized and not managed by a soap context
	virtual witsml1__perLengthMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__perLengthMeasure); }
	         witsml1__perLengthMeasure() { witsml1__perLengthMeasure::soap_default(NULL); }
	virtual ~witsml1__perLengthMeasure() { }
	friend witsml1__perLengthMeasure *soap_instantiate_witsml1__perLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:354 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__permeabilityRockMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__permeabilityRockMeasure (67)
/* Type witsml1__permeabilityRockMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:permeabilityRockMeasure simple type: */
class SOAP_CMAC witsml1__permeabilityRockMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__PermeabilityRockUom uom;	/* required attribute of XSD type witsml1:PermeabilityRockUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__permeabilityRockMeasure (67)
	virtual int soap_type(void) const { return 67; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__permeabilityRockMeasure, default initialized and not managed by a soap context
	virtual witsml1__permeabilityRockMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__permeabilityRockMeasure); }
	         witsml1__permeabilityRockMeasure() { witsml1__permeabilityRockMeasure::soap_default(NULL); }
	virtual ~witsml1__permeabilityRockMeasure() { }
	friend witsml1__permeabilityRockMeasure *soap_instantiate_witsml1__permeabilityRockMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:357 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__planeAngleMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__planeAngleMeasure (68)
/* Type witsml1__planeAngleMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:planeAngleMeasure simple type: */
class SOAP_CMAC witsml1__planeAngleMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__PlaneAngleUom uom;	/* required attribute of XSD type witsml1:PlaneAngleUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__planeAngleMeasure (68)
	virtual int soap_type(void) const { return 68; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__planeAngleMeasure, default initialized and not managed by a soap context
	virtual witsml1__planeAngleMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__planeAngleMeasure); }
	         witsml1__planeAngleMeasure() { witsml1__planeAngleMeasure::soap_default(NULL); }
	virtual ~witsml1__planeAngleMeasure() { }
	friend witsml1__planeAngleMeasure *soap_instantiate_witsml1__planeAngleMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:360 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__powerMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__powerMeasure (69)
/* Type witsml1__powerMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:powerMeasure simple type: */
class SOAP_CMAC witsml1__powerMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__PowerUom uom;	/* required attribute of XSD type witsml1:PowerUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__powerMeasure (69)
	virtual int soap_type(void) const { return 69; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__powerMeasure, default initialized and not managed by a soap context
	virtual witsml1__powerMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__powerMeasure); }
	         witsml1__powerMeasure() { witsml1__powerMeasure::soap_default(NULL); }
	virtual ~witsml1__powerMeasure() { }
	friend witsml1__powerMeasure *soap_instantiate_witsml1__powerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:363 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__pressureMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__pressureMeasure (70)
/* Type witsml1__pressureMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:pressureMeasure simple type: */
class SOAP_CMAC witsml1__pressureMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__PressureUom uom;	/* required attribute of XSD type witsml1:PressureUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__pressureMeasure (70)
	virtual int soap_type(void) const { return 70; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__pressureMeasure, default initialized and not managed by a soap context
	virtual witsml1__pressureMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__pressureMeasure); }
	         witsml1__pressureMeasure() { witsml1__pressureMeasure::soap_default(NULL); }
	virtual ~witsml1__pressureMeasure() { }
	friend witsml1__pressureMeasure *soap_instantiate_witsml1__pressureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:366 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__relativePowerMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__relativePowerMeasure (71)
/* Type witsml1__relativePowerMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:relativePowerMeasure simple type: */
class SOAP_CMAC witsml1__relativePowerMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__RelativePowerUom uom;	/* required attribute of XSD type witsml1:RelativePowerUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__relativePowerMeasure (71)
	virtual int soap_type(void) const { return 71; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__relativePowerMeasure, default initialized and not managed by a soap context
	virtual witsml1__relativePowerMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__relativePowerMeasure); }
	         witsml1__relativePowerMeasure() { witsml1__relativePowerMeasure::soap_default(NULL); }
	virtual ~witsml1__relativePowerMeasure() { }
	friend witsml1__relativePowerMeasure *soap_instantiate_witsml1__relativePowerMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:369 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__specificHeatCapacityMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__specificHeatCapacityMeasure (72)
/* Type witsml1__specificHeatCapacityMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:specificHeatCapacityMeasure simple type: */
class SOAP_CMAC witsml1__specificHeatCapacityMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__SpecificHeatCapacityUom uom;	/* required attribute of XSD type witsml1:SpecificHeatCapacityUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__specificHeatCapacityMeasure (72)
	virtual int soap_type(void) const { return 72; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__specificHeatCapacityMeasure, default initialized and not managed by a soap context
	virtual witsml1__specificHeatCapacityMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__specificHeatCapacityMeasure); }
	         witsml1__specificHeatCapacityMeasure() { witsml1__specificHeatCapacityMeasure::soap_default(NULL); }
	virtual ~witsml1__specificHeatCapacityMeasure() { }
	friend witsml1__specificHeatCapacityMeasure *soap_instantiate_witsml1__specificHeatCapacityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:372 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__specificVolumeMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__specificVolumeMeasure (73)
/* Type witsml1__specificVolumeMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:specificVolumeMeasure simple type: */
class SOAP_CMAC witsml1__specificVolumeMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__SpecificVolumeUom uom;	/* required attribute of XSD type witsml1:SpecificVolumeUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__specificVolumeMeasure (73)
	virtual int soap_type(void) const { return 73; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__specificVolumeMeasure, default initialized and not managed by a soap context
	virtual witsml1__specificVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__specificVolumeMeasure); }
	         witsml1__specificVolumeMeasure() { witsml1__specificVolumeMeasure::soap_default(NULL); }
	virtual ~witsml1__specificVolumeMeasure() { }
	friend witsml1__specificVolumeMeasure *soap_instantiate_witsml1__specificVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:375 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__standardVolumeMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__standardVolumeMeasure (74)
/* Type witsml1__standardVolumeMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:standardVolumeMeasure simple type: */
class SOAP_CMAC witsml1__standardVolumeMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__StandardVolumeUom uom;	/* required attribute of XSD type witsml1:StandardVolumeUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__standardVolumeMeasure (74)
	virtual int soap_type(void) const { return 74; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__standardVolumeMeasure, default initialized and not managed by a soap context
	virtual witsml1__standardVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__standardVolumeMeasure); }
	         witsml1__standardVolumeMeasure() { witsml1__standardVolumeMeasure::soap_default(NULL); }
	virtual ~witsml1__standardVolumeMeasure() { }
	friend witsml1__standardVolumeMeasure *soap_instantiate_witsml1__standardVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:378 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__standardVolumePerTimeMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__standardVolumePerTimeMeasure (75)
/* Type witsml1__standardVolumePerTimeMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:standardVolumePerTimeMeasure simple type: */
class SOAP_CMAC witsml1__standardVolumePerTimeMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__StandardVolumePerTimeUom uom;	/* required attribute of XSD type witsml1:StandardVolumePerTimeUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__standardVolumePerTimeMeasure (75)
	virtual int soap_type(void) const { return 75; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__standardVolumePerTimeMeasure, default initialized and not managed by a soap context
	virtual witsml1__standardVolumePerTimeMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__standardVolumePerTimeMeasure); }
	         witsml1__standardVolumePerTimeMeasure() { witsml1__standardVolumePerTimeMeasure::soap_default(NULL); }
	virtual ~witsml1__standardVolumePerTimeMeasure() { }
	friend witsml1__standardVolumePerTimeMeasure *soap_instantiate_witsml1__standardVolumePerTimeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:381 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__thermalConductivityMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__thermalConductivityMeasure (76)
/* Type witsml1__thermalConductivityMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:thermalConductivityMeasure simple type: */
class SOAP_CMAC witsml1__thermalConductivityMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__ThermalConductivityUom uom;	/* required attribute of XSD type witsml1:ThermalConductivityUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__thermalConductivityMeasure (76)
	virtual int soap_type(void) const { return 76; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__thermalConductivityMeasure, default initialized and not managed by a soap context
	virtual witsml1__thermalConductivityMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__thermalConductivityMeasure); }
	         witsml1__thermalConductivityMeasure() { witsml1__thermalConductivityMeasure::soap_default(NULL); }
	virtual ~witsml1__thermalConductivityMeasure() { }
	friend witsml1__thermalConductivityMeasure *soap_instantiate_witsml1__thermalConductivityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:384 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__thermalVolumetricExpansionMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__thermalVolumetricExpansionMeasure (77)
/* Type witsml1__thermalVolumetricExpansionMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:thermalVolumetricExpansionMeasure simple type: */
class SOAP_CMAC witsml1__thermalVolumetricExpansionMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__ThermalVolumetricExpansionUom uom;	/* required attribute of XSD type witsml1:ThermalVolumetricExpansionUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__thermalVolumetricExpansionMeasure (77)
	virtual int soap_type(void) const { return 77; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__thermalVolumetricExpansionMeasure, default initialized and not managed by a soap context
	virtual witsml1__thermalVolumetricExpansionMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__thermalVolumetricExpansionMeasure); }
	         witsml1__thermalVolumetricExpansionMeasure() { witsml1__thermalVolumetricExpansionMeasure::soap_default(NULL); }
	virtual ~witsml1__thermalVolumetricExpansionMeasure() { }
	friend witsml1__thermalVolumetricExpansionMeasure *soap_instantiate_witsml1__thermalVolumetricExpansionMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:387 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__thermodynamicTemperatureMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__thermodynamicTemperatureMeasure (78)
/* Type witsml1__thermodynamicTemperatureMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:thermodynamicTemperatureMeasure simple type: */
class SOAP_CMAC witsml1__thermodynamicTemperatureMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__ThermodynamicTemperatureUom uom;	/* required attribute of XSD type witsml1:ThermodynamicTemperatureUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__thermodynamicTemperatureMeasure (78)
	virtual int soap_type(void) const { return 78; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__thermodynamicTemperatureMeasure, default initialized and not managed by a soap context
	virtual witsml1__thermodynamicTemperatureMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__thermodynamicTemperatureMeasure); }
	         witsml1__thermodynamicTemperatureMeasure() { witsml1__thermodynamicTemperatureMeasure::soap_default(NULL); }
	virtual ~witsml1__thermodynamicTemperatureMeasure() { }
	friend witsml1__thermodynamicTemperatureMeasure *soap_instantiate_witsml1__thermodynamicTemperatureMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:390 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timeMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timeMeasure (79)
/* Type witsml1__timeMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:timeMeasure simple type: */
class SOAP_CMAC witsml1__timeMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__TimeUom uom;	/* required attribute of XSD type witsml1:TimeUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timeMeasure (79)
	virtual int soap_type(void) const { return 79; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__timeMeasure, default initialized and not managed by a soap context
	virtual witsml1__timeMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__timeMeasure); }
	         witsml1__timeMeasure() { witsml1__timeMeasure::soap_default(NULL); }
	virtual ~witsml1__timeMeasure() { }
	friend witsml1__timeMeasure *soap_instantiate_witsml1__timeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:393 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__velocityMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__velocityMeasure (80)
/* Type witsml1__velocityMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:velocityMeasure simple type: */
class SOAP_CMAC witsml1__velocityMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__VelocityUom uom;	/* required attribute of XSD type witsml1:VelocityUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__velocityMeasure (80)
	virtual int soap_type(void) const { return 80; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__velocityMeasure, default initialized and not managed by a soap context
	virtual witsml1__velocityMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__velocityMeasure); }
	         witsml1__velocityMeasure() { witsml1__velocityMeasure::soap_default(NULL); }
	virtual ~witsml1__velocityMeasure() { }
	friend witsml1__velocityMeasure *soap_instantiate_witsml1__velocityMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:396 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumeMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumeMeasure (81)
/* Type witsml1__volumeMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:volumeMeasure simple type: */
class SOAP_CMAC witsml1__volumeMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__VolumeUom uom;	/* required attribute of XSD type witsml1:VolumeUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumeMeasure (81)
	virtual int soap_type(void) const { return 81; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__volumeMeasure, default initialized and not managed by a soap context
	virtual witsml1__volumeMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__volumeMeasure); }
	         witsml1__volumeMeasure() { witsml1__volumeMeasure::soap_default(NULL); }
	virtual ~witsml1__volumeMeasure() { }
	friend witsml1__volumeMeasure *soap_instantiate_witsml1__volumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:399 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumeFlowRateMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumeFlowRateMeasure (82)
/* Type witsml1__volumeFlowRateMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:volumeFlowRateMeasure simple type: */
class SOAP_CMAC witsml1__volumeFlowRateMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__VolumeFlowRateUom uom;	/* required attribute of XSD type witsml1:VolumeFlowRateUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumeFlowRateMeasure (82)
	virtual int soap_type(void) const { return 82; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__volumeFlowRateMeasure, default initialized and not managed by a soap context
	virtual witsml1__volumeFlowRateMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__volumeFlowRateMeasure); }
	         witsml1__volumeFlowRateMeasure() { witsml1__volumeFlowRateMeasure::soap_default(NULL); }
	virtual ~witsml1__volumeFlowRateMeasure() { }
	friend witsml1__volumeFlowRateMeasure *soap_instantiate_witsml1__volumeFlowRateMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:402 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumePerLengthMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumePerLengthMeasure (83)
/* Type witsml1__volumePerLengthMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:volumePerLengthMeasure simple type: */
class SOAP_CMAC witsml1__volumePerLengthMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__VolumePerLengthUom uom;	/* required attribute of XSD type witsml1:VolumePerLengthUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumePerLengthMeasure (83)
	virtual int soap_type(void) const { return 83; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__volumePerLengthMeasure, default initialized and not managed by a soap context
	virtual witsml1__volumePerLengthMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__volumePerLengthMeasure); }
	         witsml1__volumePerLengthMeasure() { witsml1__volumePerLengthMeasure::soap_default(NULL); }
	virtual ~witsml1__volumePerLengthMeasure() { }
	friend witsml1__volumePerLengthMeasure *soap_instantiate_witsml1__volumePerLengthMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:405 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumePerVolumeMeasure
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumePerVolumeMeasure (84)
/* Type witsml1__volumePerVolumeMeasure is a recursive data type (in)directly referencing itself through its (base) class members */
/* witsml1:volumePerVolumeMeasure simple type: */
class SOAP_CMAC witsml1__volumePerVolumeMeasure : public witsml1__abstractMeasure
{
public:
	enum witsml1__VolumePerVolumeUom uom;	/* required attribute of XSD type witsml1:VolumePerVolumeUom */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__volumePerVolumeMeasure (84)
	virtual int soap_type(void) const { return 84; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__volumePerVolumeMeasure, default initialized and not managed by a soap context
	virtual witsml1__volumePerVolumeMeasure *soap_alloc(void) const { return SOAP_NEW(witsml1__volumePerVolumeMeasure); }
	         witsml1__volumePerVolumeMeasure() { witsml1__volumePerVolumeMeasure::soap_default(NULL); }
	virtual ~witsml1__volumePerVolumeMeasure() { }
	friend witsml1__volumePerVolumeMeasure *soap_instantiate_witsml1__volumePerVolumeMeasure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:540 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__IdentifiedObjectType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__IdentifiedObjectType (129)
/* Type gml__IdentifiedObjectType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:IdentifiedObjectType complex type: */
class SOAP_CMAC gml__IdentifiedObjectType : public gml__DefinitionType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__IdentifiedObjectType (129)
	virtual int soap_type(void) const { return 129; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__IdentifiedObjectType, default initialized and not managed by a soap context
	virtual gml__IdentifiedObjectType *soap_alloc(void) const { return SOAP_NEW(gml__IdentifiedObjectType); }
	         gml__IdentifiedObjectType() { gml__IdentifiedObjectType::soap_default(NULL); }
	virtual ~gml__IdentifiedObjectType() { }
	friend gml__IdentifiedObjectType *soap_instantiate_gml__IdentifiedObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:237 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timestampedCommentString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timestampedCommentString (28)
/* witsml1:timestampedCommentString simple type: */
class SOAP_CMAC witsml1__timestampedCommentString
{
public:
	std::string __item;	/* mixed XML content */
	time_t dTim;	/* required attribute of XSD type witsml1:timestamp */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timestampedCommentString (28)
	virtual int soap_type(void) const { return 28; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type witsml1__timestampedCommentString, default initialized and not managed by a soap context
	virtual witsml1__timestampedCommentString *soap_alloc(void) const { return SOAP_NEW(witsml1__timestampedCommentString); }
	         witsml1__timestampedCommentString() { witsml1__timestampedCommentString::soap_default(NULL); }
	virtual ~witsml1__timestampedCommentString() { }
	friend witsml1__timestampedCommentString *soap_instantiate_witsml1__timestampedCommentString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:537 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractCRSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractCRSType (128)
/* Type gml__AbstractCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractCRSType complex type: */
class SOAP_CMAC gml__AbstractCRSType : public gml__IdentifiedObjectType
{
public:
	std::vector<_gml__domainOfValidity *> domainOfValidity;	/* optional element of XSD type gml:domainOfValidity */
	std::vector<std::string> scope;	/* required element of XSD type xsd:string */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractCRSType (128)
	virtual int soap_type(void) const { return 128; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractCRSType, default initialized and not managed by a soap context
	virtual gml__AbstractCRSType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCRSType); }
	         gml__AbstractCRSType() { gml__AbstractCRSType::soap_default(NULL); }
	virtual ~gml__AbstractCRSType() { }
	friend gml__AbstractCRSType *soap_instantiate_gml__AbstractCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:582 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractCoordinateSystemType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractCoordinateSystemType (143)
/* Type gml__AbstractCoordinateSystemType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractCoordinateSystemType complex type: */
class SOAP_CMAC gml__AbstractCoordinateSystemType : public gml__IdentifiedObjectType
{
public:
	std::vector<gml__CoordinateSystemAxisPropertyType *> axis;	/* required element of XSD type gml:CoordinateSystemAxisPropertyType */
	enum gml__AggregationType *aggregationType;	/* optional attribute of XSD type gml:AggregationType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractCoordinateSystemType (143)
	virtual int soap_type(void) const { return 143; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractCoordinateSystemType, default initialized and not managed by a soap context
	virtual gml__AbstractCoordinateSystemType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCoordinateSystemType); }
	         gml__AbstractCoordinateSystemType() { gml__AbstractCoordinateSystemType::soap_default(NULL); }
	virtual ~gml__AbstractCoordinateSystemType() { }
	friend gml__AbstractCoordinateSystemType *soap_instantiate_gml__AbstractCoordinateSystemType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:588 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CoordinateSystemAxisType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CoordinateSystemAxisType (145)
/* Type gml__CoordinateSystemAxisType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:CoordinateSystemAxisType complex type: */
class SOAP_CMAC gml__CoordinateSystemAxisType : public gml__IdentifiedObjectType
{
public:
	gml__CodeType *axisAbbrev;	/* required element of XSD type gml:CodeType */
	gml__CodeWithAuthorityType *axisDirection;	/* required element of XSD type gml:CodeWithAuthorityType */
	double *minimumValue;	/* optional element of XSD type xsd:double */
	double *maximumValue;	/* optional element of XSD type xsd:double */
	gml__CodeWithAuthorityType *rangeMeaning;	/* optional element of XSD type gml:CodeWithAuthorityType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CoordinateSystemAxisType (145)
	virtual int soap_type(void) const { return 145; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CoordinateSystemAxisType, default initialized and not managed by a soap context
	virtual gml__CoordinateSystemAxisType *soap_alloc(void) const { return SOAP_NEW(gml__CoordinateSystemAxisType); }
	         gml__CoordinateSystemAxisType() { gml__CoordinateSystemAxisType::soap_default(NULL); }
	virtual ~gml__CoordinateSystemAxisType() { }
	friend gml__CoordinateSystemAxisType *soap_instantiate_gml__CoordinateSystemAxisType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:609 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractDatumType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractDatumType (152)
/* Type gml__AbstractDatumType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractDatumType complex type: */
class SOAP_CMAC gml__AbstractDatumType : public gml__IdentifiedObjectType
{
public:
	_gml__domainOfValidity *domainOfValidity;	/* optional element of XSD type gml:domainOfValidity */
	std::vector<std::string> scope;	/* required element of XSD type xsd:string */
	gml__CodeType *anchorDefinition;	/* optional element of XSD type gml:CodeType */
	std::string *realizationEpoch;	/* optional element of XSD type xsd:date */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractDatumType (152)
	virtual int soap_type(void) const { return 152; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractDatumType, default initialized and not managed by a soap context
	virtual gml__AbstractDatumType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractDatumType); }
	         gml__AbstractDatumType() { gml__AbstractDatumType::soap_default(NULL); }
	virtual ~gml__AbstractDatumType() { }
	friend gml__AbstractDatumType *soap_instantiate_gml__AbstractDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:615 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__PrimeMeridianType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__PrimeMeridianType (154)
/* Type gml__PrimeMeridianType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:PrimeMeridianType complex type: */
class SOAP_CMAC gml__PrimeMeridianType : public gml__IdentifiedObjectType
{
public:
	gml__AngleType *greenwichLongitude;	/* required element of XSD type gml:AngleType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__PrimeMeridianType (154)
	virtual int soap_type(void) const { return 154; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__PrimeMeridianType, default initialized and not managed by a soap context
	virtual gml__PrimeMeridianType *soap_alloc(void) const { return SOAP_NEW(gml__PrimeMeridianType); }
	         gml__PrimeMeridianType() { gml__PrimeMeridianType::soap_default(NULL); }
	virtual ~gml__PrimeMeridianType() { }
	friend gml__PrimeMeridianType *soap_instantiate_gml__PrimeMeridianType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:627 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidType (158)
/* Type gml__EllipsoidType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:EllipsoidType complex type: */
class SOAP_CMAC gml__EllipsoidType : public gml__IdentifiedObjectType
{
public:
	gml__MeasureType *semiMajorAxis;	/* required element of XSD type gml:MeasureType */
	_gml__secondDefiningParameter *secondDefiningParameter;	/* required element of XSD type gml:secondDefiningParameter */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidType (158)
	virtual int soap_type(void) const { return 158; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__EllipsoidType, default initialized and not managed by a soap context
	virtual gml__EllipsoidType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidType); }
	         gml__EllipsoidType() { gml__EllipsoidType::soap_default(NULL); }
	virtual ~gml__EllipsoidType() { }
	friend gml__EllipsoidType *soap_instantiate_gml__EllipsoidType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:645 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractCoordinateOperationType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractCoordinateOperationType (164)
/* Type gml__AbstractCoordinateOperationType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractCoordinateOperationType complex type: */
class SOAP_CMAC gml__AbstractCoordinateOperationType : public gml__IdentifiedObjectType
{
public:
	_gml__domainOfValidity *domainOfValidity;	/* optional element of XSD type gml:domainOfValidity */
	std::vector<std::string> scope;	/* required element of XSD type xsd:string */
	std::string *operationVersion;	/* optional element of XSD type xsd:string */
	std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;	/* optional element of XSD type gml:coordinateOperationAccuracy */
	gml__CRSPropertyType *sourceCRS;	/* optional element of XSD type gml:CRSPropertyType */
	gml__CRSPropertyType *targetCRS;	/* optional element of XSD type gml:CRSPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractCoordinateOperationType (164)
	virtual int soap_type(void) const { return 164; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractCoordinateOperationType, default initialized and not managed by a soap context
	virtual gml__AbstractCoordinateOperationType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractCoordinateOperationType); }
	         gml__AbstractCoordinateOperationType() { gml__AbstractCoordinateOperationType::soap_default(NULL); }
	virtual ~gml__AbstractCoordinateOperationType() { }
	friend gml__AbstractCoordinateOperationType *soap_instantiate_gml__AbstractCoordinateOperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:18866 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_GeodeticCRSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_GeodeticCRSType (791)
/* xsd:choice complex type: */
union _gml__union_GeodeticCRSType
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__gml__union_GeodeticCRSType_ellipsoidalCS	(1)
	gml__EllipsoidalCSPropertyType *ellipsoidalCS;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gml__union_GeodeticCRSType_cartesianCS	(2)
	gml__CartesianCSPropertyType *cartesianCS;
#define SOAP_UNION_gsoap_witsml1_4_1_1__gml__union_GeodeticCRSType_sphericalCS	(3)
	gml__SphericalCSPropertyType *sphericalCS;
};
#endif

/* witsml1_4_1_1ForGsoap.h:534 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticCRSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticCRSType (127)
/* Type gml__GeodeticCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:GeodeticCRSType complex type: */
class SOAP_CMAC gml__GeodeticCRSType : public gml__AbstractCRSType
{
public:
	int __union_GeodeticCRSType;	/* union discriminant (of union defined below) */
	union _gml__union_GeodeticCRSType union_GeodeticCRSType;
	gml__GeodeticDatumPropertyType *geodeticDatum;	/* required element of XSD type gml:GeodeticDatumPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticCRSType (127)
	virtual int soap_type(void) const { return 127; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeodeticCRSType, default initialized and not managed by a soap context
	virtual gml__GeodeticCRSType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticCRSType); }
	         gml__GeodeticCRSType() { gml__GeodeticCRSType::soap_default(NULL); }
	virtual ~gml__GeodeticCRSType() { }
	friend gml__GeodeticCRSType *soap_instantiate_gml__GeodeticCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:579 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidalCSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidalCSType (142)
/* Type gml__EllipsoidalCSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:EllipsoidalCSType complex type: */
class SOAP_CMAC gml__EllipsoidalCSType : public gml__AbstractCoordinateSystemType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__EllipsoidalCSType (142)
	virtual int soap_type(void) const { return 142; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__EllipsoidalCSType, default initialized and not managed by a soap context
	virtual gml__EllipsoidalCSType *soap_alloc(void) const { return SOAP_NEW(gml__EllipsoidalCSType); }
	         gml__EllipsoidalCSType() { gml__EllipsoidalCSType::soap_default(NULL); }
	virtual ~gml__EllipsoidalCSType() { }
	friend gml__EllipsoidalCSType *soap_instantiate_gml__EllipsoidalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:594 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CartesianCSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CartesianCSType (147)
/* Type gml__CartesianCSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:CartesianCSType complex type: */
class SOAP_CMAC gml__CartesianCSType : public gml__AbstractCoordinateSystemType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__CartesianCSType (147)
	virtual int soap_type(void) const { return 147; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__CartesianCSType, default initialized and not managed by a soap context
	virtual gml__CartesianCSType *soap_alloc(void) const { return SOAP_NEW(gml__CartesianCSType); }
	         gml__CartesianCSType() { gml__CartesianCSType::soap_default(NULL); }
	virtual ~gml__CartesianCSType() { }
	friend gml__CartesianCSType *soap_instantiate_gml__CartesianCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:600 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__SphericalCSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__SphericalCSType (149)
/* Type gml__SphericalCSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:SphericalCSType complex type: */
class SOAP_CMAC gml__SphericalCSType : public gml__AbstractCoordinateSystemType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__SphericalCSType (149)
	virtual int soap_type(void) const { return 149; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__SphericalCSType, default initialized and not managed by a soap context
	virtual gml__SphericalCSType *soap_alloc(void) const { return SOAP_NEW(gml__SphericalCSType); }
	         gml__SphericalCSType() { gml__SphericalCSType::soap_default(NULL); }
	virtual ~gml__SphericalCSType() { }
	friend gml__SphericalCSType *soap_instantiate_gml__SphericalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:606 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticDatumType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticDatumType (151)
/* Type gml__GeodeticDatumType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:GeodeticDatumType complex type: */
class SOAP_CMAC gml__GeodeticDatumType : public gml__AbstractDatumType
{
public:
	gml__PrimeMeridianPropertyType *primeMeridian;	/* required element of XSD type gml:PrimeMeridianPropertyType */
	gml__EllipsoidPropertyType *ellipsoid;	/* required element of XSD type gml:EllipsoidPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__GeodeticDatumType (151)
	virtual int soap_type(void) const { return 151; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__GeodeticDatumType, default initialized and not managed by a soap context
	virtual gml__GeodeticDatumType *soap_alloc(void) const { return SOAP_NEW(gml__GeodeticDatumType); }
	         gml__GeodeticDatumType() { gml__GeodeticDatumType::soap_default(NULL); }
	virtual ~gml__GeodeticDatumType() { }
	friend gml__GeodeticDatumType *soap_instantiate_gml__GeodeticDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:636 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractGeneralDerivedCRSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractGeneralDerivedCRSType (161)
/* Type gml__AbstractGeneralDerivedCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:AbstractGeneralDerivedCRSType complex type: */
class SOAP_CMAC gml__AbstractGeneralDerivedCRSType : public gml__AbstractCRSType
{
public:
	gml__GeneralConversionPropertyType *conversion;	/* required element of XSD type gml:GeneralConversionPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractGeneralDerivedCRSType (161)
	virtual int soap_type(void) const { return 161; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractGeneralDerivedCRSType, default initialized and not managed by a soap context
	virtual gml__AbstractGeneralDerivedCRSType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGeneralDerivedCRSType); }
	         gml__AbstractGeneralDerivedCRSType() { gml__AbstractGeneralDerivedCRSType::soap_default(NULL); }
	virtual ~gml__AbstractGeneralDerivedCRSType() { }
	friend gml__AbstractGeneralDerivedCRSType *soap_instantiate_gml__AbstractGeneralDerivedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:642 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractGeneralConversionType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractGeneralConversionType (163)
/* gml:AbstractGeneralConversionType complex type: */
class SOAP_CMAC gml__AbstractGeneralConversionType
{
public:
	gml__StringOrRefType *description;	/* optional element of XSD type gml:StringOrRefType */
	gml__ReferenceType *descriptionReference;	/* optional element of XSD type gml:ReferenceType */
	gml__CodeWithAuthorityType *identifier;	/* required element of XSD type gml:CodeWithAuthorityType */
	std::vector<gml__CodeType *> name;	/* optional element of XSD type gml:CodeType */
	std::string *remarks;	/* optional element of XSD type xsd:string */
	_gml__domainOfValidity *domainOfValidity;	/* optional element of XSD type gml:domainOfValidity */
	std::vector<std::string> scope;	/* required element of XSD type xsd:string */
	std::vector<_gml__coordinateOperationAccuracy *> coordinateOperationAccuracy;	/* optional element of XSD type gml:coordinateOperationAccuracy */
	std::string gml__id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__AbstractGeneralConversionType (163)
	virtual int soap_type(void) const { return 163; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__AbstractGeneralConversionType, default initialized and not managed by a soap context
	virtual gml__AbstractGeneralConversionType *soap_alloc(void) const { return SOAP_NEW(gml__AbstractGeneralConversionType); }
	         gml__AbstractGeneralConversionType() { gml__AbstractGeneralConversionType::soap_default(NULL); }
	virtual ~gml__AbstractGeneralConversionType() { }
	friend gml__AbstractGeneralConversionType *soap_instantiate_gml__AbstractGeneralConversionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:654 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalCRSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalCRSType (167)
/* Type gml__VerticalCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:VerticalCRSType complex type: */
class SOAP_CMAC gml__VerticalCRSType : public gml__AbstractCRSType
{
public:
	gml__VerticalCSPropertyType *verticalCS;	/* required element of XSD type gml:VerticalCSPropertyType */
	gml__VerticalDatumPropertyType *verticalDatum;	/* required element of XSD type gml:VerticalDatumPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalCRSType (167)
	virtual int soap_type(void) const { return 167; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalCRSType, default initialized and not managed by a soap context
	virtual gml__VerticalCRSType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCRSType); }
	         gml__VerticalCRSType() { gml__VerticalCRSType::soap_default(NULL); }
	virtual ~gml__VerticalCRSType() { }
	friend gml__VerticalCRSType *soap_instantiate_gml__VerticalCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:660 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalCSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalCSType (169)
/* Type gml__VerticalCSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:VerticalCSType complex type: */
class SOAP_CMAC gml__VerticalCSType : public gml__AbstractCoordinateSystemType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalCSType (169)
	virtual int soap_type(void) const { return 169; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalCSType, default initialized and not managed by a soap context
	virtual gml__VerticalCSType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalCSType); }
	         gml__VerticalCSType() { gml__VerticalCSType::soap_default(NULL); }
	virtual ~gml__VerticalCSType() { }
	friend gml__VerticalCSType *soap_instantiate_gml__VerticalCSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:666 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalDatumType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalDatumType (171)
/* Type gml__VerticalDatumType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:VerticalDatumType complex type: */
class SOAP_CMAC gml__VerticalDatumType : public gml__AbstractDatumType
{
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__VerticalDatumType (171)
	virtual int soap_type(void) const { return 171; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__VerticalDatumType, default initialized and not managed by a soap context
	virtual gml__VerticalDatumType *soap_alloc(void) const { return SOAP_NEW(gml__VerticalDatumType); }
	         gml__VerticalDatumType() { gml__VerticalDatumType::soap_default(NULL); }
	virtual ~gml__VerticalDatumType() { }
	friend gml__VerticalDatumType *soap_instantiate_gml__VerticalDatumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:19342 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_ProjectedCRSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__union_ProjectedCRSType (799)
/* xsd:choice complex type: */
union _gml__union_ProjectedCRSType
{
#define SOAP_UNION_gsoap_witsml1_4_1_1__gml__union_ProjectedCRSType_baseGeodeticCRS	(1)
	gml__GeodeticCRSPropertyType *baseGeodeticCRS;
};
#endif

/* witsml1_4_1_1ForGsoap.h:633 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__ProjectedCRSType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__ProjectedCRSType (160)
/* Type gml__ProjectedCRSType is a recursive data type (in)directly referencing itself through its (base) class members */
/* gml:ProjectedCRSType complex type: */
class SOAP_CMAC gml__ProjectedCRSType : public gml__AbstractGeneralDerivedCRSType
{
public:
	int __union_ProjectedCRSType;	/* union discriminant (of union defined below) */
	union _gml__union_ProjectedCRSType union_ProjectedCRSType;
	gml__CartesianCSPropertyType *cartesianCS;	/* required element of XSD type gml:CartesianCSPropertyType */
public:
	/// Return the unique type ID value SOAP_TYPE_gsoap_witsml1_4_1_1_gml__ProjectedCRSType (160)
	virtual int soap_type(void) const { return 160; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type gml__ProjectedCRSType, default initialized and not managed by a soap context
	virtual gml__ProjectedCRSType *soap_alloc(void) const { return SOAP_NEW(gml__ProjectedCRSType); }
	         gml__ProjectedCRSType() { gml__ProjectedCRSType::soap_default(NULL); }
	virtual ~gml__ProjectedCRSType() { }
	friend gml__ProjectedCRSType *soap_instantiate_gml__ProjectedCRSType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* witsml1_4_1_1ForGsoap.h:20564 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Header
#define SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Header (877)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 877; } /* = unique type id SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	virtual ~SOAP_ENV__Header() { }
	friend SOAP_ENV__Header *soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* witsml1_4_1_1ForGsoap.h:20564 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Code
#define SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Code (878)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 878; } /* = unique type id SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	virtual ~SOAP_ENV__Code() { }
	friend SOAP_ENV__Code *soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* witsml1_4_1_1ForGsoap.h:20564 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Detail
#define SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Detail (880)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 880; } /* = unique type id SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	virtual ~SOAP_ENV__Detail() { }
	friend SOAP_ENV__Detail *soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* witsml1_4_1_1ForGsoap.h:20564 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Reason
#define SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Reason (883)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 883; } /* = unique type id SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	virtual ~SOAP_ENV__Reason() { }
	friend SOAP_ENV__Reason *soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* witsml1_4_1_1ForGsoap.h:20564 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Fault
#define SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Fault (884)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 884; } /* = unique type id SOAP_TYPE_gsoap_witsml1_4_1_1_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	virtual ~SOAP_ENV__Fault() { }
	friend SOAP_ENV__Fault *soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* witsml1_4_1_1ForGsoap.h:1 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__QName
#define SOAP_TYPE_gsoap_witsml1_4_1_1__QName (5)
typedef char *_QName;
#endif

/* witsml1_4_1_1ForGsoap.h:1 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__XML
#define SOAP_TYPE_gsoap_witsml1_4_1_1__XML (6)
typedef char *_XML;
#endif

/* witsml1_4_1_1ForGsoap.h:181 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_xsd__ID
#define SOAP_TYPE_gsoap_witsml1_4_1_1_xsd__ID (12)
typedef std::string xsd__ID;
#endif

/* witsml1_4_1_1ForGsoap.h:184 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_xsd__anyURI
#define SOAP_TYPE_gsoap_witsml1_4_1_1_xsd__anyURI (13)
typedef std::string xsd__anyURI;
#endif

/* witsml1_4_1_1ForGsoap.h:187 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_xsd__date
#define SOAP_TYPE_gsoap_witsml1_4_1_1_xsd__date (14)
typedef std::string xsd__date;
#endif

/* witsml1_4_1_1ForGsoap.h:826 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__listOfString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__listOfString (220)
typedef std::string witsml1__listOfString;
#endif

/* witsml1_4_1_1ForGsoap.h:845 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__NilReasonType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__NilReasonType (221)
typedef std::string gml__NilReasonType;
#endif

/* witsml1_4_1_1ForGsoap.h:849 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__NilReasonEnumeration
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__NilReasonEnumeration (222)
typedef std::string gml__NilReasonEnumeration;
#endif

/* witsml1_4_1_1ForGsoap.h:852 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__UomIdentifier
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__UomIdentifier (223)
typedef std::string gml__UomIdentifier;
#endif

/* witsml1_4_1_1ForGsoap.h:887 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Date_USCOREType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gco__Date_USCOREType (224)
typedef std::string gco__Date_USCOREType;
#endif

/* witsml1_4_1_1ForGsoap.h:905 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractBoolean
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractBoolean (226)
typedef bool witsml1__abstractBoolean;
#endif

/* witsml1_4_1_1ForGsoap.h:915 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractDateTime
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractDateTime (228)
typedef time_t witsml1__abstractDateTime;
#endif

/* witsml1_4_1_1ForGsoap.h:925 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractDate
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractDate (229)
typedef std::string witsml1__abstractDate;
#endif

/* witsml1_4_1_1ForGsoap.h:934 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractDouble
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractDouble (231)
typedef double witsml1__abstractDouble;
#endif

/* witsml1_4_1_1ForGsoap.h:943 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractShort
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractShort (233)
typedef short witsml1__abstractShort;
#endif

/* witsml1_4_1_1ForGsoap.h:952 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractInt
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractInt (234)
typedef int witsml1__abstractInt;
#endif

/* witsml1_4_1_1ForGsoap.h:966 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractString (235)
typedef std::string witsml1__abstractString;
#endif

/* witsml1_4_1_1ForGsoap.h:978 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractUncollapsedString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractUncollapsedString (236)
typedef std::string witsml1__abstractUncollapsedString;
#endif

/* witsml1_4_1_1ForGsoap.h:1002 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__UomSymbol
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__UomSymbol (237)
typedef std::string gml__UomSymbol;
#endif

/* witsml1_4_1_1ForGsoap.h:1012 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_gml__UomURI
#define SOAP_TYPE_gsoap_witsml1_4_1_1_gml__UomURI (238)
typedef std::string gml__UomURI;
#endif

/* witsml1_4_1_1ForGsoap.h:1105 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__date
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__date (242)
typedef witsml1__abstractDate witsml1__date;
#endif

/* witsml1_4_1_1ForGsoap.h:1115 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timestamp
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timestamp (243)
typedef time_t witsml1__timestamp;
#endif

/* witsml1_4_1_1ForGsoap.h:1124 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__calendarYear
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__calendarYear (244)
typedef witsml1__abstractInt witsml1__calendarYear;
#endif

/* witsml1_4_1_1ForGsoap.h:1131 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__logicalBoolean
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__logicalBoolean (245)
typedef witsml1__abstractBoolean witsml1__logicalBoolean;
#endif

/* witsml1_4_1_1ForGsoap.h:1138 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__unitlessQuantity
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__unitlessQuantity (246)
typedef witsml1__abstractDouble witsml1__unitlessQuantity;
#endif

/* witsml1_4_1_1ForGsoap.h:1146 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__shortDescriptionString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__shortDescriptionString (247)
typedef std::string witsml1__shortDescriptionString;
#endif

/* witsml1_4_1_1ForGsoap.h:1157 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__schemaVersionString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__schemaVersionString (248)
typedef std::string witsml1__schemaVersionString;
#endif

/* witsml1_4_1_1ForGsoap.h:1165 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__uncollapsedString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__uncollapsedString (249)
typedef std::string witsml1__uncollapsedString;
#endif

/* witsml1_4_1_1ForGsoap.h:1174 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__iadcBearingWearCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__iadcBearingWearCode (250)
typedef std::string witsml1__iadcBearingWearCode;
#endif

/* witsml1_4_1_1ForGsoap.h:1183 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__geodeticZoneString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__geodeticZoneString (251)
typedef std::string witsml1__geodeticZoneString;
#endif

/* witsml1_4_1_1ForGsoap.h:1192 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__sectionNumber
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__sectionNumber (252)
typedef std::string witsml1__sectionNumber;
#endif

/* witsml1_4_1_1ForGsoap.h:1202 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__publicLandSurveySystemQuarterTownship
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__publicLandSurveySystemQuarterTownship (253)
typedef std::string witsml1__publicLandSurveySystemQuarterTownship;
#endif

/* witsml1_4_1_1ForGsoap.h:1212 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__publicLandSurveySystemQuarterSection
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__publicLandSurveySystemQuarterSection (254)
typedef std::string witsml1__publicLandSurveySystemQuarterSection;
#endif

/* witsml1_4_1_1ForGsoap.h:1220 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__gtZeroAndLeOne
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__gtZeroAndLeOne (255)
typedef witsml1__abstractDouble witsml1__gtZeroAndLeOne;
#endif

/* witsml1_4_1_1ForGsoap.h:1232 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__nonNegativeCount
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__nonNegativeCount (256)
typedef witsml1__abstractShort witsml1__nonNegativeCount;
#endif

/* witsml1_4_1_1ForGsoap.h:1243 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__positiveBigCount
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__positiveBigCount (257)
typedef witsml1__abstractInt witsml1__positiveBigCount;
#endif

/* witsml1_4_1_1ForGsoap.h:1250 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__integerCount
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__integerCount (258)
typedef witsml1__abstractInt witsml1__integerCount;
#endif

/* witsml1_4_1_1ForGsoap.h:1258 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__beaufortScaleIntegerCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__beaufortScaleIntegerCode (259)
typedef witsml1__abstractShort witsml1__beaufortScaleIntegerCode;
#endif

/* witsml1_4_1_1ForGsoap.h:1266 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__pumpActionIntegerCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__pumpActionIntegerCode (260)
typedef witsml1__abstractShort witsml1__pumpActionIntegerCode;
#endif

/* witsml1_4_1_1ForGsoap.h:1274 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__iadcIntegerCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__iadcIntegerCode (261)
typedef witsml1__abstractShort witsml1__iadcIntegerCode;
#endif

/* witsml1_4_1_1ForGsoap.h:1282 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__levelIntegerCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__levelIntegerCode (262)
typedef witsml1__abstractShort witsml1__levelIntegerCode;
#endif

/* witsml1_4_1_1ForGsoap.h:1287 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__str2
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__str2 (263)
typedef std::string witsml1__str2;
#endif

/* witsml1_4_1_1ForGsoap.h:1292 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__str16
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__str16 (264)
typedef std::string witsml1__str16;
#endif

/* witsml1_4_1_1ForGsoap.h:1304 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractMaximumLengthString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractMaximumLengthString (265)
typedef std::string witsml1__abstractMaximumLengthString;
#endif

/* witsml1_4_1_1ForGsoap.h:1315 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractPositiveCount
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractPositiveCount (266)
typedef witsml1__abstractShort witsml1__abstractPositiveCount;
#endif

/* witsml1_4_1_1ForGsoap.h:1325 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractTimeZone
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractTimeZone (267)
typedef std::string witsml1__abstractTimeZone;
#endif

/* witsml1_4_1_1ForGsoap.h:1334 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractNameString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractNameString (268)
typedef std::string witsml1__abstractNameString;
#endif

/* witsml1_4_1_1ForGsoap.h:1344 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractUidString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractUidString (269)
typedef std::string witsml1__abstractUidString;
#endif

/* witsml1_4_1_1ForGsoap.h:1352 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractDescriptionString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractDescriptionString (270)
typedef std::string witsml1__abstractDescriptionString;
#endif

/* witsml1_4_1_1ForGsoap.h:1360 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractString32
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractString32 (271)
typedef std::string witsml1__abstractString32;
#endif

/* witsml1_4_1_1ForGsoap.h:1371 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractTypeEnum
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractTypeEnum (272)
typedef std::string witsml1__abstractTypeEnum;
#endif

/* witsml1_4_1_1ForGsoap.h:1380 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractUomEnum
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractUomEnum (273)
typedef std::string witsml1__abstractUomEnum;
#endif

/* witsml1_4_1_1ForGsoap.h:1443 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timeZone
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__timeZone (274)
typedef witsml1__abstractTimeZone witsml1__timeZone;
#endif

/* witsml1_4_1_1ForGsoap.h:1450 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__uidString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__uidString (275)
typedef witsml1__abstractUidString witsml1__uidString;
#endif

/* witsml1_4_1_1ForGsoap.h:1459 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__uidParentString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__uidParentString (276)
typedef witsml1__abstractUidString witsml1__uidParentString;
#endif

/* witsml1_4_1_1ForGsoap.h:1467 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refString (277)
typedef witsml1__abstractUidString witsml1__refString;
#endif

/* witsml1_4_1_1ForGsoap.h:1478 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refWellDatum
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__refWellDatum (278)
typedef witsml1__abstractUidString witsml1__refWellDatum;
#endif

/* witsml1_4_1_1ForGsoap.h:1486 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__nameString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__nameString (279)
typedef witsml1__abstractNameString witsml1__nameString;
#endif

/* witsml1_4_1_1ForGsoap.h:1493 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__descriptionString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__descriptionString (280)
typedef witsml1__abstractDescriptionString witsml1__descriptionString;
#endif

/* witsml1_4_1_1ForGsoap.h:1501 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__encodedValueString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__encodedValueString (281)
typedef witsml1__abstractString32 witsml1__encodedValueString;
#endif

/* witsml1_4_1_1ForGsoap.h:1508 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__kindString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__kindString (282)
typedef witsml1__abstractTypeEnum witsml1__kindString;
#endif

/* witsml1_4_1_1ForGsoap.h:1515 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__uomString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__uomString (283)
typedef witsml1__abstractUomEnum witsml1__uomString;
#endif

/* witsml1_4_1_1ForGsoap.h:1526 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__positiveCount
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__positiveCount (284)
typedef witsml1__abstractPositiveCount witsml1__positiveCount;
#endif

/* witsml1_4_1_1ForGsoap.h:1530 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__str32
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__str32 (285)
typedef witsml1__abstractString32 witsml1__str32;
#endif

/* witsml1_4_1_1ForGsoap.h:2493 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractCommentString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__abstractCommentString (331)
typedef witsml1__abstractMaximumLengthString witsml1__abstractCommentString;
#endif

/* witsml1_4_1_1ForGsoap.h:2523 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ActivityCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ActivityCode (333)
typedef witsml1__abstractTypeEnum witsml1__ActivityCode;
#endif

/* witsml1_4_1_1ForGsoap.h:3744 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ExtensionName
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__ExtensionName (359)
typedef witsml1__abstractTypeEnum witsml1__ExtensionName;
#endif

/* witsml1_4_1_1ForGsoap.h:4178 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LithologyType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__LithologyType (370)
typedef witsml1__abstractTypeEnum witsml1__LithologyType;
#endif

/* witsml1_4_1_1ForGsoap.h:4453 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MatrixCementType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MatrixCementType (378)
typedef witsml1__abstractTypeEnum witsml1__MatrixCementType;
#endif

/* witsml1_4_1_1ForGsoap.h:4461 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MeasureClass
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MeasureClass (379)
typedef witsml1__abstractTypeEnum witsml1__MeasureClass;
#endif

/* witsml1_4_1_1ForGsoap.h:5943 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MudSubClass
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__MudSubClass (386)
typedef witsml1__abstractTypeEnum witsml1__MudSubClass;
#endif

/* witsml1_4_1_1ForGsoap.h:5970 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NameTagLocation
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NameTagLocation (388)
typedef witsml1__abstractTypeEnum witsml1__NameTagLocation;
#endif

/* witsml1_4_1_1ForGsoap.h:5978 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NameTagNumberingScheme
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NameTagNumberingScheme (389)
typedef witsml1__abstractTypeEnum witsml1__NameTagNumberingScheme;
#endif

/* witsml1_4_1_1ForGsoap.h:5986 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NameTagTechnology
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__NameTagTechnology (390)
typedef witsml1__abstractTypeEnum witsml1__NameTagTechnology;
#endif

/* witsml1_4_1_1ForGsoap.h:6574 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__QualifierType
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__QualifierType (403)
typedef witsml1__abstractTypeEnum witsml1__QualifierType;
#endif

/* witsml1_4_1_1ForGsoap.h:8387 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TrajStnCalcAlgorithm
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TrajStnCalcAlgorithm (429)
typedef witsml1__abstractTypeEnum witsml1__TrajStnCalcAlgorithm;
#endif

/* witsml1_4_1_1ForGsoap.h:9291 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TypeSurveyTool
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__TypeSurveyTool (434)
typedef witsml1__abstractTypeEnum witsml1__TypeSurveyTool;
#endif

/* witsml1_4_1_1ForGsoap.h:9856 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__commentString
#define SOAP_TYPE_gsoap_witsml1_4_1_1_witsml1__commentString (445)
typedef witsml1__abstractCommentString witsml1__commentString;
#endif

/* witsml1_4_1_1ForGsoap.h:19364 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__wells
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__wells (800)
typedef witsml1__obj_USCOREwells _witsml1__wells;
#endif

/* witsml1_4_1_1ForGsoap.h:19371 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__wellbores
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__wellbores (801)
typedef witsml1__obj_USCOREwellbores _witsml1__wellbores;
#endif

/* witsml1_4_1_1ForGsoap.h:19378 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__trajectorys
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__trajectorys (802)
typedef witsml1__obj_USCOREtrajectorys _witsml1__trajectorys;
#endif

/* witsml1_4_1_1ForGsoap.h:19385 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__logs
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__logs (803)
typedef witsml1__obj_USCORElogs _witsml1__logs;
#endif

/* witsml1_4_1_1ForGsoap.h:19392 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__formationMarkers
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__formationMarkers (804)
typedef witsml1__obj_USCOREformationMarkers _witsml1__formationMarkers;
#endif

/* witsml1_4_1_1ForGsoap.h:19399 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__coordinateReferenceSystems
#define SOAP_TYPE_gsoap_witsml1_4_1_1__witsml1__coordinateReferenceSystems (805)
typedef witsml1__obj_USCOREcoordinateReferenceSystems _witsml1__coordinateReferenceSystems;
#endif

/* witsml1_4_1_1ForGsoap.h:19434 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__GeodeticCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__GeodeticCRS (806)
typedef gml__GeodeticCRSType _gml__GeodeticCRS;
#endif

/* witsml1_4_1_1ForGsoap.h:19440 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__description
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__description (807)
typedef gml__StringOrRefType _gml__description;
#endif

/* witsml1_4_1_1ForGsoap.h:19446 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__descriptionReference
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__descriptionReference (808)
typedef gml__ReferenceType _gml__descriptionReference;
#endif

/* witsml1_4_1_1ForGsoap.h:19452 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__identifier
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__identifier (809)
typedef gml__CodeWithAuthorityType _gml__identifier;
#endif

/* witsml1_4_1_1ForGsoap.h:19458 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__name
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__name (810)
typedef gml__CodeType _gml__name;
#endif

/* witsml1_4_1_1ForGsoap.h:19461 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__remarks
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__remarks (811)
typedef std::string _gml__remarks;
#endif

/* witsml1_4_1_1ForGsoap.h:19469 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__Definition
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__Definition (812)
typedef gml__DefinitionType _gml__Definition;
#endif

/* witsml1_4_1_1ForGsoap.h:19475 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__scope
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__scope (813)
typedef std::string _gml__scope;
#endif

/* witsml1_4_1_1ForGsoap.h:19481 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__ellipsoidalCS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__ellipsoidalCS (814)
typedef gml__EllipsoidalCSPropertyType _gml__ellipsoidalCS;
#endif

/* witsml1_4_1_1ForGsoap.h:19487 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__EllipsoidalCS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__EllipsoidalCS (815)
typedef gml__EllipsoidalCSType _gml__EllipsoidalCS;
#endif

/* witsml1_4_1_1ForGsoap.h:19493 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__axis
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__axis (816)
typedef gml__CoordinateSystemAxisPropertyType _gml__axis;
#endif

/* witsml1_4_1_1ForGsoap.h:19499 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__CoordinateSystemAxis
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__CoordinateSystemAxis (817)
typedef gml__CoordinateSystemAxisType _gml__CoordinateSystemAxis;
#endif

/* witsml1_4_1_1ForGsoap.h:19505 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__axisAbbrev
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__axisAbbrev (818)
typedef gml__CodeType _gml__axisAbbrev;
#endif

/* witsml1_4_1_1ForGsoap.h:19513 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__axisDirection
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__axisDirection (819)
typedef gml__CodeWithAuthorityType _gml__axisDirection;
#endif

/* witsml1_4_1_1ForGsoap.h:19519 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__minimumValue
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__minimumValue (820)
typedef double _gml__minimumValue;
#endif

/* witsml1_4_1_1ForGsoap.h:19525 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__maximumValue
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__maximumValue (821)
typedef double _gml__maximumValue;
#endif

/* witsml1_4_1_1ForGsoap.h:19531 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__rangeMeaning
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__rangeMeaning (822)
typedef gml__CodeWithAuthorityType _gml__rangeMeaning;
#endif

/* witsml1_4_1_1ForGsoap.h:19537 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__cartesianCS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__cartesianCS (823)
typedef gml__CartesianCSPropertyType _gml__cartesianCS;
#endif

/* witsml1_4_1_1ForGsoap.h:19543 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__CartesianCS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__CartesianCS (824)
typedef gml__CartesianCSType _gml__CartesianCS;
#endif

/* witsml1_4_1_1ForGsoap.h:19549 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__sphericalCS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__sphericalCS (825)
typedef gml__SphericalCSPropertyType _gml__sphericalCS;
#endif

/* witsml1_4_1_1ForGsoap.h:19555 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__SphericalCS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__SphericalCS (826)
typedef gml__SphericalCSType _gml__SphericalCS;
#endif

/* witsml1_4_1_1ForGsoap.h:19561 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__geodeticDatum
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__geodeticDatum (827)
typedef gml__GeodeticDatumPropertyType _gml__geodeticDatum;
#endif

/* witsml1_4_1_1ForGsoap.h:19567 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__GeodeticDatum
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__GeodeticDatum (828)
typedef gml__GeodeticDatumType _gml__GeodeticDatum;
#endif

/* witsml1_4_1_1ForGsoap.h:19577 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__anchorDefinition
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__anchorDefinition (829)
typedef gml__CodeType _gml__anchorDefinition;
#endif

/* witsml1_4_1_1ForGsoap.h:19583 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__realizationEpoch
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__realizationEpoch (830)
typedef xsd__date _gml__realizationEpoch;
#endif

/* witsml1_4_1_1ForGsoap.h:19589 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__primeMeridian
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__primeMeridian (831)
typedef gml__PrimeMeridianPropertyType _gml__primeMeridian;
#endif

/* witsml1_4_1_1ForGsoap.h:19595 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__PrimeMeridian
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__PrimeMeridian (832)
typedef gml__PrimeMeridianType _gml__PrimeMeridian;
#endif

/* witsml1_4_1_1ForGsoap.h:19601 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__greenwichLongitude
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__greenwichLongitude (833)
typedef gml__AngleType _gml__greenwichLongitude;
#endif

/* witsml1_4_1_1ForGsoap.h:19607 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__ellipsoid
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__ellipsoid (834)
typedef gml__EllipsoidPropertyType _gml__ellipsoid;
#endif

/* witsml1_4_1_1ForGsoap.h:19613 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__Ellipsoid
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__Ellipsoid (835)
typedef gml__EllipsoidType _gml__Ellipsoid;
#endif

/* witsml1_4_1_1ForGsoap.h:19619 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__semiMajorAxis
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__semiMajorAxis (836)
typedef gml__MeasureType _gml__semiMajorAxis;
#endif

/* witsml1_4_1_1ForGsoap.h:19625 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__ProjectedCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__ProjectedCRS (837)
typedef gml__ProjectedCRSType _gml__ProjectedCRS;
#endif

/* witsml1_4_1_1ForGsoap.h:19631 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__conversion
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__conversion (838)
typedef gml__GeneralConversionPropertyType _gml__conversion;
#endif

/* witsml1_4_1_1ForGsoap.h:19637 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__operationVersion
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__operationVersion (839)
typedef std::string _gml__operationVersion;
#endif

/* witsml1_4_1_1ForGsoap.h:19643 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__sourceCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__sourceCRS (840)
typedef gml__CRSPropertyType _gml__sourceCRS;
#endif

/* witsml1_4_1_1ForGsoap.h:19649 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__targetCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__targetCRS (841)
typedef gml__CRSPropertyType _gml__targetCRS;
#endif

/* witsml1_4_1_1ForGsoap.h:19655 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__baseGeodeticCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__baseGeodeticCRS (842)
typedef gml__GeodeticCRSPropertyType _gml__baseGeodeticCRS;
#endif

/* witsml1_4_1_1ForGsoap.h:19661 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__VerticalCRS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__VerticalCRS (843)
typedef gml__VerticalCRSType _gml__VerticalCRS;
#endif

/* witsml1_4_1_1ForGsoap.h:19667 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__verticalCS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__verticalCS (844)
typedef gml__VerticalCSPropertyType _gml__verticalCS;
#endif

/* witsml1_4_1_1ForGsoap.h:19673 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__VerticalCS
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__VerticalCS (845)
typedef gml__VerticalCSType _gml__VerticalCS;
#endif

/* witsml1_4_1_1ForGsoap.h:19679 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__verticalDatum
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__verticalDatum (846)
typedef gml__VerticalDatumPropertyType _gml__verticalDatum;
#endif

/* witsml1_4_1_1ForGsoap.h:19685 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__VerticalDatum
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__VerticalDatum (847)
typedef gml__VerticalDatumType _gml__VerticalDatum;
#endif

/* witsml1_4_1_1ForGsoap.h:19699 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gml__id
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gml__id (848)
typedef xsd__ID _gml__id;
#endif

/* witsml1_4_1_1ForGsoap.h:19718 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__href
#define SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__href (849)
typedef xsd__anyURI _xlink__href;
#endif

/* witsml1_4_1_1ForGsoap.h:19721 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__role
#define SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__role (850)
typedef xsd__anyURI _xlink__role;
#endif

/* witsml1_4_1_1ForGsoap.h:19724 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__arcrole
#define SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__arcrole (851)
typedef xsd__anyURI _xlink__arcrole;
#endif

/* witsml1_4_1_1ForGsoap.h:19727 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__title
#define SOAP_TYPE_gsoap_witsml1_4_1_1__xlink__title (852)
typedef std::string _xlink__title;
#endif

/* witsml1_4_1_1ForGsoap.h:19738 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__EX_USCOREExtent
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__EX_USCOREExtent (853)
typedef gmd__EX_USCOREExtent_USCOREType _gmd__EX_USCOREExtent;
#endif

/* witsml1_4_1_1ForGsoap.h:19741 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__EX_USCORETemporalExtent
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__EX_USCORETemporalExtent (854)
typedef gmd__EX_USCORETemporalExtent_USCOREType _gmd__EX_USCORETemporalExtent;
#endif

/* witsml1_4_1_1ForGsoap.h:19744 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__EX_USCOREVerticalExtent
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__EX_USCOREVerticalExtent (855)
typedef gmd__EX_USCOREVerticalExtent_USCOREType _gmd__EX_USCOREVerticalExtent;
#endif

/* witsml1_4_1_1ForGsoap.h:19747 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__MD_USCOREIdentifier
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__MD_USCOREIdentifier (856)
typedef gmd__MD_USCOREIdentifier_USCOREType _gmd__MD_USCOREIdentifier;
#endif

/* witsml1_4_1_1ForGsoap.h:19750 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCORECitation
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCORECitation (857)
typedef gmd__CI_USCORECitation_USCOREType _gmd__CI_USCORECitation;
#endif

/* witsml1_4_1_1ForGsoap.h:19753 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREDate
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREDate (858)
typedef gmd__CI_USCOREDate_USCOREType _gmd__CI_USCOREDate;
#endif

/* witsml1_4_1_1ForGsoap.h:19756 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREDateTypeCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREDateTypeCode (859)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREDateTypeCode;
#endif

/* witsml1_4_1_1ForGsoap.h:19759 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREResponsibleParty
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREResponsibleParty (860)
typedef gmd__CI_USCOREResponsibleParty_USCOREType _gmd__CI_USCOREResponsibleParty;
#endif

/* witsml1_4_1_1ForGsoap.h:19762 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREContact
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREContact (861)
typedef gmd__CI_USCOREContact_USCOREType _gmd__CI_USCOREContact;
#endif

/* witsml1_4_1_1ForGsoap.h:19765 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCORETelephone
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCORETelephone (862)
typedef gmd__CI_USCORETelephone_USCOREType _gmd__CI_USCORETelephone;
#endif

/* witsml1_4_1_1ForGsoap.h:19768 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREAddress
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREAddress (863)
typedef gmd__CI_USCOREAddress_USCOREType _gmd__CI_USCOREAddress;
#endif

/* witsml1_4_1_1ForGsoap.h:19771 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREOnlineResource
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREOnlineResource (864)
typedef gmd__CI_USCOREOnlineResource_USCOREType _gmd__CI_USCOREOnlineResource;
#endif

/* witsml1_4_1_1ForGsoap.h:19774 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__URL
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__URL (865)
typedef xsd__anyURI _gmd__URL;
#endif

/* witsml1_4_1_1ForGsoap.h:19777 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREOnLineFunctionCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREOnLineFunctionCode (866)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREOnLineFunctionCode;
#endif

/* witsml1_4_1_1ForGsoap.h:19780 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCORERoleCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCORERoleCode (867)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCORERoleCode;
#endif

/* witsml1_4_1_1ForGsoap.h:19783 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREPresentationFormCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCOREPresentationFormCode (868)
typedef gco__CodeListValue_USCOREType _gmd__CI_USCOREPresentationFormCode;
#endif

/* witsml1_4_1_1ForGsoap.h:19786 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCORESeries
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__CI_USCORESeries (869)
typedef gmd__CI_USCORESeries_USCOREType _gmd__CI_USCORESeries;
#endif

/* witsml1_4_1_1ForGsoap.h:19789 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__DQ_USCOREEvaluationMethodTypeCode
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gmd__DQ_USCOREEvaluationMethodTypeCode (870)
typedef gco__CodeListValue_USCOREType _gmd__DQ_USCOREEvaluationMethodTypeCode;
#endif

/* witsml1_4_1_1ForGsoap.h:19824 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gco__CharacterString
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gco__CharacterString (871)
typedef std::string _gco__CharacterString;
#endif

/* witsml1_4_1_1ForGsoap.h:19827 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gco__Boolean
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gco__Boolean (872)
typedef bool _gco__Boolean;
#endif

/* witsml1_4_1_1ForGsoap.h:19830 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gco__Real
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gco__Real (873)
typedef double _gco__Real;
#endif

/* witsml1_4_1_1ForGsoap.h:19833 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gco__Date
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gco__Date (874)
typedef gco__Date_USCOREType _gco__Date;
#endif

/* witsml1_4_1_1ForGsoap.h:19836 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gco__DateTime
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gco__DateTime (875)
typedef time_t _gco__DateTime;
#endif

/* witsml1_4_1_1ForGsoap.h:19847 */
#ifndef SOAP_TYPE_gsoap_witsml1_4_1_1__gco__nilReason
#define SOAP_TYPE_gsoap_witsml1_4_1_1__gco__nilReason (876)
typedef gml__NilReasonType _gco__nilReason;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace gsoap_witsml1_4_1_1


#endif

/* End of gsoap_witsml1_4_1_1Stub.h */
